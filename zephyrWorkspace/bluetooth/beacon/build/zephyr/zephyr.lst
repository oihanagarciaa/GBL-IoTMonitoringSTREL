
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:
			msg->flags & I2C_MSG_READ ? 'R' : 'W', msg->len);
		if (!(msg->flags & I2C_MSG_READ)) {
			LOG_HEXDUMP_DBG(msg->buf, msg->len, "contents:");
		}
	}
}
   0:	40 32 00 20 01 2a 00 00 85 d9 00 00 d5 29 00 00     @2. .*.......)..
  10:	d5 29 00 00 d5 29 00 00 d5 29 00 00 00 00 00 00     .)...)...)......
	...
  2c:	2d 23 00 00 d5 29 00 00 00 00 00 00 d9 22 00 00     -#...)......."..
  3c:	d5 29 00 00                                         .)..

00000040 <_irq_vector_table>:
  40:	dd 23 00 00 41 e7 00 00 dd 23 00 00 dd 23 00 00     .#..A....#...#..
  50:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  60:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  70:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  80:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  90:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  a0:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  b0:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  c0:	dd 23 00 00 dd 23 00 00 dd 23 00 00 dd 23 00 00     .#...#...#...#..
  d0:	dd 23 00 00 dd 23 00 00 dd 23 00 00                 .#...#...#..

Disassembly of section text:

000000e0 <__aeabi_uldivmod>:
      e0:	b953      	cbnz	r3, f8 <__aeabi_uldivmod+0x18>
      e2:	b94a      	cbnz	r2, f8 <__aeabi_uldivmod+0x18>
      e4:	2900      	cmp	r1, #0
      e6:	bf08      	it	eq
      e8:	2800      	cmpeq	r0, #0
      ea:	bf1c      	itt	ne
      ec:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
      f0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
      f4:	f000 b80c 	b.w	110 <__aeabi_idiv0>
      f8:	f1ad 0c08 	sub.w	ip, sp, #8
      fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     100:	f000 f808 	bl	114 <__udivmoddi4>
     104:	f8dd e004 	ldr.w	lr, [sp, #4]
     108:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     10c:	b004      	add	sp, #16
     10e:	4770      	bx	lr

00000110 <__aeabi_idiv0>:
     110:	4770      	bx	lr
     112:	bf00      	nop

00000114 <__udivmoddi4>:
     114:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     118:	4607      	mov	r7, r0
     11a:	468c      	mov	ip, r1
     11c:	4608      	mov	r0, r1
     11e:	9e09      	ldr	r6, [sp, #36]	; 0x24
     120:	4615      	mov	r5, r2
     122:	463c      	mov	r4, r7
     124:	4619      	mov	r1, r3
     126:	2b00      	cmp	r3, #0
     128:	f040 80c6 	bne.w	2b8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x38>
     12c:	4282      	cmp	r2, r0
     12e:	fab2 f782 	clz	r7, r2
     132:	d946      	bls.n	1c2 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x2>
     134:	b14f      	cbz	r7, 14a <CONFIG_NRF52_ANOMALY_132_DELAY_US>
     136:	f1c7 0e20 	rsb	lr, r7, #32
     13a:	fa24 fe0e 	lsr.w	lr, r4, lr
     13e:	fa00 f307 	lsl.w	r3, r0, r7
     142:	40bd      	lsls	r5, r7
     144:	ea4e 0c03 	orr.w	ip, lr, r3
     148:	40bc      	lsls	r4, r7
     14a:	ea4f 4815 	mov.w	r8, r5, lsr #16
     14e:	fa1f fe85 	uxth.w	lr, r5
     152:	fbbc f9f8 	udiv	r9, ip, r8
     156:	0c22      	lsrs	r2, r4, #16
     158:	fb08 c319 	mls	r3, r8, r9, ip
     15c:	fb09 fa0e 	mul.w	sl, r9, lr
     160:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
     164:	459a      	cmp	sl, r3
     166:	d928      	bls.n	1ba <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x4d>
     168:	18eb      	adds	r3, r5, r3
     16a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
     16e:	d204      	bcs.n	17a <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0xd>
     170:	459a      	cmp	sl, r3
     172:	d902      	bls.n	17a <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0xd>
     174:	f1a9 0002 	sub.w	r0, r9, #2
     178:	442b      	add	r3, r5
     17a:	eba3 030a 	sub.w	r3, r3, sl
     17e:	b2a4      	uxth	r4, r4
     180:	fbb3 f2f8 	udiv	r2, r3, r8
     184:	fb08 3312 	mls	r3, r8, r2, r3
     188:	fb02 fe0e 	mul.w	lr, r2, lr
     18c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     190:	45a6      	cmp	lr, r4
     192:	d914      	bls.n	1be <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x51>
     194:	192c      	adds	r4, r5, r4
     196:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
     19a:	d203      	bcs.n	1a4 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x37>
     19c:	45a6      	cmp	lr, r4
     19e:	d901      	bls.n	1a4 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x37>
     1a0:	1e93      	subs	r3, r2, #2
     1a2:	442c      	add	r4, r5
     1a4:	eba4 040e 	sub.w	r4, r4, lr
     1a8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     1ac:	b11e      	cbz	r6, 1b6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x49>
     1ae:	40fc      	lsrs	r4, r7
     1b0:	2300      	movs	r3, #0
     1b2:	6034      	str	r4, [r6, #0]
     1b4:	6073      	str	r3, [r6, #4]
     1b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     1ba:	4648      	mov	r0, r9
     1bc:	e7dd      	b.n	17a <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0xd>
     1be:	4613      	mov	r3, r2
     1c0:	e7f0      	b.n	1a4 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x37>
     1c2:	b902      	cbnz	r2, 1c6 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x6>
     1c4:	deff      	udf	#255	; 0xff
     1c6:	bb87      	cbnz	r7, 22a <CONFIG_FLASH_SIZE+0x2a>
     1c8:	1a83      	subs	r3, r0, r2
     1ca:	2101      	movs	r1, #1
     1cc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     1d0:	b2aa      	uxth	r2, r5
     1d2:	fbb3 fcfe 	udiv	ip, r3, lr
     1d6:	0c20      	lsrs	r0, r4, #16
     1d8:	fb0e 331c 	mls	r3, lr, ip, r3
     1dc:	fb0c f802 	mul.w	r8, ip, r2
     1e0:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
     1e4:	4598      	cmp	r8, r3
     1e6:	d963      	bls.n	2b0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x30>
     1e8:	18eb      	adds	r3, r5, r3
     1ea:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
     1ee:	d204      	bcs.n	1fa <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x3a>
     1f0:	4598      	cmp	r8, r3
     1f2:	d902      	bls.n	1fa <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x3a>
     1f4:	f1ac 0002 	sub.w	r0, ip, #2
     1f8:	442b      	add	r3, r5
     1fa:	eba3 0308 	sub.w	r3, r3, r8
     1fe:	b2a4      	uxth	r4, r4
     200:	fbb3 fcfe 	udiv	ip, r3, lr
     204:	fb0e 331c 	mls	r3, lr, ip, r3
     208:	fb0c f202 	mul.w	r2, ip, r2
     20c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     210:	42a2      	cmp	r2, r4
     212:	d94f      	bls.n	2b4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x34>
     214:	192c      	adds	r4, r5, r4
     216:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
     21a:	d204      	bcs.n	226 <CONFIG_FLASH_SIZE+0x26>
     21c:	42a2      	cmp	r2, r4
     21e:	d902      	bls.n	226 <CONFIG_FLASH_SIZE+0x26>
     220:	f1ac 0302 	sub.w	r3, ip, #2
     224:	442c      	add	r4, r5
     226:	1aa4      	subs	r4, r4, r2
     228:	e7be      	b.n	1a8 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x3b>
     22a:	f1c7 0c20 	rsb	ip, r7, #32
     22e:	fa20 f80c 	lsr.w	r8, r0, ip
     232:	fa00 f307 	lsl.w	r3, r0, r7
     236:	fa24 fc0c 	lsr.w	ip, r4, ip
     23a:	40bd      	lsls	r5, r7
     23c:	ea4c 0203 	orr.w	r2, ip, r3
     240:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     244:	b2ab      	uxth	r3, r5
     246:	fbb8 fcfe 	udiv	ip, r8, lr
     24a:	0c11      	lsrs	r1, r2, #16
     24c:	fb0e 801c 	mls	r0, lr, ip, r8
     250:	fb0c f903 	mul.w	r9, ip, r3
     254:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
     258:	4581      	cmp	r9, r0
     25a:	fa04 f407 	lsl.w	r4, r4, r7
     25e:	d923      	bls.n	2a8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x28>
     260:	1828      	adds	r0, r5, r0
     262:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
     266:	d204      	bcs.n	272 <CONFIG_FLASH_SIZE+0x72>
     268:	4581      	cmp	r9, r0
     26a:	d902      	bls.n	272 <CONFIG_FLASH_SIZE+0x72>
     26c:	f1ac 0102 	sub.w	r1, ip, #2
     270:	4428      	add	r0, r5
     272:	eba0 0009 	sub.w	r0, r0, r9
     276:	b292      	uxth	r2, r2
     278:	fbb0 fcfe 	udiv	ip, r0, lr
     27c:	fb0e 001c 	mls	r0, lr, ip, r0
     280:	fb0c f803 	mul.w	r8, ip, r3
     284:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
     288:	4598      	cmp	r8, r3
     28a:	d90f      	bls.n	2ac <CONFIG_BT_HCI_TX_STACK_SIZE+0x2c>
     28c:	18eb      	adds	r3, r5, r3
     28e:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
     292:	d204      	bcs.n	29e <CONFIG_BT_HCI_TX_STACK_SIZE+0x1e>
     294:	4598      	cmp	r8, r3
     296:	d902      	bls.n	29e <CONFIG_BT_HCI_TX_STACK_SIZE+0x1e>
     298:	f1ac 0202 	sub.w	r2, ip, #2
     29c:	442b      	add	r3, r5
     29e:	eba3 0308 	sub.w	r3, r3, r8
     2a2:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
     2a6:	e791      	b.n	1cc <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0xc>
     2a8:	4661      	mov	r1, ip
     2aa:	e7e2      	b.n	272 <CONFIG_FLASH_SIZE+0x72>
     2ac:	4662      	mov	r2, ip
     2ae:	e7f6      	b.n	29e <CONFIG_BT_HCI_TX_STACK_SIZE+0x1e>
     2b0:	4660      	mov	r0, ip
     2b2:	e7a2      	b.n	1fa <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x3a>
     2b4:	4663      	mov	r3, ip
     2b6:	e7b6      	b.n	226 <CONFIG_FLASH_SIZE+0x26>
     2b8:	4283      	cmp	r3, r0
     2ba:	d905      	bls.n	2c8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x48>
     2bc:	b10e      	cbz	r6, 2c2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x42>
     2be:	e9c6 7000 	strd	r7, r0, [r6]
     2c2:	2100      	movs	r1, #0
     2c4:	4608      	mov	r0, r1
     2c6:	e776      	b.n	1b6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x49>
     2c8:	fab3 f183 	clz	r1, r3
     2cc:	b981      	cbnz	r1, 2f0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x70>
     2ce:	4283      	cmp	r3, r0
     2d0:	d301      	bcc.n	2d6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x56>
     2d2:	42ba      	cmp	r2, r7
     2d4:	d80a      	bhi.n	2ec <CONFIG_BT_HCI_TX_STACK_SIZE+0x6c>
     2d6:	1abc      	subs	r4, r7, r2
     2d8:	eb60 0303 	sbc.w	r3, r0, r3
     2dc:	2001      	movs	r0, #1
     2de:	469c      	mov	ip, r3
     2e0:	2e00      	cmp	r6, #0
     2e2:	d068      	beq.n	3b6 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb6>
     2e4:	e9c6 4c00 	strd	r4, ip, [r6]
     2e8:	2100      	movs	r1, #0
     2ea:	e764      	b.n	1b6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x49>
     2ec:	4608      	mov	r0, r1
     2ee:	e7f7      	b.n	2e0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x60>
     2f0:	f1c1 0c20 	rsb	ip, r1, #32
     2f4:	408b      	lsls	r3, r1
     2f6:	fa22 f40c 	lsr.w	r4, r2, ip
     2fa:	431c      	orrs	r4, r3
     2fc:	fa02 f501 	lsl.w	r5, r2, r1
     300:	fa00 f301 	lsl.w	r3, r0, r1
     304:	fa27 f20c 	lsr.w	r2, r7, ip
     308:	fa20 fb0c 	lsr.w	fp, r0, ip
     30c:	ea4f 4914 	mov.w	r9, r4, lsr #16
     310:	4313      	orrs	r3, r2
     312:	fbbb f8f9 	udiv	r8, fp, r9
     316:	fa1f fe84 	uxth.w	lr, r4
     31a:	fb09 bb18 	mls	fp, r9, r8, fp
     31e:	0c1a      	lsrs	r2, r3, #16
     320:	fb08 fa0e 	mul.w	sl, r8, lr
     324:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
     328:	4592      	cmp	sl, r2
     32a:	fa07 f701 	lsl.w	r7, r7, r1
     32e:	d93e      	bls.n	3ae <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xae>
     330:	18a2      	adds	r2, r4, r2
     332:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
     336:	d204      	bcs.n	342 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x42>
     338:	4592      	cmp	sl, r2
     33a:	d902      	bls.n	342 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x42>
     33c:	f1a8 0002 	sub.w	r0, r8, #2
     340:	4422      	add	r2, r4
     342:	eba2 020a 	sub.w	r2, r2, sl
     346:	b29b      	uxth	r3, r3
     348:	fbb2 f8f9 	udiv	r8, r2, r9
     34c:	fb09 2218 	mls	r2, r9, r8, r2
     350:	fb08 fe0e 	mul.w	lr, r8, lr
     354:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     358:	4596      	cmp	lr, r2
     35a:	d92a      	bls.n	3b2 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb2>
     35c:	18a2      	adds	r2, r4, r2
     35e:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
     362:	d204      	bcs.n	36e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x6e>
     364:	4596      	cmp	lr, r2
     366:	d902      	bls.n	36e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x6e>
     368:	f1a8 0302 	sub.w	r3, r8, #2
     36c:	4422      	add	r2, r4
     36e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     372:	fba0 9305 	umull	r9, r3, r0, r5
     376:	eba2 020e 	sub.w	r2, r2, lr
     37a:	429a      	cmp	r2, r3
     37c:	46ce      	mov	lr, r9
     37e:	4698      	mov	r8, r3
     380:	d302      	bcc.n	388 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x88>
     382:	d106      	bne.n	392 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x92>
     384:	454f      	cmp	r7, r9
     386:	d204      	bcs.n	392 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x92>
     388:	ebb9 0e05 	subs.w	lr, r9, r5
     38c:	eb63 0804 	sbc.w	r8, r3, r4
     390:	3801      	subs	r0, #1
     392:	b186      	cbz	r6, 3b6 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb6>
     394:	ebb7 030e 	subs.w	r3, r7, lr
     398:	eb62 0708 	sbc.w	r7, r2, r8
     39c:	fa07 fc0c 	lsl.w	ip, r7, ip
     3a0:	40cb      	lsrs	r3, r1
     3a2:	ea4c 0303 	orr.w	r3, ip, r3
     3a6:	40cf      	lsrs	r7, r1
     3a8:	e9c6 3700 	strd	r3, r7, [r6]
     3ac:	e79c      	b.n	2e8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x68>
     3ae:	4640      	mov	r0, r8
     3b0:	e7c7      	b.n	342 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x42>
     3b2:	4643      	mov	r3, r8
     3b4:	e7db      	b.n	36e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x6e>
     3b6:	4631      	mov	r1, r6
     3b8:	e6fd      	b.n	1b6 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x49>
     3ba:	0000      	movs	r0, r0
     3bc:	0000      	movs	r0, r0
	...

000003c0 <ll_adv_enable>:
	uint8_t aux_is_started = 0U;
	uint32_t ticks_anchor;
#endif /* !CONFIG_BT_HCI_MESH_EXT */
#else /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
uint8_t ll_adv_enable(uint8_t enable)
{
     3c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     3c4:	b08c      	sub	sp, #48	; 0x30
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	uint8_t hci_err;
	uint32_t ret;

	if (!enable) {
     3c6:	b920      	cbnz	r0, 3d2 <ll_adv_enable+0x12>
		conn_release(adv);
	}
#endif /* CONFIG_BT_PERIPHERAL */

	return BT_HCI_ERR_CMD_DISALLOWED;
}
     3c8:	b00c      	add	sp, #48	; 0x30
     3ca:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return disable(handle);
     3ce:	f006 b8f7 	b.w	65c0 <disable.constprop.0>
static inline struct ll_adv_set *is_disabled_get(uint8_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
     3d2:	4c55      	ldr	r4, [pc, #340]	; (528 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb4>)
     3d4:	f894 503e 	ldrb.w	r5, [r4, #62]	; 0x3e
     3d8:	f015 0501 	ands.w	r5, r5, #1
     3dc:	f040 809b 	bne.w	516 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa2>
	ull_filter_adv_update(lll->filter_policy);
     3e0:	f894 0020 	ldrb.w	r0, [r4, #32]
	lll->rl_idx = FILTER_IDX_NONE;
     3e4:	23ff      	movs	r3, #255	; 0xff
	ull_filter_adv_update(lll->filter_policy);
     3e6:	0980      	lsrs	r0, r0, #6
	lll->rl_idx = FILTER_IDX_NONE;
     3e8:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	ull_filter_adv_update(lll->filter_policy);
     3ec:	f006 faec 	bl	69c8 <ull_filter_adv_update>
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
     3f0:	f894 003e 	ldrb.w	r0, [r4, #62]	; 0x3e
     3f4:	0742      	lsls	r2, r0, #29
     3f6:	d50d      	bpl.n	414 <CONFIG_BT_RX_STACK_SIZE+0x14>
		lll->rl_idx = ull_filter_rl_find(adv->peer_addr_type,
     3f8:	462a      	mov	r2, r5
     3fa:	f104 013f 	add.w	r1, r4, #63	; 0x3f
     3fe:	f3c0 00c0 	ubfx	r0, r0, #3, #1
     402:	f006 fc2d 	bl	6c60 <ull_filter_rl_find>
		if (lll->rl_idx != FILTER_IDX_NONE) {
     406:	28ff      	cmp	r0, #255	; 0xff
		lll->rl_idx = ull_filter_rl_find(adv->peer_addr_type,
     408:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
		if (lll->rl_idx != FILTER_IDX_NONE) {
     40c:	d002      	beq.n	414 <CONFIG_BT_RX_STACK_SIZE+0x14>
			ull_filter_rpa_update(false);
     40e:	4628      	mov	r0, r5
     410:	f006 faf4 	bl	69fc <ull_filter_rpa_update>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     414:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
     418:	eb04 0383 	add.w	r3, r4, r3, lsl #2
     41c:	6a9e      	ldr	r6, [r3, #40]	; 0x28
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     41e:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
     422:	eb04 0383 	add.w	r3, r4, r3, lsl #2
     426:	6b5f      	ldr	r7, [r3, #52]	; 0x34
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		pdu_adv_to_update = pdu;
	}

	if (pdu_adv_to_update) {
     428:	b156      	cbz	r6, 440 <CONFIG_BT_RX_STACK_SIZE+0x40>
		const uint8_t *adv_addr;

		adv_addr = ull_adv_pdu_update_addrs(adv, pdu_adv_to_update);
     42a:	483f      	ldr	r0, [pc, #252]	; (528 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb4>)
     42c:	4631      	mov	r1, r6
     42e:	f00e f8a4 	bl	e57a <ull_adv_pdu_update_addrs>

		/* In case the local IRK was not set or no match was
		 * found the fallback address was used instead, check
		 * that a valid address has been set.
		 */
		if (pdu_adv_to_update->tx_addr &&
     432:	7833      	ldrb	r3, [r6, #0]
     434:	065b      	lsls	r3, r3, #25
     436:	d415      	bmi.n	464 <CONFIG_BT_RX_STACK_SIZE+0x64>
		if ((pdu->type != PDU_ADV_TYPE_EXT_IND) ||
		    (pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_SCAN)) {
#else
		if (1) {
#endif
			ull_adv_pdu_update_addrs(adv, pdu_scan);
     438:	483b      	ldr	r0, [pc, #236]	; (528 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb4>)
     43a:	4639      	mov	r1, r7
     43c:	f00e f89d 	bl	e57a <ull_adv_pdu_update_addrs>
	uint8_t ch_map = lll->chan_map;
     440:	f894 3020 	ldrb.w	r3, [r4, #32]
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     444:	2101      	movs	r1, #1
	uint8_t ch_map = lll->chan_map;
     446:	f3c3 0302 	ubfx	r3, r3, #0, #3
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     44a:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
	uint8_t ch_map = lll->chan_map;
     44e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     452:	f00d fd26 	bl	dea2 <util_ones_count_get>
	if (adv_chn_cnt == 0) {
     456:	4602      	mov	r2, r0
     458:	b958      	cbnz	r0, 472 <CONFIG_BT_RX_STACK_SIZE+0x72>
	return BT_HCI_ERR_CMD_DISALLOWED;
     45a:	250c      	movs	r5, #12
}
     45c:	4628      	mov	r0, r5
     45e:	b00c      	add	sp, #48	; 0x30
     460:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		    !mem_nz((void *)adv_addr, BDADDR_SIZE)) {
     464:	2106      	movs	r1, #6
     466:	f00d fcf0 	bl	de4a <mem_nz>
		if (pdu_adv_to_update->tx_addr &&
     46a:	2800      	cmp	r0, #0
     46c:	d1e4      	bne.n	438 <CONFIG_BT_RX_STACK_SIZE+0x38>
			return BT_HCI_ERR_INVALID_PARAM;
     46e:	2512      	movs	r5, #18
     470:	e7f4      	b.n	45c <CONFIG_BT_RX_STACK_SIZE+0x5c>
	uint16_t time_us = adv_time_get(pdu_adv, pdu_scan, adv_chn_cnt, phy,
     472:	7879      	ldrb	r1, [r7, #1]
     474:	4630      	mov	r0, r6
     476:	f00e f837 	bl	e4e8 <adv_time_get.constprop.0.isra.0>
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     47a:	492c      	ldr	r1, [pc, #176]	; (52c <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb8>)
	uint16_t interval = adv->interval;
     47c:	f8b4 803c 	ldrh.w	r8, [r4, #60]	; 0x3c
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->ref = 0U;
     480:	2600      	movs	r6, #0
	adv->ull.ticks_prepare_to_start =
     482:	2331      	movs	r3, #49	; 0x31
	adv->ull.ticks_preempt_to_start =
     484:	e9c4 3602 	strd	r3, r6, [r4, #8]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     488:	fba0 0101 	umull	r0, r1, r0, r1
     48c:	a324      	add	r3, pc, #144	; (adr r3, 520 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xac>)
     48e:	e9d3 2300 	ldrd	r2, r3, [r3]
	hdr->disabled_cb = hdr->disabled_param = NULL;
     492:	e9c4 6605 	strd	r6, r6, [r4, #20]
	hdr->ref = 0U;
     496:	7026      	strb	r6, [r4, #0]
	adv->ull.ticks_active_to_start = 0;
     498:	6066      	str	r6, [r4, #4]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     49a:	f7ff fe21 	bl	e0 <__aeabi_uldivmod>
     49e:	6120      	str	r0, [r4, #16]
	ticks_anchor = ticker_ticks_now_get();
     4a0:	f00d ffa7 	bl	e3f2 <ticker_ticks_now_get>
		const uint32_t ticks_slot = adv->ull.ticks_slot +
     4a4:	6923      	ldr	r3, [r4, #16]
		ll_adv_ticker_ext[handle].ticks_slot_window =
     4a6:	4a22      	ldr	r2, [pc, #136]	; (530 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xbc>)
			ULL_ADV_RANDOM_DELAY + ticks_slot;
     4a8:	f203 1147 	addw	r1, r3, #327	; 0x147
		ll_adv_ticker_ext[handle].ticks_slot_window =
     4ac:	6011      	str	r1, [r2, #0]
		ret = ticker_start_ext(
     4ae:	9209      	str	r2, [sp, #36]	; 0x24
     4b0:	4a20      	ldr	r2, [pc, #128]	; (534 <__data_size+0x2>)
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     4b2:	4921      	ldr	r1, [pc, #132]	; (538 <__data_size+0x6>)
		ret = ticker_start_ext(
     4b4:	e9cd 4206 	strd	r4, r2, [sp, #24]
     4b8:	4a20      	ldr	r2, [pc, #128]	; (53c <__data_size+0xa>)
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     4ba:	f04f 0c91 	mov.w	ip, #145	; 0x91
		ret = ticker_start_ext(
     4be:	e9cd 3204 	strd	r3, r2, [sp, #16]
	ticks_anchor = ticker_ticks_now_get();
     4c2:	4607      	mov	r7, r0
		ret = ticker_start_ext(
     4c4:	f64f 73ff 	movw	r3, #65535	; 0xffff
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     4c8:	fba8 0101 	umull	r0, r1, r8, r1
		ret = ticker_start_ext(
     4cc:	e9cd 6302 	strd	r6, r3, [sp, #8]
		ret_cb = TICKER_STATUS_BUSY;
     4d0:	f04f 0a02 	mov.w	sl, #2
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     4d4:	a312      	add	r3, pc, #72	; (adr r3, 520 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xac>)
     4d6:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret = ticker_start_ext(
     4da:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     4de:	fb0c 1108 	mla	r1, ip, r8, r1
		ret_cb = TICKER_STATUS_BUSY;
     4e2:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
		ret = ticker_start_ext(
     4e6:	f8cd 9020 	str.w	r9, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     4ea:	f7ff fdf9 	bl	e0 <__aeabi_uldivmod>
		ret = ticker_start_ext(
     4ee:	2103      	movs	r1, #3
     4f0:	e9cd 6000 	strd	r6, r0, [sp]
     4f4:	463b      	mov	r3, r7
     4f6:	4652      	mov	r2, sl
     4f8:	4630      	mov	r0, r6
     4fa:	f004 fd13 	bl	4f24 <ticker_start_ext>
	ret = ull_ticker_status_take(ret, &ret_cb);
     4fe:	4649      	mov	r1, r9
     500:	f005 fb7e 	bl	5c00 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     504:	2800      	cmp	r0, #0
     506:	d1a8      	bne.n	45a <CONFIG_BT_RX_STACK_SIZE+0x5a>
	adv->is_enabled = 1;
     508:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
     50c:	f043 0301 	orr.w	r3, r3, #1
     510:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
	return 0;
     514:	e7a2      	b.n	45c <CONFIG_BT_RX_STACK_SIZE+0x5c>
			return 0;
     516:	2500      	movs	r5, #0
     518:	e7a0      	b.n	45c <CONFIG_BT_RX_STACK_SIZE+0x5c>
     51a:	bf00      	nop
     51c:	f3af 8000 	nop.w
     520:	1afd498d 	.word	0x1afd498d
     524:	00000007 	.word	0x00000007
     528:	20001700 	.word	0x20001700
     52c:	3b9aca00 	.word	0x3b9aca00
     530:	20001748 	.word	0x20001748
     534:	00005aad 	.word	0x00005aad
     538:	84e72a00 	.word	0x84e72a00
     53c:	00006361 	.word	0x00006361

00000540 <ull_adv_time_update>:
{
     540:	b570      	push	{r4, r5, r6, lr}
	chan_map = lll->chan_map;
     542:	f890 3020 	ldrb.w	r3, [r0, #32]
{
     546:	b08a      	sub	sp, #40	; 0x28
	chan_map = lll->chan_map;
     548:	f3c3 0302 	ubfx	r3, r3, #0, #3
{
     54c:	460d      	mov	r5, r1
     54e:	4604      	mov	r4, r0
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     550:	2101      	movs	r1, #1
     552:	f10d 0023 	add.w	r0, sp, #35	; 0x23
{
     556:	4616      	mov	r6, r2
	chan_map = lll->chan_map;
     558:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     55c:	f00d fca1 	bl	dea2 <util_ones_count_get>
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
     560:	7871      	ldrb	r1, [r6, #1]
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     562:	4602      	mov	r2, r0
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
     564:	4628      	mov	r0, r5
     566:	f00d ffbf 	bl	e4e8 <adv_time_get.constprop.0.isra.0>
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     56a:	491d      	ldr	r1, [pc, #116]	; (5e0 <CONFIG_BT_CTLR_XTAL_THRESHOLD+0x4>)
     56c:	a31a      	add	r3, pc, #104	; (adr r3, 5d8 <ull_adv_time_update+0x98>)
     56e:	e9d3 2300 	ldrd	r2, r3, [r3]
     572:	fba0 0101 	umull	r0, r1, r0, r1
     576:	f7ff fdb3 	bl	e0 <__aeabi_uldivmod>
	if (adv->ull.ticks_slot > time_ticks) {
     57a:	6921      	ldr	r1, [r4, #16]
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     57c:	4605      	mov	r5, r0
	if (adv->ull.ticks_slot > time_ticks) {
     57e:	428d      	cmp	r5, r1
     580:	d21f      	bcs.n	5c2 <ull_adv_time_update+0x82>
		ticks_minus = adv->ull.ticks_slot - time_ticks;
     582:	1b48      	subs	r0, r1, r5
		ticks_plus = 0U;
     584:	2100      	movs	r1, #0
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     586:	4a17      	ldr	r2, [pc, #92]	; (5e4 <CONFIG_BT_CTLR_XTAL_THRESHOLD+0x8>)
	ret_cb = TICKER_STATUS_BUSY;
     588:	2302      	movs	r3, #2
     58a:	9309      	str	r3, [sp, #36]	; 0x24
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     58c:	1aa2      	subs	r2, r4, r2
     58e:	2348      	movs	r3, #72	; 0x48
     590:	fbb2 f2f3 	udiv	r2, r2, r3
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     594:	4b14      	ldr	r3, [pc, #80]	; (5e8 <CONFIG_BT_CTLR_XTAL_THRESHOLD+0xc>)
     596:	9305      	str	r3, [sp, #20]
     598:	ae09      	add	r6, sp, #36	; 0x24
     59a:	2300      	movs	r3, #0
     59c:	3202      	adds	r2, #2
     59e:	e9cd 1001 	strd	r1, r0, [sp, #4]
     5a2:	e9cd 3303 	strd	r3, r3, [sp, #12]
     5a6:	2103      	movs	r1, #3
     5a8:	9606      	str	r6, [sp, #24]
     5aa:	9300      	str	r3, [sp, #0]
     5ac:	b2d2      	uxtb	r2, r2
     5ae:	4618      	mov	r0, r3
     5b0:	f00d ff07 	bl	e3c2 <ticker_update>
	ret = ull_ticker_status_take(ret, &ret_cb);
     5b4:	4631      	mov	r1, r6
     5b6:	f005 fb23 	bl	5c00 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     5ba:	b940      	cbnz	r0, 5ce <ull_adv_time_update+0x8e>
	adv->ull.ticks_slot = time_ticks;
     5bc:	6125      	str	r5, [r4, #16]
}
     5be:	b00a      	add	sp, #40	; 0x28
     5c0:	bd70      	pop	{r4, r5, r6, pc}
	} else if (adv->ull.ticks_slot < time_ticks) {
     5c2:	d902      	bls.n	5ca <ull_adv_time_update+0x8a>
		ticks_plus = time_ticks - adv->ull.ticks_slot;
     5c4:	1a69      	subs	r1, r5, r1
		ticks_minus = 0U;
     5c6:	2000      	movs	r0, #0
     5c8:	e7dd      	b.n	586 <ull_adv_time_update+0x46>
		return BT_HCI_ERR_SUCCESS;
     5ca:	2000      	movs	r0, #0
     5cc:	e7f7      	b.n	5be <ull_adv_time_update+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
     5ce:	200c      	movs	r0, #12
     5d0:	e7f5      	b.n	5be <ull_adv_time_update+0x7e>
     5d2:	bf00      	nop
     5d4:	f3af 8000 	nop.w
     5d8:	1afd498d 	.word	0x1afd498d
     5dc:	00000007 	.word	0x00000007
     5e0:	3b9aca00 	.word	0x3b9aca00
     5e4:	20001700 	.word	0x20001700
     5e8:	00005aad 	.word	0x00005aad

000005ec <bt_ready>:
static const struct bt_data sd[] = {
	BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),
};

static void bt_ready(int err)
{
     5ec:	b570      	push	{r4, r5, r6, lr}
     5ee:	b09a      	sub	sp, #104	; 0x68
	char addr_s[BT_ADDR_LE_STR_LEN];
	bt_addr_le_t addr = {0};
     5f0:	2300      	movs	r3, #0
	size_t count = 1;
     5f2:	2601      	movs	r6, #1
	bt_addr_le_t addr = {0};
     5f4:	9308      	str	r3, [sp, #32]
	size_t count = 1;
     5f6:	9607      	str	r6, [sp, #28]
	bt_addr_le_t addr = {0};
     5f8:	f8cd 3023 	str.w	r3, [sp, #35]	; 0x23

	if (err) {
     5fc:	4601      	mov	r1, r0
     5fe:	b120      	cbz	r0, 60a <CONFIG_BT_COMPANY_ID+0x19>
		printk("Bluetooth init failed (err %d)\n", err);
     600:	4827      	ldr	r0, [pc, #156]	; (6a0 <CONFIG_BT_COMPANY_ID+0xaf>)
	 */

	bt_id_get(&addr, &count);
	bt_addr_le_to_str(&addr, addr_s, sizeof(addr_s));

	printk("Beacon started, advertising as %s\n", addr_s);
     602:	f00c fbfc 	bl	cdfe <printk>
}
     606:	b01a      	add	sp, #104	; 0x68
     608:	bd70      	pop	{r4, r5, r6, pc}
	err = bt_le_adv_start(BT_LE_ADV_NCONN_IDENTITY, ad, ARRAY_SIZE(ad),
     60a:	4d26      	ldr	r5, [pc, #152]	; (6a4 <CONFIG_BT_COMPANY_ID+0xb3>)
	printk("Bluetooth initialized\n");
     60c:	4826      	ldr	r0, [pc, #152]	; (6a8 <CONFIG_BT_COMPANY_ID+0xb7>)
     60e:	f00c fbf6 	bl	cdfe <printk>
	err = bt_le_adv_start(BT_LE_ADV_NCONN_IDENTITY, ad, ARRAY_SIZE(ad),
     612:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     614:	ac0d      	add	r4, sp, #52	; 0x34
     616:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     618:	682b      	ldr	r3, [r5, #0]
     61a:	6023      	str	r3, [r4, #0]
     61c:	4923      	ldr	r1, [pc, #140]	; (6ac <CONFIG_BT_COMPANY_ID+0xbb>)
     61e:	4b24      	ldr	r3, [pc, #144]	; (6b0 <CONFIG_BT_COMPANY_ID+0xbf>)
     620:	9600      	str	r6, [sp, #0]
     622:	2203      	movs	r2, #3
     624:	a80d      	add	r0, sp, #52	; 0x34
     626:	f003 fecf 	bl	43c8 <bt_le_adv_start>
	if (err) {
     62a:	4601      	mov	r1, r0
     62c:	b108      	cbz	r0, 632 <CONFIG_BT_COMPANY_ID+0x41>
		printk("Advertising failed to start (err %d)\n", err);
     62e:	4821      	ldr	r0, [pc, #132]	; (6b4 <CONFIG_BT_COMPANY_ID+0xc3>)
     630:	e7e7      	b.n	602 <CONFIG_BT_COMPANY_ID+0x11>
	bt_id_get(&addr, &count);
     632:	a907      	add	r1, sp, #28
     634:	a808      	add	r0, sp, #32
     636:	f003 fb31 	bl	3c9c <bt_id_get>
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
     63a:	f89d 3020 	ldrb.w	r3, [sp, #32]
     63e:	ac0a      	add	r4, sp, #40	; 0x28
     640:	2b03      	cmp	r3, #3
     642:	d827      	bhi.n	694 <CONFIG_BT_COMPANY_ID+0xa3>
     644:	e8df f003 	tbb	[pc, r3]
     648:	24222002 	.word	0x24222002
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
     64c:	491a      	ldr	r1, [pc, #104]	; (6b8 <CONFIG_BT_COMPANY_ID+0xc7>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
     64e:	4620      	mov	r0, r4
     650:	f00d f9a2 	bl	d998 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
     654:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     658:	9304      	str	r3, [sp, #16]
     65a:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
     65e:	9303      	str	r3, [sp, #12]
     660:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
     664:	9302      	str	r3, [sp, #8]
     666:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
     66a:	9301      	str	r3, [sp, #4]
     66c:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
     670:	9300      	str	r3, [sp, #0]
     672:	211e      	movs	r1, #30
     674:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
     678:	4a10      	ldr	r2, [pc, #64]	; (6bc <CONFIG_BT_COMPANY_ID+0xcb>)
     67a:	9405      	str	r4, [sp, #20]
     67c:	a812      	add	r0, sp, #72	; 0x48
     67e:	f00c fbcb 	bl	ce18 <snprintk>
	printk("Beacon started, advertising as %s\n", addr_s);
     682:	480f      	ldr	r0, [pc, #60]	; (6c0 <CONFIG_BT_COMPANY_ID+0xcf>)
     684:	a912      	add	r1, sp, #72	; 0x48
     686:	e7bc      	b.n	602 <CONFIG_BT_COMPANY_ID+0x11>
		strcpy(type, "random");
     688:	490e      	ldr	r1, [pc, #56]	; (6c4 <CONFIG_BT_COMPANY_ID+0xd3>)
     68a:	e7e0      	b.n	64e <CONFIG_BT_COMPANY_ID+0x5d>
		strcpy(type, "public-id");
     68c:	490e      	ldr	r1, [pc, #56]	; (6c8 <CONFIG_BT_COMPANY_ID+0xd7>)
     68e:	e7de      	b.n	64e <CONFIG_BT_COMPANY_ID+0x5d>
		strcpy(type, "random-id");
     690:	490e      	ldr	r1, [pc, #56]	; (6cc <CONFIG_BT_COMPANY_ID+0xdb>)
     692:	e7dc      	b.n	64e <CONFIG_BT_COMPANY_ID+0x5d>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
     694:	4a0e      	ldr	r2, [pc, #56]	; (6d0 <CONFIG_BT_COMPANY_ID+0xdf>)
     696:	210a      	movs	r1, #10
     698:	4620      	mov	r0, r4
     69a:	f00c fbbd 	bl	ce18 <snprintk>
		break;
     69e:	e7d9      	b.n	654 <CONFIG_BT_COMPANY_ID+0x63>
     6a0:	00010738 	.word	0x00010738
     6a4:	00010390 	.word	0x00010390
     6a8:	00010758 	.word	0x00010758
     6ac:	000103e8 	.word	0x000103e8
     6b0:	00010400 	.word	0x00010400
     6b4:	0001076f 	.word	0x0001076f
     6b8:	00010795 	.word	0x00010795
     6bc:	000107b7 	.word	0x000107b7
     6c0:	000107da 	.word	0x000107da
     6c4:	0001079c 	.word	0x0001079c
     6c8:	000107a3 	.word	0x000107a3
     6cc:	000107ad 	.word	0x000107ad
     6d0:	00010fca 	.word	0x00010fca

000006d4 <main>:

void main(void)
{
     6d4:	b508      	push	{r3, lr}
	int err;

	printk("Starting Beacon Demo\n");
     6d6:	4807      	ldr	r0, [pc, #28]	; (6f4 <main+0x20>)
     6d8:	f00c fb91 	bl	cdfe <printk>

	/* Initialize the Bluetooth Subsystem */
	err = bt_enable(bt_ready);
     6dc:	4806      	ldr	r0, [pc, #24]	; (6f8 <main+0x24>)
     6de:	f003 f9e5 	bl	3aac <bt_enable>
	if (err) {
     6e2:	4601      	mov	r1, r0
     6e4:	b120      	cbz	r0, 6f0 <main+0x1c>
		printk("Bluetooth init failed (err %d)\n", err);
	}
}
     6e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		printk("Bluetooth init failed (err %d)\n", err);
     6ea:	4804      	ldr	r0, [pc, #16]	; (6fc <main+0x28>)
     6ec:	f00c bb87 	b.w	cdfe <printk>
}
     6f0:	bd08      	pop	{r3, pc}
     6f2:	bf00      	nop
     6f4:	000107fd 	.word	0x000107fd
     6f8:	000005ed 	.word	0x000005ed
     6fc:	00010738 	.word	0x00010738

00000700 <cbvprintf_package>:

#endif

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
     700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     704:	4605      	mov	r5, r0
     706:	b08b      	sub	sp, #44	; 0x2c
     708:	4618      	mov	r0, r3
	unsigned int i;
	const char *s;
	bool parsing = false;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
     70a:	f015 0303 	ands.w	r3, r5, #3
     70e:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
{
     712:	9203      	str	r2, [sp, #12]
     714:	460e      	mov	r6, r1
	if ((uintptr_t)packaged % sizeof(void *)) {
     716:	9301      	str	r3, [sp, #4]
     718:	f040 81f5 	bne.w	b06 <CONFIG_ISR_STACK_SIZE+0x306>
	 *
	 * Given the next value to store is the format string pointer
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * a pointer size for the above to preserve alignment.
	 */
	buf += sizeof(char *);
     71c:	1d2c      	adds	r4, r5, #4
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
     71e:	2d00      	cmp	r5, #0
     720:	f040 81f4 	bne.w	b0c <CONFIG_ISR_STACK_SIZE+0x30c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
     724:	f001 0607 	and.w	r6, r1, #7
     728:	1d34      	adds	r4, r6, #4
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
     72a:	f1c6 0608 	rsb	r6, r6, #8
	unsigned int s_ro_cnt = 0; /* number of ro strings */
     72e:	f04f 0a00 	mov.w	sl, #0
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
     732:	2704      	movs	r7, #4
	s = fmt--;
     734:	1e41      	subs	r1, r0, #1
	unsigned int s_rw_cnt = 0; /* number of rw strings */
     736:	f8cd a008 	str.w	sl, [sp, #8]
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
     73a:	f8cd a000 	str.w	sl, [sp]
	bool parsing = false;
     73e:	4652      	mov	r2, sl
	size = sizeof(char *);
     740:	46b9      	mov	r9, r7

		/* copy va_list data over to our buffer */
		if (*fmt == 's') {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
     742:	b105      	cbz	r5, 746 <cbvprintf_package+0x46>
				*(const char **)buf = s;
     744:	6020      	str	r0, [r4, #0]
			}

			bool is_ro = ptr_in_rodata(s);
			bool do_all = !!(flags & CBPRINTF_PACKAGE_ADD_STRING_IDXS);
     746:	9b03      	ldr	r3, [sp, #12]
     748:	f003 0e01 	and.w	lr, r3, #1
	return ((addr >= (const char *)RO_START) &&
     74c:	4bce      	ldr	r3, [pc, #824]	; (a88 <CONFIG_ISR_STACK_SIZE+0x288>)
     74e:	4298      	cmp	r0, r3
     750:	f0c0 812a 	bcc.w	9a8 <CONFIG_ISR_STACK_SIZE+0x1a8>

			if (is_ro && !do_all) {
     754:	4bcd      	ldr	r3, [pc, #820]	; (a8c <CONFIG_ISR_STACK_SIZE+0x28c>)
     756:	4298      	cmp	r0, r3
     758:	f080 8126 	bcs.w	9a8 <CONFIG_ISR_STACK_SIZE+0x1a8>
     75c:	f1be 0f00 	cmp.w	lr, #0
     760:	f000 813c 	beq.w	9dc <CONFIG_ISR_STACK_SIZE+0x1dc>
	return ((addr >= (const char *)RO_START) &&
     764:	f04f 0c01 	mov.w	ip, #1
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
     768:	eba4 0b05 	sub.w	fp, r4, r5
				 * In the do_all case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_all && s_ptr_idx > STR_POS_MASK) {
     76c:	f1be 0f00 	cmp.w	lr, #0
     770:	f000 811d 	beq.w	9ae <CONFIG_ISR_STACK_SIZE+0x1ae>
     774:	f5bb 7f00 	cmp.w	fp, #512	; 0x200
     778:	f0c0 8119 	bcc.w	9ae <CONFIG_ISR_STACK_SIZE+0x1ae>
					__ASSERT(false, "String with too many arguments");
					return -EINVAL;
     77c:	f06f 0015 	mvn.w	r0, #21
     780:	e0f5      	b.n	96e <CONFIG_ISR_STACK_SIZE+0x16e>
		if (!parsing) {
     782:	b932      	cbnz	r2, 792 <cbvprintf_package+0x92>
			if (*fmt == '%') {
     784:	2b25      	cmp	r3, #37	; 0x25
     786:	f040 812c 	bne.w	9e2 <CONFIG_ISR_STACK_SIZE+0x1e2>
				parsing = true;
     78a:	2201      	movs	r2, #1
			align = VA_STACK_ALIGN(ptrdiff_t);
     78c:	2704      	movs	r7, #4
			size = sizeof(intmax_t);
     78e:	46b9      	mov	r9, r7
     790:	e127      	b.n	9e2 <CONFIG_ISR_STACK_SIZE+0x1e2>
		switch (*fmt) {
     792:	2b2b      	cmp	r3, #43	; 0x2b
     794:	d824      	bhi.n	7e0 <cbvprintf_package+0xe0>
     796:	2b1f      	cmp	r3, #31
     798:	d801      	bhi.n	79e <cbvprintf_package+0x9e>
			parsing = false;
     79a:	2200      	movs	r2, #0
     79c:	e121      	b.n	9e2 <CONFIG_ISR_STACK_SIZE+0x1e2>
		switch (*fmt) {
     79e:	f1a3 0020 	sub.w	r0, r3, #32
     7a2:	280b      	cmp	r0, #11
     7a4:	d8f9      	bhi.n	79a <cbvprintf_package+0x9a>
     7a6:	f20f 0c08 	addw	ip, pc, #8
     7aa:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
     7ae:	bf00      	nop
     7b0:	000009e3 	.word	0x000009e3
     7b4:	0000079b 	.word	0x0000079b
     7b8:	0000079b 	.word	0x0000079b
     7bc:	000009e3 	.word	0x000009e3
     7c0:	0000079b 	.word	0x0000079b
     7c4:	0000079b 	.word	0x0000079b
     7c8:	0000079b 	.word	0x0000079b
     7cc:	0000079b 	.word	0x0000079b
     7d0:	0000079b 	.word	0x0000079b
     7d4:	0000079b 	.word	0x0000079b
     7d8:	00000987 	.word	0x00000987
     7dc:	000009e3 	.word	0x000009e3
     7e0:	f1a3 002d 	sub.w	r0, r3, #45	; 0x2d
     7e4:	fa5f fc80 	uxtb.w	ip, r0
     7e8:	f1bc 0f4d 	cmp.w	ip, #77	; 0x4d
     7ec:	d8d5      	bhi.n	79a <cbvprintf_package+0x9a>
     7ee:	284d      	cmp	r0, #77	; 0x4d
     7f0:	d8d3      	bhi.n	79a <cbvprintf_package+0x9a>
     7f2:	f20f 0c08 	addw	ip, pc, #8
     7f6:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
     7fa:	bf00      	nop
     7fc:	000009e3 	.word	0x000009e3
     800:	000009e3 	.word	0x000009e3
     804:	0000079b 	.word	0x0000079b
     808:	000009e3 	.word	0x000009e3
     80c:	000009e3 	.word	0x000009e3
     810:	000009e3 	.word	0x000009e3
     814:	000009e3 	.word	0x000009e3
     818:	000009e3 	.word	0x000009e3
     81c:	000009e3 	.word	0x000009e3
     820:	000009e3 	.word	0x000009e3
     824:	000009e3 	.word	0x000009e3
     828:	000009e3 	.word	0x000009e3
     82c:	000009e3 	.word	0x000009e3
     830:	0000079b 	.word	0x0000079b
     834:	0000079b 	.word	0x0000079b
     838:	0000079b 	.word	0x0000079b
     83c:	0000079b 	.word	0x0000079b
     840:	0000079b 	.word	0x0000079b
     844:	0000079b 	.word	0x0000079b
     848:	0000079b 	.word	0x0000079b
     84c:	0000094f 	.word	0x0000094f
     850:	0000079b 	.word	0x0000079b
     854:	0000079b 	.word	0x0000079b
     858:	0000079b 	.word	0x0000079b
     85c:	0000094f 	.word	0x0000094f
     860:	0000094f 	.word	0x0000094f
     864:	0000094f 	.word	0x0000094f
     868:	0000079b 	.word	0x0000079b
     86c:	0000079b 	.word	0x0000079b
     870:	0000079b 	.word	0x0000079b
     874:	0000079b 	.word	0x0000079b
     878:	000009e3 	.word	0x000009e3
     87c:	0000079b 	.word	0x0000079b
     880:	0000079b 	.word	0x0000079b
     884:	0000079b 	.word	0x0000079b
     888:	0000079b 	.word	0x0000079b
     88c:	0000079b 	.word	0x0000079b
     890:	0000079b 	.word	0x0000079b
     894:	0000079b 	.word	0x0000079b
     898:	0000079b 	.word	0x0000079b
     89c:	0000079b 	.word	0x0000079b
     8a0:	0000079b 	.word	0x0000079b
     8a4:	0000079b 	.word	0x0000079b
     8a8:	00000935 	.word	0x00000935
     8ac:	0000079b 	.word	0x0000079b
     8b0:	0000079b 	.word	0x0000079b
     8b4:	0000079b 	.word	0x0000079b
     8b8:	0000079b 	.word	0x0000079b
     8bc:	0000079b 	.word	0x0000079b
     8c0:	0000079b 	.word	0x0000079b
     8c4:	0000079b 	.word	0x0000079b
     8c8:	0000079b 	.word	0x0000079b
     8cc:	0000094f 	.word	0x0000094f
     8d0:	0000079b 	.word	0x0000079b
     8d4:	00000935 	.word	0x00000935
     8d8:	00000935 	.word	0x00000935
     8dc:	0000094f 	.word	0x0000094f
     8e0:	0000094f 	.word	0x0000094f
     8e4:	0000094f 	.word	0x0000094f
     8e8:	000009e3 	.word	0x000009e3
     8ec:	00000935 	.word	0x00000935
     8f0:	0000097d 	.word	0x0000097d
     8f4:	0000079b 	.word	0x0000079b
     8f8:	000009e3 	.word	0x000009e3
     8fc:	0000079b 	.word	0x0000079b
     900:	00000981 	.word	0x00000981
     904:	00000935 	.word	0x00000935
     908:	00000981 	.word	0x00000981
     90c:	0000079b 	.word	0x0000079b
     910:	0000079b 	.word	0x0000079b
     914:	00000981 	.word	0x00000981
     918:	0000078d 	.word	0x0000078d
     91c:	00000935 	.word	0x00000935
     920:	0000079b 	.word	0x0000079b
     924:	0000079b 	.word	0x0000079b
     928:	00000935 	.word	0x00000935
     92c:	0000079b 	.word	0x0000079b
     930:	0000078d 	.word	0x0000078d
			if (fmt[-1] == 'l') {
     934:	f811 2c01 	ldrb.w	r2, [r1, #-1]
     938:	2a6c      	cmp	r2, #108	; 0x6c
     93a:	d123      	bne.n	984 <CONFIG_ISR_STACK_SIZE+0x184>
				if (fmt[-2] == 'l') {
     93c:	f811 2c02 	ldrb.w	r2, [r1, #-2]
     940:	2a6c      	cmp	r2, #108	; 0x6c
			parsing = false;
     942:	f04f 0200 	mov.w	r2, #0
				if (fmt[-2] == 'l') {
     946:	d02d      	beq.n	9a4 <CONFIG_ISR_STACK_SIZE+0x1a4>
			align = VA_STACK_ALIGN(void *);
     948:	2704      	movs	r7, #4
					size = sizeof(long long);
     94a:	46b9      	mov	r9, r7
     94c:	e01b      	b.n	986 <CONFIG_ISR_STACK_SIZE+0x186>
				v.ld = va_arg(ap, long double);
     94e:	f108 0807 	add.w	r8, r8, #7
     952:	f028 0807 	bic.w	r8, r8, #7
			buf = (void *) ROUND_UP(buf, align);
     956:	3407      	adds	r4, #7
				v.ld = va_arg(ap, long double);
     958:	e8f8 2302 	ldrd	r2, r3, [r8], #8
			buf = (void *) ROUND_UP(buf, align);
     95c:	f024 0407 	bic.w	r4, r4, #7
			if (buf0 != NULL) {
     960:	b155      	cbz	r5, 978 <CONFIG_ISR_STACK_SIZE+0x178>
				if (BUF_OFFSET + size > len) {
     962:	eb0e 0004 	add.w	r0, lr, r4
     966:	42b0      	cmp	r0, r6
     968:	d904      	bls.n	974 <CONFIG_ISR_STACK_SIZE+0x174>
					return -ENOSPC;
     96a:	f06f 001b 	mvn.w	r0, #27
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
     96e:	b00b      	add	sp, #44	; 0x2c
     970:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					*(long double *)buf = v.ld;
     974:	e9c4 2300 	strd	r2, r3, [r4]
			buf += size;
     978:	3408      	adds	r4, #8
			parsing = false;
     97a:	2200      	movs	r2, #0
			align = VA_STACK_ALIGN(intmax_t);
     97c:	2708      	movs	r7, #8
     97e:	e706      	b.n	78e <cbvprintf_package+0x8e>
			parsing = false;
     980:	2200      	movs	r2, #0
     982:	e7e1      	b.n	948 <CONFIG_ISR_STACK_SIZE+0x148>
			parsing = false;
     984:	2200      	movs	r2, #0
		buf = (void *) ROUND_UP(buf, align);
     986:	3c01      	subs	r4, #1
     988:	443c      	add	r4, r7
     98a:	4278      	negs	r0, r7
     98c:	4004      	ands	r4, r0
		if (buf0 != NULL && BUF_OFFSET + size > len) {
     98e:	b125      	cbz	r5, 99a <CONFIG_ISR_STACK_SIZE+0x19a>
     990:	eba9 0005 	sub.w	r0, r9, r5
     994:	4420      	add	r0, r4
     996:	42b0      	cmp	r0, r6
     998:	d8e7      	bhi.n	96a <CONFIG_ISR_STACK_SIZE+0x16a>
		if (*fmt == 's') {
     99a:	2b73      	cmp	r3, #115	; 0x73
     99c:	d143      	bne.n	a26 <CONFIG_ISR_STACK_SIZE+0x226>
			s = va_arg(ap, char *);
     99e:	f858 0b04 	ldr.w	r0, [r8], #4
     9a2:	e6ce      	b.n	742 <cbvprintf_package+0x42>
					align = VA_STACK_ALIGN(long long);
     9a4:	2708      	movs	r7, #8
     9a6:	e7d0      	b.n	94a <CONFIG_ISR_STACK_SIZE+0x14a>
	return ((addr >= (const char *)RO_START) &&
     9a8:	f04f 0c00 	mov.w	ip, #0
     9ac:	e6dc      	b.n	768 <cbvprintf_package+0x68>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
     9ae:	9b00      	ldr	r3, [sp, #0]
     9b0:	2b0f      	cmp	r3, #15
     9b2:	f63f aee3 	bhi.w	77c <cbvprintf_package+0x7c>
				if (buf0 != NULL) {
     9b6:	b345      	cbz	r5, a0a <CONFIG_ISR_STACK_SIZE+0x20a>
					str_ptr_pos[s_idx] = s_ptr_idx;
     9b8:	f8dd e000 	ldr.w	lr, [sp]
     9bc:	a80a      	add	r0, sp, #40	; 0x28
     9be:	f3cb 0387 	ubfx	r3, fp, #2, #8
					if (is_ro) {
     9c2:	4470      	add	r0, lr
     9c4:	f1bc 0f00 	cmp.w	ip, #0
     9c8:	d019      	beq.n	9fe <CONFIG_ISR_STACK_SIZE+0x1fe>
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
     9ca:	f063 037f 	orn	r3, r3, #127	; 0x7f
     9ce:	f800 3c10 	strb.w	r3, [r0, #-16]
						s_ro_cnt++;
     9d2:	f10a 0a01 	add.w	sl, sl, #1
				s_idx++;
     9d6:	9b00      	ldr	r3, [sp, #0]
     9d8:	3301      	adds	r3, #1
     9da:	9300      	str	r3, [sp, #0]
			buf += sizeof(char *);
     9dc:	3404      	adds	r4, #4
				if (BUF_OFFSET + size > len) {
     9de:	f1c5 0e08 	rsb	lr, r5, #8
	while (*++fmt != '\0') {
     9e2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
     9e6:	2b00      	cmp	r3, #0
     9e8:	f47f aecb 	bne.w	782 <cbvprintf_package+0x82>
	if (BUF_OFFSET / sizeof(int) > 255) {
     9ec:	1b60      	subs	r0, r4, r5
     9ee:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
     9f2:	f4bf aec3 	bcs.w	77c <cbvprintf_package+0x7c>
	if (buf0 == NULL) {
     9f6:	bb9d      	cbnz	r5, a60 <CONFIG_ISR_STACK_SIZE+0x260>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
     9f8:	3e08      	subs	r6, #8
     9fa:	4430      	add	r0, r6
     9fc:	e7b7      	b.n	96e <CONFIG_ISR_STACK_SIZE+0x16e>
					str_ptr_pos[s_idx] = s_ptr_idx;
     9fe:	f800 3c10 	strb.w	r3, [r0, #-16]
						s_rw_cnt++;
     a02:	9b02      	ldr	r3, [sp, #8]
     a04:	3301      	adds	r3, #1
     a06:	9302      	str	r3, [sp, #8]
     a08:	e7e5      	b.n	9d6 <CONFIG_ISR_STACK_SIZE+0x1d6>
				} else if (is_ro) {
     a0a:	f1bc 0f00 	cmp.w	ip, #0
     a0e:	d001      	beq.n	a14 <CONFIG_ISR_STACK_SIZE+0x214>
					len += 1;
     a10:	3601      	adds	r6, #1
     a12:	e7e0      	b.n	9d6 <CONFIG_ISR_STACK_SIZE+0x1d6>
     a14:	e9cd 1204 	strd	r1, r2, [sp, #16]
					len += strlen(s) + 1 + 1;
     a18:	f00c ffc8 	bl	d9ac <strlen>
     a1c:	3602      	adds	r6, #2
     a1e:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
     a22:	4406      	add	r6, r0
     a24:	e7d7      	b.n	9d6 <CONFIG_ISR_STACK_SIZE+0x1d6>
		} else if (size == sizeof(int)) {
     a26:	f1b9 0f04 	cmp.w	r9, #4
     a2a:	d108      	bne.n	a3e <CONFIG_ISR_STACK_SIZE+0x23e>
			int v = va_arg(ap, int);
     a2c:	f108 0004 	add.w	r0, r8, #4
			if (buf0 != NULL) {
     a30:	b115      	cbz	r5, a38 <CONFIG_ISR_STACK_SIZE+0x238>
			int v = va_arg(ap, int);
     a32:	f8d8 3000 	ldr.w	r3, [r8]
				*(int *)buf = v;
     a36:	6023      	str	r3, [r4, #0]
			buf += sizeof(int);
     a38:	3404      	adds	r4, #4
			int v = va_arg(ap, int);
     a3a:	4680      	mov	r8, r0
     a3c:	e7d1      	b.n	9e2 <CONFIG_ISR_STACK_SIZE+0x1e2>
		} else if (size == sizeof(long long)) {
     a3e:	f1b9 0f08 	cmp.w	r9, #8
     a42:	f47f ae9b 	bne.w	77c <cbvprintf_package+0x7c>
			long long v = va_arg(ap, long long);
     a46:	f108 0307 	add.w	r3, r8, #7
     a4a:	f023 0307 	bic.w	r3, r3, #7
     a4e:	f103 0808 	add.w	r8, r3, #8
			if (buf0 != NULL) {
     a52:	b11d      	cbz	r5, a5c <CONFIG_ISR_STACK_SIZE+0x25c>
			long long v = va_arg(ap, long long);
     a54:	e9d3 bc00 	ldrd	fp, ip, [r3]
     a58:	e9c4 bc00 	strd	fp, ip, [r4]
			buf += sizeof(long long);
     a5c:	3408      	adds	r4, #8
     a5e:	e7c0      	b.n	9e2 <CONFIG_ISR_STACK_SIZE+0x1e2>
	buf0[1] = s_rw_cnt;
     a60:	9a02      	ldr	r2, [sp, #8]
	*(char **)buf0 = NULL;
     a62:	602b      	str	r3, [r5, #0]
	buf0[0] = BUF_OFFSET / sizeof(int);
     a64:	0880      	lsrs	r0, r0, #2
     a66:	7028      	strb	r0, [r5, #0]
	buf0[1] = s_rw_cnt;
     a68:	706a      	strb	r2, [r5, #1]
	buf0[2] = s_ro_cnt;
     a6a:	f885 a002 	strb.w	sl, [r5, #2]
	if (s_ro_cnt) {
     a6e:	f1ba 0f00 	cmp.w	sl, #0
     a72:	d005      	beq.n	a80 <CONFIG_ISR_STACK_SIZE+0x280>
     a74:	a906      	add	r1, sp, #24
			if (BUF_OFFSET + 1 > len) {
     a76:	f1c5 0001 	rsb	r0, r5, #1
		for (i = 0; i < s_idx; i++) {
     a7a:	9a00      	ldr	r2, [sp, #0]
     a7c:	429a      	cmp	r2, r3
     a7e:	d107      	bne.n	a90 <CONFIG_ISR_STACK_SIZE+0x290>
		if (BUF_OFFSET + 1 + size > len) {
     a80:	f1c5 0901 	rsb	r9, r5, #1
     a84:	e039      	b.n	afa <CONFIG_ISR_STACK_SIZE+0x2fa>
     a86:	bf00      	nop
     a88:	0000fee0 	.word	0x0000fee0
     a8c:	00012154 	.word	0x00012154
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
     a90:	f811 2b01 	ldrb.w	r2, [r1], #1
     a94:	0617      	lsls	r7, r2, #24
     a96:	d507      	bpl.n	aa8 <CONFIG_ISR_STACK_SIZE+0x2a8>
			if (BUF_OFFSET + 1 > len) {
     a98:	1827      	adds	r7, r4, r0
     a9a:	42b7      	cmp	r7, r6
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
     a9c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
			if (BUF_OFFSET + 1 > len) {
     aa0:	f63f af63 	bhi.w	96a <CONFIG_ISR_STACK_SIZE+0x16a>
			*buf++ = pos;
     aa4:	f804 2b01 	strb.w	r2, [r4], #1
		for (i = 0; i < s_idx; i++) {
     aa8:	3301      	adds	r3, #1
     aaa:	e7e6      	b.n	a7a <CONFIG_ISR_STACK_SIZE+0x27a>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
     aac:	9b01      	ldr	r3, [sp, #4]
     aae:	aa06      	add	r2, sp, #24
     ab0:	f812 8003 	ldrb.w	r8, [r2, r3]
     ab4:	f1ba 0f00 	cmp.w	sl, #0
     ab8:	d002      	beq.n	ac0 <CONFIG_ISR_STACK_SIZE+0x2c0>
     aba:	f018 0f80 	tst.w	r8, #128	; 0x80
     abe:	d119      	bne.n	af4 <CONFIG_ISR_STACK_SIZE+0x2f4>
		s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
     ac0:	fa0f f288 	sxth.w	r2, r8
		*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
     ac4:	2300      	movs	r3, #0
		s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
     ac6:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
		*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
     aca:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
		size = strlen(s) + 1;
     ace:	4608      	mov	r0, r1
     ad0:	9102      	str	r1, [sp, #8]
     ad2:	f00c ff6b 	bl	d9ac <strlen>
		if (BUF_OFFSET + 1 + size > len) {
     ad6:	eb04 0209 	add.w	r2, r4, r9
		size = strlen(s) + 1;
     ada:	1c47      	adds	r7, r0, #1
		if (BUF_OFFSET + 1 + size > len) {
     adc:	443a      	add	r2, r7
     ade:	42b2      	cmp	r2, r6
     ae0:	f63f af43 	bhi.w	96a <CONFIG_ISR_STACK_SIZE+0x16a>
		*buf++ = str_ptr_pos[i];
     ae4:	f804 8b01 	strb.w	r8, [r4], #1
		memcpy(buf, s, size);
     ae8:	9902      	ldr	r1, [sp, #8]
     aea:	4620      	mov	r0, r4
     aec:	463a      	mov	r2, r7
     aee:	f00c ff8a 	bl	da06 <memcpy>
		buf += size;
     af2:	443c      	add	r4, r7
	for (i = 0; i < s_idx; i++) {
     af4:	9b01      	ldr	r3, [sp, #4]
     af6:	3301      	adds	r3, #1
     af8:	9301      	str	r3, [sp, #4]
     afa:	e9dd 2300 	ldrd	r2, r3, [sp]
     afe:	429a      	cmp	r2, r3
     b00:	d1d4      	bne.n	aac <CONFIG_ISR_STACK_SIZE+0x2ac>
	return BUF_OFFSET;
     b02:	1b60      	subs	r0, r4, r5
     b04:	e733      	b.n	96e <CONFIG_ISR_STACK_SIZE+0x16e>
		return -EFAULT;
     b06:	f06f 000d 	mvn.w	r0, #13
     b0a:	e730      	b.n	96e <CONFIG_ISR_STACK_SIZE+0x16e>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
     b0c:	2907      	cmp	r1, #7
     b0e:	f63f ae0e 	bhi.w	72e <cbvprintf_package+0x2e>
     b12:	e72a      	b.n	96a <CONFIG_ISR_STACK_SIZE+0x16a>

00000b14 <__printk_hook_install>:
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
     b14:	4b01      	ldr	r3, [pc, #4]	; (b1c <__printk_hook_install+0x8>)
     b16:	6018      	str	r0, [r3, #0]
}
     b18:	4770      	bx	lr
     b1a:	bf00      	nop
     b1c:	20000118 	.word	0x20000118

00000b20 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
     b20:	b530      	push	{r4, r5, lr}
     b22:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
     b24:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
     b28:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
     b2a:	2500      	movs	r5, #0

	cbvprintf(str_out, &ctx, fmt, ap);
     b2c:	a901      	add	r1, sp, #4
     b2e:	4805      	ldr	r0, [pc, #20]	; (b44 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
     b30:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
     b32:	f000 f8e9 	bl	d08 <cbvprintf>

	if (ctx.count < ctx.max) {
     b36:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
     b3a:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
     b3c:	bfb8      	it	lt
     b3e:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
     b40:	b005      	add	sp, #20
     b42:	bd30      	pop	{r4, r5, pc}
     b44:	0000cdd9 	.word	0x0000cdd9

00000b48 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     b48:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     b4c:	f8b0 9018 	ldrh.w	r9, [r0, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     b50:	f019 0808 	ands.w	r8, r9, #8
{
     b54:	4604      	mov	r4, r0
     b56:	4693      	mov	fp, r2
	if (processing) {
     b58:	d00d      	beq.n	b76 <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
     b5a:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     b5c:	bf0c      	ite	eq
     b5e:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     b62:	f049 0920 	orrne.w	r9, r9, #32
     b66:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     b6a:	f38b 8811 	msr	BASEPRI, fp
     b6e:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     b72:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     b76:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
     b7a:	2902      	cmp	r1, #2
     b7c:	d107      	bne.n	b8e <process_event+0x46>
			evt = process_recheck(mgr);
     b7e:	4620      	mov	r0, r4
     b80:	f00c f957 	bl	ce32 <process_recheck>
		if (evt == EVT_NOP) {
     b84:	2800      	cmp	r0, #0
     b86:	d0f0      	beq.n	b6a <process_event+0x22>
		if (evt == EVT_COMPLETE) {
     b88:	2801      	cmp	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     b8a:	8b23      	ldrh	r3, [r4, #24]
		if (evt == EVT_COMPLETE) {
     b8c:	d14e      	bne.n	c2c <process_event+0xe4>
			res = mgr->last_res;
     b8e:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     b90:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
     b92:	2f00      	cmp	r7, #0
     b94:	da15      	bge.n	bc2 <process_event+0x7a>
		*clients = mgr->clients;
     b96:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     b98:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
     b9c:	e9c4 8800 	strd	r8, r8, [r4]
     ba0:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
     ba4:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
     ba6:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     ba8:	8b21      	ldrh	r1, [r4, #24]
     baa:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
     bae:	45ca      	cmp	sl, r9
     bb0:	d002      	beq.n	bb8 <process_event+0x70>
		if (do_monitors
     bb2:	68a3      	ldr	r3, [r4, #8]
     bb4:	2b00      	cmp	r3, #0
     bb6:	d15a      	bne.n	c6e <process_event+0x126>
		    || !sys_slist_is_empty(&clients)
     bb8:	b90d      	cbnz	r5, bbe <process_event+0x76>
		    || (transit != NULL)) {
     bba:	2e00      	cmp	r6, #0
     bbc:	d071      	beq.n	ca2 <process_event+0x15a>
     bbe:	2300      	movs	r3, #0
     bc0:	e056      	b.n	c70 <process_event+0x128>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     bc2:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
     bc6:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
     bc8:	2a01      	cmp	r2, #1
     bca:	d81e      	bhi.n	c0a <process_event+0xc2>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     bcc:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
     bd0:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
     bd2:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     bd4:	b289      	uxth	r1, r1
     bd6:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
     bda:	d10a      	bne.n	bf2 <process_event+0xaa>
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     bdc:	b13d      	cbz	r5, bee <process_event+0xa6>
     bde:	8b63      	ldrh	r3, [r4, #26]
     be0:	462a      	mov	r2, r5

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
     be2:	6812      	ldr	r2, [r2, #0]
				mgr->refs += 1U;
     be4:	3301      	adds	r3, #1
     be6:	b29b      	uxth	r3, r3
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     be8:	2a00      	cmp	r2, #0
     bea:	d1fa      	bne.n	be2 <process_event+0x9a>
     bec:	8363      	strh	r3, [r4, #26]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     bee:	f041 0102 	orr.w	r1, r1, #2
	mgr->flags = (state & ONOFF_STATE_MASK)
     bf2:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
     bf4:	4620      	mov	r0, r4
     bf6:	f00c f91c 	bl	ce32 <process_recheck>
     bfa:	4606      	mov	r6, r0
     bfc:	2800      	cmp	r0, #0
     bfe:	d0d3      	beq.n	ba8 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     c00:	8b23      	ldrh	r3, [r4, #24]
     c02:	f043 0320 	orr.w	r3, r3, #32
     c06:	8323      	strh	r3, [r4, #24]
     c08:	e7cd      	b.n	ba6 <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
     c0a:	2b04      	cmp	r3, #4
     c0c:	d10c      	bne.n	c28 <process_event+0xe0>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     c0e:	f021 0107 	bic.w	r1, r1, #7
     c12:	b289      	uxth	r1, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
     c14:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
     c16:	4620      	mov	r0, r4
     c18:	f00c f90b 	bl	ce32 <process_recheck>
     c1c:	4605      	mov	r5, r0
     c1e:	2800      	cmp	r0, #0
     c20:	d0c1      	beq.n	ba6 <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     c22:	f041 0120 	orr.w	r1, r1, #32
     c26:	8321      	strh	r1, [r4, #24]
     c28:	2500      	movs	r5, #0
     c2a:	e7bc      	b.n	ba6 <process_event+0x5e>
		} else if (evt == EVT_START) {
     c2c:	2803      	cmp	r0, #3
     c2e:	d109      	bne.n	c44 <process_event+0xfc>
			transit = mgr->transitions->start;
     c30:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     c32:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
     c36:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     c38:	f043 0306 	orr.w	r3, r3, #6
	mgr->flags = (state & ONOFF_STATE_MASK)
     c3c:	8323      	strh	r3, [r4, #24]
}
     c3e:	2500      	movs	r5, #0
		res = 0;
     c40:	462f      	mov	r7, r5
     c42:	e7b1      	b.n	ba8 <process_event+0x60>
		} else if (evt == EVT_STOP) {
     c44:	2804      	cmp	r0, #4
     c46:	d106      	bne.n	c56 <process_event+0x10e>
			transit = mgr->transitions->stop;
     c48:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     c4a:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
     c4e:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     c50:	f043 0304 	orr.w	r3, r3, #4
     c54:	e7f2      	b.n	c3c <process_event+0xf4>
		} else if (evt == EVT_RESET) {
     c56:	2805      	cmp	r0, #5
     c58:	d106      	bne.n	c68 <process_event+0x120>
			transit = mgr->transitions->reset;
     c5a:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     c5c:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
     c60:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     c62:	f043 0305 	orr.w	r3, r3, #5
     c66:	e7e9      	b.n	c3c <process_event+0xf4>
     c68:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
     c6a:	462e      	mov	r6, r5
     c6c:	e7e8      	b.n	c40 <process_event+0xf8>
				   && !sys_slist_is_empty(&mgr->monitors);
     c6e:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     c70:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
     c74:	8321      	strh	r1, [r4, #24]
     c76:	f38b 8811 	msr	BASEPRI, fp
     c7a:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
     c7e:	b9fb      	cbnz	r3, cc0 <process_event+0x178>
	while (!sys_slist_is_empty(list)) {
     c80:	bb85      	cbnz	r5, ce4 <process_event+0x19c>
			if (transit != NULL) {
     c82:	b116      	cbz	r6, c8a <process_event+0x142>
				transit(mgr, transition_complete);
     c84:	491f      	ldr	r1, [pc, #124]	; (d04 <process_event+0x1bc>)
     c86:	4620      	mov	r0, r4
     c88:	47b0      	blx	r6
	__asm__ volatile(
     c8a:	f04f 0320 	mov.w	r3, #32
     c8e:	f3ef 8b11 	mrs	fp, BASEPRI
     c92:	f383 8812 	msr	BASEPRI_MAX, r3
     c96:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     c9a:	8b23      	ldrh	r3, [r4, #24]
     c9c:	f023 0308 	bic.w	r3, r3, #8
     ca0:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     ca2:	8b23      	ldrh	r3, [r4, #24]
     ca4:	06da      	lsls	r2, r3, #27
     ca6:	d525      	bpl.n	cf4 <process_event+0x1ac>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     ca8:	f023 0310 	bic.w	r3, r3, #16
     cac:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
     cae:	2101      	movs	r1, #1
		state = mgr->flags & ONOFF_STATE_MASK;
     cb0:	f8b4 9018 	ldrh.w	r9, [r4, #24]
     cb4:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
     cb8:	2900      	cmp	r1, #0
     cba:	f47f af5e 	bne.w	b7a <process_event+0x32>
out:
     cbe:	e754      	b.n	b6a <process_event+0x22>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
     cc0:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
     cc2:	2900      	cmp	r1, #0
     cc4:	d0dc      	beq.n	c80 <process_event+0x138>
	return node->next;
     cc6:	f8d1 9000 	ldr.w	r9, [r1]
		mon->callback(mgr, mon, state, res);
     cca:	f8d1 b004 	ldr.w	fp, [r1, #4]
     cce:	463b      	mov	r3, r7
     cd0:	4652      	mov	r2, sl
     cd2:	4620      	mov	r0, r4
     cd4:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
     cd6:	f1b9 0f00 	cmp.w	r9, #0
     cda:	d0d1      	beq.n	c80 <process_event+0x138>
     cdc:	4649      	mov	r1, r9
     cde:	f8d9 9000 	ldr.w	r9, [r9]
     ce2:	e7f2      	b.n	cca <process_event+0x182>
     ce4:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
     ce6:	463b      	mov	r3, r7
     ce8:	4652      	mov	r2, sl
     cea:	4620      	mov	r0, r4
     cec:	682d      	ldr	r5, [r5, #0]
     cee:	f00c f8bc 	bl	ce6a <notify_one>
     cf2:	e7c5      	b.n	c80 <process_event+0x138>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     cf4:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     cf8:	bf1e      	ittt	ne
     cfa:	f023 0320 	bicne.w	r3, r3, #32
     cfe:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
     d00:	2102      	movne	r1, #2
     d02:	e7d5      	b.n	cb0 <process_event+0x168>
     d04:	0000ce97 	.word	0x0000ce97

00000d08 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
     d08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     d0c:	b091      	sub	sp, #68	; 0x44
     d0e:	468b      	mov	fp, r1
     d10:	9002      	str	r0, [sp, #8]
     d12:	4692      	mov	sl, r2
     d14:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
     d16:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
     d18:	f89a 0000 	ldrb.w	r0, [sl]
     d1c:	b908      	cbnz	r0, d22 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
     d1e:	4628      	mov	r0, r5
     d20:	e35f      	b.n	13e2 <cbvprintf+0x6da>
		if (*fp != '%') {
     d22:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
     d24:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
     d28:	d007      	beq.n	d3a <cbvprintf+0x32>
			OUTC('%');
     d2a:	9b02      	ldr	r3, [sp, #8]
     d2c:	4659      	mov	r1, fp
     d2e:	4798      	blx	r3
     d30:	2800      	cmp	r0, #0
     d32:	f2c0 8356 	blt.w	13e2 <cbvprintf+0x6da>
     d36:	3501      	adds	r5, #1
			break;
     d38:	e212      	b.n	1160 <cbvprintf+0x458>
		} state = {
     d3a:	2218      	movs	r2, #24
     d3c:	2100      	movs	r1, #0
     d3e:	a80a      	add	r0, sp, #40	; 0x28
     d40:	f00c fe6c 	bl	da1c <memset>
	if (*sp == '%') {
     d44:	f89a 3001 	ldrb.w	r3, [sl, #1]
     d48:	2b25      	cmp	r3, #37	; 0x25
     d4a:	d078      	beq.n	e3e <cbvprintf+0x136>
     d4c:	2200      	movs	r2, #0
     d4e:	4610      	mov	r0, r2
     d50:	4696      	mov	lr, r2
     d52:	4694      	mov	ip, r2
     d54:	4616      	mov	r6, r2
     d56:	4639      	mov	r1, r7
		switch (*sp) {
     d58:	f817 3b01 	ldrb.w	r3, [r7], #1
     d5c:	2b2b      	cmp	r3, #43	; 0x2b
     d5e:	f000 809d 	beq.w	e9c <cbvprintf+0x194>
     d62:	f200 8094 	bhi.w	e8e <cbvprintf+0x186>
     d66:	2b20      	cmp	r3, #32
     d68:	f000 809b 	beq.w	ea2 <cbvprintf+0x19a>
     d6c:	2b23      	cmp	r3, #35	; 0x23
     d6e:	f000 809b 	beq.w	ea8 <cbvprintf+0x1a0>
     d72:	b12e      	cbz	r6, d80 <cbvprintf+0x78>
     d74:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
     d78:	f046 0604 	orr.w	r6, r6, #4
     d7c:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
     d80:	f1bc 0f00 	cmp.w	ip, #0
     d84:	d005      	beq.n	d92 <cbvprintf+0x8a>
     d86:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
     d8a:	f046 0608 	orr.w	r6, r6, #8
     d8e:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
     d92:	f1be 0f00 	cmp.w	lr, #0
     d96:	d005      	beq.n	da4 <cbvprintf+0x9c>
     d98:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
     d9c:	f046 0610 	orr.w	r6, r6, #16
     da0:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
     da4:	b128      	cbz	r0, db2 <cbvprintf+0xaa>
     da6:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
     daa:	f040 0020 	orr.w	r0, r0, #32
     dae:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
     db2:	b12a      	cbz	r2, dc0 <cbvprintf+0xb8>
     db4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
     db8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
     dbc:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
     dc0:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
     dc4:	f002 0044 	and.w	r0, r2, #68	; 0x44
     dc8:	2844      	cmp	r0, #68	; 0x44
     dca:	d103      	bne.n	dd4 <cbvprintf+0xcc>
		conv->flag_zero = false;
     dcc:	f36f 1286 	bfc	r2, #6, #1
     dd0:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
     dd4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
     dd8:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
     dda:	f042 0280 	orr.w	r2, r2, #128	; 0x80
     dde:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
     de2:	d17b      	bne.n	edc <cbvprintf+0x1d4>
		conv->width_star = true;
     de4:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
     de8:	f042 0201 	orr.w	r2, r2, #1
			++sp;
     dec:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
     dee:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
     df2:	781a      	ldrb	r2, [r3, #0]
     df4:	2a2e      	cmp	r2, #46	; 0x2e
     df6:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
     dfa:	bf0c      	ite	eq
     dfc:	2101      	moveq	r1, #1
     dfe:	2100      	movne	r1, #0
     e00:	f361 0241 	bfi	r2, r1, #1, #1
     e04:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
     e08:	d174      	bne.n	ef4 <cbvprintf+0x1ec>
	if (*sp == '*') {
     e0a:	785a      	ldrb	r2, [r3, #1]
     e0c:	2a2a      	cmp	r2, #42	; 0x2a
     e0e:	d06a      	beq.n	ee6 <cbvprintf+0x1de>
	++sp;
     e10:	3301      	adds	r3, #1
	size_t val = 0;
     e12:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
     e14:	260a      	movs	r6, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
     e16:	4618      	mov	r0, r3
     e18:	f810 2b01 	ldrb.w	r2, [r0], #1
     e1c:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
     e20:	2f09      	cmp	r7, #9
     e22:	f240 808e 	bls.w	f42 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
     e26:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
     e2a:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
     e2c:	f3c2 0040 	ubfx	r0, r2, #1, #1
     e30:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
     e34:	f361 0241 	bfi	r2, r1, #1, #1
     e38:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
     e3c:	e05a      	b.n	ef4 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
     e3e:	f10a 0702 	add.w	r7, sl, #2
     e42:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
     e46:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
     e4a:	07d9      	lsls	r1, r3, #31
     e4c:	f140 8149 	bpl.w	10e2 <cbvprintf+0x3da>
			width = va_arg(ap, int);
     e50:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
     e54:	f1b9 0f00 	cmp.w	r9, #0
     e58:	da07      	bge.n	e6a <cbvprintf+0x162>
				conv->flag_dash = true;
     e5a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
     e5e:	f042 0204 	orr.w	r2, r2, #4
     e62:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				width = -width;
     e66:	f1c9 0900 	rsb	r9, r9, #0
		if (conv->prec_star) {
     e6a:	075a      	lsls	r2, r3, #29
     e6c:	f140 8142 	bpl.w	10f4 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
     e70:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
     e74:	f1b8 0f00 	cmp.w	r8, #0
     e78:	f280 8141 	bge.w	10fe <cbvprintf+0x3f6>
				conv->prec_present = false;
     e7c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
     e80:	f36f 0341 	bfc	r3, #1, #1
     e84:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
     e88:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
     e8c:	e137      	b.n	10fe <cbvprintf+0x3f6>
		switch (*sp) {
     e8e:	2b2d      	cmp	r3, #45	; 0x2d
     e90:	d00c      	beq.n	eac <cbvprintf+0x1a4>
     e92:	2b30      	cmp	r3, #48	; 0x30
     e94:	f47f af6d 	bne.w	d72 <cbvprintf+0x6a>
			conv->flag_zero = true;
     e98:	2201      	movs	r2, #1
	} while (loop);
     e9a:	e75c      	b.n	d56 <cbvprintf+0x4e>
			conv->flag_plus = true;
     e9c:	f04f 0c01 	mov.w	ip, #1
     ea0:	e759      	b.n	d56 <cbvprintf+0x4e>
			conv->flag_space = true;
     ea2:	f04f 0e01 	mov.w	lr, #1
     ea6:	e756      	b.n	d56 <cbvprintf+0x4e>
			conv->flag_hash = true;
     ea8:	2001      	movs	r0, #1
     eaa:	e754      	b.n	d56 <cbvprintf+0x4e>
		switch (*sp) {
     eac:	2601      	movs	r6, #1
     eae:	e752      	b.n	d56 <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
     eb0:	fb0c 0202 	mla	r2, ip, r2, r0
     eb4:	3a30      	subs	r2, #48	; 0x30
     eb6:	4633      	mov	r3, r6
     eb8:	461e      	mov	r6, r3
     eba:	f816 0b01 	ldrb.w	r0, [r6], #1
     ebe:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
     ec2:	2f09      	cmp	r7, #9
     ec4:	d9f4      	bls.n	eb0 <cbvprintf+0x1a8>
	if (sp != wp) {
     ec6:	4299      	cmp	r1, r3
     ec8:	d093      	beq.n	df2 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
     eca:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
     ece:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
     ed0:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
     ed2:	f362 0141 	bfi	r1, r2, #1, #1
     ed6:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
     eda:	e78a      	b.n	df2 <cbvprintf+0xea>
     edc:	460b      	mov	r3, r1
	size_t val = 0;
     ede:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
     ee0:	f04f 0c0a 	mov.w	ip, #10
     ee4:	e7e8      	b.n	eb8 <cbvprintf+0x1b0>
		conv->prec_star = true;
     ee6:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
     eea:	f042 0204 	orr.w	r2, r2, #4
     eee:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
		return ++sp;
     ef2:	3302      	adds	r3, #2
	switch (*sp) {
     ef4:	461f      	mov	r7, r3
     ef6:	f817 2b01 	ldrb.w	r2, [r7], #1
     efa:	2a6c      	cmp	r2, #108	; 0x6c
     efc:	d041      	beq.n	f82 <cbvprintf+0x27a>
     efe:	d825      	bhi.n	f4c <cbvprintf+0x244>
     f00:	2a68      	cmp	r2, #104	; 0x68
     f02:	d02b      	beq.n	f5c <cbvprintf+0x254>
     f04:	2a6a      	cmp	r2, #106	; 0x6a
     f06:	d046      	beq.n	f96 <cbvprintf+0x28e>
     f08:	2a4c      	cmp	r2, #76	; 0x4c
     f0a:	d04c      	beq.n	fa6 <cbvprintf+0x29e>
     f0c:	461f      	mov	r7, r3
	conv->specifier = *sp++;
     f0e:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
     f12:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	conv->specifier = *sp++;
     f16:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
     f1a:	2a78      	cmp	r2, #120	; 0x78
     f1c:	f200 80d9 	bhi.w	10d2 <cbvprintf+0x3ca>
     f20:	2a57      	cmp	r2, #87	; 0x57
     f22:	d84d      	bhi.n	fc0 <cbvprintf+0x2b8>
     f24:	2a41      	cmp	r2, #65	; 0x41
     f26:	d003      	beq.n	f30 <cbvprintf+0x228>
     f28:	3a45      	subs	r2, #69	; 0x45
     f2a:	2a02      	cmp	r2, #2
     f2c:	f200 80d1 	bhi.w	10d2 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
     f30:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
     f34:	2204      	movs	r2, #4
     f36:	f362 0302 	bfi	r3, r2, #0, #3
     f3a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
     f3e:	2301      	movs	r3, #1
			break;
     f40:	e09e      	b.n	1080 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
     f42:	fb06 2101 	mla	r1, r6, r1, r2
     f46:	3930      	subs	r1, #48	; 0x30
     f48:	4603      	mov	r3, r0
     f4a:	e764      	b.n	e16 <cbvprintf+0x10e>
	switch (*sp) {
     f4c:	2a74      	cmp	r2, #116	; 0x74
     f4e:	d026      	beq.n	f9e <cbvprintf+0x296>
     f50:	2a7a      	cmp	r2, #122	; 0x7a
     f52:	d1db      	bne.n	f0c <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
     f54:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
     f58:	2206      	movs	r2, #6
     f5a:	e00d      	b.n	f78 <cbvprintf+0x270>
		if (*++sp == 'h') {
     f5c:	785a      	ldrb	r2, [r3, #1]
     f5e:	2a68      	cmp	r2, #104	; 0x68
     f60:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
     f64:	d106      	bne.n	f74 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
     f66:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
     f68:	f361 02c6 	bfi	r2, r1, #3, #4
     f6c:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
     f70:	1c9f      	adds	r7, r3, #2
     f72:	e7cc      	b.n	f0e <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
     f74:	4613      	mov	r3, r2
     f76:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
     f78:	f362 03c6 	bfi	r3, r2, #3, #4
     f7c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
     f80:	e7c5      	b.n	f0e <cbvprintf+0x206>
		if (*++sp == 'l') {
     f82:	785a      	ldrb	r2, [r3, #1]
     f84:	2a6c      	cmp	r2, #108	; 0x6c
     f86:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
     f8a:	d101      	bne.n	f90 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
     f8c:	2104      	movs	r1, #4
     f8e:	e7eb      	b.n	f68 <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
     f90:	4613      	mov	r3, r2
     f92:	2203      	movs	r2, #3
     f94:	e7f0      	b.n	f78 <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
     f96:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
     f9a:	2205      	movs	r2, #5
     f9c:	e7ec      	b.n	f78 <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
     f9e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
     fa2:	2207      	movs	r2, #7
     fa4:	e7e8      	b.n	f78 <cbvprintf+0x270>
		conv->unsupported = true;
     fa6:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
     faa:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
     fae:	f023 0302 	bic.w	r3, r3, #2
     fb2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
     fb6:	f043 0302 	orr.w	r3, r3, #2
     fba:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
     fbe:	e7a6      	b.n	f0e <cbvprintf+0x206>
	switch (conv->specifier) {
     fc0:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
     fc4:	2920      	cmp	r1, #32
     fc6:	f200 8084 	bhi.w	10d2 <cbvprintf+0x3ca>
     fca:	a001      	add	r0, pc, #4	; (adr r0, fd0 <cbvprintf+0x2c8>)
     fcc:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
     fd0:	00001095 	.word	0x00001095
     fd4:	000010d3 	.word	0x000010d3
     fd8:	000010d3 	.word	0x000010d3
     fdc:	000010d3 	.word	0x000010d3
     fe0:	000010d3 	.word	0x000010d3
     fe4:	000010d3 	.word	0x000010d3
     fe8:	000010d3 	.word	0x000010d3
     fec:	000010d3 	.word	0x000010d3
     ff0:	000010d3 	.word	0x000010d3
     ff4:	00000f31 	.word	0x00000f31
     ff8:	000010d3 	.word	0x000010d3
     ffc:	00001095 	.word	0x00001095
    1000:	00001055 	.word	0x00001055
    1004:	00000f31 	.word	0x00000f31
    1008:	00000f31 	.word	0x00000f31
    100c:	00000f31 	.word	0x00000f31
    1010:	000010d3 	.word	0x000010d3
    1014:	00001055 	.word	0x00001055
    1018:	000010d3 	.word	0x000010d3
    101c:	000010d3 	.word	0x000010d3
    1020:	000010d3 	.word	0x000010d3
    1024:	000010d3 	.word	0x000010d3
    1028:	0000109d 	.word	0x0000109d
    102c:	00001095 	.word	0x00001095
    1030:	000010b9 	.word	0x000010b9
    1034:	000010d3 	.word	0x000010d3
    1038:	000010d3 	.word	0x000010d3
    103c:	000010b9 	.word	0x000010b9
    1040:	000010d3 	.word	0x000010d3
    1044:	00001095 	.word	0x00001095
    1048:	000010d3 	.word	0x000010d3
    104c:	000010d3 	.word	0x000010d3
    1050:	00001095 	.word	0x00001095
		conv->specifier_cat = SPECIFIER_SINT;
    1054:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    1058:	2001      	movs	r0, #1
		if (conv->length_mod == LENGTH_UPPER_L) {
    105a:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
    105e:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    1062:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
    1064:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
    1068:	bf02      	ittt	eq
    106a:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
    106e:	f041 0101 	orreq.w	r1, r1, #1
    1072:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
    1076:	2a63      	cmp	r2, #99	; 0x63
    1078:	d131      	bne.n	10de <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
    107a:	3b00      	subs	r3, #0
    107c:	bf18      	it	ne
    107e:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
    1080:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    1084:	f3c2 0140 	ubfx	r1, r2, #1, #1
    1088:	430b      	orrs	r3, r1
    108a:	f363 0241 	bfi	r2, r3, #1, #1
    108e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    1092:	e6d8      	b.n	e46 <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
    1094:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    1098:	2002      	movs	r0, #2
    109a:	e7de      	b.n	105a <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
    109c:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    10a0:	f003 0378 	and.w	r3, r3, #120	; 0x78
    10a4:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
    10a8:	2103      	movs	r1, #3
    10aa:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    10ae:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
    10b0:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    10b4:	4143      	adcs	r3, r0
    10b6:	e7e3      	b.n	1080 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
    10b8:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    10bc:	2103      	movs	r1, #3
		if (conv->length_mod != LENGTH_NONE) {
    10be:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
    10c2:	f361 0202 	bfi	r2, r1, #0, #3
    10c6:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
    10ca:	bf14      	ite	ne
    10cc:	2301      	movne	r3, #1
    10ce:	2300      	moveq	r3, #0
    10d0:	e7d6      	b.n	1080 <cbvprintf+0x378>
		conv->invalid = true;
    10d2:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    10d6:	f043 0301 	orr.w	r3, r3, #1
    10da:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
    10de:	2300      	movs	r3, #0
    10e0:	e7ce      	b.n	1080 <cbvprintf+0x378>
		} else if (conv->width_present) {
    10e2:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
    10e6:	2a00      	cmp	r2, #0
			width = conv->width_value;
    10e8:	bfb4      	ite	lt
    10ea:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
		int width = -1;
    10ee:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
    10f2:	e6ba      	b.n	e6a <cbvprintf+0x162>
		} else if (conv->prec_present) {
    10f4:	079b      	lsls	r3, r3, #30
    10f6:	f57f aec7 	bpl.w	e88 <cbvprintf+0x180>
			precision = conv->prec_value;
    10fa:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
			= (enum length_mod_enum)conv->length_mod;
    10fe:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		conv->pad0_value = 0;
    1102:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
    1104:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
    1108:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
		enum specifier_cat_enum specifier_cat
    110c:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
    1110:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
    1112:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
    1116:	d138      	bne.n	118a <cbvprintf+0x482>
			switch (length_mod) {
    1118:	1ecb      	subs	r3, r1, #3
    111a:	2b04      	cmp	r3, #4
    111c:	d822      	bhi.n	1164 <cbvprintf+0x45c>
    111e:	e8df f003 	tbb	[pc, r3]
    1122:	0903      	.short	0x0903
    1124:	2109      	.short	0x2109
    1126:	21          	.byte	0x21
    1127:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
    1128:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
    112c:	17da      	asrs	r2, r3, #31
    112e:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
    1132:	e006      	b.n	1142 <cbvprintf+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
    1134:	3407      	adds	r4, #7
    1136:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
    113a:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    113e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
    1142:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    1146:	f013 0603 	ands.w	r6, r3, #3
    114a:	d056      	beq.n	11fa <cbvprintf+0x4f2>
			OUTS(sp, fp);
    114c:	9802      	ldr	r0, [sp, #8]
    114e:	463b      	mov	r3, r7
    1150:	4652      	mov	r2, sl
    1152:	4659      	mov	r1, fp
    1154:	f00c f97f 	bl	d456 <outs>
    1158:	2800      	cmp	r0, #0
    115a:	f2c0 8142 	blt.w	13e2 <cbvprintf+0x6da>
    115e:	4405      	add	r5, r0
			continue;
    1160:	46ba      	mov	sl, r7
    1162:	e5d9      	b.n	d18 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    1164:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
    1168:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
    116a:	ea4f 72e3 	mov.w	r2, r3, asr #31
    116e:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    1172:	d105      	bne.n	1180 <cbvprintf+0x478>
				value->uint = (unsigned char)value->uint;
    1174:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
    1178:	930a      	str	r3, [sp, #40]	; 0x28
    117a:	2300      	movs	r3, #0
    117c:	930b      	str	r3, [sp, #44]	; 0x2c
    117e:	e7e0      	b.n	1142 <cbvprintf+0x43a>
			} else if (length_mod == LENGTH_H) {
    1180:	2902      	cmp	r1, #2
    1182:	d1de      	bne.n	1142 <cbvprintf+0x43a>
				value->sint = (short)value->sint;
    1184:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
    1188:	e7d0      	b.n	112c <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
    118a:	2b02      	cmp	r3, #2
    118c:	d123      	bne.n	11d6 <cbvprintf+0x4ce>
			switch (length_mod) {
    118e:	1ecb      	subs	r3, r1, #3
    1190:	2b04      	cmp	r3, #4
    1192:	d813      	bhi.n	11bc <cbvprintf+0x4b4>
    1194:	e8df f003 	tbb	[pc, r3]
    1198:	120a0a03 	.word	0x120a0a03
    119c:	12          	.byte	0x12
    119d:	00          	.byte	0x00
					value->uint = (wchar_t)va_arg(ap,
    119e:	6822      	ldr	r2, [r4, #0]
    11a0:	920a      	str	r2, [sp, #40]	; 0x28
    11a2:	2300      	movs	r3, #0
				value->sint = va_arg(ap, int);
    11a4:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
    11a6:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
    11a8:	4604      	mov	r4, r0
    11aa:	e7ca      	b.n	1142 <cbvprintf+0x43a>
					(uint_value_type)va_arg(ap,
    11ac:	1de0      	adds	r0, r4, #7
    11ae:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
    11b2:	e8f0 2302 	ldrd	r2, r3, [r0], #8
    11b6:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
    11ba:	e7f5      	b.n	11a8 <cbvprintf+0x4a0>
					(uint_value_type)va_arg(ap, size_t);
    11bc:	f854 3b04 	ldr.w	r3, [r4], #4
    11c0:	930a      	str	r3, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    11c2:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
    11c4:	f04f 0300 	mov.w	r3, #0
    11c8:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
    11ca:	d0d3      	beq.n	1174 <cbvprintf+0x46c>
			} else if (length_mod == LENGTH_H) {
    11cc:	2902      	cmp	r1, #2
    11ce:	d1b8      	bne.n	1142 <cbvprintf+0x43a>
				value->uint = (unsigned short)value->uint;
    11d0:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    11d4:	e7d0      	b.n	1178 <cbvprintf+0x470>
		} else if (specifier_cat == SPECIFIER_FP) {
    11d6:	2b04      	cmp	r3, #4
    11d8:	d109      	bne.n	11ee <cbvprintf+0x4e6>
					(sint_value_type)va_arg(ap, long long);
    11da:	1de3      	adds	r3, r4, #7
    11dc:	f023 0307 	bic.w	r3, r3, #7
    11e0:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
    11e4:	e9d3 2300 	ldrd	r2, r3, [r3]
    11e8:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    11ec:	e7a9      	b.n	1142 <cbvprintf+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
    11ee:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
    11f0:	bf04      	itt	eq
    11f2:	f854 3b04 	ldreq.w	r3, [r4], #4
    11f6:	930a      	streq	r3, [sp, #40]	; 0x28
    11f8:	e7a3      	b.n	1142 <cbvprintf+0x43a>
		switch (conv->specifier) {
    11fa:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    11fe:	2878      	cmp	r0, #120	; 0x78
    1200:	d8ae      	bhi.n	1160 <cbvprintf+0x458>
    1202:	2862      	cmp	r0, #98	; 0x62
    1204:	d822      	bhi.n	124c <cbvprintf+0x544>
    1206:	2825      	cmp	r0, #37	; 0x25
    1208:	f43f ad8f 	beq.w	d2a <cbvprintf+0x22>
    120c:	2858      	cmp	r0, #88	; 0x58
    120e:	d1a7      	bne.n	1160 <cbvprintf+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
    1210:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    1214:	9300      	str	r3, [sp, #0]
    1216:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    121a:	ab04      	add	r3, sp, #16
    121c:	aa0c      	add	r2, sp, #48	; 0x30
    121e:	f00c f8d4 	bl	d3ca <encode_uint>
    1222:	4682      	mov	sl, r0
			if (precision >= 0) {
    1224:	f1b8 0f00 	cmp.w	r8, #0
    1228:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    122c:	db0c      	blt.n	1248 <cbvprintf+0x540>
				conv->flag_zero = false;
    122e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
    1232:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
    1236:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
    123a:	4598      	cmp	r8, r3
				conv->flag_zero = false;
    123c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
    1240:	d902      	bls.n	1248 <cbvprintf+0x540>
					conv->pad0_value = precision - (int)len;
    1242:	eba8 0303 	sub.w	r3, r8, r3
    1246:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
    1248:	4680      	mov	r8, r0
    124a:	e03d      	b.n	12c8 <cbvprintf+0x5c0>
		switch (conv->specifier) {
    124c:	3863      	subs	r0, #99	; 0x63
    124e:	2815      	cmp	r0, #21
    1250:	d886      	bhi.n	1160 <cbvprintf+0x458>
    1252:	a201      	add	r2, pc, #4	; (adr r2, 1258 <cbvprintf+0x550>)
    1254:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
    1258:	000012d9 	.word	0x000012d9
    125c:	0000133d 	.word	0x0000133d
    1260:	00001161 	.word	0x00001161
    1264:	00001161 	.word	0x00001161
    1268:	00001161 	.word	0x00001161
    126c:	00001161 	.word	0x00001161
    1270:	0000133d 	.word	0x0000133d
    1274:	00001161 	.word	0x00001161
    1278:	00001161 	.word	0x00001161
    127c:	00001161 	.word	0x00001161
    1280:	00001161 	.word	0x00001161
    1284:	00001397 	.word	0x00001397
    1288:	00001365 	.word	0x00001365
    128c:	00001369 	.word	0x00001369
    1290:	00001161 	.word	0x00001161
    1294:	00001161 	.word	0x00001161
    1298:	000012b1 	.word	0x000012b1
    129c:	00001161 	.word	0x00001161
    12a0:	00001365 	.word	0x00001365
    12a4:	00001161 	.word	0x00001161
    12a8:	00001161 	.word	0x00001161
    12ac:	00001365 	.word	0x00001365
			if (precision >= 0) {
    12b0:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
    12b4:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
    12b8:	db0a      	blt.n	12d0 <cbvprintf+0x5c8>
				len = strnlen(bps, precision);
    12ba:	4641      	mov	r1, r8
    12bc:	4650      	mov	r0, sl
    12be:	f00c fb7c 	bl	d9ba <strnlen>
			bpe = bps + len;
    12c2:	eb0a 0800 	add.w	r8, sl, r0
		char sign = 0;
    12c6:	2600      	movs	r6, #0
		if (bps == NULL) {
    12c8:	f1ba 0f00 	cmp.w	sl, #0
    12cc:	d10c      	bne.n	12e8 <cbvprintf+0x5e0>
    12ce:	e747      	b.n	1160 <cbvprintf+0x458>
				len = strlen(bps);
    12d0:	4650      	mov	r0, sl
    12d2:	f00c fb6b 	bl	d9ac <strlen>
    12d6:	e7f4      	b.n	12c2 <cbvprintf+0x5ba>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    12d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12da:	f88d 3010 	strb.w	r3, [sp, #16]
			break;
    12de:	2600      	movs	r6, #0
			bps = buf;
    12e0:	f10d 0a10 	add.w	sl, sp, #16
			bpe = buf + 1;
    12e4:	f10d 0811 	add.w	r8, sp, #17
		size_t nj_len = (bpe - bps);
    12e8:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
    12ec:	b106      	cbz	r6, 12f0 <cbvprintf+0x5e8>
			nj_len += 1U;
    12ee:	3301      	adds	r3, #1
		if (conv->altform_0c) {
    12f0:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    12f4:	06d0      	lsls	r0, r2, #27
    12f6:	d568      	bpl.n	13ca <cbvprintf+0x6c2>
			nj_len += 2U;
    12f8:	3302      	adds	r3, #2
		if (conv->pad_fp) {
    12fa:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
    12fc:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
    12fe:	bf48      	it	mi
    1300:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
    1302:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
    1304:	bf48      	it	mi
    1306:	189b      	addmi	r3, r3, r2
		if (width > 0) {
    1308:	f1b9 0f00 	cmp.w	r9, #0
    130c:	dd76      	ble.n	13fc <cbvprintf+0x6f4>
			if (!conv->flag_dash) {
    130e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
    1312:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
    1316:	f3c2 0380 	ubfx	r3, r2, #2, #1
    131a:	9303      	str	r3, [sp, #12]
    131c:	0753      	lsls	r3, r2, #29
    131e:	d46d      	bmi.n	13fc <cbvprintf+0x6f4>
				if (conv->flag_zero) {
    1320:	0650      	lsls	r0, r2, #25
    1322:	d561      	bpl.n	13e8 <cbvprintf+0x6e0>
					if (sign != 0) {
    1324:	b146      	cbz	r6, 1338 <cbvprintf+0x630>
						OUTC(sign);
    1326:	9b02      	ldr	r3, [sp, #8]
    1328:	4659      	mov	r1, fp
    132a:	4630      	mov	r0, r6
    132c:	4798      	blx	r3
    132e:	2800      	cmp	r0, #0
    1330:	db57      	blt.n	13e2 <cbvprintf+0x6da>
						sign = 0;
    1332:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
    1334:	3501      	adds	r5, #1
						sign = 0;
    1336:	461e      	mov	r6, r3
					pad = '0';
    1338:	2330      	movs	r3, #48	; 0x30
    133a:	e056      	b.n	13ea <cbvprintf+0x6e2>
			if (conv->flag_plus) {
    133c:	071e      	lsls	r6, r3, #28
    133e:	d40f      	bmi.n	1360 <cbvprintf+0x658>
				sign = ' ';
    1340:	f013 0610 	ands.w	r6, r3, #16
    1344:	bf18      	it	ne
    1346:	2620      	movne	r6, #32
			sint = value->sint;
    1348:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
    134c:	2b00      	cmp	r3, #0
    134e:	f6bf af5f 	bge.w	1210 <cbvprintf+0x508>
				value->uint = (uint_value_type)-sint;
    1352:	4252      	negs	r2, r2
    1354:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    1358:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				sign = '-';
    135c:	262d      	movs	r6, #45	; 0x2d
    135e:	e757      	b.n	1210 <cbvprintf+0x508>
				sign = '+';
    1360:	262b      	movs	r6, #43	; 0x2b
    1362:	e7f1      	b.n	1348 <cbvprintf+0x640>
		switch (conv->specifier) {
    1364:	2600      	movs	r6, #0
    1366:	e753      	b.n	1210 <cbvprintf+0x508>
			if (value->ptr != NULL) {
    1368:	980a      	ldr	r0, [sp, #40]	; 0x28
    136a:	b340      	cbz	r0, 13be <cbvprintf+0x6b6>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    136c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    1370:	9300      	str	r3, [sp, #0]
    1372:	aa0c      	add	r2, sp, #48	; 0x30
    1374:	ab04      	add	r3, sp, #16
    1376:	2100      	movs	r1, #0
    1378:	f00c f827 	bl	d3ca <encode_uint>
				conv->altform_0c = true;
    137c:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
    1380:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    1384:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
    1388:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
    138c:	4682      	mov	sl, r0
				conv->altform_0c = true;
    138e:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
		char sign = 0;
    1392:	2600      	movs	r6, #0
				goto prec_int_pad0;
    1394:	e746      	b.n	1224 <cbvprintf+0x51c>
				store_count(conv, value->ptr, count);
    1396:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
    1398:	2907      	cmp	r1, #7
    139a:	f63f aee1 	bhi.w	1160 <cbvprintf+0x458>
    139e:	e8df f001 	tbb	[pc, r1]
    13a2:	040c      	.short	0x040c
    13a4:	08080c06 	.word	0x08080c06
    13a8:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
    13aa:	701d      	strb	r5, [r3, #0]
		break;
    13ac:	e6d8      	b.n	1160 <cbvprintf+0x458>
		*(short *)dp = (short)count;
    13ae:	801d      	strh	r5, [r3, #0]
		break;
    13b0:	e6d6      	b.n	1160 <cbvprintf+0x458>
		*(intmax_t *)dp = (intmax_t)count;
    13b2:	17ea      	asrs	r2, r5, #31
    13b4:	e9c3 5200 	strd	r5, r2, [r3]
		break;
    13b8:	e6d2      	b.n	1160 <cbvprintf+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    13ba:	601d      	str	r5, [r3, #0]
		break;
    13bc:	e6d0      	b.n	1160 <cbvprintf+0x458>
			bps = "(nil)";
    13be:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 1488 <cbvprintf+0x780>
    13c2:	4606      	mov	r6, r0
			bpe = bps + 5;
    13c4:	f10a 0805 	add.w	r8, sl, #5
    13c8:	e78e      	b.n	12e8 <cbvprintf+0x5e0>
		} else if (conv->altform_0) {
    13ca:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
    13cc:	bf48      	it	mi
    13ce:	3301      	addmi	r3, #1
    13d0:	e793      	b.n	12fa <cbvprintf+0x5f2>
					OUTC(pad);
    13d2:	4618      	mov	r0, r3
    13d4:	9303      	str	r3, [sp, #12]
    13d6:	4659      	mov	r1, fp
    13d8:	9b02      	ldr	r3, [sp, #8]
    13da:	4798      	blx	r3
    13dc:	2800      	cmp	r0, #0
    13de:	9b03      	ldr	r3, [sp, #12]
    13e0:	da04      	bge.n	13ec <cbvprintf+0x6e4>
#undef OUTS
#undef OUTC
}
    13e2:	b011      	add	sp, #68	; 0x44
    13e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
    13e8:	2320      	movs	r3, #32
    13ea:	444d      	add	r5, r9
    13ec:	464a      	mov	r2, r9
				while (width-- > 0) {
    13ee:	2a00      	cmp	r2, #0
    13f0:	eba5 0109 	sub.w	r1, r5, r9
    13f4:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    13f8:	dceb      	bgt.n	13d2 <cbvprintf+0x6ca>
    13fa:	460d      	mov	r5, r1
		if (sign != 0) {
    13fc:	b136      	cbz	r6, 140c <cbvprintf+0x704>
			OUTC(sign);
    13fe:	9b02      	ldr	r3, [sp, #8]
    1400:	4659      	mov	r1, fp
    1402:	4630      	mov	r0, r6
    1404:	4798      	blx	r3
    1406:	2800      	cmp	r0, #0
    1408:	dbeb      	blt.n	13e2 <cbvprintf+0x6da>
    140a:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
    140c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    1410:	06d9      	lsls	r1, r3, #27
    1412:	d401      	bmi.n	1418 <cbvprintf+0x710>
    1414:	071a      	lsls	r2, r3, #28
    1416:	d506      	bpl.n	1426 <cbvprintf+0x71e>
				OUTC('0');
    1418:	9b02      	ldr	r3, [sp, #8]
    141a:	4659      	mov	r1, fp
    141c:	2030      	movs	r0, #48	; 0x30
    141e:	4798      	blx	r3
    1420:	2800      	cmp	r0, #0
    1422:	dbde      	blt.n	13e2 <cbvprintf+0x6da>
    1424:	3501      	adds	r5, #1
			if (conv->altform_0c) {
    1426:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    142a:	06db      	lsls	r3, r3, #27
    142c:	d507      	bpl.n	143e <cbvprintf+0x736>
				OUTC(conv->specifier);
    142e:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    1432:	9b02      	ldr	r3, [sp, #8]
    1434:	4659      	mov	r1, fp
    1436:	4798      	blx	r3
    1438:	2800      	cmp	r0, #0
    143a:	dbd2      	blt.n	13e2 <cbvprintf+0x6da>
    143c:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
    143e:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    1440:	442e      	add	r6, r5
    1442:	1b73      	subs	r3, r6, r5
    1444:	2b00      	cmp	r3, #0
    1446:	dc16      	bgt.n	1476 <cbvprintf+0x76e>
			OUTS(bps, bpe);
    1448:	9802      	ldr	r0, [sp, #8]
    144a:	4643      	mov	r3, r8
    144c:	4652      	mov	r2, sl
    144e:	4659      	mov	r1, fp
    1450:	f00c f801 	bl	d456 <outs>
    1454:	2800      	cmp	r0, #0
    1456:	dbc4      	blt.n	13e2 <cbvprintf+0x6da>
    1458:	4405      	add	r5, r0
		while (width > 0) {
    145a:	44a9      	add	r9, r5
    145c:	eba9 0305 	sub.w	r3, r9, r5
    1460:	2b00      	cmp	r3, #0
    1462:	f77f ae7d 	ble.w	1160 <cbvprintf+0x458>
			OUTC(' ');
    1466:	9b02      	ldr	r3, [sp, #8]
    1468:	4659      	mov	r1, fp
    146a:	2020      	movs	r0, #32
    146c:	4798      	blx	r3
    146e:	2800      	cmp	r0, #0
    1470:	dbb7      	blt.n	13e2 <cbvprintf+0x6da>
    1472:	3501      	adds	r5, #1
			--width;
    1474:	e7f2      	b.n	145c <cbvprintf+0x754>
				OUTC('0');
    1476:	9b02      	ldr	r3, [sp, #8]
    1478:	4659      	mov	r1, fp
    147a:	2030      	movs	r0, #48	; 0x30
    147c:	4798      	blx	r3
    147e:	2800      	cmp	r0, #0
    1480:	dbaf      	blt.n	13e2 <cbvprintf+0x6da>
    1482:	3501      	adds	r5, #1
    1484:	e7dd      	b.n	1442 <cbvprintf+0x73a>
    1486:	bf00      	nop
    1488:	0001081f 	.word	0x0001081f

0000148c <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    148c:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    148e:	4910      	ldr	r1, [pc, #64]	; (14d0 <enable_logger+0x44>)
    1490:	4810      	ldr	r0, [pc, #64]	; (14d4 <enable_logger+0x48>)
{
    1492:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
    1494:	2200      	movs	r2, #0
    1496:	f00e fbaf 	bl	fbf8 <k_timer_init>
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke6(*(uintptr_t *)&new_thread, *(uintptr_t *)&stack, *(uintptr_t *)&stack_size, *(uintptr_t *)&entry, *(uintptr_t *)&p1, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    149a:	4d0f      	ldr	r5, [pc, #60]	; (14d8 <enable_logger+0x4c>)
    149c:	490f      	ldr	r1, [pc, #60]	; (14dc <enable_logger+0x50>)
    149e:	2200      	movs	r2, #0
    14a0:	2300      	movs	r3, #0
    14a2:	e9cd 2306 	strd	r2, r3, [sp, #24]
    14a6:	2400      	movs	r4, #0
    14a8:	230e      	movs	r3, #14
    14aa:	e9cd 3403 	strd	r3, r4, [sp, #12]
    14ae:	e9cd 4401 	strd	r4, r4, [sp, #4]
    14b2:	4b0b      	ldr	r3, [pc, #44]	; (14e0 <enable_logger+0x54>)
    14b4:	9400      	str	r4, [sp, #0]
    14b6:	f44f 7240 	mov.w	r2, #768	; 0x300
    14ba:	4628      	mov	r0, r5
    14bc:	f00a faaa 	bl	ba14 <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
    14c0:	4908      	ldr	r1, [pc, #32]	; (14e4 <enable_logger+0x58>)
    14c2:	4628      	mov	r0, r5
    14c4:	f00e f87e 	bl	f5c4 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    14c8:	4620      	mov	r0, r4
    14ca:	b009      	add	sp, #36	; 0x24
    14cc:	bd30      	pop	{r4, r5, pc}
    14ce:	bf00      	nop
    14d0:	000014e9 	.word	0x000014e9
    14d4:	20000a48 	.word	0x20000a48
    14d8:	20000a80 	.word	0x20000a80
    14dc:	20002280 	.word	0x20002280
    14e0:	00001701 	.word	0x00001701
    14e4:	00010825 	.word	0x00010825

000014e8 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    14e8:	4801      	ldr	r0, [pc, #4]	; (14f0 <log_process_thread_timer_expiry_fn+0x8>)
    14ea:	f00a bc25 	b.w	bd38 <z_impl_k_sem_give>
    14ee:	bf00      	nop
    14f0:	2000057c 	.word	0x2000057c

000014f4 <log_init>:
{
    14f4:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    14f6:	4b12      	ldr	r3, [pc, #72]	; (1540 <log_init+0x4c>)
    14f8:	f3bf 8f5b 	dmb	ish
    14fc:	e853 5f00 	ldrex	r5, [r3]
    1500:	1c6a      	adds	r2, r5, #1
    1502:	e843 2100 	strex	r1, r2, [r3]
    1506:	2900      	cmp	r1, #0
    1508:	d1f8      	bne.n	14fc <log_init+0x8>
    150a:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    150e:	b92d      	cbnz	r5, 151c <log_init+0x28>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    1510:	4c0c      	ldr	r4, [pc, #48]	; (1544 <log_init+0x50>)
    1512:	4e0d      	ldr	r6, [pc, #52]	; (1548 <log_init+0x54>)
    1514:	1b36      	subs	r6, r6, r4
    1516:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
    1518:	42b5      	cmp	r5, r6
    151a:	db00      	blt.n	151e <log_init+0x2a>
}
    151c:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
    151e:	7b23      	ldrb	r3, [r4, #12]
    1520:	b153      	cbz	r3, 1538 <log_init+0x44>
			if (backend->api->init != NULL) {
    1522:	6823      	ldr	r3, [r4, #0]
    1524:	699b      	ldr	r3, [r3, #24]
    1526:	b10b      	cbz	r3, 152c <log_init+0x38>
				backend->api->init(backend);
    1528:	4620      	mov	r0, r4
    152a:	4798      	blx	r3
			log_backend_enable(backend,
    152c:	6863      	ldr	r3, [r4, #4]
    152e:	2204      	movs	r2, #4
    1530:	6819      	ldr	r1, [r3, #0]
    1532:	4620      	mov	r0, r4
    1534:	f000 f992 	bl	185c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    1538:	3501      	adds	r5, #1
    153a:	3410      	adds	r4, #16
    153c:	e7ec      	b.n	1518 <log_init+0x24>
    153e:	bf00      	nop
    1540:	20000f90 	.word	0x20000f90
    1544:	00010308 	.word	0x00010308
    1548:	00010318 	.word	0x00010318

0000154c <z_log_notify_backend_enabled>:
{
    154c:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    154e:	4c04      	ldr	r4, [pc, #16]	; (1560 <z_log_notify_backend_enabled+0x14>)
    1550:	7823      	ldrb	r3, [r4, #0]
    1552:	b913      	cbnz	r3, 155a <z_log_notify_backend_enabled+0xe>
    1554:	4803      	ldr	r0, [pc, #12]	; (1564 <z_log_notify_backend_enabled+0x18>)
    1556:	f00a fbef 	bl	bd38 <z_impl_k_sem_give>
	backend_attached = true;
    155a:	2301      	movs	r3, #1
    155c:	7023      	strb	r3, [r4, #0]
}
    155e:	bd10      	pop	{r4, pc}
    1560:	20001c06 	.word	0x20001c06
    1564:	2000057c 	.word	0x2000057c

00001568 <z_log_dropped>:
    1568:	4b0c      	ldr	r3, [pc, #48]	; (159c <z_log_dropped+0x34>)
    156a:	f3bf 8f5b 	dmb	ish
    156e:	e853 2f00 	ldrex	r2, [r3]
    1572:	3201      	adds	r2, #1
    1574:	e843 2100 	strex	r1, r2, [r3]
    1578:	2900      	cmp	r1, #0
    157a:	d1f8      	bne.n	156e <z_log_dropped+0x6>
    157c:	f3bf 8f5b 	dmb	ish
	if (buffered) {
    1580:	b158      	cbz	r0, 159a <z_log_dropped+0x32>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    1582:	f3bf 8f5b 	dmb	ish
    1586:	4b06      	ldr	r3, [pc, #24]	; (15a0 <z_log_dropped+0x38>)
    1588:	e853 2f00 	ldrex	r2, [r3]
    158c:	3a01      	subs	r2, #1
    158e:	e843 2100 	strex	r1, r2, [r3]
    1592:	2900      	cmp	r1, #0
    1594:	d1f8      	bne.n	1588 <z_log_dropped+0x20>
    1596:	f3bf 8f5b 	dmb	ish
}
    159a:	4770      	bx	lr
    159c:	20000f8c 	.word	0x20000f8c
    15a0:	20000f88 	.word	0x20000f88

000015a4 <z_log_dropped_read_and_clear>:
}
    15a4:	2000      	movs	r0, #0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    15a6:	4b06      	ldr	r3, [pc, #24]	; (15c0 <z_log_dropped_read_and_clear+0x1c>)
    15a8:	f3bf 8f5b 	dmb	ish
    15ac:	4602      	mov	r2, r0
    15ae:	e853 0f00 	ldrex	r0, [r3]
    15b2:	e843 2100 	strex	r1, r2, [r3]
    15b6:	2900      	cmp	r1, #0
    15b8:	d1f9      	bne.n	15ae <z_log_dropped_read_and_clear+0xa>
    15ba:	f3bf 8f5b 	dmb	ish
    15be:	4770      	bx	lr
    15c0:	20000f8c 	.word	0x20000f8c

000015c4 <dropped_notify>:
{
    15c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
    15c6:	f7ff ffed 	bl	15a4 <z_log_dropped_read_and_clear>
    15ca:	4c0a      	ldr	r4, [pc, #40]	; (15f4 <dropped_notify+0x30>)
    15cc:	4d0a      	ldr	r5, [pc, #40]	; (15f8 <dropped_notify+0x34>)
    15ce:	1b2d      	subs	r5, r5, r4
    15d0:	4607      	mov	r7, r0
    15d2:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    15d4:	2600      	movs	r6, #0
    15d6:	42ae      	cmp	r6, r5
    15d8:	db00      	blt.n	15dc <dropped_notify+0x18>
}
    15da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    15dc:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    15de:	795b      	ldrb	r3, [r3, #5]
    15e0:	b12b      	cbz	r3, 15ee <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
    15e2:	6823      	ldr	r3, [r4, #0]
    15e4:	691b      	ldr	r3, [r3, #16]
    15e6:	b113      	cbz	r3, 15ee <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
    15e8:	4639      	mov	r1, r7
    15ea:	4620      	mov	r0, r4
    15ec:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    15ee:	3601      	adds	r6, #1
    15f0:	3410      	adds	r4, #16
    15f2:	e7f0      	b.n	15d6 <dropped_notify+0x12>
    15f4:	00010308 	.word	0x00010308
    15f8:	00010318 	.word	0x00010318

000015fc <z_log_msg2_init>:
	mpsc_pbuf_init(&log_buffer, &mpsc_config);
    15fc:	4901      	ldr	r1, [pc, #4]	; (1604 <z_log_msg2_init+0x8>)
    15fe:	4802      	ldr	r0, [pc, #8]	; (1608 <z_log_msg2_init+0xc>)
    1600:	f00b bfd2 	b.w	d5a8 <mpsc_pbuf_init>
    1604:	00010408 	.word	0x00010408
    1608:	20000f94 	.word	0x20000f94

0000160c <log_core_init>:
	panic_mode = false;
    160c:	4a08      	ldr	r2, [pc, #32]	; (1630 <log_core_init+0x24>)
{
    160e:	b508      	push	{r3, lr}
	panic_mode = false;
    1610:	2300      	movs	r3, #0
    1612:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
    1614:	4a07      	ldr	r2, [pc, #28]	; (1634 <log_core_init+0x28>)
    1616:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
    1618:	4b07      	ldr	r3, [pc, #28]	; (1638 <log_core_init+0x2c>)
    161a:	4a08      	ldr	r2, [pc, #32]	; (163c <log_core_init+0x30>)
    161c:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    161e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    1622:	f000 faf7 	bl	1c14 <log_output_timestamp_freq_set>
}
    1626:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		z_log_msg2_init();
    162a:	f7ff bfe7 	b.w	15fc <z_log_msg2_init>
    162e:	bf00      	nop
    1630:	20001c07 	.word	0x20001c07
    1634:	20000f8c 	.word	0x20000f8c
    1638:	2000011c 	.word	0x2000011c
    163c:	0000d847 	.word	0x0000d847

00001640 <z_log_msg2_alloc>:
{
    1640:	4601      	mov	r1, r0
	return (struct log_msg2 *)mpsc_pbuf_alloc(&log_buffer, wlen,
    1642:	2200      	movs	r2, #0
    1644:	4801      	ldr	r0, [pc, #4]	; (164c <z_log_msg2_alloc+0xc>)
    1646:	2300      	movs	r3, #0
    1648:	f00b bfcd 	b.w	d5e6 <mpsc_pbuf_alloc>
    164c:	20000f94 	.word	0x20000f94

00001650 <z_log_msg2_claim>:
	return (union log_msg2_generic *)mpsc_pbuf_claim(&log_buffer);
    1650:	4801      	ldr	r0, [pc, #4]	; (1658 <z_log_msg2_claim+0x8>)
    1652:	f00c b85b 	b.w	d70c <mpsc_pbuf_claim>
    1656:	bf00      	nop
    1658:	20000f94 	.word	0x20000f94

0000165c <z_log_msg2_free>:
{
    165c:	4601      	mov	r1, r0
	mpsc_pbuf_free(&log_buffer, (union mpsc_pbuf_generic *)msg);
    165e:	4801      	ldr	r0, [pc, #4]	; (1664 <z_log_msg2_free+0x8>)
    1660:	f00c b8a0 	b.w	d7a4 <mpsc_pbuf_free>
    1664:	20000f94 	.word	0x20000f94

00001668 <z_log_msg2_pending>:
	return mpsc_pbuf_is_pending(&log_buffer);
    1668:	4801      	ldr	r0, [pc, #4]	; (1670 <z_log_msg2_pending+0x8>)
    166a:	f00c b8cf 	b.w	d80c <mpsc_pbuf_is_pending>
    166e:	bf00      	nop
    1670:	20000f94 	.word	0x20000f94

00001674 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
    1674:	4b1d      	ldr	r3, [pc, #116]	; (16ec <z_impl_log_process+0x78>)
    1676:	781b      	ldrb	r3, [r3, #0]
{
    1678:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    167c:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
    167e:	b903      	cbnz	r3, 1682 <z_impl_log_process+0xe>
    1680:	b388      	cbz	r0, 16e6 <z_impl_log_process+0x72>
	msg = get_msg();
    1682:	f00c f8f4 	bl	d86e <get_msg>
	if (msg.msg) {
    1686:	4606      	mov	r6, r0
    1688:	b118      	cbz	r0, 1692 <z_impl_log_process+0x1e>
		if (!bypass) {
    168a:	b16d      	cbz	r5, 16a8 <z_impl_log_process+0x34>
		z_log_msg2_free(msg.msg2);
    168c:	4630      	mov	r0, r6
    168e:	f7ff ffe5 	bl	165c <z_log_msg2_free>
	if (!bypass && z_log_dropped_pending()) {
    1692:	b92d      	cbnz	r5, 16a0 <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
    1694:	4b16      	ldr	r3, [pc, #88]	; (16f0 <z_impl_log_process+0x7c>)
	if (!bypass && z_log_dropped_pending()) {
    1696:	681b      	ldr	r3, [r3, #0]
    1698:	2b00      	cmp	r3, #0
    169a:	dd01      	ble.n	16a0 <z_impl_log_process+0x2c>
		dropped_notify();
    169c:	f7ff ff92 	bl	15c4 <dropped_notify>
}
    16a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_log_msg2_pending();
    16a4:	f7ff bfe0 	b.w	1668 <z_log_msg2_pending>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    16a8:	4b12      	ldr	r3, [pc, #72]	; (16f4 <z_impl_log_process+0x80>)
    16aa:	f3bf 8f5b 	dmb	ish
    16ae:	e853 2f00 	ldrex	r2, [r3]
    16b2:	3a01      	subs	r2, #1
    16b4:	e843 2100 	strex	r1, r2, [r3]
    16b8:	2900      	cmp	r1, #0
    16ba:	d1f8      	bne.n	16ae <z_impl_log_process+0x3a>
    16bc:	f3bf 8f5b 	dmb	ish
	return __log_backends_end - __log_backends_start;
    16c0:	4c0d      	ldr	r4, [pc, #52]	; (16f8 <z_impl_log_process+0x84>)
    16c2:	4f0e      	ldr	r7, [pc, #56]	; (16fc <z_impl_log_process+0x88>)
    16c4:	1b3f      	subs	r7, r7, r4
    16c6:	113f      	asrs	r7, r7, #4
    16c8:	46a8      	mov	r8, r5
		for (int i = 0; i < log_backend_count_get(); i++) {
    16ca:	45b8      	cmp	r8, r7
    16cc:	dade      	bge.n	168c <z_impl_log_process+0x18>
	return backend->cb->active;
    16ce:	6863      	ldr	r3, [r4, #4]
			if (log_backend_is_active(backend) &&
    16d0:	795b      	ldrb	r3, [r3, #5]
    16d2:	b123      	cbz	r3, 16de <z_impl_log_process+0x6a>
	backend->api->process(backend, msg);
    16d4:	6823      	ldr	r3, [r4, #0]
    16d6:	4631      	mov	r1, r6
    16d8:	681b      	ldr	r3, [r3, #0]
    16da:	4620      	mov	r0, r4
    16dc:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
    16de:	f108 0801 	add.w	r8, r8, #1
    16e2:	3410      	adds	r4, #16
    16e4:	e7f1      	b.n	16ca <z_impl_log_process+0x56>
}
    16e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    16ea:	bf00      	nop
    16ec:	20001c06 	.word	0x20001c06
    16f0:	20000f8c 	.word	0x20000f8c
    16f4:	20000f88 	.word	0x20000f88
    16f8:	00010308 	.word	0x00010308
    16fc:	00010318 	.word	0x00010318

00001700 <log_process_thread_func>:
{
    1700:	b510      	push	{r4, lr}
	log_init();
    1702:	f7ff fef7 	bl	14f4 <log_init>
	return z_impl_z_current_get();
    1706:	f00a ffdd 	bl	c6c4 <z_impl_z_current_get>
	proc_tid = process_tid;
    170a:	4b0c      	ldr	r3, [pc, #48]	; (173c <log_process_thread_func+0x3c>)
    170c:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    170e:	b130      	cbz	r0, 171e <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    1710:	4b0b      	ldr	r3, [pc, #44]	; (1740 <log_process_thread_func+0x40>)
	    process_tid &&
    1712:	681b      	ldr	r3, [r3, #0]
    1714:	2b09      	cmp	r3, #9
    1716:	dd02      	ble.n	171e <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
    1718:	480a      	ldr	r0, [pc, #40]	; (1744 <log_process_thread_func+0x44>)
    171a:	f00a fb0d 	bl	bd38 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    171e:	4c09      	ldr	r4, [pc, #36]	; (1744 <log_process_thread_func+0x44>)
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    1720:	2000      	movs	r0, #0
    1722:	f7ff ffa7 	bl	1674 <z_impl_log_process>
		if (log_process(false) == false) {
    1726:	2800      	cmp	r0, #0
    1728:	d1fa      	bne.n	1720 <log_process_thread_func+0x20>
    172a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    172e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1732:	4620      	mov	r0, r4
    1734:	f00a fb26 	bl	bd84 <z_impl_k_sem_take>
    1738:	e7f2      	b.n	1720 <log_process_thread_func+0x20>
    173a:	bf00      	nop
    173c:	20000fd0 	.word	0x20000fd0
    1740:	20000f88 	.word	0x20000f88
    1744:	2000057c 	.word	0x2000057c

00001748 <z_log_msg_post_finalize>:
{
    1748:	b513      	push	{r0, r1, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    174a:	4b1d      	ldr	r3, [pc, #116]	; (17c0 <z_log_msg_post_finalize+0x78>)
    174c:	f3bf 8f5b 	dmb	ish
    1750:	e853 2f00 	ldrex	r2, [r3]
    1754:	1c51      	adds	r1, r2, #1
    1756:	e843 1000 	strex	r0, r1, [r3]
    175a:	2800      	cmp	r0, #0
    175c:	d1f8      	bne.n	1750 <z_log_msg_post_finalize+0x8>
    175e:	f3bf 8f5b 	dmb	ish
	if (panic_mode) {
    1762:	4b18      	ldr	r3, [pc, #96]	; (17c4 <z_log_msg_post_finalize+0x7c>)
    1764:	781b      	ldrb	r3, [r3, #0]
    1766:	b183      	cbz	r3, 178a <z_log_msg_post_finalize+0x42>
    1768:	f04f 0320 	mov.w	r3, #32
    176c:	f3ef 8411 	mrs	r4, BASEPRI
    1770:	f383 8812 	msr	BASEPRI_MAX, r3
    1774:	f3bf 8f6f 	isb	sy
    1778:	2000      	movs	r0, #0
    177a:	f7ff ff7b 	bl	1674 <z_impl_log_process>
	__asm__ volatile(
    177e:	f384 8811 	msr	BASEPRI, r4
    1782:	f3bf 8f6f 	isb	sy
}
    1786:	b002      	add	sp, #8
    1788:	bd10      	pop	{r4, pc}
	} else if (proc_tid != NULL && cnt == 0) {
    178a:	4b0f      	ldr	r3, [pc, #60]	; (17c8 <z_log_msg_post_finalize+0x80>)
    178c:	681b      	ldr	r3, [r3, #0]
    178e:	2b00      	cmp	r3, #0
    1790:	d0f9      	beq.n	1786 <z_log_msg_post_finalize+0x3e>
    1792:	b952      	cbnz	r2, 17aa <z_log_msg_post_finalize+0x62>
	z_impl_k_timer_start(timer, duration, period);
    1794:	2200      	movs	r2, #0
    1796:	2300      	movs	r3, #0
    1798:	e9cd 2300 	strd	r2, r3, [sp]
    179c:	480b      	ldr	r0, [pc, #44]	; (17cc <z_log_msg_post_finalize+0x84>)
    179e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    17a2:	2300      	movs	r3, #0
    17a4:	f00b f9a2 	bl	caec <z_impl_k_timer_start>
    17a8:	e7ed      	b.n	1786 <z_log_msg_post_finalize+0x3e>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    17aa:	2a0a      	cmp	r2, #10
    17ac:	d1eb      	bne.n	1786 <z_log_msg_post_finalize+0x3e>
	z_impl_k_timer_stop(timer);
    17ae:	4807      	ldr	r0, [pc, #28]	; (17cc <z_log_msg_post_finalize+0x84>)
    17b0:	f00e fa2e 	bl	fc10 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    17b4:	4806      	ldr	r0, [pc, #24]	; (17d0 <z_log_msg_post_finalize+0x88>)
}
    17b6:	b002      	add	sp, #8
    17b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    17bc:	f00a babc 	b.w	bd38 <z_impl_k_sem_give>
    17c0:	20000f88 	.word	0x20000f88
    17c4:	20001c07 	.word	0x20001c07
    17c8:	20000fd0 	.word	0x20000fd0
    17cc:	20000a48 	.word	0x20000a48
    17d0:	2000057c 	.word	0x2000057c

000017d4 <z_log_msg2_commit>:
	msg->hdr.timestamp = timestamp_func();
    17d4:	4b06      	ldr	r3, [pc, #24]	; (17f0 <z_log_msg2_commit+0x1c>)
{
    17d6:	b510      	push	{r4, lr}
	msg->hdr.timestamp = timestamp_func();
    17d8:	681b      	ldr	r3, [r3, #0]
{
    17da:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
    17dc:	4798      	blx	r3
	mpsc_pbuf_commit(&log_buffer, (union mpsc_pbuf_generic *)msg);
    17de:	4621      	mov	r1, r4
	msg->hdr.timestamp = timestamp_func();
    17e0:	60a0      	str	r0, [r4, #8]
	mpsc_pbuf_commit(&log_buffer, (union mpsc_pbuf_generic *)msg);
    17e2:	4804      	ldr	r0, [pc, #16]	; (17f4 <z_log_msg2_commit+0x20>)
    17e4:	f00b ff75 	bl	d6d2 <mpsc_pbuf_commit>
}
    17e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_log_msg_post_finalize();
    17ec:	f7ff bfac 	b.w	1748 <z_log_msg_post_finalize>
    17f0:	2000011c 	.word	0x2000011c
    17f4:	20000f94 	.word	0x20000f94

000017f8 <z_impl_log_panic>:
{
    17f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
    17fa:	4f0e      	ldr	r7, [pc, #56]	; (1834 <z_impl_log_panic+0x3c>)
    17fc:	783d      	ldrb	r5, [r7, #0]
    17fe:	b975      	cbnz	r5, 181e <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
    1800:	4c0d      	ldr	r4, [pc, #52]	; (1838 <z_impl_log_panic+0x40>)
    1802:	4e0e      	ldr	r6, [pc, #56]	; (183c <z_impl_log_panic+0x44>)
	log_init();
    1804:	f7ff fe76 	bl	14f4 <log_init>
    1808:	1b36      	subs	r6, r6, r4
    180a:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    180c:	42b5      	cmp	r5, r6
    180e:	db07      	blt.n	1820 <z_impl_log_panic+0x28>
    1810:	2000      	movs	r0, #0
    1812:	f7ff ff2f 	bl	1674 <z_impl_log_process>
		while (log_process(false) == true) {
    1816:	2800      	cmp	r0, #0
    1818:	d1fa      	bne.n	1810 <z_impl_log_panic+0x18>
	panic_mode = true;
    181a:	2301      	movs	r3, #1
    181c:	703b      	strb	r3, [r7, #0]
}
    181e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
    1820:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    1822:	795b      	ldrb	r3, [r3, #5]
    1824:	b11b      	cbz	r3, 182e <z_impl_log_panic+0x36>
	backend->api->panic(backend);
    1826:	6823      	ldr	r3, [r4, #0]
    1828:	4620      	mov	r0, r4
    182a:	695b      	ldr	r3, [r3, #20]
    182c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    182e:	3501      	adds	r5, #1
    1830:	3410      	adds	r4, #16
    1832:	e7eb      	b.n	180c <z_impl_log_panic+0x14>
    1834:	20001c07 	.word	0x20001c07
    1838:	00010308 	.word	0x00010308
    183c:	00010318 	.word	0x00010318

00001840 <log_source_name_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
    1840:	4a04      	ldr	r2, [pc, #16]	; (1854 <log_source_name_get+0x14>)
    1842:	4b05      	ldr	r3, [pc, #20]	; (1858 <log_source_name_get+0x18>)
    1844:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    1846:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
    184a:	bf34      	ite	cc
    184c:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    1850:	2000      	movcs	r0, #0
}
    1852:	4770      	bx	lr
    1854:	00010200 	.word	0x00010200
    1858:	00010308 	.word	0x00010308

0000185c <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
    185c:	4a05      	ldr	r2, [pc, #20]	; (1874 <log_backend_enable+0x18>)
	backend->cb->id = id;
    185e:	6843      	ldr	r3, [r0, #4]
    1860:	1a80      	subs	r0, r0, r2
    1862:	1100      	asrs	r0, r0, #4
    1864:	3001      	adds	r0, #1
	backend->cb->active = true;
    1866:	2201      	movs	r2, #1

	if (!IS_ENABLED(CONFIG_LOG1)) {
		__ASSERT(backend->api->process, "Backend does not support v2 API");
	}

	log_backend_id_set(backend, id);
    1868:	7118      	strb	r0, [r3, #4]
	backend->cb->ctx = ctx;
    186a:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    186c:	715a      	strb	r2, [r3, #5]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
    186e:	f7ff be6d 	b.w	154c <z_log_notify_backend_enabled>
    1872:	bf00      	nop
    1874:	00010308 	.word	0x00010308

00001878 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
    1878:	b40e      	push	{r1, r2, r3}
    187a:	b503      	push	{r0, r1, lr}
    187c:	ab03      	add	r3, sp, #12
    187e:	4601      	mov	r1, r0
    1880:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
    1884:	4804      	ldr	r0, [pc, #16]	; (1898 <print_formatted+0x20>)
	va_start(args, fmt);
    1886:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    1888:	f7ff fa3e 	bl	d08 <cbvprintf>
	va_end(args);

	return length;
}
    188c:	b002      	add	sp, #8
    188e:	f85d eb04 	ldr.w	lr, [sp], #4
    1892:	b003      	add	sp, #12
    1894:	4770      	bx	lr
    1896:	bf00      	nop
    1898:	0000d8af 	.word	0x0000d8af

0000189c <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
    189c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    18a0:	461d      	mov	r5, r3
    18a2:	9b08      	ldr	r3, [sp, #32]
    18a4:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    18a6:	06da      	lsls	r2, r3, #27
{
    18a8:	4604      	mov	r4, r0
    18aa:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    18ac:	d405      	bmi.n	18ba <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    18ae:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
    18b0:	bf4c      	ite	mi
    18b2:	492a      	ldrmi	r1, [pc, #168]	; (195c <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
    18b4:	492a      	ldrpl	r1, [pc, #168]	; (1960 <hexdump_line_print+0xc4>)
    18b6:	f7ff ffdf 	bl	1878 <print_formatted>
	newline_print(output, flags);

	for (int i = 0; i < prefix_offset; i++) {
		print_formatted(output, " ");
    18ba:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1964 <hexdump_line_print+0xc8>
{
    18be:	f04f 0800 	mov.w	r8, #0
	for (int i = 0; i < prefix_offset; i++) {
    18c2:	45a8      	cmp	r8, r5
    18c4:	db2a      	blt.n	191c <hexdump_line_print+0x80>
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
    18c6:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 1968 <hexdump_line_print+0xcc>
			print_formatted(output, "%02x ", data[i]);
    18ca:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 196c <hexdump_line_print+0xd0>
			print_formatted(output, " ");
    18ce:	f8df a094 	ldr.w	sl, [pc, #148]	; 1964 <hexdump_line_print+0xc8>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    18d2:	2500      	movs	r5, #0
		if (i < length) {
    18d4:	42bd      	cmp	r5, r7
    18d6:	d22f      	bcs.n	1938 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
    18d8:	5d72      	ldrb	r2, [r6, r5]
    18da:	4649      	mov	r1, r9
    18dc:	4620      	mov	r0, r4
    18de:	f7ff ffcb 	bl	1878 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    18e2:	3501      	adds	r5, #1
    18e4:	2d10      	cmp	r5, #16
    18e6:	d120      	bne.n	192a <hexdump_line_print+0x8e>
		}
	}

	print_formatted(output, "|");
    18e8:	4921      	ldr	r1, [pc, #132]	; (1970 <hexdump_line_print+0xd4>)
			char c = (char)data[i];

			print_formatted(output, "%c",
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
    18ea:	f8df 8078 	ldr.w	r8, [pc, #120]	; 1964 <hexdump_line_print+0xc8>
			print_formatted(output, "%c",
    18ee:	f8df 9084 	ldr.w	r9, [pc, #132]	; 1974 <hexdump_line_print+0xd8>
	print_formatted(output, "|");
    18f2:	4620      	mov	r0, r4
    18f4:	f7ff ffc0 	bl	1878 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    18f8:	2500      	movs	r5, #0
		if (i < length) {
    18fa:	42af      	cmp	r7, r5
    18fc:	d928      	bls.n	1950 <hexdump_line_print+0xb4>
			char c = (char)data[i];
    18fe:	5d72      	ldrb	r2, [r6, r5]
	return (int)((((unsigned)c) >= ' ') &&
    1900:	f1a2 0320 	sub.w	r3, r2, #32
    1904:	2b5f      	cmp	r3, #95	; 0x5f
			print_formatted(output, "%c",
    1906:	bf28      	it	cs
    1908:	222e      	movcs	r2, #46	; 0x2e
    190a:	4649      	mov	r1, r9
    190c:	4620      	mov	r0, r4
    190e:	f7ff ffb3 	bl	1878 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    1912:	3501      	adds	r5, #1
    1914:	2d10      	cmp	r5, #16
    1916:	d114      	bne.n	1942 <hexdump_line_print+0xa6>
		}
	}
}
    1918:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
    191c:	4649      	mov	r1, r9
    191e:	4620      	mov	r0, r4
    1920:	f7ff ffaa 	bl	1878 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    1924:	f108 0801 	add.w	r8, r8, #1
    1928:	e7cb      	b.n	18c2 <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
    192a:	076a      	lsls	r2, r5, #29
    192c:	d1d2      	bne.n	18d4 <hexdump_line_print+0x38>
			print_formatted(output, " ");
    192e:	4651      	mov	r1, sl
    1930:	4620      	mov	r0, r4
    1932:	f7ff ffa1 	bl	1878 <print_formatted>
    1936:	e7cd      	b.n	18d4 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
    1938:	4641      	mov	r1, r8
    193a:	4620      	mov	r0, r4
    193c:	f7ff ff9c 	bl	1878 <print_formatted>
    1940:	e7cf      	b.n	18e2 <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
    1942:	076b      	lsls	r3, r5, #29
    1944:	d1d9      	bne.n	18fa <hexdump_line_print+0x5e>
			print_formatted(output, " ");
    1946:	4641      	mov	r1, r8
    1948:	4620      	mov	r0, r4
    194a:	f7ff ff95 	bl	1878 <print_formatted>
    194e:	e7d4      	b.n	18fa <hexdump_line_print+0x5e>
			print_formatted(output, " ");
    1950:	4641      	mov	r1, r8
    1952:	4620      	mov	r0, r4
    1954:	f7ff ff90 	bl	1878 <print_formatted>
    1958:	e7db      	b.n	1912 <hexdump_line_print+0x76>
    195a:	bf00      	nop
    195c:	00010832 	.word	0x00010832
    1960:	00010831 	.word	0x00010831
    1964:	0001083c 	.word	0x0001083c
    1968:	0001083a 	.word	0x0001083a
    196c:	00010834 	.word	0x00010834
    1970:	0001083e 	.word	0x0001083e
    1974:	00010840 	.word	0x00010840

00001978 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
    1978:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    197c:	b087      	sub	sp, #28
    197e:	461c      	mov	r4, r3
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    1980:	f001 0301 	and.w	r3, r1, #1
{
    1984:	9205      	str	r2, [sp, #20]
    1986:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
    198a:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    198e:	9304      	str	r3, [sp, #16]
{
    1990:	4607      	mov	r7, r0
    1992:	4688      	mov	r8, r1
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
    1994:	f001 0b02 	and.w	fp, r1, #2
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    1998:	f001 0608 	and.w	r6, r1, #8
	const char *tag = z_log_get_tag();
    199c:	f00b ff6b 	bl	d876 <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
    19a0:	4602      	mov	r2, r0
    19a2:	2800      	cmp	r0, #0
    19a4:	d044      	beq.n	1a30 <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
    19a6:	493a      	ldr	r1, [pc, #232]	; (1a90 <prefix_print+0x118>)
    19a8:	4638      	mov	r0, r7
    19aa:	f7ff ff65 	bl	1878 <print_formatted>
    19ae:	4605      	mov	r5, r0
	}

	if (stamp) {
    19b0:	f1bb 0f00 	cmp.w	fp, #0
    19b4:	d008      	beq.n	19c8 <prefix_print+0x50>
	if (!format) {
    19b6:	f018 0f44 	tst.w	r8, #68	; 0x44
    19ba:	d13b      	bne.n	1a34 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
    19bc:	4935      	ldr	r1, [pc, #212]	; (1a94 <prefix_print+0x11c>)
    19be:	4622      	mov	r2, r4
    19c0:	4638      	mov	r0, r7
    19c2:	f7ff ff59 	bl	1878 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
    19c6:	4405      	add	r5, r0
	if (color) {
    19c8:	9b04      	ldr	r3, [sp, #16]
    19ca:	b153      	cbz	r3, 19e2 <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
    19cc:	4b32      	ldr	r3, [pc, #200]	; (1a98 <prefix_print+0x120>)
		print_formatted(output, "%s", log_color);
    19ce:	4933      	ldr	r1, [pc, #204]	; (1a9c <prefix_print+0x124>)
		const char *log_color = start && (colors[level] != NULL) ?
    19d0:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
    19d4:	4b32      	ldr	r3, [pc, #200]	; (1aa0 <prefix_print+0x128>)
    19d6:	4638      	mov	r0, r7
    19d8:	2a00      	cmp	r2, #0
    19da:	bf08      	it	eq
    19dc:	461a      	moveq	r2, r3
    19de:	f7ff ff4b 	bl	1878 <print_formatted>
	if (level_on) {
    19e2:	b13e      	cbz	r6, 19f4 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
    19e4:	4b2f      	ldr	r3, [pc, #188]	; (1aa4 <prefix_print+0x12c>)
    19e6:	4930      	ldr	r1, [pc, #192]	; (1aa8 <prefix_print+0x130>)
    19e8:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
    19ec:	4638      	mov	r0, r7
    19ee:	f7ff ff43 	bl	1878 <print_formatted>
    19f2:	4606      	mov	r6, r0
	if (source_id >= 0) {
    19f4:	f1ba 0f00 	cmp.w	sl, #0
    19f8:	db16      	blt.n	1a28 <prefix_print+0xb0>
		total += print_formatted(output,
    19fa:	9b05      	ldr	r3, [sp, #20]
    19fc:	2b00      	cmp	r3, #0
    19fe:	d045      	beq.n	1a8c <prefix_print+0x114>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    1a00:	2301      	movs	r3, #1
    1a02:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
    1a06:	4b29      	ldr	r3, [pc, #164]	; (1aac <prefix_print+0x134>)
    1a08:	4c29      	ldr	r4, [pc, #164]	; (1ab0 <prefix_print+0x138>)
    1a0a:	f019 0f10 	tst.w	r9, #16
    1a0e:	bf18      	it	ne
    1a10:	461c      	movne	r4, r3
    1a12:	4651      	mov	r1, sl
    1a14:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
    1a18:	f7ff ff12 	bl	1840 <log_source_name_get>
    1a1c:	4621      	mov	r1, r4
    1a1e:	4602      	mov	r2, r0
    1a20:	4638      	mov	r0, r7
    1a22:	f7ff ff29 	bl	1878 <print_formatted>
    1a26:	4406      	add	r6, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
    1a28:	1970      	adds	r0, r6, r5
    1a2a:	b007      	add	sp, #28
    1a2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
    1a30:	4605      	mov	r5, r0
    1a32:	e7bd      	b.n	19b0 <prefix_print+0x38>
	} else if (freq != 0U) {
    1a34:	4b1f      	ldr	r3, [pc, #124]	; (1ab4 <prefix_print+0x13c>)
    1a36:	6818      	ldr	r0, [r3, #0]
    1a38:	2800      	cmp	r0, #0
    1a3a:	d0c4      	beq.n	19c6 <prefix_print+0x4e>
		timestamp /= timestamp_div;
    1a3c:	4b1e      	ldr	r3, [pc, #120]	; (1ab8 <prefix_print+0x140>)
		ms = (remainder * 1000U) / freq;
    1a3e:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
		timestamp /= timestamp_div;
    1a42:	681b      	ldr	r3, [r3, #0]
    1a44:	fbb4 f4f3 	udiv	r4, r4, r3
		total_seconds = timestamp / freq;
    1a48:	f44f 6161 	mov.w	r1, #3600	; 0xe10
    1a4c:	fbb4 f3f0 	udiv	r3, r4, r0
		remainder = timestamp % freq;
    1a50:	fb00 4413 	mls	r4, r0, r3, r4
		ms = (remainder * 1000U) / freq;
    1a54:	fb08 f404 	mul.w	r4, r8, r4
		mins = seconds / 60U;
    1a58:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
    1a5c:	fbb3 f2f1 	udiv	r2, r3, r1
    1a60:	fb01 3112 	mls	r1, r1, r2, r3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    1a64:	fbb4 fef0 	udiv	lr, r4, r0
		mins = seconds / 60U;
    1a68:	fbb1 f3fc 	udiv	r3, r1, ip
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    1a6c:	fb00 441e 	mls	r4, r0, lr, r4
			length = print_formatted(output,
    1a70:	fb0c 1113 	mls	r1, ip, r3, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    1a74:	fb08 f404 	mul.w	r4, r8, r4
			length = print_formatted(output,
    1a78:	9100      	str	r1, [sp, #0]
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    1a7a:	fbb4 f0f0 	udiv	r0, r4, r0
			length = print_formatted(output,
    1a7e:	490f      	ldr	r1, [pc, #60]	; (1abc <prefix_print+0x144>)
    1a80:	e9cd e001 	strd	lr, r0, [sp, #4]
    1a84:	4638      	mov	r0, r7
    1a86:	f7ff fef7 	bl	1878 <print_formatted>
    1a8a:	e79c      	b.n	19c6 <prefix_print+0x4e>
		total += print_formatted(output,
    1a8c:	4c08      	ldr	r4, [pc, #32]	; (1ab0 <prefix_print+0x138>)
    1a8e:	e7c0      	b.n	1a12 <prefix_print+0x9a>
    1a90:	00010851 	.word	0x00010851
    1a94:	00010855 	.word	0x00010855
    1a98:	0001041c 	.word	0x0001041c
    1a9c:	000111df 	.word	0x000111df
    1aa0:	00010843 	.word	0x00010843
    1aa4:	00010430 	.word	0x00010430
    1aa8:	0001087a 	.word	0x0001087a
    1aac:	0001084d 	.word	0x0001084d
    1ab0:	00010848 	.word	0x00010848
    1ab4:	20000fd4 	.word	0x20000fd4
    1ab8:	20000fd8 	.word	0x20000fd8
    1abc:	0001085e 	.word	0x0001085e

00001ac0 <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
    1ac0:	b538      	push	{r3, r4, r5, lr}
    1ac2:	460c      	mov	r4, r1
	if (color) {
    1ac4:	07e1      	lsls	r1, r4, #31
{
    1ac6:	4605      	mov	r5, r0
	if (color) {
    1ac8:	d503      	bpl.n	1ad2 <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
    1aca:	4a08      	ldr	r2, [pc, #32]	; (1aec <postfix_print+0x2c>)
    1acc:	4908      	ldr	r1, [pc, #32]	; (1af0 <postfix_print+0x30>)
    1ace:	f7ff fed3 	bl	1878 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    1ad2:	06e2      	lsls	r2, r4, #27
    1ad4:	d408      	bmi.n	1ae8 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    1ad6:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
    1ad8:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
    1ada:	bf4c      	ite	mi
    1adc:	4905      	ldrmi	r1, [pc, #20]	; (1af4 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
    1ade:	4906      	ldrpl	r1, [pc, #24]	; (1af8 <postfix_print+0x38>)
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
    1ae0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
    1ae4:	f7ff bec8 	b.w	1878 <print_formatted>
}
    1ae8:	bd38      	pop	{r3, r4, r5, pc}
    1aea:	bf00      	nop
    1aec:	00010843 	.word	0x00010843
    1af0:	000111df 	.word	0x000111df
    1af4:	00010832 	.word	0x00010832
    1af8:	00010831 	.word	0x00010831

00001afc <log_output_msg2_process>:
	log_output_flush(output);
}

void log_output_msg2_process(const struct log_output *output,
			     struct log_msg2 *msg, uint32_t flags)
{
    1afc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 *
 * @return Log level.
 */
static inline uint8_t log_msg2_get_level(struct log_msg2 *msg)
{
	return msg->hdr.desc.level;
    1b00:	880b      	ldrh	r3, [r1, #0]
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYST) {
		log_output_msg2_syst_process(output, msg, flags);
		return;
	}

	if (!raw_string) {
    1b02:	f413 7fe0 	tst.w	r3, #448	; 0x1c0
{
    1b06:	4606      	mov	r6, r0
    1b08:	460c      	mov	r4, r1
    1b0a:	4690      	mov	r8, r2
    1b0c:	f3c3 1982 	ubfx	r9, r3, #6, #3
	if (!raw_string) {
    1b10:	d04c      	beq.n	1bac <log_output_msg2_process+0xb0>
	return msg->hdr.desc.domain;
    1b12:	780a      	ldrb	r2, [r1, #0]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg2_get_source(struct log_msg2 *msg)
{
	return msg->hdr.source;
    1b14:	684b      	ldr	r3, [r1, #4]
	return msg->hdr.desc.domain;
    1b16:	f3c2 02c2 	ubfx	r2, r2, #3, #3
		void *source = (void *)log_msg2_get_source(msg);
		uint8_t domain_id = log_msg2_get_domain(msg);
		int16_t source_id = source ?
    1b1a:	2b00      	cmp	r3, #0
    1b1c:	d043      	beq.n	1ba6 <log_output_msg2_process+0xaa>
    1b1e:	4924      	ldr	r1, [pc, #144]	; (1bb0 <log_output_msg2_process+0xb4>)
    1b20:	1a5b      	subs	r3, r3, r1
    1b22:	f343 03cf 	sbfx	r3, r3, #3, #16
			(IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
				log_dynamic_source_id(source) :
				log_const_source_id(source)) :
			-1;

		prefix_offset = prefix_print(output, flags, 0, timestamp,
    1b26:	e9cd 2301 	strd	r2, r3, [sp, #4]
    1b2a:	f8cd 9000 	str.w	r9, [sp]
    1b2e:	68a3      	ldr	r3, [r4, #8]
    1b30:	2200      	movs	r2, #0
    1b32:	4641      	mov	r1, r8
    1b34:	4630      	mov	r0, r6
    1b36:	f7ff ff1f 	bl	1978 <prefix_print>
    1b3a:	4682      	mov	sl, r0
 */
static inline uint8_t *log_msg2_get_package(struct log_msg2 *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;

	return msg->data;
    1b3c:	4625      	mov	r5, r4
	*len = msg->hdr.desc.package_len;
    1b3e:	f855 3b0c 	ldr.w	r3, [r5], #12
	}

	size_t len;
	uint8_t *data = log_msg2_get_package(msg, &len);

	if (len) {
    1b42:	f3c3 2349 	ubfx	r3, r3, #9, #10
    1b46:	b14b      	cbz	r3, 1b5c <log_output_msg2_process+0x60>
		int err = cbpprintf(raw_string ? cr_out_func :  out_func,
    1b48:	481a      	ldr	r0, [pc, #104]	; (1bb4 <log_output_msg2_process+0xb8>)
    1b4a:	4b1b      	ldr	r3, [pc, #108]	; (1bb8 <log_output_msg2_process+0xbc>)
    1b4c:	462a      	mov	r2, r5
    1b4e:	4631      	mov	r1, r6
    1b50:	f1b9 0f00 	cmp.w	r9, #0
    1b54:	bf18      	it	ne
    1b56:	4618      	movne	r0, r3
    1b58:	f00b f8e5 	bl	cd26 <cbpprintf>
	*len = msg->hdr.desc.data_len;
    1b5c:	8867      	ldrh	r7, [r4, #2]
    1b5e:	f3c7 07cb 	ubfx	r7, r7, #3, #12
		(void)err;
		__ASSERT_NO_MSG(err >= 0);
	}

	data = log_msg2_get_data(msg, &len);
	if (len) {
    1b62:	b197      	cbz	r7, 1b8a <log_output_msg2_process+0x8e>
	return msg->data + msg->hdr.desc.package_len;
    1b64:	6822      	ldr	r2, [r4, #0]
    1b66:	f3c2 2249 	ubfx	r2, r2, #9, #10
    1b6a:	4415      	add	r5, r2
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
    1b6c:	2f10      	cmp	r7, #16
    1b6e:	463c      	mov	r4, r7
    1b70:	bf28      	it	cs
    1b72:	2410      	movcs	r4, #16
		hexdump_line_print(output, data, length,
    1b74:	4629      	mov	r1, r5
    1b76:	f8cd 8000 	str.w	r8, [sp]
    1b7a:	4653      	mov	r3, sl
    1b7c:	4622      	mov	r2, r4
    1b7e:	4630      	mov	r0, r6
    1b80:	f7ff fe8c 	bl	189c <hexdump_line_print>
	} while (len);
    1b84:	1b3f      	subs	r7, r7, r4
		data += length;
    1b86:	4425      	add	r5, r4
	} while (len);
    1b88:	d1f0      	bne.n	1b6c <log_output_msg2_process+0x70>
		log_msg2_hexdump(output, data, len, prefix_offset, flags);
	}

	if (!raw_string) {
    1b8a:	f1b9 0f00 	cmp.w	r9, #0
    1b8e:	d004      	beq.n	1b9a <log_output_msg2_process+0x9e>
		postfix_print(output, flags, level);
    1b90:	464a      	mov	r2, r9
    1b92:	4641      	mov	r1, r8
    1b94:	4630      	mov	r0, r6
    1b96:	f7ff ff93 	bl	1ac0 <postfix_print>
	}

	log_output_flush(output);
    1b9a:	4630      	mov	r0, r6
}
    1b9c:	b004      	add	sp, #16
    1b9e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(output);
    1ba2:	f00b be77 	b.w	d894 <log_output_flush>
		int16_t source_id = source ?
    1ba6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1baa:	e7bc      	b.n	1b26 <log_output_msg2_process+0x2a>
		prefix_offset = 0;
    1bac:	46ca      	mov	sl, r9
    1bae:	e7c5      	b.n	1b3c <log_output_msg2_process+0x40>
    1bb0:	00010200 	.word	0x00010200
    1bb4:	0000d8e5 	.word	0x0000d8e5
    1bb8:	0000d8af 	.word	0x0000d8af

00001bbc <log_output_dropped_process>:
	postfix_print(output, flags, level);
	log_output_flush(output);
}

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
    1bbc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    1bbe:	f242 730f 	movw	r3, #9999	; 0x270f
    1bc2:	428b      	cmp	r3, r1
    1bc4:	bf28      	it	cs
    1bc6:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
    1bc8:	6805      	ldr	r5, [r0, #0]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    1bca:	4a0f      	ldr	r2, [pc, #60]	; (1c08 <log_output_dropped_process+0x4c>)
{
    1bcc:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    1bce:	2105      	movs	r1, #5
    1bd0:	4668      	mov	r0, sp
    1bd2:	f00b f921 	bl	ce18 <snprintk>

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    1bd6:	6863      	ldr	r3, [r4, #4]
    1bd8:	490c      	ldr	r1, [pc, #48]	; (1c0c <log_output_dropped_process+0x50>)
    1bda:	685b      	ldr	r3, [r3, #4]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    1bdc:	4606      	mov	r6, r0
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    1bde:	220b      	movs	r2, #11
    1be0:	4628      	mov	r0, r5
    1be2:	f00b fe4a 	bl	d87a <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
    1be6:	6863      	ldr	r3, [r4, #4]
    1be8:	4632      	mov	r2, r6
    1bea:	4669      	mov	r1, sp
    1bec:	4628      	mov	r0, r5
    1bee:	685b      	ldr	r3, [r3, #4]
    1bf0:	f00b fe43 	bl	d87a <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    1bf4:	6863      	ldr	r3, [r4, #4]
    1bf6:	4906      	ldr	r1, [pc, #24]	; (1c10 <log_output_dropped_process+0x54>)
    1bf8:	685b      	ldr	r3, [r3, #4]
    1bfa:	221b      	movs	r2, #27
    1bfc:	4628      	mov	r0, r5
    1bfe:	f00b fe3c 	bl	d87a <buffer_write>
		     output->control_block->ctx);
}
    1c02:	b002      	add	sp, #8
    1c04:	bd70      	pop	{r4, r5, r6, pc}
    1c06:	bf00      	nop
    1c08:	00011f85 	.word	0x00011f85
    1c0c:	000108b8 	.word	0x000108b8
    1c10:	0001089c 	.word	0x0001089c

00001c14 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    1c14:	4a08      	ldr	r2, [pc, #32]	; (1c38 <log_output_timestamp_freq_set+0x24>)
{
    1c16:	b510      	push	{r4, lr}
	timestamp_div = 1U;
    1c18:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    1c1a:	4c08      	ldr	r4, [pc, #32]	; (1c3c <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
    1c1c:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    1c1e:	2100      	movs	r1, #0
    1c20:	42a0      	cmp	r0, r4
    1c22:	d804      	bhi.n	1c2e <log_output_timestamp_freq_set+0x1a>
    1c24:	b101      	cbz	r1, 1c28 <log_output_timestamp_freq_set+0x14>
    1c26:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    1c28:	4b05      	ldr	r3, [pc, #20]	; (1c40 <log_output_timestamp_freq_set+0x2c>)
    1c2a:	6018      	str	r0, [r3, #0]
}
    1c2c:	bd10      	pop	{r4, pc}
		frequency /= 2U;
    1c2e:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    1c30:	005b      	lsls	r3, r3, #1
    1c32:	2101      	movs	r1, #1
    1c34:	e7f4      	b.n	1c20 <log_output_timestamp_freq_set+0xc>
    1c36:	bf00      	nop
    1c38:	20000fd8 	.word	0x20000fd8
    1c3c:	000f4240 	.word	0x000f4240
    1c40:	20000fd4 	.word	0x20000fd4

00001c44 <z_impl_z_log_msg2_runtime_vcreate>:
#endif

void z_impl_z_log_msg2_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				const char *fmt, va_list ap)
{
    1c44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1c48:	b085      	sub	sp, #20
    1c4a:	e9dd 6b0e 	ldrd	r6, fp, [sp, #56]	; 0x38
    1c4e:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
    1c52:	4605      	mov	r5, r0
    1c54:	4688      	mov	r8, r1
    1c56:	4614      	mov	r4, r2
    1c58:	4699      	mov	r9, r3
	int plen;

	if (fmt) {
    1c5a:	f1bb 0f00 	cmp.w	fp, #0
    1c5e:	d037      	beq.n	1cd0 <z_impl_z_log_msg2_runtime_vcreate+0x8c>
		va_list ap2;

		va_copy(ap2, ap);
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET, 0,
    1c60:	2200      	movs	r2, #0
    1c62:	f8cd a000 	str.w	sl, [sp]
    1c66:	465b      	mov	r3, fp
    1c68:	210c      	movs	r1, #12
    1c6a:	4610      	mov	r0, r2
		va_copy(ap2, ap);
    1c6c:	f8cd a00c 	str.w	sl, [sp, #12]
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET, 0,
    1c70:	f7fe fd46 	bl	700 <cbvprintf_package>
    1c74:	4607      	mov	r7, r0
		plen = 0;
	}

	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
	struct log_msg2 *msg;
	struct log_msg2_desc desc =
    1c76:	f004 0207 	and.w	r2, r4, #7
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
    1c7a:	f106 0013 	add.w	r0, r6, #19
	struct log_msg2_desc desc =
    1c7e:	f005 0407 	and.w	r4, r5, #7
    1c82:	4d14      	ldr	r5, [pc, #80]	; (1cd4 <z_impl_z_log_msg2_runtime_vcreate+0x90>)
    1c84:	4b14      	ldr	r3, [pc, #80]	; (1cd8 <z_impl_z_log_msg2_runtime_vcreate+0x94>)
    1c86:	00e4      	lsls	r4, r4, #3
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
    1c88:	4438      	add	r0, r7
	struct log_msg2_desc desc =
    1c8a:	ea44 1482 	orr.w	r4, r4, r2, lsl #6
    1c8e:	ea05 2547 	and.w	r5, r5, r7, lsl #9
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
    1c92:	f020 0007 	bic.w	r0, r0, #7
	struct log_msg2_desc desc =
    1c96:	432c      	orrs	r4, r5
    1c98:	ea03 43c6 	and.w	r3, r3, r6, lsl #19
		Z_LOG_MSG_DESC_INITIALIZER(domain_id, level, plen, dlen);

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		msg = alloca(msg_wlen * sizeof(int));
	} else {
		msg = z_log_msg2_alloc(msg_wlen);
    1c9c:	0880      	lsrs	r0, r0, #2
	struct log_msg2_desc desc =
    1c9e:	431c      	orrs	r4, r3
		msg = z_log_msg2_alloc(msg_wlen);
    1ca0:	f7ff fcce 	bl	1640 <z_log_msg2_alloc>
	}

	if (msg && fmt) {
    1ca4:	4605      	mov	r5, r0
    1ca6:	b150      	cbz	r0, 1cbe <z_impl_z_log_msg2_runtime_vcreate+0x7a>
    1ca8:	f1bb 0f00 	cmp.w	fp, #0
    1cac:	d007      	beq.n	1cbe <z_impl_z_log_msg2_runtime_vcreate+0x7a>
		plen = cbvprintf_package(msg->data, (size_t)plen, 0, fmt, ap);
    1cae:	f8cd a000 	str.w	sl, [sp]
    1cb2:	465b      	mov	r3, fp
    1cb4:	2200      	movs	r2, #0
    1cb6:	4639      	mov	r1, r7
    1cb8:	300c      	adds	r0, #12
    1cba:	f7fe fd21 	bl	700 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
	}

	z_log_msg2_finalize(msg, source, desc, data);
    1cbe:	464b      	mov	r3, r9
    1cc0:	4622      	mov	r2, r4
    1cc2:	4641      	mov	r1, r8
    1cc4:	4628      	mov	r0, r5
}
    1cc6:	b005      	add	sp, #20
    1cc8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_log_msg2_finalize(msg, source, desc, data);
    1ccc:	f00b be17 	b.w	d8fe <z_log_msg2_finalize>
		plen = 0;
    1cd0:	465f      	mov	r7, fp
    1cd2:	e7d0      	b.n	1c76 <z_impl_z_log_msg2_runtime_vcreate+0x32>
    1cd4:	0007fe00 	.word	0x0007fe00
    1cd8:	7ff80000 	.word	0x7ff80000

00001cdc <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    1cdc:	4b01      	ldr	r3, [pc, #4]	; (1ce4 <log_backend_rtt_init+0x8>)
    1cde:	2201      	movs	r2, #1
    1ce0:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    1ce2:	4770      	bx	lr
    1ce4:	20001c18 	.word	0x20001c18

00001ce8 <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
    1ce8:	4b02      	ldr	r3, [pc, #8]	; (1cf4 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
    1cea:	4803      	ldr	r0, [pc, #12]	; (1cf8 <panic+0x10>)
    1cec:	2201      	movs	r2, #1
    1cee:	701a      	strb	r2, [r3, #0]
    1cf0:	f00b bdd0 	b.w	d894 <log_output_flush>
    1cf4:	20001c19 	.word	0x20001c19
    1cf8:	00010460 	.word	0x00010460

00001cfc <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
    1cfc:	4801      	ldr	r0, [pc, #4]	; (1d04 <dropped+0x8>)
    1cfe:	f7ff bf5d 	b.w	1bbc <log_output_dropped_process>
    1d02:	bf00      	nop
    1d04:	00010460 	.word	0x00010460

00001d08 <process>:
{
	uint32_t flags = log_backend_std_get_flags();

	flags |= IS_ENABLED(CONFIG_LOG_BACKEND_RTT_SYST_ENABLE) ? LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_output_msg2_process(&log_output_rtt, &msg->log, flags);
    1d08:	4801      	ldr	r0, [pc, #4]	; (1d10 <process+0x8>)
    1d0a:	220f      	movs	r2, #15
    1d0c:	f7ff bef6 	b.w	1afc <log_output_msg2_process>
    1d10:	00010460 	.word	0x00010460

00001d14 <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE) || panic_mode;
    1d14:	4b05      	ldr	r3, [pc, #20]	; (1d2c <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
    1d16:	781b      	ldrb	r3, [r3, #0]
    1d18:	b11b      	cbz	r3, 1d22 <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
    1d1a:	f241 3088 	movw	r0, #5000	; 0x1388
    1d1e:	f00d bf3c 	b.w	fb9a <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
    1d22:	20a4      	movs	r0, #164	; 0xa4
    1d24:	2100      	movs	r1, #0
    1d26:	f00a bcb3 	b.w	c690 <z_impl_k_sleep>
    1d2a:	bf00      	nop
    1d2c:	20001c19 	.word	0x20001c19

00001d30 <data_out_block_mode>:
{
    1d30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE) || panic_mode;
    1d34:	f8df 908c 	ldr.w	r9, [pc, #140]	; 1dc4 <data_out_block_mode+0x94>
	return z_impl_k_mutex_lock(mutex, timeout);
    1d38:	f8df a08c 	ldr.w	sl, [pc, #140]	; 1dc8 <data_out_block_mode+0x98>
{
    1d3c:	4680      	mov	r8, r0
    1d3e:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
    1d40:	2404      	movs	r4, #4
		if (!is_sync_mode()) {
    1d42:	f899 5000 	ldrb.w	r5, [r9]
    1d46:	b9cd      	cbnz	r5, 1d7c <data_out_block_mode+0x4c>
    1d48:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1d4c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    1d50:	4650      	mov	r0, sl
    1d52:	f009 ff03 	bl	bb5c <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    1d56:	463a      	mov	r2, r7
    1d58:	4641      	mov	r1, r8
    1d5a:	4628      	mov	r0, r5
    1d5c:	f009 fbe2 	bl	b524 <SEGGER_RTT_WriteSkipNoLock>
    1d60:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
    1d62:	4650      	mov	r0, sl
    1d64:	f009 ff72 	bl	bc4c <z_impl_k_mutex_unlock>
		if (ret) {
    1d68:	4d18      	ldr	r5, [pc, #96]	; (1dcc <data_out_block_mode+0x9c>)
    1d6a:	b1fe      	cbz	r6, 1dac <data_out_block_mode+0x7c>
	host_present = true;
    1d6c:	2301      	movs	r3, #1
    1d6e:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
    1d70:	f899 3000 	ldrb.w	r3, [r9]
    1d74:	b96b      	cbnz	r3, 1d92 <data_out_block_mode+0x62>
}
    1d76:	4638      	mov	r0, r7
    1d78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    1d7c:	463a      	mov	r2, r7
    1d7e:	4641      	mov	r1, r8
    1d80:	2000      	movs	r0, #0
    1d82:	f009 fbcf 	bl	b524 <SEGGER_RTT_WriteSkipNoLock>
    1d86:	4606      	mov	r6, r0
    1d88:	e7ee      	b.n	1d68 <data_out_block_mode+0x38>
	if (retry_cnt == 0) {
    1d8a:	b95c      	cbnz	r4, 1da4 <data_out_block_mode+0x74>
		host_present = false;
    1d8c:	702c      	strb	r4, [r5, #0]
    1d8e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    1d92:	2000      	movs	r0, #0
    1d94:	f009 fc42 	bl	b61c <SEGGER_RTT_HasDataUp>
    1d98:	2800      	cmp	r0, #0
    1d9a:	d0ec      	beq.n	1d76 <data_out_block_mode+0x46>
    1d9c:	782b      	ldrb	r3, [r5, #0]
    1d9e:	2b00      	cmp	r3, #0
    1da0:	d1f3      	bne.n	1d8a <data_out_block_mode+0x5a>
    1da2:	e7e8      	b.n	1d76 <data_out_block_mode+0x46>
			on_failed_write(retry_cnt--);
    1da4:	3c01      	subs	r4, #1
    1da6:	f7ff ffb5 	bl	1d14 <on_failed_write.part.0>
    1daa:	e7f2      	b.n	1d92 <data_out_block_mode+0x62>
		} else if (host_present) {
    1dac:	782b      	ldrb	r3, [r5, #0]
    1dae:	b113      	cbz	r3, 1db6 <data_out_block_mode+0x86>
	if (retry_cnt == 0) {
    1db0:	3c01      	subs	r4, #1
    1db2:	d104      	bne.n	1dbe <data_out_block_mode+0x8e>
		host_present = false;
    1db4:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
    1db6:	782b      	ldrb	r3, [r5, #0]
    1db8:	2b00      	cmp	r3, #0
    1dba:	d1c2      	bne.n	1d42 <data_out_block_mode+0x12>
    1dbc:	e7db      	b.n	1d76 <data_out_block_mode+0x46>
    1dbe:	f7ff ffa9 	bl	1d14 <on_failed_write.part.0>
    1dc2:	e7f8      	b.n	1db6 <data_out_block_mode+0x86>
    1dc4:	20001c19 	.word	0x20001c19
    1dc8:	20000568 	.word	0x20000568
    1dcc:	20001c18 	.word	0x20001c18

00001dd0 <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
    1dd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1dd4:	4605      	mov	r5, r0
	__asm__ volatile(
    1dd6:	f04f 0320 	mov.w	r3, #32
    1dda:	f3ef 8611 	mrs	r6, BASEPRI
    1dde:	f383 8812 	msr	BASEPRI_MAX, r3
    1de2:	f3bf 8f6f 	isb	sy
	return list->head;
    1de6:	4b0e      	ldr	r3, [pc, #56]	; (1e20 <pm_state_notify+0x50>)
    1de8:	681c      	ldr	r4, [r3, #0]
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    1dea:	b19c      	cbz	r4, 1e14 <pm_state_notify+0x44>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_cpus_pm_state[_current_cpu->id].state);
    1dec:	4f0d      	ldr	r7, [pc, #52]	; (1e24 <pm_state_notify+0x54>)
    1dee:	f8df 8038 	ldr.w	r8, [pc, #56]	; 1e28 <pm_state_notify+0x58>
    1df2:	f04f 090c 	mov.w	r9, #12
			callback = notifier->state_exit;
    1df6:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
    1dfa:	2d00      	cmp	r5, #0
    1dfc:	bf08      	it	eq
    1dfe:	4613      	moveq	r3, r2
		if (callback) {
    1e00:	b12b      	cbz	r3, 1e0e <pm_state_notify+0x3e>
			callback(z_cpus_pm_state[_current_cpu->id].state);
    1e02:	f898 2014 	ldrb.w	r2, [r8, #20]
    1e06:	fb09 f202 	mul.w	r2, r9, r2
    1e0a:	5cb8      	ldrb	r0, [r7, r2]
    1e0c:	4798      	blx	r3
	return node->next;
    1e0e:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    1e10:	2c00      	cmp	r4, #0
    1e12:	d1f0      	bne.n	1df6 <pm_state_notify+0x26>
	__asm__ volatile(
    1e14:	f386 8811 	msr	BASEPRI, r6
    1e18:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
    1e1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    1e20:	20000ff0 	.word	0x20000ff0
    1e24:	20000ff8 	.word	0x20000ff8
    1e28:	20001bc4 	.word	0x20001bc4

00001e2c <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    1e2c:	f000 031f 	and.w	r3, r0, #31
    1e30:	2201      	movs	r2, #1
    1e32:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    1e34:	4b0a      	ldr	r3, [pc, #40]	; (1e60 <atomic_test_and_set_bit.constprop.0+0x34>)
    1e36:	f3bf 8f5b 	dmb	ish
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    1e3a:	0940      	lsrs	r0, r0, #5
    1e3c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    1e40:	e850 3f00 	ldrex	r3, [r0]
    1e44:	ea43 0102 	orr.w	r1, r3, r2
    1e48:	e840 1c00 	strex	ip, r1, [r0]
    1e4c:	f1bc 0f00 	cmp.w	ip, #0
    1e50:	d1f6      	bne.n	1e40 <atomic_test_and_set_bit.constprop.0+0x14>
    1e52:	f3bf 8f5b 	dmb	ish

	return (old & mask) != 0;
    1e56:	421a      	tst	r2, r3
}
    1e58:	bf14      	ite	ne
    1e5a:	2001      	movne	r0, #1
    1e5c:	2000      	moveq	r0, #0
    1e5e:	4770      	bx	lr
    1e60:	20001004 	.word	0x20001004

00001e64 <pm_system_resume>:

void pm_system_resume(void)
{
    1e64:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
    1e66:	4b1d      	ldr	r3, [pc, #116]	; (1edc <pm_system_resume+0x78>)
    1e68:	7d1c      	ldrb	r4, [r3, #20]
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    1e6a:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
    1e6e:	f004 031f 	and.w	r3, r4, #31
    1e72:	2201      	movs	r2, #1
    1e74:	409a      	lsls	r2, r3
    1e76:	4b1a      	ldr	r3, [pc, #104]	; (1ee0 <pm_system_resume+0x7c>)
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    1e78:	0961      	lsrs	r1, r4, #5
{
    1e7a:	b085      	sub	sp, #20
    1e7c:	43d0      	mvns	r0, r2
    1e7e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    1e82:	e853 1f00 	ldrex	r1, [r3]
    1e86:	ea01 0500 	and.w	r5, r1, r0
    1e8a:	e843 5c00 	strex	ip, r5, [r3]
    1e8e:	f1bc 0f00 	cmp.w	ip, #0
    1e92:	d1f6      	bne.n	1e82 <pm_system_resume+0x1e>
    1e94:	f3bf 8f5b 	dmb	ish
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    1e98:	4211      	tst	r1, r2
    1e9a:	d017      	beq.n	1ecc <pm_system_resume+0x68>
		exit_pos_ops(z_cpus_pm_state[id]);
    1e9c:	4d11      	ldr	r5, [pc, #68]	; (1ee4 <pm_system_resume+0x80>)
    1e9e:	220c      	movs	r2, #12
    1ea0:	fb02 5204 	mla	r2, r2, r4, r5
    1ea4:	ca07      	ldmia	r2, {r0, r1, r2}
    1ea6:	ab01      	add	r3, sp, #4
    1ea8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
    1eac:	4a0e      	ldr	r2, [pc, #56]	; (1ee8 <pm_system_resume+0x84>)
    1eae:	b17a      	cbz	r2, 1ed0 <pm_system_resume+0x6c>
		pm_power_state_exit_post_ops(info);
    1eb0:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    1eb4:	f00b fdd1 	bl	da5a <pm_power_state_exit_post_ops>
		pm_state_notify(false);
    1eb8:	2000      	movs	r0, #0
    1eba:	f7ff ff89 	bl	1dd0 <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    1ebe:	230c      	movs	r3, #12
    1ec0:	435c      	muls	r4, r3
    1ec2:	192a      	adds	r2, r5, r4
    1ec4:	2300      	movs	r3, #0
    1ec6:	512b      	str	r3, [r5, r4]
    1ec8:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
    1ecc:	b005      	add	sp, #20
    1ece:	bd30      	pop	{r4, r5, pc}
    1ed0:	f382 8811 	msr	BASEPRI, r2
    1ed4:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    1ed8:	e7ee      	b.n	1eb8 <pm_system_resume+0x54>
    1eda:	bf00      	nop
    1edc:	20001bc4 	.word	0x20001bc4
    1ee0:	20001008 	.word	0x20001008
    1ee4:	20000ff8 	.word	0x20000ff8
    1ee8:	0000da5b 	.word	0x0000da5b

00001eec <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
    1eec:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
    1ef0:	4b35      	ldr	r3, [pc, #212]	; (1fc8 <pm_system_suspend+0xdc>)
    1ef2:	4c36      	ldr	r4, [pc, #216]	; (1fcc <pm_system_suspend+0xe0>)
    1ef4:	7d1d      	ldrb	r5, [r3, #20]
{
    1ef6:	4680      	mov	r8, r0

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_cpus_pm_state_forced, id)) {
    1ef8:	4628      	mov	r0, r5
    1efa:	f7ff ff97 	bl	1e2c <atomic_test_and_set_bit.constprop.0>
    1efe:	b950      	cbnz	r0, 1f16 <pm_system_suspend+0x2a>
		const struct pm_state_info *info;

		info = pm_policy_next_state(id, ticks);
    1f00:	4641      	mov	r1, r8
    1f02:	4628      	mov	r0, r5
    1f04:	f000 f884 	bl	2010 <pm_policy_next_state>
		if (info != NULL) {
    1f08:	b128      	cbz	r0, 1f16 <pm_system_suspend+0x2a>
			z_cpus_pm_state[id] = *info;
    1f0a:	c807      	ldmia	r0, {r0, r1, r2}
    1f0c:	230c      	movs	r3, #12
    1f0e:	fb03 4305 	mla	r3, r3, r5, r4
    1f12:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		}
	}

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
    1f16:	230c      	movs	r3, #12
    1f18:	436b      	muls	r3, r5
    1f1a:	18e2      	adds	r2, r4, r3
    1f1c:	5ce0      	ldrb	r0, [r4, r3]
    1f1e:	096e      	lsrs	r6, r5, #5
    1f20:	f005 071f 	and.w	r7, r5, #31
    1f24:	2800      	cmp	r0, #0
    1f26:	d03b      	beq.n	1fa0 <pm_system_suspend+0xb4>
				   z_cpus_pm_state[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
    1f28:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    1f2c:	d010      	beq.n	1f50 <pm_system_suspend+0x64>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    1f2e:	f8d2 e008 	ldr.w	lr, [r2, #8]
    1f32:	4827      	ldr	r0, [pc, #156]	; (1fd0 <pm_system_suspend+0xe4>)
    1f34:	4a27      	ldr	r2, [pc, #156]	; (1fd4 <pm_system_suspend+0xe8>)
    1f36:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
    1f3a:	2100      	movs	r1, #0
    1f3c:	2300      	movs	r3, #0
    1f3e:	fbee 010c 	umlal	r0, r1, lr, ip
    1f42:	f7fe f8cd 	bl	e0 <__aeabi_uldivmod>
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
    1f46:	2101      	movs	r1, #1
    1f48:	eba8 0000 	sub.w	r0, r8, r0
    1f4c:	f00d fe05 	bl	fb5a <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    1f50:	f00a f920 	bl	c194 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
    1f54:	2001      	movs	r0, #1
    1f56:	f7ff ff3b 	bl	1dd0 <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    1f5a:	f3bf 8f5b 	dmb	ish
    1f5e:	4b1e      	ldr	r3, [pc, #120]	; (1fd8 <pm_system_suspend+0xec>)
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    1f60:	2201      	movs	r2, #1
    1f62:	40ba      	lsls	r2, r7
    1f64:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    1f68:	e853 1f00 	ldrex	r1, [r3]
    1f6c:	4311      	orrs	r1, r2
    1f6e:	e843 1000 	strex	r0, r1, [r3]
    1f72:	2800      	cmp	r0, #0
    1f74:	d1f8      	bne.n	1f68 <pm_system_suspend+0x7c>
    1f76:	f3bf 8f5b 	dmb	ish
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_cpus_pm_state[id]);
    1f7a:	230c      	movs	r3, #12
    1f7c:	fb03 4405 	mla	r4, r3, r5, r4
    1f80:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    1f84:	ab01      	add	r3, sp, #4
    1f86:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
    1f8a:	4a14      	ldr	r2, [pc, #80]	; (1fdc <pm_system_suspend+0xf0>)
    1f8c:	b11a      	cbz	r2, 1f96 <pm_system_suspend+0xaa>
		pm_power_state_set(info);
    1f8e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    1f92:	f00b fd4f 	bl	da34 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
    1f96:	f7ff ff65 	bl	1e64 <pm_system_resume>
	k_sched_unlock();
    1f9a:	f00a fac9 	bl	c530 <k_sched_unlock>
	bool ret = true;
    1f9e:	2001      	movs	r0, #1
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    1fa0:	4a0f      	ldr	r2, [pc, #60]	; (1fe0 <pm_system_suspend+0xf4>)
    1fa2:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
    1fa6:	2301      	movs	r3, #1
    1fa8:	40bb      	lsls	r3, r7
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    1faa:	43db      	mvns	r3, r3
    1fac:	eb02 0686 	add.w	r6, r2, r6, lsl #2
    1fb0:	e856 2f00 	ldrex	r2, [r6]
    1fb4:	401a      	ands	r2, r3
    1fb6:	e846 2100 	strex	r1, r2, [r6]
    1fba:	2900      	cmp	r1, #0
    1fbc:	d1f8      	bne.n	1fb0 <pm_system_suspend+0xc4>
    1fbe:	f3bf 8f5b 	dmb	ish
				   z_cpus_pm_state[id].state);

end:
	atomic_clear_bit(z_cpus_pm_state_forced, id);
	return ret;
}
    1fc2:	b004      	add	sp, #16
    1fc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1fc8:	20001bc4 	.word	0x20001bc4
    1fcc:	20000ff8 	.word	0x20000ff8
    1fd0:	000f423f 	.word	0x000f423f
    1fd4:	000f4240 	.word	0x000f4240
    1fd8:	20001008 	.word	0x20001008
    1fdc:	0000da35 	.word	0x0000da35
    1fe0:	20001004 	.word	0x20001004

00001fe4 <pm_constraint_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    1fe4:	4b05      	ldr	r3, [pc, #20]	; (1ffc <pm_constraint_get+0x18>)
    1fe6:	f3bf 8f5b 	dmb	ish
    1fea:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    1fee:	f3bf 8f5b 	dmb	ish
__weak bool pm_constraint_get(enum pm_state state)
{
	__ASSERT(state < PM_STATE_COUNT, "Invalid power state!");

	return (atomic_get(&power_state_disable_count[state]) == 0);
}
    1ff2:	fab0 f080 	clz	r0, r0
    1ff6:	0940      	lsrs	r0, r0, #5
    1ff8:	4770      	bx	lr
    1ffa:	bf00      	nop
    1ffc:	2000100c 	.word	0x2000100c

00002000 <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD(DT_PATH(cpus), NUM_CPU_STATES)
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
    2000:	b908      	cbnz	r0, 2006 <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
    2002:	4b02      	ldr	r3, [pc, #8]	; (200c <pm_state_cpu_get_all+0xc>)
    2004:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
    2006:	2000      	movs	r0, #0
    2008:	4770      	bx	lr
    200a:	bf00      	nop
    200c:	20001028 	.word	0x20001028

00002010 <pm_policy_next_state>:

#include <logging/log.h>
LOG_MODULE_DECLARE(pm, CONFIG_PM_LOG_LEVEL);

const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
    2010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2014:	b085      	sub	sp, #20
    2016:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
    2018:	a903      	add	r1, sp, #12
    201a:	f7ff fff1 	bl	2000 <pm_state_cpu_get_all>
    201e:	f8df a074 	ldr.w	sl, [pc, #116]	; 2094 <pm_policy_next_state+0x84>
    2022:	f8df 8074 	ldr.w	r8, [pc, #116]	; 2098 <pm_policy_next_state+0x88>

	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    2026:	1e44      	subs	r4, r0, #1
    2028:	b224      	sxth	r4, r4
    202a:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    202e:	f04f 0900 	mov.w	r9, #0
    2032:	1c63      	adds	r3, r4, #1
    2034:	d104      	bne.n	2040 <pm_policy_next_state+0x30>
		    (ticks >= (min_residency + exit_latency))) {
			return state;
		}
	}

	return NULL;
    2036:	2500      	movs	r5, #0
}
    2038:	4628      	mov	r0, r5
    203a:	b005      	add	sp, #20
    203c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		const struct pm_state_info *state = &cpu_states[i];
    2040:	9a03      	ldr	r2, [sp, #12]
    2042:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    2046:	eb02 0583 	add.w	r5, r2, r3, lsl #2
		if (!pm_constraint_get(state->state)) {
    204a:	f812 0023 	ldrb.w	r0, [r2, r3, lsl #2]
    204e:	f7ff ffc9 	bl	1fe4 <pm_constraint_get>
    2052:	b1e0      	cbz	r0, 208e <pm_policy_next_state+0x7e>
    2054:	6868      	ldr	r0, [r5, #4]
    2056:	f04f 0b00 	mov.w	fp, #0
    205a:	46d4      	mov	ip, sl
    205c:	4659      	mov	r1, fp
    205e:	fbe0 c107 	umlal	ip, r1, r0, r7
    2062:	4642      	mov	r2, r8
    2064:	464b      	mov	r3, r9
    2066:	4660      	mov	r0, ip
    2068:	f7fe f83a 	bl	e0 <__aeabi_uldivmod>
    206c:	9001      	str	r0, [sp, #4]
    206e:	68a8      	ldr	r0, [r5, #8]
    2070:	46d4      	mov	ip, sl
    2072:	4659      	mov	r1, fp
    2074:	fbe0 c107 	umlal	ip, r1, r0, r7
    2078:	4642      	mov	r2, r8
    207a:	464b      	mov	r3, r9
    207c:	4660      	mov	r0, ip
    207e:	f7fe f82f 	bl	e0 <__aeabi_uldivmod>
		if ((ticks == K_TICKS_FOREVER) ||
    2082:	1c72      	adds	r2, r6, #1
    2084:	d0d8      	beq.n	2038 <pm_policy_next_state+0x28>
		    (ticks >= (min_residency + exit_latency))) {
    2086:	9b01      	ldr	r3, [sp, #4]
    2088:	4418      	add	r0, r3
		if ((ticks == K_TICKS_FOREVER) ||
    208a:	42b0      	cmp	r0, r6
    208c:	d9d4      	bls.n	2038 <pm_policy_next_state+0x28>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    208e:	3c01      	subs	r4, #1
    2090:	b224      	sxth	r4, r4
    2092:	e7ce      	b.n	2032 <pm_policy_next_state+0x22>
    2094:	000f423f 	.word	0x000f423f
    2098:	000f4240 	.word	0x000f4240

0000209c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    209c:	4901      	ldr	r1, [pc, #4]	; (20a4 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    209e:	2210      	movs	r2, #16
	str	r2, [r1]
    20a0:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    20a2:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    20a4:	e000ed10 	.word	0xe000ed10

000020a8 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    20a8:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    20aa:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    20ac:	f380 8811 	msr	BASEPRI, r0
	isb
    20b0:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    20b4:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    20b8:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    20ba:	b662      	cpsie	i
	isb
    20bc:	f3bf 8f6f 	isb	sy

	bx	lr
    20c0:	4770      	bx	lr
    20c2:	bf00      	nop

000020c4 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    20c4:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    20c6:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    20c8:	f381 8811 	msr	BASEPRI, r1

	wfe
    20cc:	bf20      	wfe

	msr	BASEPRI, r0
    20ce:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    20d2:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    20d4:	4770      	bx	lr
    20d6:	bf00      	nop

000020d8 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    20d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    20dc:	b088      	sub	sp, #32
    20de:	4681      	mov	r9, r0
    20e0:	af00      	add	r7, sp, #0

	if (esf != NULL) {
    20e2:	460c      	mov	r4, r1
    20e4:	2900      	cmp	r1, #0
    20e6:	d04b      	beq.n	2180 <z_arm_fatal_error+0xa8>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    20e8:	46ea      	mov	sl, sp
    20ea:	b088      	sub	sp, #32
    20ec:	466d      	mov	r5, sp
    20ee:	e9d1 1200 	ldrd	r1, r2, [r1]
    20f2:	68a3      	ldr	r3, [r4, #8]
    20f4:	4826      	ldr	r0, [pc, #152]	; (2190 <z_arm_fatal_error+0xb8>)
    20f6:	462e      	mov	r6, r5
    20f8:	f04f 0805 	mov.w	r8, #5
    20fc:	e9c5 0104 	strd	r0, r1, [r5, #16]
    2100:	e9c5 2306 	strd	r2, r3, [r5, #24]
    2104:	f8c7 8008 	str.w	r8, [r7, #8]
    2108:	f846 8f0c 	str.w	r8, [r6, #12]!
		arch_syscall_invoke4(*(uintptr_t *)&source, *(uintptr_t *)&desc, *(uintptr_t *)&package, *(uintptr_t *)&data, K_SYSCALL_Z_LOG_MSG2_STATIC_CREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    210c:	4821      	ldr	r0, [pc, #132]	; (2194 <z_arm_fatal_error+0xbc>)
    210e:	4632      	mov	r2, r6
    2110:	2300      	movs	r3, #0
    2112:	f44f 5121 	mov.w	r1, #10304	; 0x2840
    2116:	f00b fc0d 	bl	d934 <z_impl_z_log_msg2_static_create>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    211a:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
    211e:	6963      	ldr	r3, [r4, #20]
    2120:	481d      	ldr	r0, [pc, #116]	; (2198 <z_arm_fatal_error+0xc0>)
    2122:	f8c7 8008 	str.w	r8, [r7, #8]
    2126:	46d5      	mov	sp, sl
    2128:	e9c5 0104 	strd	r0, r1, [r5, #16]
    212c:	e9c5 2306 	strd	r2, r3, [r5, #24]
    2130:	46ad      	mov	sp, r5
    2132:	f8c5 800c 	str.w	r8, [r5, #12]
    2136:	4817      	ldr	r0, [pc, #92]	; (2194 <z_arm_fatal_error+0xbc>)
    2138:	4632      	mov	r2, r6
    213a:	2300      	movs	r3, #0
    213c:	f44f 5121 	mov.w	r1, #10304	; 0x2840
    2140:	f00b fbf8 	bl	d934 <z_impl_z_log_msg2_static_create>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    2144:	4a15      	ldr	r2, [pc, #84]	; (219c <z_arm_fatal_error+0xc4>)
    2146:	69e3      	ldr	r3, [r4, #28]
    2148:	2503      	movs	r5, #3
    214a:	e9c7 2306 	strd	r2, r3, [r7, #24]
    214e:	46d5      	mov	sp, sl
    2150:	607d      	str	r5, [r7, #4]
    2152:	617d      	str	r5, [r7, #20]
    2154:	480f      	ldr	r0, [pc, #60]	; (2194 <z_arm_fatal_error+0xbc>)
    2156:	f107 0214 	add.w	r2, r7, #20
    215a:	2300      	movs	r3, #0
    215c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    2160:	f00b fbe8 	bl	d934 <z_impl_z_log_msg2_static_create>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    2164:	4a0e      	ldr	r2, [pc, #56]	; (21a0 <z_arm_fatal_error+0xc8>)
    2166:	69a3      	ldr	r3, [r4, #24]
    2168:	607d      	str	r5, [r7, #4]
    216a:	e9c7 2306 	strd	r2, r3, [r7, #24]
    216e:	617d      	str	r5, [r7, #20]
    2170:	4808      	ldr	r0, [pc, #32]	; (2194 <z_arm_fatal_error+0xbc>)
    2172:	2300      	movs	r3, #0
    2174:	f107 0214 	add.w	r2, r7, #20
    2178:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    217c:	f00b fbda 	bl	d934 <z_impl_z_log_msg2_static_create>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    2180:	4621      	mov	r1, r4
    2182:	4648      	mov	r0, r9
    2184:	f009 fab6 	bl	b6f4 <z_fatal_error>
}
    2188:	3720      	adds	r7, #32
    218a:	46bd      	mov	sp, r7
    218c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2190:	000108d7 	.word	0x000108d7
    2194:	000102d8 	.word	0x000102d8
    2198:	00010906 	.word	0x00010906
    219c:	00010935 	.word	0x00010935
    21a0:	00010944 	.word	0x00010944

000021a4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    21a4:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    21a6:	2b00      	cmp	r3, #0
    21a8:	db08      	blt.n	21bc <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    21aa:	2201      	movs	r2, #1
    21ac:	f000 001f 	and.w	r0, r0, #31
    21b0:	fa02 f000 	lsl.w	r0, r2, r0
    21b4:	095b      	lsrs	r3, r3, #5
    21b6:	4a02      	ldr	r2, [pc, #8]	; (21c0 <arch_irq_enable+0x1c>)
    21b8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    21bc:	4770      	bx	lr
    21be:	bf00      	nop
    21c0:	e000e100 	.word	0xe000e100

000021c4 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    21c4:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    21c6:	2b00      	cmp	r3, #0
    21c8:	db0d      	blt.n	21e6 <arch_irq_disable+0x22>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    21ca:	2201      	movs	r2, #1
    21cc:	095b      	lsrs	r3, r3, #5
    21ce:	f000 001f 	and.w	r0, r0, #31
    21d2:	fa02 f000 	lsl.w	r0, r2, r0
    21d6:	3320      	adds	r3, #32
    21d8:	4a03      	ldr	r2, [pc, #12]	; (21e8 <arch_irq_disable+0x24>)
    21da:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    21de:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    21e2:	f3bf 8f6f 	isb	sy
}
    21e6:	4770      	bx	lr
    21e8:	e000e100 	.word	0xe000e100

000021ec <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    21ec:	4b05      	ldr	r3, [pc, #20]	; (2204 <arch_irq_is_enabled+0x18>)
    21ee:	0942      	lsrs	r2, r0, #5
    21f0:	f000 001f 	and.w	r0, r0, #31
    21f4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    21f8:	2301      	movs	r3, #1
    21fa:	fa03 f000 	lsl.w	r0, r3, r0
}
    21fe:	4010      	ands	r0, r2
    2200:	4770      	bx	lr
    2202:	bf00      	nop
    2204:	e000e100 	.word	0xe000e100

00002208 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    2208:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    220a:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    220c:	bfa8      	it	ge
    220e:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
    2212:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2216:	bfb8      	it	lt
    2218:	4b06      	ldrlt	r3, [pc, #24]	; (2234 <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    221a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    221e:	bfac      	ite	ge
    2220:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2224:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2228:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    222a:	bfb4      	ite	lt
    222c:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    222e:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
}
    2232:	4770      	bx	lr
    2234:	e000ed14 	.word	0xe000ed14

00002238 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
    2238:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    223a:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    223c:	4b04      	ldr	r3, [pc, #16]	; (2250 <_arch_isr_direct_pm+0x18>)
    223e:	699a      	ldr	r2, [r3, #24]
    2240:	b11a      	cbz	r2, 224a <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
    2242:	2200      	movs	r2, #0
    2244:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
    2246:	f00d f9c4 	bl	f5d2 <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    224a:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    224c:	bd08      	pop	{r3, pc}
    224e:	bf00      	nop
    2250:	20001bc4 	.word	0x20001bc4

00002254 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    2254:	bf30      	wfi
    b z_SysNmiOnReset
    2256:	f7ff bffd 	b.w	2254 <z_SysNmiOnReset>
    225a:	bf00      	nop

0000225c <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    225c:	4a0f      	ldr	r2, [pc, #60]	; (229c <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
    225e:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    2260:	4b0f      	ldr	r3, [pc, #60]	; (22a0 <z_arm_prep_c+0x44>)
    2262:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    2266:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    2268:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    226c:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    2270:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    2274:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    2278:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    227c:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    2280:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    2284:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
    2288:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    228c:	f009 fadc 	bl	b848 <z_bss_zero>
	z_data_copy();
    2290:	f00a fa92 	bl	c7b8 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    2294:	f000 fba8 	bl	29e8 <z_arm_interrupt_init>
	z_cstart();
    2298:	f009 fae0 	bl	b85c <z_cstart>
    229c:	00000000 	.word	0x00000000
    22a0:	e000ed00 	.word	0xe000ed00

000022a4 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    22a4:	4a09      	ldr	r2, [pc, #36]	; (22cc <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    22a6:	490a      	ldr	r1, [pc, #40]	; (22d0 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    22a8:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    22aa:	6809      	ldr	r1, [r1, #0]
    22ac:	67d9      	str	r1, [r3, #124]	; 0x7c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    22ae:	4909      	ldr	r1, [pc, #36]	; (22d4 <arch_swap+0x30>)
	_current->arch.basepri = key;
    22b0:	6798      	str	r0, [r3, #120]	; 0x78
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    22b2:	684b      	ldr	r3, [r1, #4]
    22b4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    22b8:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
    22ba:	2300      	movs	r3, #0
    22bc:	f383 8811 	msr	BASEPRI, r3
    22c0:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    22c4:	6893      	ldr	r3, [r2, #8]
}
    22c6:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
    22c8:	4770      	bx	lr
    22ca:	bf00      	nop
    22cc:	20001bc4 	.word	0x20001bc4
    22d0:	00010720 	.word	0x00010720
    22d4:	e000ed00 	.word	0xe000ed00

000022d8 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    22d8:	4912      	ldr	r1, [pc, #72]	; (2324 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    22da:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    22dc:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    22e0:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    22e2:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    22e6:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    22ea:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
    22ec:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    22f0:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    22f4:	4f0c      	ldr	r7, [pc, #48]	; (2328 <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    22f6:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    22fa:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
    22fc:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    22fe:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    2300:	6f90      	ldr	r0, [r2, #120]	; 0x78
    movs r3, #0
    2302:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    2304:	6793      	str	r3, [r2, #120]	; 0x78
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    2306:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
    230a:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    230c:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    230e:	f000 fbad 	bl	2a6c <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    2312:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    2316:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    231a:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    231e:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    2322:	4770      	bx	lr
    ldr r1, =_kernel
    2324:	20001bc4 	.word	0x20001bc4
    ldr v4, =_SCS_ICSR
    2328:	e000ed04 	.word	0xe000ed04

0000232c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    232c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    2330:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    2332:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    2336:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    233a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    233c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    2340:	2902      	cmp	r1, #2
    beq _oops
    2342:	d0ff      	beq.n	2344 <_oops>

00002344 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    2344:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    2346:	f00b fb15 	bl	d974 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    234a:	bd01      	pop	{r0, pc}

0000234c <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
    234c:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    2350:	9b00      	ldr	r3, [sp, #0]
    2352:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
    2356:	490a      	ldr	r1, [pc, #40]	; (2380 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
    2358:	9b01      	ldr	r3, [sp, #4]
    235a:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    235e:	9b02      	ldr	r3, [sp, #8]
    2360:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
    2364:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    2368:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    236c:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
    2370:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
    2374:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    2376:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
    2378:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    237a:	6783      	str	r3, [r0, #120]	; 0x78
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    237c:	4770      	bx	lr
    237e:	bf00      	nop
    2380:	0000d02b 	.word	0x0000d02b

00002384 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
    2384:	4a09      	ldr	r2, [pc, #36]	; (23ac <z_check_thread_stack_fail+0x28>)
{
    2386:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
    2388:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
    238a:	b170      	cbz	r0, 23aa <z_check_thread_stack_fail+0x26>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    238c:	f113 0f16 	cmn.w	r3, #22
    2390:	6e80      	ldr	r0, [r0, #104]	; 0x68
    2392:	d005      	beq.n	23a0 <z_check_thread_stack_fail+0x1c>
    2394:	f1a0 0220 	sub.w	r2, r0, #32
    2398:	429a      	cmp	r2, r3
    239a:	d805      	bhi.n	23a8 <z_check_thread_stack_fail+0x24>
    239c:	4283      	cmp	r3, r0
    239e:	d203      	bcs.n	23a8 <z_check_thread_stack_fail+0x24>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
    23a0:	4281      	cmp	r1, r0
    23a2:	bf28      	it	cs
    23a4:	2000      	movcs	r0, #0
    23a6:	4770      	bx	lr
    23a8:	2000      	movs	r0, #0
}
    23aa:	4770      	bx	lr
    23ac:	20001bc4 	.word	0x20001bc4

000023b0 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    23b0:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    23b2:	4b09      	ldr	r3, [pc, #36]	; (23d8 <arch_switch_to_main_thread+0x28>)
    23b4:	6098      	str	r0, [r3, #8]
{
    23b6:	460d      	mov	r5, r1
    23b8:	4614      	mov	r4, r2
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    23ba:	f000 fb57 	bl	2a6c <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    23be:	4620      	mov	r0, r4
    23c0:	f385 8809 	msr	PSP, r5
    23c4:	2100      	movs	r1, #0
    23c6:	b663      	cpsie	if
    23c8:	f381 8811 	msr	BASEPRI, r1
    23cc:	f3bf 8f6f 	isb	sy
    23d0:	2200      	movs	r2, #0
    23d2:	2300      	movs	r3, #0
    23d4:	f00a fe29 	bl	d02a <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    23d8:	20001bc4 	.word	0x20001bc4

000023dc <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    23dc:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    23de:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    23e0:	4a0b      	ldr	r2, [pc, #44]	; (2410 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    23e2:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
    23e4:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    23e6:	bf1e      	ittt	ne
	movne	r1, #0
    23e8:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    23ea:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
    23ec:	f00d f8f1 	blne	f5d2 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    23f0:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    23f2:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    23f6:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    23fa:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    23fe:	4905      	ldr	r1, [pc, #20]	; (2414 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    2400:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    2402:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    2404:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    2406:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    240a:	4903      	ldr	r1, [pc, #12]	; (2418 <_isr_wrapper+0x3c>)
	bx r1
    240c:	4708      	bx	r1
    240e:	0000      	.short	0x0000
	ldr r2, =_kernel
    2410:	20001bc4 	.word	0x20001bc4
	ldr r1, =_sw_isr_table
    2414:	000100c8 	.word	0x000100c8
	ldr r1, =z_arm_int_exit
    2418:	0000241d 	.word	0x0000241d

0000241c <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    241c:	4b04      	ldr	r3, [pc, #16]	; (2430 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    241e:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    2420:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
    2422:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    2424:	d003      	beq.n	242e <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    2426:	4903      	ldr	r1, [pc, #12]	; (2434 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    2428:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    242c:	600a      	str	r2, [r1, #0]

0000242e <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    242e:	4770      	bx	lr
	ldr r3, =_kernel
    2430:	20001bc4 	.word	0x20001bc4
	ldr r1, =_SCS_ICSR
    2434:	e000ed04 	.word	0xe000ed04

00002438 <bus_fault.constprop.0>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason.
 *
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    2438:	b570      	push	{r4, r5, r6, lr}
    243a:	b088      	sub	sp, #32
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
    243c:	4b3c      	ldr	r3, [pc, #240]	; (2530 <bus_fault.constprop.0+0xf8>)
    243e:	9306      	str	r3, [sp, #24]
    2440:	2402      	movs	r4, #2
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    2442:	4606      	mov	r6, r0
    2444:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    2446:	483b      	ldr	r0, [pc, #236]	; (2534 <bus_fault.constprop.0+0xfc>)
    2448:	9401      	str	r4, [sp, #4]
    244a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    244e:	aa05      	add	r2, sp, #20
    2450:	9405      	str	r4, [sp, #20]
    2452:	f00b fa9e 	bl	d992 <z_log_msg2_static_create.constprop.0>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    2456:	4b38      	ldr	r3, [pc, #224]	; (2538 <bus_fault.constprop.0+0x100>)
    2458:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    245a:	04d9      	lsls	r1, r3, #19
    245c:	d509      	bpl.n	2472 <bus_fault.constprop.0+0x3a>
		PR_FAULT_INFO("  Stacking error");
    245e:	4b37      	ldr	r3, [pc, #220]	; (253c <bus_fault.constprop.0+0x104>)
    2460:	4834      	ldr	r0, [pc, #208]	; (2534 <bus_fault.constprop.0+0xfc>)
    2462:	9306      	str	r3, [sp, #24]
    2464:	aa05      	add	r2, sp, #20
    2466:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    246a:	9401      	str	r4, [sp, #4]
    246c:	9405      	str	r4, [sp, #20]
    246e:	f00b fa90 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    2472:	4b31      	ldr	r3, [pc, #196]	; (2538 <bus_fault.constprop.0+0x100>)
    2474:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2476:	051a      	lsls	r2, r3, #20
    2478:	d50a      	bpl.n	2490 <bus_fault.constprop.0+0x58>
		PR_FAULT_INFO("  Unstacking error");
    247a:	4b31      	ldr	r3, [pc, #196]	; (2540 <bus_fault.constprop.0+0x108>)
    247c:	9306      	str	r3, [sp, #24]
    247e:	482d      	ldr	r0, [pc, #180]	; (2534 <bus_fault.constprop.0+0xfc>)
    2480:	2302      	movs	r3, #2
    2482:	aa05      	add	r2, sp, #20
    2484:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    2488:	9301      	str	r3, [sp, #4]
    248a:	9305      	str	r3, [sp, #20]
    248c:	f00b fa81 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    2490:	4c29      	ldr	r4, [pc, #164]	; (2538 <bus_fault.constprop.0+0x100>)
    2492:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2494:	059b      	lsls	r3, r3, #22
    2496:	d51f      	bpl.n	24d8 <bus_fault.constprop.0+0xa0>
		PR_FAULT_INFO("  Precise data bus error");
    2498:	4b2a      	ldr	r3, [pc, #168]	; (2544 <bus_fault.constprop.0+0x10c>)
    249a:	4826      	ldr	r0, [pc, #152]	; (2534 <bus_fault.constprop.0+0xfc>)
    249c:	9306      	str	r3, [sp, #24]
    249e:	aa05      	add	r2, sp, #20
    24a0:	2302      	movs	r3, #2
    24a2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    24a6:	9301      	str	r3, [sp, #4]
    24a8:	9305      	str	r3, [sp, #20]
    24aa:	f00b fa72 	bl	d992 <z_log_msg2_static_create.constprop.0>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    24ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    24b0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    24b2:	0410      	lsls	r0, r2, #16
    24b4:	d510      	bpl.n	24d8 <bus_fault.constprop.0+0xa0>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    24b6:	4a24      	ldr	r2, [pc, #144]	; (2548 <bus_fault.constprop.0+0x110>)
    24b8:	481e      	ldr	r0, [pc, #120]	; (2534 <bus_fault.constprop.0+0xfc>)
    24ba:	e9cd 2306 	strd	r2, r3, [sp, #24]
    24be:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    24c2:	2303      	movs	r3, #3
    24c4:	aa05      	add	r2, sp, #20
    24c6:	9301      	str	r3, [sp, #4]
    24c8:	9305      	str	r3, [sp, #20]
    24ca:	f00b fa62 	bl	d992 <z_log_msg2_static_create.constprop.0>
			if (from_hard_fault != 0) {
    24ce:	b11e      	cbz	r6, 24d8 <bus_fault.constprop.0+0xa0>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    24d0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    24d2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    24d6:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    24d8:	4b17      	ldr	r3, [pc, #92]	; (2538 <bus_fault.constprop.0+0x100>)
    24da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    24dc:	0559      	lsls	r1, r3, #21
    24de:	d50a      	bpl.n	24f6 <bus_fault.constprop.0+0xbe>
		PR_FAULT_INFO("  Imprecise data bus error");
    24e0:	4b1a      	ldr	r3, [pc, #104]	; (254c <bus_fault.constprop.0+0x114>)
    24e2:	9306      	str	r3, [sp, #24]
    24e4:	4813      	ldr	r0, [pc, #76]	; (2534 <bus_fault.constprop.0+0xfc>)
    24e6:	2302      	movs	r3, #2
    24e8:	aa05      	add	r2, sp, #20
    24ea:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    24ee:	9301      	str	r3, [sp, #4]
    24f0:	9305      	str	r3, [sp, #20]
    24f2:	f00b fa4e 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    24f6:	4b10      	ldr	r3, [pc, #64]	; (2538 <bus_fault.constprop.0+0x100>)
    24f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    24fa:	05d2      	lsls	r2, r2, #23
    24fc:	d513      	bpl.n	2526 <bus_fault.constprop.0+0xee>
		PR_FAULT_INFO("  Instruction bus error");
    24fe:	4b14      	ldr	r3, [pc, #80]	; (2550 <bus_fault.constprop.0+0x118>)
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    2500:	9306      	str	r3, [sp, #24]
    2502:	480c      	ldr	r0, [pc, #48]	; (2534 <bus_fault.constprop.0+0xfc>)
    2504:	2302      	movs	r3, #2
    2506:	aa05      	add	r2, sp, #20
    2508:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    250c:	9301      	str	r3, [sp, #4]
    250e:	9305      	str	r3, [sp, #20]
    2510:	f00b fa3f 	bl	d992 <z_log_msg2_static_create.constprop.0>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    2514:	4a08      	ldr	r2, [pc, #32]	; (2538 <bus_fault.constprop.0+0x100>)
    2516:	6a93      	ldr	r3, [r2, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
    2518:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    251a:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    251e:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    2520:	7028      	strb	r0, [r5, #0]

	return reason;
}
    2522:	b008      	add	sp, #32
    2524:	bd70      	pop	{r4, r5, r6, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    2526:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2528:	049b      	lsls	r3, r3, #18
    252a:	d5f3      	bpl.n	2514 <bus_fault.constprop.0+0xdc>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    252c:	4b09      	ldr	r3, [pc, #36]	; (2554 <bus_fault.constprop.0+0x11c>)
    252e:	e7e7      	b.n	2500 <bus_fault.constprop.0+0xc8>
    2530:	00010972 	.word	0x00010972
    2534:	000102d8 	.word	0x000102d8
    2538:	e000ed00 	.word	0xe000ed00
    253c:	00010988 	.word	0x00010988
    2540:	00010999 	.word	0x00010999
    2544:	000109ac 	.word	0x000109ac
    2548:	000109c5 	.word	0x000109c5
    254c:	000109da 	.word	0x000109da
    2550:	000109f5 	.word	0x000109f5
    2554:	00010a0d 	.word	0x00010a0d

00002558 <usage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
    2558:	b510      	push	{r4, lr}
    255a:	b088      	sub	sp, #32
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    255c:	4b36      	ldr	r3, [pc, #216]	; (2638 <usage_fault.constprop.0+0xe0>)
    255e:	4837      	ldr	r0, [pc, #220]	; (263c <usage_fault.constprop.0+0xe4>)
    2560:	9306      	str	r3, [sp, #24]
    2562:	2402      	movs	r4, #2
    2564:	aa05      	add	r2, sp, #20
    2566:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    256a:	9401      	str	r4, [sp, #4]
    256c:	9405      	str	r4, [sp, #20]
    256e:	f00b fa10 	bl	d992 <z_log_msg2_static_create.constprop.0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    2572:	4b33      	ldr	r3, [pc, #204]	; (2640 <usage_fault.constprop.0+0xe8>)
    2574:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2576:	019b      	lsls	r3, r3, #6
    2578:	d509      	bpl.n	258e <usage_fault.constprop.0+0x36>
		PR_FAULT_INFO("  Division by zero");
    257a:	4b32      	ldr	r3, [pc, #200]	; (2644 <usage_fault.constprop.0+0xec>)
    257c:	482f      	ldr	r0, [pc, #188]	; (263c <usage_fault.constprop.0+0xe4>)
    257e:	9306      	str	r3, [sp, #24]
    2580:	aa05      	add	r2, sp, #20
    2582:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    2586:	9401      	str	r4, [sp, #4]
    2588:	9405      	str	r4, [sp, #20]
    258a:	f00b fa02 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    258e:	4b2c      	ldr	r3, [pc, #176]	; (2640 <usage_fault.constprop.0+0xe8>)
    2590:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2592:	01dc      	lsls	r4, r3, #7
    2594:	d50a      	bpl.n	25ac <usage_fault.constprop.0+0x54>
		PR_FAULT_INFO("  Unaligned memory access");
    2596:	4b2c      	ldr	r3, [pc, #176]	; (2648 <usage_fault.constprop.0+0xf0>)
    2598:	9306      	str	r3, [sp, #24]
    259a:	4828      	ldr	r0, [pc, #160]	; (263c <usage_fault.constprop.0+0xe4>)
    259c:	2302      	movs	r3, #2
    259e:	aa05      	add	r2, sp, #20
    25a0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    25a4:	9301      	str	r3, [sp, #4]
    25a6:	9305      	str	r3, [sp, #20]
    25a8:	f00b f9f3 	bl	d992 <z_log_msg2_static_create.constprop.0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    25ac:	4b24      	ldr	r3, [pc, #144]	; (2640 <usage_fault.constprop.0+0xe8>)
    25ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    25b0:	0318      	lsls	r0, r3, #12
    25b2:	d50a      	bpl.n	25ca <usage_fault.constprop.0+0x72>
		PR_FAULT_INFO("  No coprocessor instructions");
    25b4:	4b25      	ldr	r3, [pc, #148]	; (264c <usage_fault.constprop.0+0xf4>)
    25b6:	9306      	str	r3, [sp, #24]
    25b8:	4820      	ldr	r0, [pc, #128]	; (263c <usage_fault.constprop.0+0xe4>)
    25ba:	2302      	movs	r3, #2
    25bc:	aa05      	add	r2, sp, #20
    25be:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    25c2:	9301      	str	r3, [sp, #4]
    25c4:	9305      	str	r3, [sp, #20]
    25c6:	f00b f9e4 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    25ca:	4b1d      	ldr	r3, [pc, #116]	; (2640 <usage_fault.constprop.0+0xe8>)
    25cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    25ce:	0359      	lsls	r1, r3, #13
    25d0:	d50a      	bpl.n	25e8 <usage_fault.constprop.0+0x90>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    25d2:	4b1f      	ldr	r3, [pc, #124]	; (2650 <usage_fault.constprop.0+0xf8>)
    25d4:	9306      	str	r3, [sp, #24]
    25d6:	4819      	ldr	r0, [pc, #100]	; (263c <usage_fault.constprop.0+0xe4>)
    25d8:	2302      	movs	r3, #2
    25da:	aa05      	add	r2, sp, #20
    25dc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    25e0:	9301      	str	r3, [sp, #4]
    25e2:	9305      	str	r3, [sp, #20]
    25e4:	f00b f9d5 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    25e8:	4b15      	ldr	r3, [pc, #84]	; (2640 <usage_fault.constprop.0+0xe8>)
    25ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    25ec:	039a      	lsls	r2, r3, #14
    25ee:	d50a      	bpl.n	2606 <usage_fault.constprop.0+0xae>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    25f0:	4b18      	ldr	r3, [pc, #96]	; (2654 <usage_fault.constprop.0+0xfc>)
    25f2:	9306      	str	r3, [sp, #24]
    25f4:	4811      	ldr	r0, [pc, #68]	; (263c <usage_fault.constprop.0+0xe4>)
    25f6:	2302      	movs	r3, #2
    25f8:	aa05      	add	r2, sp, #20
    25fa:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    25fe:	9301      	str	r3, [sp, #4]
    2600:	9305      	str	r3, [sp, #20]
    2602:	f00b f9c6 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    2606:	4b0e      	ldr	r3, [pc, #56]	; (2640 <usage_fault.constprop.0+0xe8>)
    2608:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    260a:	03db      	lsls	r3, r3, #15
    260c:	d50a      	bpl.n	2624 <usage_fault.constprop.0+0xcc>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    260e:	4b12      	ldr	r3, [pc, #72]	; (2658 <usage_fault.constprop.0+0x100>)
    2610:	9306      	str	r3, [sp, #24]
    2612:	480a      	ldr	r0, [pc, #40]	; (263c <usage_fault.constprop.0+0xe4>)
    2614:	2302      	movs	r3, #2
    2616:	aa05      	add	r2, sp, #20
    2618:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    261c:	9301      	str	r3, [sp, #4]
    261e:	9305      	str	r3, [sp, #20]
    2620:	f00b f9b7 	bl	d992 <z_log_msg2_static_create.constprop.0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    2624:	4a06      	ldr	r2, [pc, #24]	; (2640 <usage_fault.constprop.0+0xe8>)
    2626:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2628:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    262c:	ea6f 4313 	mvn.w	r3, r3, lsr #16

	return reason;
}
    2630:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    2632:	6293      	str	r3, [r2, #40]	; 0x28
}
    2634:	b008      	add	sp, #32
    2636:	bd10      	pop	{r4, pc}
    2638:	00010a3c 	.word	0x00010a3c
    263c:	000102d8 	.word	0x000102d8
    2640:	e000ed00 	.word	0xe000ed00
    2644:	00010a54 	.word	0x00010a54
    2648:	00010a67 	.word	0x00010a67
    264c:	00010a81 	.word	0x00010a81
    2650:	00010a9f 	.word	0x00010a9f
    2654:	00010ac4 	.word	0x00010ac4
    2658:	00010ade 	.word	0x00010ade

0000265c <mem_manage_fault>:
{
    265c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2660:	b088      	sub	sp, #32
	PR_FAULT_INFO("***** MPU FAULT *****");
    2662:	4b48      	ldr	r3, [pc, #288]	; (2784 <mem_manage_fault+0x128>)
    2664:	9306      	str	r3, [sp, #24]
    2666:	2402      	movs	r4, #2
{
    2668:	4607      	mov	r7, r0
    266a:	4688      	mov	r8, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    266c:	4846      	ldr	r0, [pc, #280]	; (2788 <mem_manage_fault+0x12c>)
    266e:	9401      	str	r4, [sp, #4]
{
    2670:	4615      	mov	r5, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
    2672:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    2676:	aa05      	add	r2, sp, #20
    2678:	9405      	str	r4, [sp, #20]
    267a:	f00b f98a 	bl	d992 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    267e:	4b43      	ldr	r3, [pc, #268]	; (278c <mem_manage_fault+0x130>)
    2680:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2682:	06d8      	lsls	r0, r3, #27
    2684:	d509      	bpl.n	269a <mem_manage_fault+0x3e>
		PR_FAULT_INFO("  Stacking error (context area might be"
    2686:	4b42      	ldr	r3, [pc, #264]	; (2790 <mem_manage_fault+0x134>)
    2688:	483f      	ldr	r0, [pc, #252]	; (2788 <mem_manage_fault+0x12c>)
    268a:	9306      	str	r3, [sp, #24]
    268c:	aa05      	add	r2, sp, #20
    268e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    2692:	9401      	str	r4, [sp, #4]
    2694:	9405      	str	r4, [sp, #20]
    2696:	f00b f97c 	bl	d992 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    269a:	4b3c      	ldr	r3, [pc, #240]	; (278c <mem_manage_fault+0x130>)
    269c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    269e:	0719      	lsls	r1, r3, #28
    26a0:	d50a      	bpl.n	26b8 <mem_manage_fault+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    26a2:	4b3c      	ldr	r3, [pc, #240]	; (2794 <mem_manage_fault+0x138>)
    26a4:	9306      	str	r3, [sp, #24]
    26a6:	4838      	ldr	r0, [pc, #224]	; (2788 <mem_manage_fault+0x12c>)
    26a8:	2302      	movs	r3, #2
    26aa:	aa05      	add	r2, sp, #20
    26ac:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    26b0:	9301      	str	r3, [sp, #4]
    26b2:	9305      	str	r3, [sp, #20]
    26b4:	f00b f96d 	bl	d992 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    26b8:	4c34      	ldr	r4, [pc, #208]	; (278c <mem_manage_fault+0x130>)
    26ba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    26bc:	079a      	lsls	r2, r3, #30
    26be:	d431      	bmi.n	2724 <mem_manage_fault+0xc8>
	uint32_t mmfar = -EINVAL;
    26c0:	f06f 0615 	mvn.w	r6, #21
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    26c4:	4b31      	ldr	r3, [pc, #196]	; (278c <mem_manage_fault+0x130>)
    26c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    26c8:	07dc      	lsls	r4, r3, #31
    26ca:	d50a      	bpl.n	26e2 <mem_manage_fault+0x86>
		PR_FAULT_INFO("  Instruction Access Violation");
    26cc:	4b32      	ldr	r3, [pc, #200]	; (2798 <mem_manage_fault+0x13c>)
    26ce:	9306      	str	r3, [sp, #24]
    26d0:	482d      	ldr	r0, [pc, #180]	; (2788 <mem_manage_fault+0x12c>)
    26d2:	2302      	movs	r3, #2
    26d4:	aa05      	add	r2, sp, #20
    26d6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    26da:	9301      	str	r3, [sp, #4]
    26dc:	9305      	str	r3, [sp, #20]
    26de:	f00b f958 	bl	d992 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    26e2:	4b2a      	ldr	r3, [pc, #168]	; (278c <mem_manage_fault+0x130>)
    26e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    26e6:	0698      	lsls	r0, r3, #26
    26e8:	d50a      	bpl.n	2700 <mem_manage_fault+0xa4>
		PR_FAULT_INFO(
    26ea:	4b2c      	ldr	r3, [pc, #176]	; (279c <mem_manage_fault+0x140>)
    26ec:	9306      	str	r3, [sp, #24]
    26ee:	4826      	ldr	r0, [pc, #152]	; (2788 <mem_manage_fault+0x12c>)
    26f0:	2302      	movs	r3, #2
    26f2:	aa05      	add	r2, sp, #20
    26f4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    26f8:	9301      	str	r3, [sp, #4]
    26fa:	9305      	str	r3, [sp, #20]
    26fc:	f00b f949 	bl	d992 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    2700:	4b22      	ldr	r3, [pc, #136]	; (278c <mem_manage_fault+0x130>)
    2702:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2704:	06d1      	lsls	r1, r2, #27
    2706:	d430      	bmi.n	276a <mem_manage_fault+0x10e>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    2708:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    270a:	0792      	lsls	r2, r2, #30
    270c:	d42d      	bmi.n	276a <mem_manage_fault+0x10e>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    270e:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    2710:	4a1e      	ldr	r2, [pc, #120]	; (278c <mem_manage_fault+0x130>)
    2712:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2714:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    2718:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    271a:	2300      	movs	r3, #0
    271c:	702b      	strb	r3, [r5, #0]
}
    271e:	b008      	add	sp, #32
    2720:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		PR_FAULT_INFO("  Data Access Violation");
    2724:	4b1e      	ldr	r3, [pc, #120]	; (27a0 <mem_manage_fault+0x144>)
    2726:	9306      	str	r3, [sp, #24]
    2728:	4817      	ldr	r0, [pc, #92]	; (2788 <mem_manage_fault+0x12c>)
    272a:	2302      	movs	r3, #2
    272c:	aa05      	add	r2, sp, #20
    272e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    2732:	9301      	str	r3, [sp, #4]
    2734:	9305      	str	r3, [sp, #20]
    2736:	f00b f92c 	bl	d992 <z_log_msg2_static_create.constprop.0>
		uint32_t temp = SCB->MMFAR;
    273a:	6b66      	ldr	r6, [r4, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    273c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    273e:	061b      	lsls	r3, r3, #24
    2740:	d5be      	bpl.n	26c0 <mem_manage_fault+0x64>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    2742:	4b18      	ldr	r3, [pc, #96]	; (27a4 <mem_manage_fault+0x148>)
    2744:	4810      	ldr	r0, [pc, #64]	; (2788 <mem_manage_fault+0x12c>)
    2746:	e9cd 3606 	strd	r3, r6, [sp, #24]
    274a:	aa05      	add	r2, sp, #20
    274c:	2303      	movs	r3, #3
    274e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    2752:	9301      	str	r3, [sp, #4]
    2754:	9305      	str	r3, [sp, #20]
    2756:	f00b f91c 	bl	d992 <z_log_msg2_static_create.constprop.0>
			if (from_hard_fault != 0) {
    275a:	f1b8 0f00 	cmp.w	r8, #0
    275e:	d0b1      	beq.n	26c4 <mem_manage_fault+0x68>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    2760:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2762:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    2766:	62a3      	str	r3, [r4, #40]	; 0x28
    2768:	e7ac      	b.n	26c4 <mem_manage_fault+0x68>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    276a:	685b      	ldr	r3, [r3, #4]
    276c:	051b      	lsls	r3, r3, #20
    276e:	d5ce      	bpl.n	270e <mem_manage_fault+0xb2>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    2770:	4639      	mov	r1, r7
    2772:	4630      	mov	r0, r6
    2774:	f7ff fe06 	bl	2384 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
    2778:	2800      	cmp	r0, #0
    277a:	d0c8      	beq.n	270e <mem_manage_fault+0xb2>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    277c:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
    2780:	2002      	movs	r0, #2
    2782:	e7c5      	b.n	2710 <mem_manage_fault+0xb4>
    2784:	00010b09 	.word	0x00010b09
    2788:	000102d8 	.word	0x000102d8
    278c:	e000ed00 	.word	0xe000ed00
    2790:	00010b1f 	.word	0x00010b1f
    2794:	00010999 	.word	0x00010999
    2798:	00010b80 	.word	0x00010b80
    279c:	00010a0d 	.word	0x00010a0d
    27a0:	00010b52 	.word	0x00010b52
    27a4:	00010b6a 	.word	0x00010b6a

000027a8 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    27a8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    27aa:	ab0a      	add	r3, sp, #40	; 0x28
    27ac:	9305      	str	r3, [sp, #20]
		arch_syscall_invoke6(*(uintptr_t *)&domain_id, *(uintptr_t *)&source, *(uintptr_t *)&level, *(uintptr_t *)&data, *(uintptr_t *)&dlen, (uintptr_t) &more, K_SYSCALL_Z_LOG_MSG2_RUNTIME_VCREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    27ae:	9302      	str	r3, [sp, #8]
    27b0:	4b05      	ldr	r3, [pc, #20]	; (27c8 <z_log_msg2_runtime_create.constprop.0+0x20>)
    27b2:	9301      	str	r3, [sp, #4]
    27b4:	2300      	movs	r3, #0
    27b6:	9300      	str	r3, [sp, #0]
    27b8:	2201      	movs	r2, #1
    27ba:	4618      	mov	r0, r3
    27bc:	f7ff fa42 	bl	1c44 <z_impl_z_log_msg2_runtime_vcreate>
}
    27c0:	b007      	add	sp, #28
    27c2:	f85d fb04 	ldr.w	pc, [sp], #4
    27c6:	bf00      	nop
    27c8:	00010b9f 	.word	0x00010b9f

000027cc <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    27cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    27d0:	4b70      	ldr	r3, [pc, #448]	; (2994 <z_arm_fault+0x1c8>)
    27d2:	685d      	ldr	r5, [r3, #4]
{
    27d4:	b08f      	sub	sp, #60	; 0x3c
    27d6:	460f      	mov	r7, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    27d8:	f3c5 0408 	ubfx	r4, r5, #0, #9
    27dc:	f04f 0800 	mov.w	r8, #0
    27e0:	f388 8811 	msr	BASEPRI, r8
    27e4:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    27e8:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    27ec:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    27f0:	d10e      	bne.n	2810 <z_arm_fault+0x44>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    27f2:	f002 030c 	and.w	r3, r2, #12
    27f6:	2b08      	cmp	r3, #8
    27f8:	d10c      	bne.n	2814 <z_arm_fault+0x48>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    27fa:	4b67      	ldr	r3, [pc, #412]	; (2998 <z_arm_fault+0x1cc>)
    27fc:	930a      	str	r3, [sp, #40]	; 0x28
    27fe:	4867      	ldr	r0, [pc, #412]	; (299c <z_arm_fault+0x1d0>)
    2800:	2302      	movs	r3, #2
    2802:	aa09      	add	r2, sp, #36	; 0x24
    2804:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    2808:	9305      	str	r3, [sp, #20]
    280a:	9309      	str	r3, [sp, #36]	; 0x24
    280c:	f00b f8c1 	bl	d992 <z_log_msg2_static_create.constprop.0>
		return NULL;
    2810:	4647      	mov	r7, r8
    2812:	e004      	b.n	281e <z_arm_fault+0x52>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    2814:	0712      	lsls	r2, r2, #28
    2816:	d402      	bmi.n	281e <z_arm_fault+0x52>
			ptr_esf = (z_arch_esf_t *)msp;
    2818:	4607      	mov	r7, r0
			*nested_exc = true;
    281a:	f04f 0801 	mov.w	r8, #1
	*recoverable = false;
    281e:	2300      	movs	r3, #0
    2820:	f88d 3013 	strb.w	r3, [sp, #19]
	switch (fault) {
    2824:	1ee3      	subs	r3, r4, #3
    2826:	2b09      	cmp	r3, #9
    2828:	f200 809a 	bhi.w	2960 <z_arm_fault+0x194>
    282c:	e8df f003 	tbb	[pc, r3]
    2830:	878e8a05 	.word	0x878e8a05
    2834:	98989898 	.word	0x98989898
    2838:	9298      	.short	0x9298
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    283a:	4e56      	ldr	r6, [pc, #344]	; (2994 <z_arm_fault+0x1c8>)
	PR_FAULT_INFO("***** HARD FAULT *****");
    283c:	4b58      	ldr	r3, [pc, #352]	; (29a0 <z_arm_fault+0x1d4>)
    283e:	4857      	ldr	r0, [pc, #348]	; (299c <z_arm_fault+0x1d0>)
    2840:	930a      	str	r3, [sp, #40]	; 0x28
    2842:	2502      	movs	r5, #2
    2844:	aa09      	add	r2, sp, #36	; 0x24
    2846:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    284a:	9505      	str	r5, [sp, #20]
    284c:	9509      	str	r5, [sp, #36]	; 0x24
    284e:	f00b f8a0 	bl	d992 <z_log_msg2_static_create.constprop.0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    2852:	6af4      	ldr	r4, [r6, #44]	; 0x2c
	*recoverable = false;
    2854:	f04f 0900 	mov.w	r9, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    2858:	402c      	ands	r4, r5
	*recoverable = false;
    285a:	f88d 9013 	strb.w	r9, [sp, #19]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    285e:	d00b      	beq.n	2878 <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
    2860:	4b50      	ldr	r3, [pc, #320]	; (29a4 <z_arm_fault+0x1d8>)
    2862:	930a      	str	r3, [sp, #40]	; 0x28
    2864:	9505      	str	r5, [sp, #20]
    2866:	9509      	str	r5, [sp, #36]	; 0x24
	PR_FAULT_INFO(
    2868:	484c      	ldr	r0, [pc, #304]	; (299c <z_arm_fault+0x1d0>)
    286a:	aa09      	add	r2, sp, #36	; 0x24
    286c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    2870:	f00b f88f 	bl	d992 <z_log_msg2_static_create.constprop.0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2874:	2400      	movs	r4, #0
}
    2876:	e00c      	b.n	2892 <z_arm_fault+0xc6>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    2878:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    287a:	2b00      	cmp	r3, #0
    287c:	da24      	bge.n	28c8 <z_arm_fault+0xfc>
		PR_EXC("  Debug event");
    287e:	4b4a      	ldr	r3, [pc, #296]	; (29a8 <z_arm_fault+0x1dc>)
    2880:	4846      	ldr	r0, [pc, #280]	; (299c <z_arm_fault+0x1d0>)
    2882:	930a      	str	r3, [sp, #40]	; 0x28
    2884:	aa09      	add	r2, sp, #36	; 0x24
    2886:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    288a:	9505      	str	r5, [sp, #20]
    288c:	9509      	str	r5, [sp, #36]	; 0x24
    288e:	f00b f880 	bl	d992 <z_log_msg2_static_create.constprop.0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    2892:	f89d 3013 	ldrb.w	r3, [sp, #19]
    2896:	b9a3      	cbnz	r3, 28c2 <z_arm_fault+0xf6>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    2898:	2220      	movs	r2, #32
    289a:	4639      	mov	r1, r7
    289c:	a806      	add	r0, sp, #24
    289e:	f00b f8b2 	bl	da06 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    28a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    28a4:	f1b8 0f00 	cmp.w	r8, #0
    28a8:	d06e      	beq.n	2988 <z_arm_fault+0x1bc>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    28aa:	f3c3 0208 	ubfx	r2, r3, #0, #9
    28ae:	b922      	cbnz	r2, 28ba <z_arm_fault+0xee>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    28b0:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    28b4:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    28b8:	930d      	str	r3, [sp, #52]	; 0x34
	}

	z_arm_fatal_error(reason, &esf_copy);
    28ba:	a906      	add	r1, sp, #24
    28bc:	4620      	mov	r0, r4
    28be:	f7ff fc0b 	bl	20d8 <z_arm_fatal_error>
}
    28c2:	b00f      	add	sp, #60	; 0x3c
    28c4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    28c8:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    28ca:	005b      	lsls	r3, r3, #1
    28cc:	d5e1      	bpl.n	2892 <z_arm_fault+0xc6>
		PR_EXC("  Fault escalation (see below)");
    28ce:	4b37      	ldr	r3, [pc, #220]	; (29ac <z_arm_fault+0x1e0>)
    28d0:	4832      	ldr	r0, [pc, #200]	; (299c <z_arm_fault+0x1d0>)
    28d2:	930a      	str	r3, [sp, #40]	; 0x28
    28d4:	aa09      	add	r2, sp, #36	; 0x24
    28d6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    28da:	9505      	str	r5, [sp, #20]
    28dc:	9509      	str	r5, [sp, #36]	; 0x24
    28de:	f00b f858 	bl	d992 <z_log_msg2_static_create.constprop.0>
	uint16_t fault_insn = *(ret_addr - 1);
    28e2:	69bb      	ldr	r3, [r7, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    28e4:	f833 2c02 	ldrh.w	r2, [r3, #-2]
    28e8:	f64d 7302 	movw	r3, #57090	; 0xdf02
    28ec:	429a      	cmp	r2, r3
    28ee:	d00a      	beq.n	2906 <z_arm_fault+0x13a>
		} else if (SCB_MMFSR != 0) {
    28f0:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
    28f4:	b1b3      	cbz	r3, 2924 <z_arm_fault+0x158>
			reason = mem_manage_fault(esf, 1, recoverable);
    28f6:	f10d 0213 	add.w	r2, sp, #19
    28fa:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    28fc:	4638      	mov	r0, r7
    28fe:	f7ff fead 	bl	265c <mem_manage_fault>
    2902:	4604      	mov	r4, r0
		break;
    2904:	e7c5      	b.n	2892 <z_arm_fault+0xc6>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
    2906:	683b      	ldr	r3, [r7, #0]
    2908:	4a29      	ldr	r2, [pc, #164]	; (29b0 <z_arm_fault+0x1e4>)
    290a:	4824      	ldr	r0, [pc, #144]	; (299c <z_arm_fault+0x1d0>)
    290c:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    2910:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    2914:	2303      	movs	r3, #3
    2916:	aa09      	add	r2, sp, #36	; 0x24
    2918:	9305      	str	r3, [sp, #20]
    291a:	9309      	str	r3, [sp, #36]	; 0x24
    291c:	f00b f839 	bl	d992 <z_log_msg2_static_create.constprop.0>
			reason = esf->basic.r0;
    2920:	683c      	ldr	r4, [r7, #0]
    2922:	e7b6      	b.n	2892 <z_arm_fault+0xc6>
		} else if (SCB_BFSR != 0) {
    2924:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
    2928:	b12b      	cbz	r3, 2936 <z_arm_fault+0x16a>
			reason = bus_fault(esf, 1, recoverable);
    292a:	f10d 0113 	add.w	r1, sp, #19
    292e:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    2930:	f7ff fd82 	bl	2438 <bus_fault.constprop.0>
    2934:	e7e5      	b.n	2902 <z_arm_fault+0x136>
		} else if (SCB_UFSR != 0) {
    2936:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
    2938:	b29b      	uxth	r3, r3
    293a:	2b00      	cmp	r3, #0
    293c:	d0a9      	beq.n	2892 <z_arm_fault+0xc6>
		reason = usage_fault(esf);
    293e:	f7ff fe0b 	bl	2558 <usage_fault.constprop.0>
    2942:	e7de      	b.n	2902 <z_arm_fault+0x136>
		reason = mem_manage_fault(esf, 0, recoverable);
    2944:	f10d 0213 	add.w	r2, sp, #19
    2948:	2100      	movs	r1, #0
    294a:	e7d7      	b.n	28fc <z_arm_fault+0x130>
		reason = bus_fault(esf, 0, recoverable);
    294c:	f10d 0113 	add.w	r1, sp, #19
    2950:	2000      	movs	r0, #0
    2952:	e7ed      	b.n	2930 <z_arm_fault+0x164>
	PR_FAULT_INFO(
    2954:	4b17      	ldr	r3, [pc, #92]	; (29b4 <z_arm_fault+0x1e8>)
    2956:	930a      	str	r3, [sp, #40]	; 0x28
    2958:	2302      	movs	r3, #2
    295a:	9305      	str	r3, [sp, #20]
    295c:	9309      	str	r3, [sp, #36]	; 0x24
    295e:	e783      	b.n	2868 <z_arm_fault+0x9c>
	PR_FAULT_INFO("***** %s %d) *****",
    2960:	4a15      	ldr	r2, [pc, #84]	; (29b8 <z_arm_fault+0x1ec>)
    2962:	4b16      	ldr	r3, [pc, #88]	; (29bc <z_arm_fault+0x1f0>)
    2964:	490d      	ldr	r1, [pc, #52]	; (299c <z_arm_fault+0x1d0>)
    2966:	f415 7ff8 	tst.w	r5, #496	; 0x1f0
    296a:	bf18      	it	ne
    296c:	4613      	movne	r3, r2
    296e:	3c10      	subs	r4, #16
    2970:	e9cd 3402 	strd	r3, r4, [sp, #8]
    2974:	2400      	movs	r4, #0
    2976:	4b12      	ldr	r3, [pc, #72]	; (29c0 <z_arm_fault+0x1f4>)
    2978:	9301      	str	r3, [sp, #4]
    297a:	9400      	str	r4, [sp, #0]
    297c:	4623      	mov	r3, r4
    297e:	2201      	movs	r2, #1
    2980:	4620      	mov	r0, r4
    2982:	f7ff ff11 	bl	27a8 <z_log_msg2_runtime_create.constprop.0>
}
    2986:	e784      	b.n	2892 <z_arm_fault+0xc6>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    2988:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    298c:	f023 0301 	bic.w	r3, r3, #1
    2990:	e792      	b.n	28b8 <z_arm_fault+0xec>
    2992:	bf00      	nop
    2994:	e000ed00 	.word	0xe000ed00
    2998:	00010be0 	.word	0x00010be0
    299c:	000102d8 	.word	0x000102d8
    29a0:	00010c0b 	.word	0x00010c0b
    29a4:	00010c22 	.word	0x00010c22
    29a8:	00010c43 	.word	0x00010c43
    29ac:	00010c51 	.word	0x00010c51
    29b0:	00010c70 	.word	0x00010c70
    29b4:	00010c8c 	.word	0x00010c8c
    29b8:	00010bc7 	.word	0x00010bc7
    29bc:	00010bb2 	.word	0x00010bb2
    29c0:	00010b9f 	.word	0x00010b9f

000029c4 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    29c4:	4a02      	ldr	r2, [pc, #8]	; (29d0 <z_arm_fault_init+0xc>)
    29c6:	6953      	ldr	r3, [r2, #20]
    29c8:	f043 0310 	orr.w	r3, r3, #16
    29cc:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    29ce:	4770      	bx	lr
    29d0:	e000ed00 	.word	0xe000ed00

000029d4 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    29d4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    29d8:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    29dc:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    29de:	4672      	mov	r2, lr
	bl z_arm_fault
    29e0:	f7ff fef4 	bl	27cc <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    29e4:	bd01      	pop	{r0, pc}
    29e6:	bf00      	nop

000029e8 <z_arm_interrupt_init>:
    29e8:	4804      	ldr	r0, [pc, #16]	; (29fc <z_arm_interrupt_init+0x14>)
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    29ea:	2300      	movs	r3, #0
    29ec:	2120      	movs	r1, #32
    29ee:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    29f0:	3301      	adds	r3, #1
    29f2:	2b27      	cmp	r3, #39	; 0x27
    29f4:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    29f8:	d1f9      	bne.n	29ee <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    29fa:	4770      	bx	lr
    29fc:	e000e100 	.word	0xe000e100

00002a00 <__start>:
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    2a00:	f00d fa68 	bl	fed4 <z_arm_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    2a04:	2020      	movs	r0, #32
    msr BASEPRI, r0
    2a06:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    2a0a:	4808      	ldr	r0, [pc, #32]	; (2a2c <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    2a0c:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
    2a10:	1840      	adds	r0, r0, r1
    msr PSP, r0
    2a12:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    2a16:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    2a1a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    2a1c:	4308      	orrs	r0, r1
    msr CONTROL, r0
    2a1e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    2a22:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    2a26:	f7ff fc19 	bl	225c <z_arm_prep_c>
    2a2a:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    2a2c:	200033c0 	.word	0x200033c0

00002a30 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
    2a30:	4b06      	ldr	r3, [pc, #24]	; (2a4c <z_impl_k_thread_abort+0x1c>)
    2a32:	689b      	ldr	r3, [r3, #8]
    2a34:	4283      	cmp	r3, r0
    2a36:	d107      	bne.n	2a48 <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    2a38:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    2a3c:	b123      	cbz	r3, 2a48 <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    2a3e:	4a04      	ldr	r2, [pc, #16]	; (2a50 <z_impl_k_thread_abort+0x20>)
    2a40:	6853      	ldr	r3, [r2, #4]
    2a42:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    2a46:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
    2a48:	f009 be52 	b.w	c6f0 <z_thread_abort>
    2a4c:	20001bc4 	.word	0x20001bc4
    2a50:	e000ed00 	.word	0xe000ed00

00002a54 <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    2a54:	4b02      	ldr	r3, [pc, #8]	; (2a60 <z_arm_configure_static_mpu_regions+0xc>)
    2a56:	4a03      	ldr	r2, [pc, #12]	; (2a64 <z_arm_configure_static_mpu_regions+0x10>)
    2a58:	4803      	ldr	r0, [pc, #12]	; (2a68 <z_arm_configure_static_mpu_regions+0x14>)
    2a5a:	2101      	movs	r1, #1
    2a5c:	f000 b888 	b.w	2b70 <arm_core_mpu_configure_static_mpu_regions>
    2a60:	20010000 	.word	0x20010000
    2a64:	20000000 	.word	0x20000000
    2a68:	00010470 	.word	0x00010470

00002a6c <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
    2a6c:	6e82      	ldr	r2, [r0, #104]	; 0x68
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
    2a6e:	4b05      	ldr	r3, [pc, #20]	; (2a84 <z_arm_configure_dynamic_mpu_regions+0x18>)
		guard_start = thread->stack_info.start - guard_size;
    2a70:	3a20      	subs	r2, #32
	dynamic_regions[region_num].start = guard_start;
    2a72:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
    2a74:	4a04      	ldr	r2, [pc, #16]	; (2a88 <z_arm_configure_dynamic_mpu_regions+0x1c>)
    2a76:	2120      	movs	r1, #32
    2a78:	e9c3 1201 	strd	r1, r2, [r3, #4]

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
    2a7c:	4618      	mov	r0, r3
    2a7e:	2101      	movs	r1, #1
    2a80:	f000 b880 	b.w	2b84 <arm_core_mpu_configure_dynamic_mpu_regions>
    2a84:	20001028 	.word	0x20001028
    2a88:	150b0000 	.word	0x150b0000

00002a8c <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    2a8c:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
    2a8e:	4f29      	ldr	r7, [pc, #164]	; (2b34 <mpu_configure_regions+0xa8>)
    2a90:	b089      	sub	sp, #36	; 0x24
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    2a92:	2600      	movs	r6, #0
    2a94:	428e      	cmp	r6, r1
    2a96:	da17      	bge.n	2ac8 <mpu_configure_regions+0x3c>
		if (regions[i].size == 0U) {
    2a98:	6844      	ldr	r4, [r0, #4]
    2a9a:	2c00      	cmp	r4, #0
    2a9c:	d046      	beq.n	2b2c <mpu_configure_regions+0xa0>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    2a9e:	b1e3      	cbz	r3, 2ada <mpu_configure_regions+0x4e>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
    2aa0:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    2aa4:	ea14 0f0c 	tst.w	r4, ip
    2aa8:	d011      	beq.n	2ace <mpu_configure_regions+0x42>
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    2aaa:	4b23      	ldr	r3, [pc, #140]	; (2b38 <mpu_configure_regions+0xac>)
    2aac:	e9cd 3606 	strd	r3, r6, [sp, #24]
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    2ab0:	2303      	movs	r3, #3
    2ab2:	9301      	str	r3, [sp, #4]
    2ab4:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    2ab6:	4821      	ldr	r0, [pc, #132]	; (2b3c <mpu_configure_regions+0xb0>)
    2ab8:	aa05      	add	r2, sp, #20
    2aba:	2300      	movs	r3, #0
    2abc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    2ac0:	f00a ff38 	bl	d934 <z_impl_z_log_msg2_static_create>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
    2ac4:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    2ac8:	4610      	mov	r0, r2
    2aca:	b009      	add	sp, #36	; 0x24
    2acc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		&&
    2ace:	2c1f      	cmp	r4, #31
    2ad0:	d9eb      	bls.n	2aaa <mpu_configure_regions+0x1e>
		((part->start & (part->size - 1U)) == 0U);
    2ad2:	6805      	ldr	r5, [r0, #0]
		&&
    2ad4:	ea1c 0f05 	tst.w	ip, r5
    2ad8:	d1e7      	bne.n	2aaa <mpu_configure_regions+0x1e>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    2ada:	2c20      	cmp	r4, #32
	region_conf.base = new_region->start;
    2adc:	6805      	ldr	r5, [r0, #0]
#if defined(CONFIG_CPU_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    2ade:	f8d0 c008 	ldr.w	ip, [r0, #8]
		reg_index = mpu_configure_region(reg_index, &regions[i]);
    2ae2:	b2d2      	uxtb	r2, r2
	if (size <= 32U) {
    2ae4:	d910      	bls.n	2b08 <mpu_configure_regions+0x7c>
	if (size > (1UL << 31)) {
    2ae6:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    2aea:	d80f      	bhi.n	2b0c <mpu_configure_regions+0x80>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    2aec:	3c01      	subs	r4, #1
    2aee:	fab4 f484 	clz	r4, r4
    2af2:	f1c4 041f 	rsb	r4, r4, #31
    2af6:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
    2af8:	2a07      	cmp	r2, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    2afa:	ea4c 0404 	orr.w	r4, ip, r4
    2afe:	d907      	bls.n	2b10 <mpu_configure_regions+0x84>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    2b00:	4b0f      	ldr	r3, [pc, #60]	; (2b40 <mpu_configure_regions+0xb4>)
    2b02:	e9cd 3206 	strd	r3, r2, [sp, #24]
    2b06:	e7d3      	b.n	2ab0 <mpu_configure_regions+0x24>
		return REGION_32B;
    2b08:	2408      	movs	r4, #8
    2b0a:	e7f5      	b.n	2af8 <mpu_configure_regions+0x6c>
		return REGION_4G;
    2b0c:	243e      	movs	r4, #62	; 0x3e
    2b0e:	e7f3      	b.n	2af8 <mpu_configure_regions+0x6c>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2b10:	f025 051f 	bic.w	r5, r5, #31
				| MPU_RBAR_VALID_Msk | index;
    2b14:	4315      	orrs	r5, r2
    2b16:	f045 0510 	orr.w	r5, r5, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    2b1a:	f044 0401 	orr.w	r4, r4, #1
    2b1e:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2b22:	f8c7 509c 	str.w	r5, [r7, #156]	; 0x9c
		reg_index++;
    2b26:	3201      	adds	r2, #1
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    2b28:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
    2b2c:	3601      	adds	r6, #1
    2b2e:	300c      	adds	r0, #12
    2b30:	e7b0      	b.n	2a94 <mpu_configure_regions+0x8>
    2b32:	bf00      	nop
    2b34:	e000ed00 	.word	0xe000ed00
    2b38:	00010cb4 	.word	0x00010cb4
    2b3c:	000102c8 	.word	0x000102c8
    2b40:	00010cd7 	.word	0x00010cd7

00002b44 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    2b44:	4b04      	ldr	r3, [pc, #16]	; (2b58 <arm_core_mpu_enable+0x14>)
    2b46:	2205      	movs	r2, #5
    2b48:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
    2b4c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2b50:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    2b54:	4770      	bx	lr
    2b56:	bf00      	nop
    2b58:	e000ed00 	.word	0xe000ed00

00002b5c <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    2b5c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    2b60:	4b02      	ldr	r3, [pc, #8]	; (2b6c <arm_core_mpu_disable+0x10>)
    2b62:	2200      	movs	r2, #0
    2b64:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    2b68:	4770      	bx	lr
    2b6a:	bf00      	nop
    2b6c:	e000ed00 	.word	0xe000ed00

00002b70 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
    2b70:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    2b72:	4c03      	ldr	r4, [pc, #12]	; (2b80 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    2b74:	2301      	movs	r3, #1
    2b76:	7822      	ldrb	r2, [r4, #0]
    2b78:	f7ff ff88 	bl	2a8c <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    2b7c:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
    2b7e:	bd10      	pop	{r4, pc}
    2b80:	20001c1a 	.word	0x20001c1a

00002b84 <arm_core_mpu_configure_dynamic_mpu_regions>:
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
    2b84:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    2b86:	4a09      	ldr	r2, [pc, #36]	; (2bac <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
    2b88:	2300      	movs	r3, #0
    2b8a:	7812      	ldrb	r2, [r2, #0]
    2b8c:	f7ff ff7e 	bl	2a8c <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    2b90:	f110 0f16 	cmn.w	r0, #22
    2b94:	d003      	beq.n	2b9e <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    2b96:	4b06      	ldr	r3, [pc, #24]	; (2bb0 <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)
  MPU->RASR = 0U;
    2b98:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    2b9a:	2807      	cmp	r0, #7
    2b9c:	dd00      	ble.n	2ba0 <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
    2b9e:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
    2ba0:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
  MPU->RASR = 0U;
    2ba4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    2ba8:	3001      	adds	r0, #1
    2baa:	e7f6      	b.n	2b9a <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
    2bac:	20001c1a 	.word	0x20001c1a
    2bb0:	e000ed00 	.word	0xe000ed00

00002bb4 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    2bb4:	4914      	ldr	r1, [pc, #80]	; (2c08 <z_arm_mpu_init+0x54>)
    2bb6:	6808      	ldr	r0, [r1, #0]
    2bb8:	2808      	cmp	r0, #8
{
    2bba:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    2bbc:	d821      	bhi.n	2c02 <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    2bbe:	f7ff ffcd 	bl	2b5c <arm_core_mpu_disable>
    2bc2:	4c12      	ldr	r4, [pc, #72]	; (2c0c <z_arm_mpu_init+0x58>)
    2bc4:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    2bc6:	2200      	movs	r2, #0
    2bc8:	4290      	cmp	r0, r2
    2bca:	f101 010c 	add.w	r1, r1, #12
    2bce:	d105      	bne.n	2bdc <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    2bd0:	4b0f      	ldr	r3, [pc, #60]	; (2c10 <z_arm_mpu_init+0x5c>)
    2bd2:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    2bd4:	f7ff ffb6 	bl	2b44 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    2bd8:	2000      	movs	r0, #0
}
    2bda:	bd10      	pop	{r4, pc}
    2bdc:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2be0:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    2be4:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    2be8:	4313      	orrs	r3, r2
    2bea:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2bee:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    2bf2:	f851 3c04 	ldr.w	r3, [r1, #-4]
    2bf6:	f043 0301 	orr.w	r3, r3, #1
    2bfa:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    2bfe:	3201      	adds	r2, #1
    2c00:	e7e2      	b.n	2bc8 <z_arm_mpu_init+0x14>
		return -1;
    2c02:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2c06:	e7e8      	b.n	2bda <z_arm_mpu_init+0x26>
    2c08:	0001047c 	.word	0x0001047c
    2c0c:	e000ed00 	.word	0xe000ed00
    2c10:	20001c1a 	.word	0x20001c1a

00002c14 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    2c14:	4b01      	ldr	r3, [pc, #4]	; (2c1c <__stdout_hook_install+0x8>)
    2c16:	6018      	str	r0, [r3, #0]
}
    2c18:	4770      	bx	lr
    2c1a:	bf00      	nop
    2c1c:	20000120 	.word	0x20000120

00002c20 <nordicsemi_nrf52_init>:
	__asm__ volatile(
    2c20:	f04f 0220 	mov.w	r2, #32
    2c24:	f3ef 8311 	mrs	r3, BASEPRI
    2c28:	f382 8812 	msr	BASEPRI_MAX, r2
    2c2c:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    2c30:	4a04      	ldr	r2, [pc, #16]	; (2c44 <nordicsemi_nrf52_init+0x24>)
    2c32:	2101      	movs	r1, #1
    2c34:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
    2c38:	f383 8811 	msr	BASEPRI, r3
    2c3c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    2c40:	2000      	movs	r0, #0
    2c42:	4770      	bx	lr
    2c44:	4001e000 	.word	0x4001e000

00002c48 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    2c48:	b120      	cbz	r0, 2c54 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    2c4a:	4b03      	ldr	r3, [pc, #12]	; (2c58 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    2c4c:	0180      	lsls	r0, r0, #6
    2c4e:	f043 0301 	orr.w	r3, r3, #1
    2c52:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    2c54:	4770      	bx	lr
    2c56:	bf00      	nop
    2c58:	000103e0 	.word	0x000103e0

00002c5c <pwr_ctrl_init>:
	const char *port;
	uint32_t pin;
};

static int pwr_ctrl_init(const struct device *dev)
{
    2c5c:	b538      	push	{r3, r4, r5, lr}
	const struct pwr_ctrl_cfg *cfg = dev->config;
    2c5e:	6844      	ldr	r4, [r0, #4]
	const struct device *gpio;

	gpio = device_get_binding(cfg->port);
    2c60:	6820      	ldr	r0, [r4, #0]
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    2c62:	f008 fd05 	bl	b670 <z_impl_device_get_binding>
	if (!gpio) {
    2c66:	b930      	cbnz	r0, 2c76 <pwr_ctrl_init+0x1a>
		printk("Could not bind device \"%s\"\n", cfg->port);
    2c68:	480d      	ldr	r0, [pc, #52]	; (2ca0 <pwr_ctrl_init+0x44>)
    2c6a:	6821      	ldr	r1, [r4, #0]
    2c6c:	f00a f8c7 	bl	cdfe <printk>
		return -ENODEV;
    2c70:	f06f 0012 	mvn.w	r0, #18
	gpio_pin_configure(gpio, cfg->pin, GPIO_OUTPUT_HIGH);

	k_sleep(K_MSEC(1)); /* Wait for the rail to come up and stabilize */

	return 0;
}
    2c74:	bd38      	pop	{r3, r4, r5, pc}
	gpio_pin_configure(gpio, cfg->pin, GPIO_OUTPUT_HIGH);
    2c76:	6861      	ldr	r1, [r4, #4]
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
    2c78:	6904      	ldr	r4, [r0, #16]
	const struct gpio_driver_api *api =
    2c7a:	6885      	ldr	r5, [r0, #8]
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    2c7c:	b2c9      	uxtb	r1, r1
    2c7e:	2301      	movs	r3, #1
    2c80:	fa03 f201 	lsl.w	r2, r3, r1
    2c84:	6823      	ldr	r3, [r4, #0]
    2c86:	ea23 0302 	bic.w	r3, r3, r2
    2c8a:	6023      	str	r3, [r4, #0]
	}

	return api->pin_configure(port, pin, flags);
    2c8c:	f44f 6220 	mov.w	r2, #2560	; 0xa00
    2c90:	682b      	ldr	r3, [r5, #0]
    2c92:	4798      	blx	r3
	return z_impl_k_sleep(timeout);
    2c94:	2021      	movs	r0, #33	; 0x21
    2c96:	2100      	movs	r1, #0
    2c98:	f009 fcfa 	bl	c690 <z_impl_k_sleep>
	return 0;
    2c9c:	2000      	movs	r0, #0
    2c9e:	e7e9      	b.n	2c74 <pwr_ctrl_init+0x18>
    2ca0:	00010d10 	.word	0x00010d10

00002ca4 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const uint8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    2ca4:	4b0e      	ldr	r3, [pc, #56]	; (2ce0 <bt_hex_real+0x3c>)
    2ca6:	2940      	cmp	r1, #64	; 0x40
{
    2ca8:	b570      	push	{r4, r5, r6, lr}
	len = MIN(len, (sizeof(str) - 1) / 2);
    2caa:	bf28      	it	cs
    2cac:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
    2cae:	4c0d      	ldr	r4, [pc, #52]	; (2ce4 <bt_hex_real+0x40>)
    2cb0:	1846      	adds	r6, r0, r1
    2cb2:	461d      	mov	r5, r3
	for (i = 0; i < len; i++) {
    2cb4:	42b0      	cmp	r0, r6
    2cb6:	f103 0302 	add.w	r3, r3, #2
    2cba:	d104      	bne.n	2cc6 <bt_hex_real+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
    2cbc:	2300      	movs	r3, #0
    2cbe:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
    2cc2:	4807      	ldr	r0, [pc, #28]	; (2ce0 <bt_hex_real+0x3c>)
    2cc4:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2]     = hex[b[i] >> 4];
    2cc6:	7802      	ldrb	r2, [r0, #0]
    2cc8:	0912      	lsrs	r2, r2, #4
    2cca:	5ca2      	ldrb	r2, [r4, r2]
    2ccc:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    2cd0:	f810 2b01 	ldrb.w	r2, [r0], #1
    2cd4:	f002 020f 	and.w	r2, r2, #15
    2cd8:	5ca2      	ldrb	r2, [r4, r2]
    2cda:	f803 2c01 	strb.w	r2, [r3, #-1]
	for (i = 0; i < len; i++) {
    2cde:	e7e9      	b.n	2cb4 <bt_hex_real+0x10>
    2ce0:	20001c39 	.word	0x20001c39
    2ce4:	00010d33 	.word	0x00010d33

00002ce8 <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    2ce8:	b530      	push	{r4, r5, lr}
	switch (addr->type) {
    2cea:	7803      	ldrb	r3, [r0, #0]
    2cec:	b08b      	sub	sp, #44	; 0x2c
    2cee:	4604      	mov	r4, r0
    2cf0:	ad07      	add	r5, sp, #28
    2cf2:	2b03      	cmp	r3, #3
    2cf4:	d821      	bhi.n	2d3a <bt_addr_le_str_real+0x52>
    2cf6:	e8df f003 	tbb	[pc, r3]
    2cfa:	1a02      	.short	0x1a02
    2cfc:	1e1c      	.short	0x1e1c
		strcpy(type, "public");
    2cfe:	4912      	ldr	r1, [pc, #72]	; (2d48 <bt_addr_le_str_real+0x60>)
		strcpy(type, "random");
    2d00:	4628      	mov	r0, r5
    2d02:	f00a fe49 	bl	d998 <strcpy>
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    2d06:	7863      	ldrb	r3, [r4, #1]
    2d08:	9304      	str	r3, [sp, #16]
    2d0a:	78a3      	ldrb	r3, [r4, #2]
    2d0c:	9303      	str	r3, [sp, #12]
    2d0e:	78e3      	ldrb	r3, [r4, #3]
    2d10:	9302      	str	r3, [sp, #8]
    2d12:	7923      	ldrb	r3, [r4, #4]
    2d14:	9301      	str	r3, [sp, #4]
    2d16:	7963      	ldrb	r3, [r4, #5]
    2d18:	9300      	str	r3, [sp, #0]
    2d1a:	4a0c      	ldr	r2, [pc, #48]	; (2d4c <bt_addr_le_str_real+0x64>)
    2d1c:	79a3      	ldrb	r3, [r4, #6]
    2d1e:	9505      	str	r5, [sp, #20]
    2d20:	211e      	movs	r1, #30
    2d22:	480b      	ldr	r0, [pc, #44]	; (2d50 <bt_addr_le_str_real+0x68>)
    2d24:	f00a f878 	bl	ce18 <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    2d28:	4809      	ldr	r0, [pc, #36]	; (2d50 <bt_addr_le_str_real+0x68>)
    2d2a:	b00b      	add	sp, #44	; 0x2c
    2d2c:	bd30      	pop	{r4, r5, pc}
		strcpy(type, "random");
    2d2e:	4909      	ldr	r1, [pc, #36]	; (2d54 <bt_addr_le_str_real+0x6c>)
    2d30:	e7e6      	b.n	2d00 <bt_addr_le_str_real+0x18>
		strcpy(type, "public-id");
    2d32:	4909      	ldr	r1, [pc, #36]	; (2d58 <bt_addr_le_str_real+0x70>)
    2d34:	e7e4      	b.n	2d00 <bt_addr_le_str_real+0x18>
		strcpy(type, "random-id");
    2d36:	4909      	ldr	r1, [pc, #36]	; (2d5c <bt_addr_le_str_real+0x74>)
    2d38:	e7e2      	b.n	2d00 <bt_addr_le_str_real+0x18>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    2d3a:	4a09      	ldr	r2, [pc, #36]	; (2d60 <bt_addr_le_str_real+0x78>)
    2d3c:	210a      	movs	r1, #10
    2d3e:	4628      	mov	r0, r5
    2d40:	f00a f86a 	bl	ce18 <snprintk>
		break;
    2d44:	e7df      	b.n	2d06 <bt_addr_le_str_real+0x1e>
    2d46:	bf00      	nop
    2d48:	00010795 	.word	0x00010795
    2d4c:	000107b7 	.word	0x000107b7
    2d50:	20001c1b 	.word	0x20001c1b
    2d54:	0001079c 	.word	0x0001079c
    2d58:	000107a3 	.word	0x000107a3
    2d5c:	000107ad 	.word	0x000107ad
    2d60:	00010fca 	.word	0x00010fca

00002d64 <bt_buf_get_rx>:
			  BT_BUF_RX_SIZE, 8,
			  NULL);
#endif /* CONFIG_BT_HCI_ACL_FLOW_CONTROL */

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
    2d64:	b538      	push	{r3, r4, r5, lr}
    2d66:	4605      	mov	r5, r0
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
    2d68:	4805      	ldr	r0, [pc, #20]	; (2d80 <bt_buf_get_rx+0x1c>)
    2d6a:	f00b fea0 	bl	eaae <net_buf_alloc_fixed>
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
    2d6e:	4604      	mov	r4, r0
    2d70:	b120      	cbz	r0, 2d7c <bt_buf_get_rx+0x18>
 * @param buf Buffer to initialize.
 * @param reserve How much headroom to reserve.
 */
static inline void net_buf_reserve(struct net_buf *buf, size_t reserve)
{
	net_buf_simple_reserve(&buf->b, reserve);
    2d72:	2100      	movs	r1, #0
    2d74:	3008      	adds	r0, #8
    2d76:	f00b feb9 	bl	eaec <net_buf_simple_reserve>
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    2d7a:	7525      	strb	r5, [r4, #20]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    2d7c:	4620      	mov	r0, r4
    2d7e:	bd38      	pop	{r3, r4, r5, pc}
    2d80:	2000061c 	.word	0x2000061c

00002d84 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
    2d84:	460b      	mov	r3, r1
	struct net_buf *buf;

	if (bt_dev.sent_cmd) {
    2d86:	490b      	ldr	r1, [pc, #44]	; (2db4 <bt_buf_get_cmd_complete+0x30>)
{
    2d88:	4602      	mov	r2, r0
	if (bt_dev.sent_cmd) {
    2d8a:	f8d1 00f8 	ldr.w	r0, [r1, #248]	; 0xf8
{
    2d8e:	b510      	push	{r4, lr}
	if (bt_dev.sent_cmd) {
    2d90:	b920      	cbnz	r0, 2d9c <bt_buf_get_cmd_complete+0x18>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
    2d92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    2d96:	2001      	movs	r0, #1
    2d98:	f7ff bfe4 	b.w	2d64 <bt_buf_get_rx>
		buf = net_buf_ref(bt_dev.sent_cmd);
    2d9c:	f00b feb7 	bl	eb0e <net_buf_ref>
    2da0:	2301      	movs	r3, #1
		buf->len = 0U;
    2da2:	2100      	movs	r1, #0
    2da4:	7503      	strb	r3, [r0, #20]
    2da6:	8181      	strh	r1, [r0, #12]
		buf = net_buf_ref(bt_dev.sent_cmd);
    2da8:	4604      	mov	r4, r0
    2daa:	3008      	adds	r0, #8
    2dac:	f00b fe9e 	bl	eaec <net_buf_simple_reserve>
}
    2db0:	4620      	mov	r0, r4
    2db2:	bd10      	pop	{r4, pc}
    2db4:	20000000 	.word	0x20000000

00002db8 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
    2db8:	b570      	push	{r4, r5, r6, lr}
    2dba:	4605      	mov	r5, r0
	switch (evt) {
    2dbc:	3d0e      	subs	r5, #14
    2dbe:	2d01      	cmp	r5, #1
{
    2dc0:	460c      	mov	r4, r1
    2dc2:	4610      	mov	r0, r2
    2dc4:	4619      	mov	r1, r3
	switch (evt) {
    2dc6:	d803      	bhi.n	2dd0 <bt_buf_get_evt+0x18>
		}
#endif /* CONFIG_BT_BUF_EVT_DISCARDABLE_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    2dc8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_cmd_complete(timeout);
    2dcc:	f7ff bfda 	b.w	2d84 <bt_buf_get_cmd_complete>
		if (discardable) {
    2dd0:	b164      	cbz	r4, 2dec <bt_buf_get_evt+0x34>
	return net_buf_alloc_fixed(pool, timeout);
    2dd2:	4809      	ldr	r0, [pc, #36]	; (2df8 <bt_buf_get_evt+0x40>)
    2dd4:	f00b fe6b 	bl	eaae <net_buf_alloc_fixed>
			if (buf) {
    2dd8:	4604      	mov	r4, r0
    2dda:	b128      	cbz	r0, 2de8 <bt_buf_get_evt+0x30>
	net_buf_simple_reserve(&buf->b, reserve);
    2ddc:	2100      	movs	r1, #0
    2dde:	3008      	adds	r0, #8
    2de0:	f00b fe84 	bl	eaec <net_buf_simple_reserve>
    2de4:	2301      	movs	r3, #1
    2de6:	7523      	strb	r3, [r4, #20]
}
    2de8:	4620      	mov	r0, r4
    2dea:	bd70      	pop	{r4, r5, r6, pc}
    2dec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    2df0:	2001      	movs	r0, #1
    2df2:	f7ff bfb7 	b.w	2d64 <bt_buf_get_rx>
    2df6:	bf00      	nop
    2df8:	200005c4 	.word	0x200005c4

00002dfc <ver_str>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
}

#if defined(CONFIG_BT_DEBUG)
static const char *ver_str(uint8_t ver)
{
    2dfc:	b570      	push	{r4, r5, r6, lr}
	const char * const str[] = {
    2dfe:	4d0b      	ldr	r5, [pc, #44]	; (2e2c <ver_str+0x30>)
{
    2e00:	4606      	mov	r6, r0
	const char * const str[] = {
    2e02:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    2e04:	b08e      	sub	sp, #56	; 0x38
	const char * const str[] = {
    2e06:	ac01      	add	r4, sp, #4
    2e08:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2e0a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2e0c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2e0e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2e10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
		"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1", "4.2",
		"5.0", "5.1", "5.2", "5.3"
	};

	if (ver < ARRAY_SIZE(str)) {
    2e12:	2e0c      	cmp	r6, #12
	const char * const str[] = {
    2e14:	682b      	ldr	r3, [r5, #0]
    2e16:	6023      	str	r3, [r4, #0]
		return str[ver];
    2e18:	bf9b      	ittet	ls
    2e1a:	ab0e      	addls	r3, sp, #56	; 0x38
    2e1c:	eb03 0686 	addls.w	r6, r3, r6, lsl #2
	}

	return "unknown";
    2e20:	4803      	ldrhi	r0, [pc, #12]	; (2e30 <ver_str+0x34>)
		return str[ver];
    2e22:	f856 0c34 	ldrls.w	r0, [r6, #-52]
}
    2e26:	b00e      	add	sp, #56	; 0x38
    2e28:	bd70      	pop	{r4, r5, r6, pc}
    2e2a:	bf00      	nop
    2e2c:	000103a4 	.word	0x000103a4
    2e30:	00010e41 	.word	0x00010e41

00002e34 <hci_hardware_error>:
{
    2e34:	b500      	push	{lr}
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
    2e36:	2101      	movs	r1, #1
    2e38:	b089      	sub	sp, #36	; 0x24
    2e3a:	3008      	adds	r0, #8
    2e3c:	f00b fe8e 	bl	eb5c <net_buf_simple_pull_mem>
	BT_ERR("Hardware error, hardware code: %d", evt->hardware_code);
    2e40:	4a07      	ldr	r2, [pc, #28]	; (2e60 <hci_hardware_error+0x2c>)
    2e42:	7803      	ldrb	r3, [r0, #0]
    2e44:	4807      	ldr	r0, [pc, #28]	; (2e64 <hci_hardware_error+0x30>)
    2e46:	e9cd 2306 	strd	r2, r3, [sp, #24]
    2e4a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    2e4e:	2303      	movs	r3, #3
    2e50:	aa05      	add	r2, sp, #20
    2e52:	9305      	str	r3, [sp, #20]
    2e54:	f00a fe4e 	bl	daf4 <z_log_msg2_static_create.constprop.0>
}
    2e58:	b009      	add	sp, #36	; 0x24
    2e5a:	f85d fb04 	ldr.w	pc, [sp], #4
    2e5e:	bf00      	nop
    2e60:	00010e49 	.word	0x00010e49
    2e64:	00010290 	.word	0x00010290

00002e68 <hci_vendor_event>:
{
    2e68:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    2e6a:	8981      	ldrh	r1, [r0, #12]
    2e6c:	6880      	ldr	r0, [r0, #8]
    2e6e:	f7ff ff19 	bl	2ca4 <bt_hex_real>
    2e72:	4b06      	ldr	r3, [pc, #24]	; (2e8c <hci_vendor_event+0x24>)
    2e74:	9301      	str	r3, [sp, #4]
    2e76:	2300      	movs	r3, #0
    2e78:	9002      	str	r0, [sp, #8]
    2e7a:	4905      	ldr	r1, [pc, #20]	; (2e90 <hci_vendor_event+0x28>)
    2e7c:	9300      	str	r3, [sp, #0]
    2e7e:	2202      	movs	r2, #2
    2e80:	4618      	mov	r0, r3
    2e82:	f00a fe3a 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
}
    2e86:	b005      	add	sp, #20
    2e88:	f85d fb04 	ldr.w	pc, [sp], #4
    2e8c:	00010e6b 	.word	0x00010e6b
    2e90:	00010290 	.word	0x00010290

00002e94 <handle_event>:
{
    2e94:	b5b0      	push	{r4, r5, r7, lr}
    2e96:	b088      	sub	sp, #32
    2e98:	4604      	mov	r4, r0
    2e9a:	af06      	add	r7, sp, #24
    2e9c:	4608      	mov	r0, r1
	for (i = 0; i < num_handlers; i++) {
    2e9e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    2ea2:	429a      	cmp	r2, r3
    2ea4:	d111      	bne.n	2eca <handle_event+0x36>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    2ea6:	8985      	ldrh	r5, [r0, #12]
    2ea8:	6880      	ldr	r0, [r0, #8]
    2eaa:	4629      	mov	r1, r5
    2eac:	f7ff fefa 	bl	2ca4 <bt_hex_real>
    2eb0:	4b16      	ldr	r3, [pc, #88]	; (2f0c <handle_event+0x78>)
    2eb2:	9301      	str	r3, [sp, #4]
    2eb4:	2300      	movs	r3, #0
    2eb6:	e9cd 5003 	strd	r5, r0, [sp, #12]
    2eba:	4915      	ldr	r1, [pc, #84]	; (2f10 <handle_event+0x7c>)
    2ebc:	9402      	str	r4, [sp, #8]
    2ebe:	9300      	str	r3, [sp, #0]
    2ec0:	2202      	movs	r2, #2
    2ec2:	4618      	mov	r0, r3
    2ec4:	f00a fe19 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
    2ec8:	e019      	b.n	2efe <handle_event+0x6a>
		const struct event_handler *handler = &handlers[i];
    2eca:	4611      	mov	r1, r2
		if (handler->event != event) {
    2ecc:	f812 5b08 	ldrb.w	r5, [r2], #8
    2ed0:	42a5      	cmp	r5, r4
    2ed2:	d1e6      	bne.n	2ea2 <handle_event+0xe>
		if (buf->len < handler->min_len) {
    2ed4:	8983      	ldrh	r3, [r0, #12]
    2ed6:	784a      	ldrb	r2, [r1, #1]
    2ed8:	429a      	cmp	r2, r3
    2eda:	d913      	bls.n	2f04 <handle_event+0x70>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    2edc:	490d      	ldr	r1, [pc, #52]	; (2f14 <handle_event+0x80>)
    2ede:	480c      	ldr	r0, [pc, #48]	; (2f10 <handle_event+0x7c>)
    2ee0:	466d      	mov	r5, sp
    2ee2:	b088      	sub	sp, #32
    2ee4:	aa06      	add	r2, sp, #24
    2ee6:	e9c2 1304 	strd	r1, r3, [r2, #16]
    2eea:	2304      	movs	r3, #4
    2eec:	6194      	str	r4, [r2, #24]
    2eee:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    2ef2:	f842 3f0c 	str.w	r3, [r2, #12]!
    2ef6:	607b      	str	r3, [r7, #4]
    2ef8:	f00a fdfc 	bl	daf4 <z_log_msg2_static_create.constprop.0>
    2efc:	46ad      	mov	sp, r5
}
    2efe:	3708      	adds	r7, #8
    2f00:	46bd      	mov	sp, r7
    2f02:	bdb0      	pop	{r4, r5, r7, pc}
		handler->handler(buf);
    2f04:	684b      	ldr	r3, [r1, #4]
    2f06:	4798      	blx	r3
		return;
    2f08:	e7f9      	b.n	2efe <handle_event+0x6a>
    2f0a:	bf00      	nop
    2f0c:	00010eb1 	.word	0x00010eb1
    2f10:	00010290 	.word	0x00010290
    2f14:	00010e8f 	.word	0x00010e8f

00002f18 <hci_le_meta_event>:
{
    2f18:	b510      	push	{r4, lr}
    2f1a:	2101      	movs	r1, #1
    2f1c:	4604      	mov	r4, r0
    2f1e:	3008      	adds	r0, #8
    2f20:	f00b fe1c 	bl	eb5c <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    2f24:	4621      	mov	r1, r4
    2f26:	4a03      	ldr	r2, [pc, #12]	; (2f34 <hci_le_meta_event+0x1c>)
    2f28:	7800      	ldrb	r0, [r0, #0]
}
    2f2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    2f2e:	2300      	movs	r3, #0
    2f30:	f7ff bfb0 	b.w	2e94 <handle_event>
    2f34:	000104c4 	.word	0x000104c4

00002f38 <hci_cmd_done>:
{
    2f38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2f3c:	b082      	sub	sp, #8
    2f3e:	4680      	mov	r8, r0
    2f40:	af00      	add	r7, sp, #0
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    2f42:	7990      	ldrb	r0, [r2, #6]
    2f44:	f8df 9150 	ldr.w	r9, [pc, #336]	; 3098 <hci_cmd_done+0x160>
{
    2f48:	460e      	mov	r6, r1
    2f4a:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    2f4c:	f005 fd3a 	bl	89c4 <net_buf_pool_get>
    2f50:	4581      	cmp	r9, r0
    2f52:	d020      	beq.n	2f96 <hci_cmd_done+0x5e>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    2f54:	79a0      	ldrb	r0, [r4, #6]
    2f56:	f005 fd35 	bl	89c4 <net_buf_pool_get>
    2f5a:	466e      	mov	r6, sp
    2f5c:	b08a      	sub	sp, #40	; 0x28
    2f5e:	466d      	mov	r5, sp
    2f60:	4b4e      	ldr	r3, [pc, #312]	; (309c <hci_cmd_done+0x164>)
    2f62:	79a0      	ldrb	r0, [r4, #6]
    2f64:	61a8      	str	r0, [r5, #24]
    2f66:	e9c5 3804 	strd	r3, r8, [r5, #16]
    2f6a:	f005 fd2b 	bl	89c4 <net_buf_pool_get>
    2f6e:	79a0      	ldrb	r0, [r4, #6]
    2f70:	f005 fd28 	bl	89c4 <net_buf_pool_get>
    2f74:	462a      	mov	r2, r5
    2f76:	2306      	movs	r3, #6
    2f78:	e9c5 0907 	strd	r0, r9, [r5, #28]
    2f7c:	f44f 5142 	mov.w	r1, #12416	; 0x3080
    2f80:	f842 3f0c 	str.w	r3, [r2, #12]!
    2f84:	4846      	ldr	r0, [pc, #280]	; (30a0 <hci_cmd_done+0x168>)
    2f86:	607b      	str	r3, [r7, #4]
    2f88:	f00a fdb4 	bl	daf4 <z_log_msg2_static_create.constprop.0>
    2f8c:	46b5      	mov	sp, r6
}
    2f8e:	3708      	adds	r7, #8
    2f90:	46bd      	mov	sp, r7
    2f92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (cmd(buf)->opcode != opcode) {
    2f96:	4620      	mov	r0, r4
    2f98:	f005 fd1c 	bl	89d4 <net_buf_id>
    2f9c:	4d41      	ldr	r5, [pc, #260]	; (30a4 <hci_cmd_done+0x16c>)
    2f9e:	f04f 0a0c 	mov.w	sl, #12
    2fa2:	fb0a 5000 	mla	r0, sl, r0, r5
    2fa6:	8843      	ldrh	r3, [r0, #2]
    2fa8:	4543      	cmp	r3, r8
    2faa:	d01e      	beq.n	2fea <hci_cmd_done+0xb2>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    2fac:	4620      	mov	r0, r4
    2fae:	f005 fd11 	bl	89d4 <net_buf_id>
    2fb2:	46e9      	mov	r9, sp
    2fb4:	4b3c      	ldr	r3, [pc, #240]	; (30a8 <hci_cmd_done+0x170>)
    2fb6:	b088      	sub	sp, #32
    2fb8:	466e      	mov	r6, sp
    2fba:	e9c6 3804 	strd	r3, r8, [r6, #16]
    2fbe:	4620      	mov	r0, r4
    2fc0:	f005 fd08 	bl	89d4 <net_buf_id>
    2fc4:	4620      	mov	r0, r4
    2fc6:	f005 fd05 	bl	89d4 <net_buf_id>
    2fca:	fb0a 5500 	mla	r5, sl, r0, r5
    2fce:	4632      	mov	r2, r6
    2fd0:	886b      	ldrh	r3, [r5, #2]
    2fd2:	61b3      	str	r3, [r6, #24]
    2fd4:	2304      	movs	r3, #4
    2fd6:	f842 3f0c 	str.w	r3, [r2, #12]!
    2fda:	4831      	ldr	r0, [pc, #196]	; (30a0 <hci_cmd_done+0x168>)
    2fdc:	607b      	str	r3, [r7, #4]
    2fde:	f44f 5102 	mov.w	r1, #8320	; 0x2080
    2fe2:	f00a fd87 	bl	daf4 <z_log_msg2_static_create.constprop.0>
    2fe6:	46cd      	mov	sp, r9
		return;
    2fe8:	e7d1      	b.n	2f8e <hci_cmd_done+0x56>
	if (bt_dev.sent_cmd) {
    2fea:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 30ac <hci_cmd_done+0x174>
    2fee:	f8d8 00f8 	ldr.w	r0, [r8, #248]	; 0xf8
    2ff2:	b120      	cbz	r0, 2ffe <hci_cmd_done+0xc6>
		net_buf_unref(bt_dev.sent_cmd);
    2ff4:	f005 fdaa 	bl	8b4c <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    2ff8:	2300      	movs	r3, #0
    2ffa:	f8c8 30f8 	str.w	r3, [r8, #248]	; 0xf8
	if (cmd(buf)->state && !status) {
    2ffe:	4620      	mov	r0, r4
    3000:	f005 fce8 	bl	89d4 <net_buf_id>
    3004:	f04f 080c 	mov.w	r8, #12
    3008:	fb08 5000 	mla	r0, r8, r0, r5
    300c:	6843      	ldr	r3, [r0, #4]
    300e:	b1eb      	cbz	r3, 304c <hci_cmd_done+0x114>
    3010:	b9e6      	cbnz	r6, 304c <hci_cmd_done+0x114>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
    3012:	4620      	mov	r0, r4
    3014:	f005 fcde 	bl	89d4 <net_buf_id>
    3018:	fb08 5000 	mla	r0, r8, r0, r5
 * @param bit Bit number (starting from 0).
 * @param val true for 1, false for 0.
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    301c:	2201      	movs	r2, #1
    301e:	6840      	ldr	r0, [r0, #4]
    3020:	e9d0 3100 	ldrd	r3, r1, [r0]

	if (val) {
    3024:	7a00      	ldrb	r0, [r0, #8]
	atomic_val_t mask = ATOMIC_MASK(bit);
    3026:	f001 0c1f 	and.w	ip, r1, #31
    302a:	fa02 f20c 	lsl.w	r2, r2, ip
	if (val) {
    302e:	0949      	lsrs	r1, r1, #5
    3030:	b328      	cbz	r0, 307e <hci_cmd_done+0x146>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    3032:	f3bf 8f5b 	dmb	ish
    3036:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    303a:	e853 1f00 	ldrex	r1, [r3]
    303e:	4311      	orrs	r1, r2
    3040:	e843 1000 	strex	r0, r1, [r3]
    3044:	2800      	cmp	r0, #0
    3046:	d1f8      	bne.n	303a <hci_cmd_done+0x102>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    3048:	f3bf 8f5b 	dmb	ish
	if (cmd(buf)->sync) {
    304c:	4620      	mov	r0, r4
    304e:	f005 fcc1 	bl	89d4 <net_buf_id>
    3052:	f04f 080c 	mov.w	r8, #12
    3056:	fb08 5000 	mla	r0, r8, r0, r5
    305a:	6883      	ldr	r3, [r0, #8]
    305c:	2b00      	cmp	r3, #0
    305e:	d096      	beq.n	2f8e <hci_cmd_done+0x56>
		cmd(buf)->status = status;
    3060:	4620      	mov	r0, r4
    3062:	f005 fcb7 	bl	89d4 <net_buf_id>
    3066:	fb08 f000 	mul.w	r0, r8, r0
    306a:	542e      	strb	r6, [r5, r0]
		k_sem_give(cmd(buf)->sync);
    306c:	4620      	mov	r0, r4
    306e:	f005 fcb1 	bl	89d4 <net_buf_id>
    3072:	fb08 5500 	mla	r5, r8, r0, r5
    3076:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
    3078:	f008 fe5e 	bl	bd38 <z_impl_k_sem_give>
}
    307c:	e787      	b.n	2f8e <hci_cmd_done+0x56>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    307e:	43d2      	mvns	r2, r2
    3080:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    3084:	f3bf 8f5b 	dmb	ish
    3088:	e853 1f00 	ldrex	r1, [r3]
    308c:	4011      	ands	r1, r2
    308e:	e843 1000 	strex	r0, r1, [r3]
    3092:	2800      	cmp	r0, #0
    3094:	d0d8      	beq.n	3048 <hci_cmd_done+0x110>
    3096:	e7f7      	b.n	3088 <hci_cmd_done+0x150>
    3098:	200005f0 	.word	0x200005f0
    309c:	00010ed3 	.word	0x00010ed3
    30a0:	00010290 	.word	0x00010290
    30a4:	20001034 	.word	0x20001034
    30a8:	00010f08 	.word	0x00010f08
    30ac:	20000000 	.word	0x20000000

000030b0 <hci_cmd_complete>:
{
    30b0:	b538      	push	{r3, r4, r5, lr}
    30b2:	2103      	movs	r1, #3
    30b4:	4604      	mov	r4, r0
    30b6:	3008      	adds	r0, #8
    30b8:	f00b fd50 	bl	eb5c <net_buf_simple_pull_mem>
	status = buf->data[0];
    30bc:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    30be:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    30c0:	7819      	ldrb	r1, [r3, #0]
    30c2:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    30c6:	4622      	mov	r2, r4
    30c8:	f7ff ff36 	bl	2f38 <hci_cmd_done>
	if (ncmd) {
    30cc:	b125      	cbz	r5, 30d8 <hci_cmd_complete+0x28>
	z_impl_k_sem_give(sem);
    30ce:	4803      	ldr	r0, [pc, #12]	; (30dc <hci_cmd_complete+0x2c>)
}
    30d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    30d4:	f008 be30 	b.w	bd38 <z_impl_k_sem_give>
    30d8:	bd38      	pop	{r3, r4, r5, pc}
    30da:	bf00      	nop
    30dc:	200000e0 	.word	0x200000e0

000030e0 <hci_cmd_status>:
{
    30e0:	b538      	push	{r3, r4, r5, lr}
    30e2:	2104      	movs	r1, #4
    30e4:	4604      	mov	r4, r0
    30e6:	3008      	adds	r0, #8
    30e8:	f00b fd38 	bl	eb5c <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    30ec:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    30ee:	7801      	ldrb	r1, [r0, #0]
    30f0:	8840      	ldrh	r0, [r0, #2]
    30f2:	4622      	mov	r2, r4
    30f4:	f7ff ff20 	bl	2f38 <hci_cmd_done>
	if (ncmd) {
    30f8:	b125      	cbz	r5, 3104 <hci_cmd_status+0x24>
    30fa:	4803      	ldr	r0, [pc, #12]	; (3108 <hci_cmd_status+0x28>)
}
    30fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    3100:	f008 be1a 	b.w	bd38 <z_impl_k_sem_give>
    3104:	bd38      	pop	{r3, r4, r5, pc}
    3106:	bf00      	nop
    3108:	200000e0 	.word	0x200000e0

0000310c <bt_hci_cmd_state_set_init>:
{
    310c:	b510      	push	{r4, lr}
	state->bit = bit;
    310e:	e9c1 2300 	strd	r2, r3, [r1]
	state->val = val;
    3112:	f89d 3008 	ldrb.w	r3, [sp, #8]
    3116:	720b      	strb	r3, [r1, #8]
{
    3118:	460c      	mov	r4, r1
	cmd(buf)->state = state;
    311a:	f005 fc5b 	bl	89d4 <net_buf_id>
    311e:	4b03      	ldr	r3, [pc, #12]	; (312c <bt_hci_cmd_state_set_init+0x20>)
    3120:	220c      	movs	r2, #12
    3122:	fb02 3300 	mla	r3, r2, r0, r3
    3126:	605c      	str	r4, [r3, #4]
}
    3128:	bd10      	pop	{r4, pc}
    312a:	bf00      	nop
    312c:	20001034 	.word	0x20001034

00003130 <bt_hci_cmd_create>:
{
    3130:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return net_buf_alloc_fixed(pool, timeout);
    3134:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3138:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    313c:	4606      	mov	r6, r0
    313e:	4817      	ldr	r0, [pc, #92]	; (319c <bt_hci_cmd_create+0x6c>)
	cmd(buf)->opcode = opcode;
    3140:	4d17      	ldr	r5, [pc, #92]	; (31a0 <bt_hci_cmd_create+0x70>)
{
    3142:	460f      	mov	r7, r1
    3144:	f00b fcb3 	bl	eaae <net_buf_alloc_fixed>
    3148:	4604      	mov	r4, r0
	net_buf_simple_reserve(&buf->b, reserve);
    314a:	f100 0a08 	add.w	sl, r0, #8
    314e:	2100      	movs	r1, #0
    3150:	f04f 0800 	mov.w	r8, #0
    3154:	4650      	mov	r0, sl
    3156:	f00b fcc9 	bl	eaec <net_buf_simple_reserve>
    315a:	f884 8014 	strb.w	r8, [r4, #20]
	cmd(buf)->opcode = opcode;
    315e:	4620      	mov	r0, r4
    3160:	f005 fc38 	bl	89d4 <net_buf_id>
    3164:	f04f 090c 	mov.w	r9, #12
    3168:	fb09 5000 	mla	r0, r9, r0, r5
    316c:	8046      	strh	r6, [r0, #2]
	cmd(buf)->sync = NULL;
    316e:	4620      	mov	r0, r4
    3170:	f005 fc30 	bl	89d4 <net_buf_id>
    3174:	fb09 5000 	mla	r0, r9, r0, r5
    3178:	f8c0 8008 	str.w	r8, [r0, #8]
	cmd(buf)->state = NULL;
    317c:	4620      	mov	r0, r4
    317e:	f005 fc29 	bl	89d4 <net_buf_id>
    3182:	fb09 5500 	mla	r5, r9, r0, r5
	return net_buf_simple_add(&buf->b, len);
    3186:	2103      	movs	r1, #3
    3188:	f8c5 8004 	str.w	r8, [r5, #4]
    318c:	4650      	mov	r0, sl
    318e:	f00b fcce 	bl	eb2e <net_buf_simple_add>
	hdr->param_len = param_len;
    3192:	7087      	strb	r7, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    3194:	8006      	strh	r6, [r0, #0]
}
    3196:	4620      	mov	r0, r4
    3198:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    319c:	200005f0 	.word	0x200005f0
    31a0:	20001034 	.word	0x20001034

000031a4 <bt_hci_cmd_send_sync>:
{
    31a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    31a8:	b089      	sub	sp, #36	; 0x24
    31aa:	4680      	mov	r8, r0
    31ac:	af00      	add	r7, sp, #0
    31ae:	4615      	mov	r5, r2
	if (!buf) {
    31b0:	460c      	mov	r4, r1
    31b2:	b921      	cbnz	r1, 31be <bt_hci_cmd_send_sync+0x1a>
		buf = bt_hci_cmd_create(opcode, 0);
    31b4:	f7ff ffbc 	bl	3130 <bt_hci_cmd_create>
		if (!buf) {
    31b8:	4604      	mov	r4, r0
    31ba:	2800      	cmp	r0, #0
    31bc:	d05e      	beq.n	327c <bt_hci_cmd_send_sync+0xd8>
	return z_impl_k_sem_init(sem, initial_count, limit);
    31be:	f107 0608 	add.w	r6, r7, #8
    31c2:	2201      	movs	r2, #1
    31c4:	2100      	movs	r1, #0
    31c6:	4630      	mov	r0, r6
    31c8:	f00c fad3 	bl	f772 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    31cc:	4620      	mov	r0, r4
    31ce:	f005 fc01 	bl	89d4 <net_buf_id>
    31d2:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 3284 <bt_hci_cmd_send_sync+0xe0>
    31d6:	230c      	movs	r3, #12
    31d8:	fb03 9000 	mla	r0, r3, r0, r9
    31dc:	6086      	str	r6, [r0, #8]
	net_buf_put(&bt_dev.cmd_tx_queue, net_buf_ref(buf));
    31de:	4620      	mov	r0, r4
    31e0:	f00b fc95 	bl	eb0e <net_buf_ref>
    31e4:	4601      	mov	r1, r0
    31e6:	4828      	ldr	r0, [pc, #160]	; (3288 <bt_hci_cmd_send_sync+0xe4>)
    31e8:	f00b fc84 	bl	eaf4 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    31ec:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    31f0:	4630      	mov	r0, r6
    31f2:	2300      	movs	r3, #0
    31f4:	f008 fdc6 	bl	bd84 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    31f8:	4606      	mov	r6, r0
    31fa:	b180      	cbz	r0, 321e <bt_hci_cmd_send_sync+0x7a>
    31fc:	4a23      	ldr	r2, [pc, #140]	; (328c <bt_hci_cmd_send_sync+0xe8>)
    31fe:	4924      	ldr	r1, [pc, #144]	; (3290 <bt_hci_cmd_send_sync+0xec>)
    3200:	4824      	ldr	r0, [pc, #144]	; (3294 <bt_hci_cmd_send_sync+0xf0>)
    3202:	f240 1331 	movw	r3, #305	; 0x131
    3206:	f009 fdfa 	bl	cdfe <printk>
    320a:	4823      	ldr	r0, [pc, #140]	; (3298 <bt_hci_cmd_send_sync+0xf4>)
    320c:	4631      	mov	r1, r6
    320e:	f009 fdf6 	bl	cdfe <printk>
    3212:	4040      	eors	r0, r0
    3214:	f380 8811 	msr	BASEPRI, r0
    3218:	f04f 0003 	mov.w	r0, #3
    321c:	df02      	svc	2
	status = cmd(buf)->status;
    321e:	4620      	mov	r0, r4
    3220:	f005 fbd8 	bl	89d4 <net_buf_id>
    3224:	230c      	movs	r3, #12
    3226:	4358      	muls	r0, r3
    3228:	f819 6000 	ldrb.w	r6, [r9, r0]
	if (status) {
    322c:	b1ee      	cbz	r6, 326a <bt_hci_cmd_send_sync+0xc6>
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
    322e:	4b1b      	ldr	r3, [pc, #108]	; (329c <bt_hci_cmd_send_sync+0xf8>)
    3230:	481b      	ldr	r0, [pc, #108]	; (32a0 <bt_hci_cmd_send_sync+0xfc>)
    3232:	466d      	mov	r5, sp
    3234:	b088      	sub	sp, #32
    3236:	466a      	mov	r2, sp
    3238:	e9c2 3804 	strd	r3, r8, [r2, #16]
    323c:	2304      	movs	r3, #4
    323e:	6196      	str	r6, [r2, #24]
    3240:	f44f 5102 	mov.w	r1, #8320	; 0x2080
    3244:	f842 3f0c 	str.w	r3, [r2, #12]!
    3248:	607b      	str	r3, [r7, #4]
    324a:	f00a fc53 	bl	daf4 <z_log_msg2_static_create.constprop.0>
		net_buf_unref(buf);
    324e:	4620      	mov	r0, r4
    3250:	46ad      	mov	sp, r5
    3252:	f005 fc7b 	bl	8b4c <net_buf_unref>
			return -EIO;
    3256:	2e09      	cmp	r6, #9
    3258:	bf0c      	ite	eq
    325a:	f06f 006e 	mvneq.w	r0, #110	; 0x6e
    325e:	f06f 0004 	mvnne.w	r0, #4
}
    3262:	3724      	adds	r7, #36	; 0x24
    3264:	46bd      	mov	sp, r7
    3266:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (rsp) {
    326a:	b115      	cbz	r5, 3272 <bt_hci_cmd_send_sync+0xce>
		*rsp = buf;
    326c:	602c      	str	r4, [r5, #0]
	return 0;
    326e:	4630      	mov	r0, r6
    3270:	e7f7      	b.n	3262 <bt_hci_cmd_send_sync+0xbe>
		net_buf_unref(buf);
    3272:	4620      	mov	r0, r4
    3274:	f005 fc6a 	bl	8b4c <net_buf_unref>
	return 0;
    3278:	4628      	mov	r0, r5
    327a:	e7f2      	b.n	3262 <bt_hci_cmd_send_sync+0xbe>
			return -ENOBUFS;
    327c:	f06f 0068 	mvn.w	r0, #104	; 0x68
    3280:	e7ef      	b.n	3262 <bt_hci_cmd_send_sync+0xbe>
    3282:	bf00      	nop
    3284:	20001034 	.word	0x20001034
    3288:	200000fc 	.word	0x200000fc
    328c:	00010f3b 	.word	0x00010f3b
    3290:	00010f6f 	.word	0x00010f6f
    3294:	00010f78 	.word	0x00010f78
    3298:	00010f95 	.word	0x00010f95
    329c:	00010fb5 	.word	0x00010fb5
    32a0:	00010290 	.word	0x00010290

000032a4 <hci_init>:
	}
}
#endif /* CONFIG_BT_HCI_VS_EXT */

static int hci_init(void)
{
    32a4:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    32a6:	4d93      	ldr	r5, [pc, #588]	; (34f4 <hci_init+0x250>)
    32a8:	f8d5 3114 	ldr.w	r3, [r5, #276]	; 0x114
    32ac:	6899      	ldr	r1, [r3, #8]
    32ae:	f011 0101 	ands.w	r1, r1, #1
{
    32b2:	b091      	sub	sp, #68	; 0x44
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    32b4:	d121      	bne.n	32fa <hci_init+0x56>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    32b6:	aa0a      	add	r2, sp, #40	; 0x28
    32b8:	f640 4003 	movw	r0, #3075	; 0xc03
    32bc:	f7ff ff72 	bl	31a4 <bt_hci_cmd_send_sync>
		if (err) {
    32c0:	4604      	mov	r4, r0
    32c2:	2800      	cmp	r0, #0
    32c4:	d174      	bne.n	33b0 <hci_init+0x10c>
	uint8_t status = buf->data[0];
    32c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    32c8:	689b      	ldr	r3, [r3, #8]
	if (status) {
    32ca:	781b      	ldrb	r3, [r3, #0]
    32cc:	b993      	cbnz	r3, 32f4 <hci_init+0x50>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    32ce:	f3bf 8f5b 	dmb	ish
    32d2:	462b      	mov	r3, r5
    32d4:	f853 2fcc 	ldr.w	r2, [r3, #204]!
    32d8:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    32dc:	f002 0205 	and.w	r2, r2, #5
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    32e0:	f3bf 8f5b 	dmb	ish
    32e4:	e853 1f00 	ldrex	r1, [r3]
    32e8:	e843 2000 	strex	r0, r2, [r3]
    32ec:	2800      	cmp	r0, #0
    32ee:	d1f9      	bne.n	32e4 <hci_init+0x40>
    32f0:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
    32f4:	980a      	ldr	r0, [sp, #40]	; 0x28
    32f6:	f005 fc29 	bl	8b4c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    32fa:	aa0a      	add	r2, sp, #40	; 0x28
    32fc:	2100      	movs	r1, #0
    32fe:	f241 0003 	movw	r0, #4099	; 0x1003
    3302:	f7ff ff4f 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3306:	4604      	mov	r4, r0
    3308:	2800      	cmp	r0, #0
    330a:	d151      	bne.n	33b0 <hci_init+0x10c>
	struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
    330c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    330e:	487a      	ldr	r0, [pc, #488]	; (34f8 <hci_init+0x254>)
    3310:	6899      	ldr	r1, [r3, #8]
    3312:	2208      	movs	r2, #8
    3314:	3101      	adds	r1, #1
    3316:	f00a fb76 	bl	da06 <memcpy>
	net_buf_unref(rsp);
    331a:	980a      	ldr	r0, [sp, #40]	; 0x28
    331c:	f005 fc16 	bl	8b4c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    3320:	4621      	mov	r1, r4
    3322:	aa0a      	add	r2, sp, #40	; 0x28
    3324:	f241 0001 	movw	r0, #4097	; 0x1001
    3328:	f7ff ff3c 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    332c:	4604      	mov	r4, r0
    332e:	2800      	cmp	r0, #0
    3330:	d13e      	bne.n	33b0 <hci_init+0x10c>
	read_local_ver_complete(rsp);
    3332:	980a      	ldr	r0, [sp, #40]	; 0x28
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
    3334:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
    3336:	785a      	ldrb	r2, [r3, #1]
    3338:	f885 2068 	strb.w	r2, [r5, #104]	; 0x68
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    333c:	78d9      	ldrb	r1, [r3, #3]
    333e:	789a      	ldrb	r2, [r3, #2]
    3340:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    3344:	f8a5 206a 	strh.w	r2, [r5, #106]	; 0x6a
	bt_dev.lmp_version = rp->lmp_version;
    3348:	791a      	ldrb	r2, [r3, #4]
    334a:	f885 2069 	strb.w	r2, [r5, #105]	; 0x69
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    334e:	7a19      	ldrb	r1, [r3, #8]
    3350:	79da      	ldrb	r2, [r3, #7]
    3352:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    3356:	f8a5 206c 	strh.w	r2, [r5, #108]	; 0x6c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    335a:	795a      	ldrb	r2, [r3, #5]
    335c:	799b      	ldrb	r3, [r3, #6]
    335e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    3362:	f8a5 306e 	strh.w	r3, [r5, #110]	; 0x6e
	net_buf_unref(rsp);
    3366:	f005 fbf1 	bl	8b4c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    336a:	4621      	mov	r1, r4
    336c:	aa0a      	add	r2, sp, #40	; 0x28
    336e:	f241 0002 	movw	r0, #4098	; 0x1002
    3372:	f7ff ff17 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3376:	4604      	mov	r4, r0
    3378:	b9d0      	cbnz	r0, 33b0 <hci_init+0x10c>
	struct bt_hci_rp_read_supported_commands *rp = (void *)buf->data;
    337a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	memcpy(bt_dev.supported_commands, rp->commands,
    337c:	485f      	ldr	r0, [pc, #380]	; (34fc <hci_init+0x258>)
    337e:	6899      	ldr	r1, [r3, #8]
    3380:	2240      	movs	r2, #64	; 0x40
    3382:	3101      	adds	r1, #1
    3384:	f00a fb3f 	bl	da06 <memcpy>
	net_buf_unref(rsp);
    3388:	980a      	ldr	r0, [sp, #40]	; 0x28
    338a:	f005 fbdf 	bl	8b4c <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
    338e:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
    3392:	0658      	lsls	r0, r3, #25
    3394:	d40f      	bmi.n	33b6 <hci_init+0x112>
		BT_ERR("Non-LE capable controller detected!");
    3396:	4b5a      	ldr	r3, [pc, #360]	; (3500 <hci_init+0x25c>)
    3398:	930e      	str	r3, [sp, #56]	; 0x38
    339a:	485a      	ldr	r0, [pc, #360]	; (3504 <hci_init+0x260>)
    339c:	2302      	movs	r3, #2
    339e:	aa0d      	add	r2, sp, #52	; 0x34
    33a0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENODEV;
    33a4:	f06f 0412 	mvn.w	r4, #18
		BT_ERR("Non-LE capable controller detected!");
    33a8:	9309      	str	r3, [sp, #36]	; 0x24
    33aa:	930d      	str	r3, [sp, #52]	; 0x34
    33ac:	f00a fba2 	bl	daf4 <z_log_msg2_static_create.constprop.0>
	if (err) {
		return err;
	}

	return 0;
}
    33b0:	4620      	mov	r0, r4
    33b2:	b011      	add	sp, #68	; 0x44
    33b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    33b6:	4621      	mov	r1, r4
    33b8:	aa0a      	add	r2, sp, #40	; 0x28
    33ba:	f242 0003 	movw	r0, #8195	; 0x2003
    33be:	f7ff fef1 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    33c2:	4604      	mov	r4, r0
    33c4:	2800      	cmp	r0, #0
    33c6:	d1f3      	bne.n	33b0 <hci_init+0x10c>
	struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
    33c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    33ca:	484f      	ldr	r0, [pc, #316]	; (3508 <hci_init+0x264>)
    33cc:	6899      	ldr	r1, [r3, #8]
    33ce:	2208      	movs	r2, #8
    33d0:	3101      	adds	r1, #1
    33d2:	f00a fb18 	bl	da06 <memcpy>
	net_buf_unref(rsp);
    33d6:	980a      	ldr	r0, [sp, #40]	; 0x28
    33d8:	f005 fbb8 	bl	8b4c <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    33dc:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
    33e0:	0699      	lsls	r1, r3, #26
    33e2:	d557      	bpl.n	3494 <hci_init+0x1f0>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    33e4:	f895 3094 	ldrb.w	r3, [r5, #148]	; 0x94
    33e8:	071a      	lsls	r2, r3, #28
    33ea:	d46e      	bmi.n	34ca <hci_init+0x226>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    33ec:	2108      	movs	r1, #8
    33ee:	f242 0001 	movw	r0, #8193	; 0x2001
    33f2:	f7ff fe9d 	bl	3130 <bt_hci_cmd_create>
	if (!buf) {
    33f6:	4604      	mov	r4, r0
    33f8:	2800      	cmp	r0, #0
    33fa:	d052      	beq.n	34a2 <hci_init+0x1fe>
    33fc:	2108      	movs	r1, #8
    33fe:	4408      	add	r0, r1
    3400:	f00b fb95 	bl	eb2e <net_buf_simple_add>
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
    3404:	2702      	movs	r7, #2
	dst[1] = val >> 8;
    3406:	2200      	movs	r2, #0
	dst[0] = val;
    3408:	7007      	strb	r7, [r0, #0]
	dst[1] = val >> 8;
    340a:	7042      	strb	r2, [r0, #1]
	dst[0] = val;
    340c:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    340e:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
    3410:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    3412:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    3414:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    3416:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    3418:	4621      	mov	r1, r4
    341a:	f242 0001 	movw	r0, #8193	; 0x2001
    341e:	f7ff fec1 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3422:	4604      	mov	r4, r0
    3424:	2800      	cmp	r0, #0
    3426:	d1c3      	bne.n	33b0 <hci_init+0x10c>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    3428:	2108      	movs	r1, #8
    342a:	f640 4001 	movw	r0, #3073	; 0xc01
    342e:	f7ff fe7f 	bl	3130 <bt_hci_cmd_create>
	if (!buf) {
    3432:	4606      	mov	r6, r0
    3434:	2800      	cmp	r0, #0
    3436:	d034      	beq.n	34a2 <hci_init+0x1fe>
    3438:	2108      	movs	r1, #8
    343a:	4408      	add	r0, r1
    343c:	f00b fb77 	bl	eb2e <net_buf_simple_add>
    3440:	2380      	movs	r3, #128	; 0x80
    3442:	7043      	strb	r3, [r0, #1]
    3444:	2320      	movs	r3, #32
	dst[0] = val;
    3446:	7004      	strb	r4, [r0, #0]
    3448:	7084      	strb	r4, [r0, #2]
    344a:	7104      	strb	r4, [r0, #4]
	dst[1] = val >> 8;
    344c:	7144      	strb	r4, [r0, #5]
	dst[0] = val;
    344e:	7184      	strb	r4, [r0, #6]
	dst[1] = val >> 8;
    3450:	70c7      	strb	r7, [r0, #3]
    3452:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    3454:	4622      	mov	r2, r4
    3456:	4631      	mov	r1, r6
    3458:	f640 4001 	movw	r0, #3073	; 0xc01
    345c:	f7ff fea2 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3460:	4604      	mov	r4, r0
    3462:	2800      	cmp	r0, #0
    3464:	d1a4      	bne.n	33b0 <hci_init+0x10c>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    3466:	4601      	mov	r1, r0
    3468:	aa08      	add	r2, sp, #32
    346a:	f64f 4001 	movw	r0, #64513	; 0xfc01
    346e:	f7ff fe99 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3472:	2800      	cmp	r0, #0
    3474:	d04c      	beq.n	3510 <hci_init+0x26c>
		BT_WARN("Vendor HCI extensions not available");
    3476:	4b25      	ldr	r3, [pc, #148]	; (350c <hci_init+0x268>)
    3478:	930e      	str	r3, [sp, #56]	; 0x38
    347a:	9709      	str	r7, [sp, #36]	; 0x24
    347c:	970d      	str	r7, [sp, #52]	; 0x34
			BT_WARN("Failed to read supported vendor features");
    347e:	4821      	ldr	r0, [pc, #132]	; (3504 <hci_init+0x260>)
    3480:	aa0d      	add	r2, sp, #52	; 0x34
    3482:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    3486:	f00a fb35 	bl	daf4 <z_log_msg2_static_create.constprop.0>
}
    348a:	b011      	add	sp, #68	; 0x44
    348c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	err = bt_id_init();
    3490:	f000 bda8 	b.w	3fe4 <bt_id_init>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    3494:	2102      	movs	r1, #2
    3496:	f640 406d 	movw	r0, #3181	; 0xc6d
    349a:	f7ff fe49 	bl	3130 <bt_hci_cmd_create>
		if (!buf) {
    349e:	4606      	mov	r6, r0
    34a0:	b910      	cbnz	r0, 34a8 <hci_init+0x204>
		return -ENOBUFS;
    34a2:	f06f 0468 	mvn.w	r4, #104	; 0x68
    34a6:	e783      	b.n	33b0 <hci_init+0x10c>
    34a8:	2102      	movs	r1, #2
    34aa:	3008      	adds	r0, #8
    34ac:	f00b fb3f 	bl	eb2e <net_buf_simple_add>
		cp_le->le = 0x01;
    34b0:	2301      	movs	r3, #1
		cp_le->simul = 0x00;
    34b2:	7044      	strb	r4, [r0, #1]
		cp_le->le = 0x01;
    34b4:	7003      	strb	r3, [r0, #0]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    34b6:	4622      	mov	r2, r4
    34b8:	4631      	mov	r1, r6
    34ba:	f640 406d 	movw	r0, #3181	; 0xc6d
    34be:	f7ff fe71 	bl	31a4 <bt_hci_cmd_send_sync>
		if (err) {
    34c2:	4604      	mov	r4, r0
    34c4:	2800      	cmp	r0, #0
    34c6:	d08d      	beq.n	33e4 <hci_init+0x140>
    34c8:	e772      	b.n	33b0 <hci_init+0x10c>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    34ca:	aa0a      	add	r2, sp, #40	; 0x28
    34cc:	2100      	movs	r1, #0
    34ce:	f242 001c 	movw	r0, #8220	; 0x201c
    34d2:	f7ff fe67 	bl	31a4 <bt_hci_cmd_send_sync>
		if (err) {
    34d6:	4604      	mov	r4, r0
    34d8:	2800      	cmp	r0, #0
    34da:	f47f af69 	bne.w	33b0 <hci_init+0x10c>
		le_read_supp_states_complete(rsp);
    34de:	980a      	ldr	r0, [sp, #40]	; 0x28
 *
 *  @return 64-bit integer in host endianness.
 */
static inline uint64_t sys_get_le64(const uint8_t src[8])
{
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    34e0:	6883      	ldr	r3, [r0, #8]
    34e2:	f8d3 2001 	ldr.w	r2, [r3, #1]
    34e6:	f8d3 3005 	ldr.w	r3, [r3, #5]
	bt_dev.le.states = sys_get_le64(rp->le_states);
    34ea:	e9c5 2336 	strd	r2, r3, [r5, #216]	; 0xd8
		net_buf_unref(rsp);
    34ee:	f005 fb2d 	bl	8b4c <net_buf_unref>
    34f2:	e77b      	b.n	33ec <hci_init+0x148>
    34f4:	20000000 	.word	0x20000000
    34f8:	20000070 	.word	0x20000070
    34fc:	20000078 	.word	0x20000078
    3500:	00010fd1 	.word	0x00010fd1
    3504:	00010290 	.word	0x00010290
    3508:	200000d0 	.word	0x200000d0
    350c:	00010ff5 	.word	0x00010ff5
	rp.info = (void *)rsp->data;
    3510:	9b08      	ldr	r3, [sp, #32]
	BT_INFO("HW Platform: %s (0x%04x)",
    3512:	493d      	ldr	r1, [pc, #244]	; (3608 <hci_init+0x364>)
	rp.info = (void *)rsp->data;
    3514:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
    3516:	f8b4 3001 	ldrh.w	r3, [r4, #1]
	if (platform < ARRAY_SIZE(plat_str)) {
    351a:	2b03      	cmp	r3, #3
		return plat_str[platform];
    351c:	bf96      	itet	ls
    351e:	4a3b      	ldrls	r2, [pc, #236]	; (360c <hci_init+0x368>)
	return "unknown";
    3520:	4a3b      	ldrhi	r2, [pc, #236]	; (3610 <hci_init+0x36c>)
		return plat_str[platform];
    3522:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
	BT_INFO("HW Platform: %s (0x%04x)",
    3526:	e9cd 2302 	strd	r2, r3, [sp, #8]
    352a:	4b3a      	ldr	r3, [pc, #232]	; (3614 <hci_init+0x370>)
    352c:	9301      	str	r3, [sp, #4]
    352e:	2300      	movs	r3, #0
    3530:	9300      	str	r3, [sp, #0]
    3532:	2203      	movs	r2, #3
    3534:	4618      	mov	r0, r3
    3536:	f00a fae0 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    353a:	f8b4 3001 	ldrh.w	r3, [r4, #1]
	BT_INFO("HW Variant: %s (0x%04x)",
    353e:	f8b4 2003 	ldrh.w	r2, [r4, #3]
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    3542:	2b02      	cmp	r3, #2
    3544:	d13b      	bne.n	35be <hci_init+0x31a>
	if (variant < ARRAY_SIZE(nordic_str)) {
    3546:	2a03      	cmp	r2, #3
    3548:	d839      	bhi.n	35be <hci_init+0x31a>
		return nordic_str[variant];
    354a:	4b33      	ldr	r3, [pc, #204]	; (3618 <hci_init+0x374>)
    354c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
	BT_INFO("HW Variant: %s (0x%04x)",
    3550:	492d      	ldr	r1, [pc, #180]	; (3608 <hci_init+0x364>)
    3552:	e9cd 3202 	strd	r3, r2, [sp, #8]
    3556:	4b31      	ldr	r3, [pc, #196]	; (361c <hci_init+0x378>)
    3558:	9301      	str	r3, [sp, #4]
    355a:	2300      	movs	r3, #0
    355c:	2203      	movs	r2, #3
    355e:	4618      	mov	r0, r3
    3560:	9300      	str	r3, [sp, #0]
    3562:	f00a faca 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    3566:	f8d4 1009 	ldr.w	r1, [r4, #9]
    356a:	7963      	ldrb	r3, [r4, #5]
    356c:	9106      	str	r1, [sp, #24]
    356e:	f8b4 1007 	ldrh.w	r1, [r4, #7]
    3572:	9105      	str	r1, [sp, #20]
	if (variant < ARRAY_SIZE(var_str)) {
    3574:	2b03      	cmp	r3, #3
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    3576:	79a1      	ldrb	r1, [r4, #6]
		return var_str[variant];
    3578:	bf96      	itet	ls
    357a:	4a29      	ldrls	r2, [pc, #164]	; (3620 <hci_init+0x37c>)
	return "unknown";
    357c:	4a24      	ldrhi	r2, [pc, #144]	; (3610 <hci_init+0x36c>)
		return var_str[variant];
    357e:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    3582:	9202      	str	r2, [sp, #8]
    3584:	2400      	movs	r4, #0
    3586:	e9cd 3103 	strd	r3, r1, [sp, #12]
    358a:	4b26      	ldr	r3, [pc, #152]	; (3624 <hci_init+0x380>)
    358c:	491e      	ldr	r1, [pc, #120]	; (3608 <hci_init+0x364>)
    358e:	9301      	str	r3, [sp, #4]
    3590:	2203      	movs	r2, #3
    3592:	4623      	mov	r3, r4
    3594:	4620      	mov	r0, r4
    3596:	9400      	str	r4, [sp, #0]
    3598:	f00a faaf 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
	net_buf_unref(rsp);
    359c:	9808      	ldr	r0, [sp, #32]
    359e:	f005 fad5 	bl	8b4c <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    35a2:	4621      	mov	r1, r4
    35a4:	aa08      	add	r2, sp, #32
    35a6:	f64f 4002 	movw	r0, #64514	; 0xfc02
    35aa:	f7ff fdfb 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    35ae:	4604      	mov	r4, r0
    35b0:	b138      	cbz	r0, 35c2 <hci_init+0x31e>
		BT_WARN("Failed to read supported vendor commands");
    35b2:	4b1d      	ldr	r3, [pc, #116]	; (3628 <hci_init+0x384>)
			BT_WARN("Failed to read supported vendor features");
    35b4:	930e      	str	r3, [sp, #56]	; 0x38
    35b6:	2302      	movs	r3, #2
    35b8:	9309      	str	r3, [sp, #36]	; 0x24
    35ba:	930d      	str	r3, [sp, #52]	; 0x34
    35bc:	e75f      	b.n	347e <hci_init+0x1da>
		return "unknown";
    35be:	4b14      	ldr	r3, [pc, #80]	; (3610 <hci_init+0x36c>)
    35c0:	e7c6      	b.n	3550 <hci_init+0x2ac>
	rp.cmds = (void *)rsp->data;
    35c2:	9b08      	ldr	r3, [sp, #32]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    35c4:	4819      	ldr	r0, [pc, #100]	; (362c <hci_init+0x388>)
    35c6:	6899      	ldr	r1, [r3, #8]
    35c8:	2202      	movs	r2, #2
    35ca:	3101      	adds	r1, #1
    35cc:	f00a fa1b 	bl	da06 <memcpy>
	net_buf_unref(rsp);
    35d0:	9808      	ldr	r0, [sp, #32]
    35d2:	f005 fabb 	bl	8b4c <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    35d6:	f895 30b9 	ldrb.w	r3, [r5, #185]	; 0xb9
    35da:	075b      	lsls	r3, r3, #29
    35dc:	f57f af55 	bpl.w	348a <hci_init+0x1e6>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    35e0:	aa08      	add	r2, sp, #32
    35e2:	4621      	mov	r1, r4
    35e4:	f64f 4003 	movw	r0, #64515	; 0xfc03
    35e8:	f7ff fddc 	bl	31a4 <bt_hci_cmd_send_sync>
		if (err) {
    35ec:	b108      	cbz	r0, 35f2 <hci_init+0x34e>
			BT_WARN("Failed to read supported vendor features");
    35ee:	4b10      	ldr	r3, [pc, #64]	; (3630 <hci_init+0x38c>)
    35f0:	e7e0      	b.n	35b4 <hci_init+0x310>
		rp.feat = (void *)rsp->data;
    35f2:	9b08      	ldr	r3, [sp, #32]
		memcpy(bt_dev.vs_features, rp.feat->features,
    35f4:	480f      	ldr	r0, [pc, #60]	; (3634 <hci_init+0x390>)
    35f6:	6899      	ldr	r1, [r3, #8]
    35f8:	2201      	movs	r2, #1
    35fa:	4411      	add	r1, r2
    35fc:	f00a fa03 	bl	da06 <memcpy>
		net_buf_unref(rsp);
    3600:	9808      	ldr	r0, [sp, #32]
    3602:	f005 faa3 	bl	8b4c <net_buf_unref>
    3606:	e740      	b.n	348a <hci_init+0x1e6>
    3608:	00010290 	.word	0x00010290
    360c:	000104fc 	.word	0x000104fc
    3610:	00010e41 	.word	0x00010e41
    3614:	00011019 	.word	0x00011019
    3618:	000104d4 	.word	0x000104d4
    361c:	00011032 	.word	0x00011032
    3620:	0001051c 	.word	0x0001051c
    3624:	0001104a 	.word	0x0001104a
    3628:	00011077 	.word	0x00011077
    362c:	200000b9 	.word	0x200000b9
    3630:	000110a0 	.word	0x000110a0
    3634:	200000b8 	.word	0x200000b8

00003638 <bt_send>:

	if (IS_ENABLED(CONFIG_BT_TINYCRYPT_ECC)) {
		return bt_hci_ecc_send(buf);
	}

	return bt_dev.drv->send(buf);
    3638:	4b02      	ldr	r3, [pc, #8]	; (3644 <bt_send+0xc>)
    363a:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
    363e:	691b      	ldr	r3, [r3, #16]
    3640:	4718      	bx	r3
    3642:	bf00      	nop
    3644:	20000000 	.word	0x20000000

00003648 <hci_tx_thread>:
{
    3648:	b5f0      	push	{r4, r5, r6, r7, lr}
    364a:	4d4d      	ldr	r5, [pc, #308]	; (3780 <hci_tx_thread+0x138>)
		events[0].state = K_POLL_STATE_NOT_READY;
    364c:	4e4d      	ldr	r6, [pc, #308]	; (3784 <hci_tx_thread+0x13c>)
{
    364e:	b089      	sub	sp, #36	; 0x24
    3650:	f105 07e0 	add.w	r7, r5, #224	; 0xe0
		events[0].state = K_POLL_STATE_NOT_READY;
    3654:	68f3      	ldr	r3, [r6, #12]
    3656:	f36f 3352 	bfc	r3, #13, #6
    365a:	60f3      	str	r3, [r6, #12]
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    365c:	4849      	ldr	r0, [pc, #292]	; (3784 <hci_tx_thread+0x13c>)
    365e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3662:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3666:	2101      	movs	r1, #1
    3668:	f009 fa92 	bl	cb90 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    366c:	b160      	cbz	r0, 3688 <hci_tx_thread+0x40>
    366e:	4a46      	ldr	r2, [pc, #280]	; (3788 <hci_tx_thread+0x140>)
    3670:	4946      	ldr	r1, [pc, #280]	; (378c <hci_tx_thread+0x144>)
    3672:	4847      	ldr	r0, [pc, #284]	; (3790 <hci_tx_thread+0x148>)
    3674:	f640 1393 	movw	r3, #2451	; 0x993
    3678:	f009 fbc1 	bl	cdfe <printk>
    367c:	4040      	eors	r0, r0
    367e:	f380 8811 	msr	BASEPRI, r0
    3682:	f04f 0003 	mov.w	r0, #3
    3686:	df02      	svc	2
		switch (ev->state) {
    3688:	68f3      	ldr	r3, [r6, #12]
    368a:	f3c3 3345 	ubfx	r3, r3, #13, #6
    368e:	2b01      	cmp	r3, #1
    3690:	d90d      	bls.n	36ae <hci_tx_thread+0x66>
    3692:	2b04      	cmp	r3, #4
    3694:	d00e      	beq.n	36b4 <hci_tx_thread+0x6c>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    3696:	4a3f      	ldr	r2, [pc, #252]	; (3794 <hci_tx_thread+0x14c>)
    3698:	483f      	ldr	r0, [pc, #252]	; (3798 <hci_tx_thread+0x150>)
		switch (ev->state) {
    369a:	e9cd 2306 	strd	r2, r3, [sp, #24]
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    369e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    36a2:	2303      	movs	r3, #3
    36a4:	aa05      	add	r2, sp, #20
    36a6:	9301      	str	r3, [sp, #4]
    36a8:	9305      	str	r3, [sp, #20]
    36aa:	f00a fa23 	bl	daf4 <z_log_msg2_static_create.constprop.0>
	z_impl_k_yield();
    36ae:	f008 ff67 	bl	c580 <z_impl_k_yield>
	while (1) {
    36b2:	e7cf      	b.n	3654 <hci_tx_thread+0xc>
			if (ev->tag == BT_EVENT_CMD_TX) {
    36b4:	7b33      	ldrb	r3, [r6, #12]
    36b6:	2b00      	cmp	r3, #0
    36b8:	d1f9      	bne.n	36ae <hci_tx_thread+0x66>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    36ba:	4838      	ldr	r0, [pc, #224]	; (379c <hci_tx_thread+0x154>)
    36bc:	2200      	movs	r2, #0
    36be:	2300      	movs	r3, #0
    36c0:	f00b f9fa 	bl	eab8 <net_buf_get>
	BT_ASSERT(buf);
    36c4:	4604      	mov	r4, r0
    36c6:	2800      	cmp	r0, #0
    36c8:	d04c      	beq.n	3764 <hci_tx_thread+0x11c>
	return z_impl_k_sem_take(sem, timeout);
    36ca:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    36ce:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    36d2:	4638      	mov	r0, r7
    36d4:	f008 fb56 	bl	bd84 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    36d8:	f8d5 30f8 	ldr.w	r3, [r5, #248]	; 0xf8
    36dc:	bb7b      	cbnz	r3, 373e <hci_tx_thread+0xf6>
	bt_dev.sent_cmd = net_buf_ref(buf);
    36de:	4620      	mov	r0, r4
    36e0:	f00b fa15 	bl	eb0e <net_buf_ref>
    36e4:	f8c5 00f8 	str.w	r0, [r5, #248]	; 0xf8
	err = bt_send(buf);
    36e8:	4620      	mov	r0, r4
    36ea:	f7ff ffa5 	bl	3638 <bt_send>
	if (err) {
    36ee:	2800      	cmp	r0, #0
    36f0:	d0dd      	beq.n	36ae <hci_tx_thread+0x66>
		BT_ERR("Unable to send to driver (err %d)", err);
    36f2:	4b2b      	ldr	r3, [pc, #172]	; (37a0 <hci_tx_thread+0x158>)
    36f4:	aa05      	add	r2, sp, #20
    36f6:	e9cd 3006 	strd	r3, r0, [sp, #24]
    36fa:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    36fe:	2303      	movs	r3, #3
    3700:	4825      	ldr	r0, [pc, #148]	; (3798 <hci_tx_thread+0x150>)
    3702:	9301      	str	r3, [sp, #4]
    3704:	9305      	str	r3, [sp, #20]
    3706:	f00a f9f5 	bl	daf4 <z_log_msg2_static_create.constprop.0>
	z_impl_k_sem_give(sem);
    370a:	4826      	ldr	r0, [pc, #152]	; (37a4 <hci_tx_thread+0x15c>)
    370c:	f008 fb14 	bl	bd38 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    3710:	4620      	mov	r0, r4
    3712:	f005 f95f 	bl	89d4 <net_buf_id>
    3716:	4b24      	ldr	r3, [pc, #144]	; (37a8 <hci_tx_thread+0x160>)
    3718:	220c      	movs	r2, #12
    371a:	fb02 3000 	mla	r0, r2, r0, r3
    371e:	211f      	movs	r1, #31
    3720:	4622      	mov	r2, r4
    3722:	8840      	ldrh	r0, [r0, #2]
    3724:	f7ff fc08 	bl	2f38 <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    3728:	f8d5 00f8 	ldr.w	r0, [r5, #248]	; 0xf8
    372c:	f005 fa0e 	bl	8b4c <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    3730:	2300      	movs	r3, #0
		net_buf_unref(buf);
    3732:	4620      	mov	r0, r4
		bt_dev.sent_cmd = NULL;
    3734:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8
		net_buf_unref(buf);
    3738:	f005 fa08 	bl	8b4c <net_buf_unref>
    373c:	e7b7      	b.n	36ae <hci_tx_thread+0x66>
		BT_ERR("Uncleared pending sent_cmd");
    373e:	4b1b      	ldr	r3, [pc, #108]	; (37ac <hci_tx_thread+0x164>)
    3740:	4815      	ldr	r0, [pc, #84]	; (3798 <hci_tx_thread+0x150>)
    3742:	9306      	str	r3, [sp, #24]
    3744:	aa05      	add	r2, sp, #20
    3746:	2302      	movs	r3, #2
    3748:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    374c:	9301      	str	r3, [sp, #4]
    374e:	9305      	str	r3, [sp, #20]
    3750:	f00a f9d0 	bl	daf4 <z_log_msg2_static_create.constprop.0>
		net_buf_unref(bt_dev.sent_cmd);
    3754:	f8d5 00f8 	ldr.w	r0, [r5, #248]	; 0xf8
    3758:	f005 f9f8 	bl	8b4c <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    375c:	2300      	movs	r3, #0
    375e:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8
    3762:	e7bc      	b.n	36de <hci_tx_thread+0x96>
	BT_ASSERT(buf);
    3764:	4a08      	ldr	r2, [pc, #32]	; (3788 <hci_tx_thread+0x140>)
    3766:	4912      	ldr	r1, [pc, #72]	; (37b0 <hci_tx_thread+0x168>)
    3768:	4809      	ldr	r0, [pc, #36]	; (3790 <hci_tx_thread+0x148>)
    376a:	f640 132a 	movw	r3, #2346	; 0x92a
    376e:	f009 fb46 	bl	cdfe <printk>
    3772:	4040      	eors	r0, r0
    3774:	f380 8811 	msr	BASEPRI, r0
    3778:	f04f 0003 	mov.w	r0, #3
    377c:	df02      	svc	2
    377e:	e7a4      	b.n	36ca <hci_tx_thread+0x82>
    3780:	20000000 	.word	0x20000000
    3784:	20000124 	.word	0x20000124
    3788:	00010f3b 	.word	0x00010f3b
    378c:	00010f6f 	.word	0x00010f6f
    3790:	00010f78 	.word	0x00010f78
    3794:	000110eb 	.word	0x000110eb
    3798:	00010290 	.word	0x00010290
    379c:	200000fc 	.word	0x200000fc
    37a0:	000110c9 	.word	0x000110c9
    37a4:	200000e0 	.word	0x200000e0
    37a8:	20001034 	.word	0x20001034
    37ac:	0001110c 	.word	0x0001110c
    37b0:	00010d4e 	.word	0x00010d4e

000037b4 <hci_event_prio>:
		      sizeof(struct bt_hci_evt_num_completed_packets)),
#endif /* CONFIG_BT_CONN_TX */
};

void hci_event_prio(struct net_buf *buf)
{
    37b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    37b8:	4604      	mov	r4, r0
	struct net_buf_simple_state state;
	struct bt_hci_evt_hdr *hdr;
	uint8_t evt_flags;

	net_buf_simple_save(&buf->b, &state);
    37ba:	f100 0608 	add.w	r6, r0, #8
	state->offset = net_buf_simple_headroom(buf);
    37be:	4630      	mov	r0, r6
    37c0:	f00b f9d4 	bl	eb6c <net_buf_simple_headroom>
	state->len = buf->len;
    37c4:	89a7      	ldrh	r7, [r4, #12]

	BT_ASSERT(buf->len >= sizeof(*hdr));
    37c6:	2f01      	cmp	r7, #1
	state->offset = net_buf_simple_headroom(buf);
    37c8:	4605      	mov	r5, r0
    37ca:	d80c      	bhi.n	37e6 <hci_event_prio+0x32>
    37cc:	4a21      	ldr	r2, [pc, #132]	; (3854 <hci_event_prio+0xa0>)
    37ce:	4922      	ldr	r1, [pc, #136]	; (3858 <hci_event_prio+0xa4>)
    37d0:	4822      	ldr	r0, [pc, #136]	; (385c <hci_event_prio+0xa8>)
    37d2:	f640 532f 	movw	r3, #3375	; 0xd2f
    37d6:	f009 fb12 	bl	cdfe <printk>
    37da:	4040      	eors	r0, r0
    37dc:	f380 8811 	msr	BASEPRI, r0
    37e0:	f04f 0003 	mov.w	r0, #3
    37e4:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
    37e6:	4630      	mov	r0, r6
    37e8:	2102      	movs	r1, #2
    37ea:	f00b f9b7 	bl	eb5c <net_buf_simple_pull_mem>

	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    37ee:	7803      	ldrb	r3, [r0, #0]
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
    37f0:	2b05      	cmp	r3, #5
    37f2:	4606      	mov	r6, r0
    37f4:	d026      	beq.n	3844 <hci_event_prio+0x90>
    37f6:	3b0e      	subs	r3, #14
#endif /* CONFIG_BT_CONN ||  CONFIG_BT_ISO */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
    37f8:	2b01      	cmp	r3, #1
    37fa:	bf94      	ite	ls
    37fc:	f04f 0801 	movls.w	r8, #1
    3800:	f04f 0802 	movhi.w	r8, #2
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    3804:	f018 0f01 	tst.w	r8, #1
    3808:	d10c      	bne.n	3824 <hci_event_prio+0x70>
    380a:	4a12      	ldr	r2, [pc, #72]	; (3854 <hci_event_prio+0xa0>)
    380c:	4914      	ldr	r1, [pc, #80]	; (3860 <hci_event_prio+0xac>)
    380e:	4813      	ldr	r0, [pc, #76]	; (385c <hci_event_prio+0xa8>)
    3810:	f640 5333 	movw	r3, #3379	; 0xd33
    3814:	f009 faf3 	bl	cdfe <printk>
    3818:	4040      	eors	r0, r0
    381a:	f380 8811 	msr	BASEPRI, r0
    381e:	f04f 0003 	mov.w	r0, #3
    3822:	df02      	svc	2

	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    3824:	4a0f      	ldr	r2, [pc, #60]	; (3864 <hci_event_prio+0xb0>)
    3826:	7830      	ldrb	r0, [r6, #0]
    3828:	2302      	movs	r3, #2
    382a:	4621      	mov	r1, r4
    382c:	f7ff fb32 	bl	2e94 <handle_event>

	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    3830:	f018 0f02 	tst.w	r8, #2
    3834:	d009      	beq.n	384a <hci_event_prio+0x96>
	buf->data = buf->__buf + state->offset;
    3836:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    3838:	81a7      	strh	r7, [r4, #12]
	buf->data = buf->__buf + state->offset;
    383a:	fa10 f585 	uxtah	r5, r0, r5
    383e:	60a5      	str	r5, [r4, #8]
		net_buf_simple_restore(&buf->b, &state);
	} else {
		net_buf_unref(buf);
	}
}
    3840:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_EVT_FLAG_RECV | BT_HCI_EVT_FLAG_RECV_PRIO;
    3844:	f04f 0803 	mov.w	r8, #3
    3848:	e7dc      	b.n	3804 <hci_event_prio+0x50>
		net_buf_unref(buf);
    384a:	4620      	mov	r0, r4
}
    384c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		net_buf_unref(buf);
    3850:	f005 b97c 	b.w	8b4c <net_buf_unref>
    3854:	00010f3b 	.word	0x00010f3b
    3858:	00011127 	.word	0x00011127
    385c:	00010f78 	.word	0x00010f78
    3860:	00011140 	.word	0x00011140
    3864:	0001050c 	.word	0x0001050c

00003868 <bt_recv>:

int bt_recv(struct net_buf *buf)
{
    3868:	b570      	push	{r4, r5, r6, lr}
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    386a:	7d05      	ldrb	r5, [r0, #20]
	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);

	BT_DBG("buf %p len %u", buf, buf->len);

	switch (bt_buf_get_type(buf)) {
    386c:	2d01      	cmp	r5, #1
{
    386e:	b088      	sub	sp, #32
    3870:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
    3872:	d139      	bne.n	38e8 <bt_recv+0x80>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    3874:	8983      	ldrh	r3, [r0, #12]
    3876:	2b01      	cmp	r3, #1
    3878:	d80c      	bhi.n	3894 <bt_recv+0x2c>
    387a:	4a24      	ldr	r2, [pc, #144]	; (390c <bt_recv+0xa4>)
    387c:	4924      	ldr	r1, [pc, #144]	; (3910 <bt_recv+0xa8>)
    387e:	4825      	ldr	r0, [pc, #148]	; (3914 <bt_recv+0xac>)
    3880:	f640 1317 	movw	r3, #2327	; 0x917
    3884:	f009 fabb 	bl	cdfe <printk>
    3888:	4040      	eors	r0, r0
    388a:	f380 8811 	msr	BASEPRI, r0
    388e:	f04f 0003 	mov.w	r0, #3
    3892:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
    3894:	2102      	movs	r1, #2
    3896:	f104 0008 	add.w	r0, r4, #8
    389a:	f00b f95f 	bl	eb5c <net_buf_simple_pull_mem>
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    389e:	7803      	ldrb	r3, [r0, #0]
	switch (evt) {
    38a0:	2b05      	cmp	r3, #5
    38a2:	4606      	mov	r6, r0
    38a4:	d01e      	beq.n	38e4 <bt_recv+0x7c>
    38a6:	3b0e      	subs	r3, #14
		return BT_HCI_EVT_FLAG_RECV;
    38a8:	2b01      	cmp	r3, #1
    38aa:	bf88      	it	hi
    38ac:	2502      	movhi	r5, #2
    38ae:	07ab      	lsls	r3, r5, #30
    38b0:	d40c      	bmi.n	38cc <bt_recv+0x64>
    38b2:	4a16      	ldr	r2, [pc, #88]	; (390c <bt_recv+0xa4>)
    38b4:	4918      	ldr	r1, [pc, #96]	; (3918 <bt_recv+0xb0>)
    38b6:	4817      	ldr	r0, [pc, #92]	; (3914 <bt_recv+0xac>)
    38b8:	f640 131b 	movw	r3, #2331	; 0x91b
    38bc:	f009 fa9f 	bl	cdfe <printk>
    38c0:	4040      	eors	r0, r0
    38c2:	f380 8811 	msr	BASEPRI, r0
    38c6:	f04f 0003 	mov.w	r0, #3
    38ca:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    38cc:	4a13      	ldr	r2, [pc, #76]	; (391c <bt_recv+0xb4>)
    38ce:	7830      	ldrb	r0, [r6, #0]
    38d0:	2303      	movs	r3, #3
    38d2:	4621      	mov	r1, r4
    38d4:	f7ff fade 	bl	2e94 <handle_event>
	net_buf_unref(buf);
    38d8:	4620      	mov	r0, r4
    38da:	f005 f937 	bl	8b4c <net_buf_unref>

		if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
			net_buf_put(&bt_dev.rx_queue, buf);
		}
#endif
		return 0;
    38de:	2000      	movs	r0, #0
	default:
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
		net_buf_unref(buf);
		return -EINVAL;
	}
}
    38e0:	b008      	add	sp, #32
    38e2:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_EVT_FLAG_RECV | BT_HCI_EVT_FLAG_RECV_PRIO;
    38e4:	2503      	movs	r5, #3
    38e6:	e7e2      	b.n	38ae <bt_recv+0x46>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    38e8:	4b0d      	ldr	r3, [pc, #52]	; (3920 <bt_recv+0xb8>)
    38ea:	480e      	ldr	r0, [pc, #56]	; (3924 <bt_recv+0xbc>)
	switch (bt_buf_get_type(buf)) {
    38ec:	e9cd 3506 	strd	r3, r5, [sp, #24]
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    38f0:	aa05      	add	r2, sp, #20
    38f2:	2303      	movs	r3, #3
    38f4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    38f8:	9301      	str	r3, [sp, #4]
    38fa:	9305      	str	r3, [sp, #20]
    38fc:	f00a f8fa 	bl	daf4 <z_log_msg2_static_create.constprop.0>
		net_buf_unref(buf);
    3900:	4620      	mov	r0, r4
    3902:	f005 f923 	bl	8b4c <net_buf_unref>
		return -EINVAL;
    3906:	f06f 0015 	mvn.w	r0, #21
    390a:	e7e9      	b.n	38e0 <bt_recv+0x78>
    390c:	00010f3b 	.word	0x00010f3b
    3910:	00011127 	.word	0x00011127
    3914:	00010f78 	.word	0x00010f78
    3918:	00011159 	.word	0x00011159
    391c:	000104e4 	.word	0x000104e4
    3920:	00011187 	.word	0x00011187
    3924:	00010290 	.word	0x00010290

00003928 <bt_recv_prio>:

#if defined(CONFIG_BT_RECV_IS_RX_THREAD)
int bt_recv_prio(struct net_buf *buf)
{
    3928:	b510      	push	{r4, lr}
	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);

	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    392a:	7d03      	ldrb	r3, [r0, #20]
    392c:	2b01      	cmp	r3, #1
{
    392e:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    3930:	d00c      	beq.n	394c <bt_recv_prio+0x24>
    3932:	4a09      	ldr	r2, [pc, #36]	; (3958 <bt_recv_prio+0x30>)
    3934:	4909      	ldr	r1, [pc, #36]	; (395c <bt_recv_prio+0x34>)
    3936:	480a      	ldr	r0, [pc, #40]	; (3960 <bt_recv_prio+0x38>)
    3938:	f640 5376 	movw	r3, #3446	; 0xd76
    393c:	f009 fa5f 	bl	cdfe <printk>
    3940:	4040      	eors	r0, r0
    3942:	f380 8811 	msr	BASEPRI, r0
    3946:	f04f 0003 	mov.w	r0, #3
    394a:	df02      	svc	2

	hci_event_prio(buf);
    394c:	4620      	mov	r0, r4
    394e:	f7ff ff31 	bl	37b4 <hci_event_prio>

	return 0;
}
    3952:	2000      	movs	r0, #0
    3954:	bd10      	pop	{r4, pc}
    3956:	bf00      	nop
    3958:	00010f3b 	.word	0x00010f3b
    395c:	0001119b 	.word	0x0001119b
    3960:	00010f78 	.word	0x00010f78

00003964 <bt_hci_driver_register>:
#endif /* defined(CONFIG_BT_RECV_IS_RX_THREAD) */

int bt_hci_driver_register(const struct bt_hci_driver *drv)
{
	if (bt_dev.drv) {
    3964:	4a08      	ldr	r2, [pc, #32]	; (3988 <bt_hci_driver_register+0x24>)
{
    3966:	4603      	mov	r3, r0
	if (bt_dev.drv) {
    3968:	f8d2 0114 	ldr.w	r0, [r2, #276]	; 0x114
    396c:	b930      	cbnz	r0, 397c <bt_hci_driver_register+0x18>
		return -EALREADY;
	}

	if (!drv->open || !drv->send) {
    396e:	68d9      	ldr	r1, [r3, #12]
    3970:	b139      	cbz	r1, 3982 <bt_hci_driver_register+0x1e>
    3972:	6919      	ldr	r1, [r3, #16]
    3974:	b129      	cbz	r1, 3982 <bt_hci_driver_register+0x1e>
		return -EINVAL;
	}

	bt_dev.drv = drv;
    3976:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
	BT_DBG("Registered %s", drv->name ? drv->name : "");

	bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
			     BT_ADDR_ANY, drv->name ? drv->name : "bt0");

	return 0;
    397a:	4770      	bx	lr
		return -EALREADY;
    397c:	f06f 0077 	mvn.w	r0, #119	; 0x77
    3980:	4770      	bx	lr
		return -EINVAL;
    3982:	f06f 0015 	mvn.w	r0, #21
}
    3986:	4770      	bx	lr
    3988:	20000000 	.word	0x20000000

0000398c <bt_finalize_init>:

void bt_finalize_init(void)
{
    398c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    3990:	4c35      	ldr	r4, [pc, #212]	; (3a68 <bt_finalize_init+0xdc>)
    3992:	f3bf 8f5b 	dmb	ish
    3996:	b087      	sub	sp, #28
    3998:	f104 03cc 	add.w	r3, r4, #204	; 0xcc
    399c:	e853 2f00 	ldrex	r2, [r3]
    39a0:	f042 0202 	orr.w	r2, r2, #2
    39a4:	e843 2100 	strex	r1, r2, [r3]
    39a8:	2900      	cmp	r1, #0
    39aa:	d1f7      	bne.n	399c <bt_finalize_init+0x10>
    39ac:	f3bf 8f5b 	dmb	ish
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    39b0:	4b2e      	ldr	r3, [pc, #184]	; (3a6c <bt_finalize_init+0xe0>)
    39b2:	79e2      	ldrb	r2, [r4, #7]
    39b4:	4d2e      	ldr	r5, [pc, #184]	; (3a70 <bt_finalize_init+0xe4>)
		BT_INFO("Identity[%d]: %s",
    39b6:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 3a74 <bt_finalize_init+0xe8>
    39ba:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 3a78 <bt_finalize_init+0xec>
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    39be:	4620      	mov	r0, r4
    39c0:	2a01      	cmp	r2, #1
    39c2:	bf98      	it	ls
    39c4:	461d      	movls	r5, r3
    39c6:	f7ff f98f 	bl	2ce8 <bt_addr_le_str_real>
    39ca:	2600      	movs	r6, #0
    39cc:	4b2b      	ldr	r3, [pc, #172]	; (3a7c <bt_finalize_init+0xf0>)
    39ce:	9301      	str	r3, [sp, #4]
    39d0:	e9cd 5002 	strd	r5, r0, [sp, #8]
    39d4:	4928      	ldr	r1, [pc, #160]	; (3a78 <bt_finalize_init+0xec>)
    39d6:	9600      	str	r6, [sp, #0]
    39d8:	4633      	mov	r3, r6
    39da:	2203      	movs	r2, #3
    39dc:	4630      	mov	r0, r6
    39de:	f00a f88c 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
	for (i = 1; i < bt_dev.id_count; i++) {
    39e2:	4627      	mov	r7, r4
    39e4:	2501      	movs	r5, #1
    39e6:	79e3      	ldrb	r3, [r4, #7]
    39e8:	429d      	cmp	r5, r3
    39ea:	f107 0707 	add.w	r7, r7, #7
    39ee:	db2c      	blt.n	3a4a <bt_finalize_init+0xbe>
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    39f0:	f894 5068 	ldrb.w	r5, [r4, #104]	; 0x68
    39f4:	4628      	mov	r0, r5
    39f6:	f7ff fa01 	bl	2dfc <ver_str>
    39fa:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
    39fe:	9305      	str	r3, [sp, #20]
    3a00:	f8b4 306a 	ldrh.w	r3, [r4, #106]	; 0x6a
    3a04:	491c      	ldr	r1, [pc, #112]	; (3a78 <bt_finalize_init+0xec>)
    3a06:	9002      	str	r0, [sp, #8]
    3a08:	e9cd 5303 	strd	r5, r3, [sp, #12]
    3a0c:	2500      	movs	r5, #0
    3a0e:	4b1c      	ldr	r3, [pc, #112]	; (3a80 <bt_finalize_init+0xf4>)
    3a10:	9301      	str	r3, [sp, #4]
    3a12:	2203      	movs	r2, #3
    3a14:	462b      	mov	r3, r5
    3a16:	4628      	mov	r0, r5
    3a18:	9500      	str	r5, [sp, #0]
    3a1a:	f00a f86e 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    3a1e:	f894 6069 	ldrb.w	r6, [r4, #105]	; 0x69
    3a22:	4630      	mov	r0, r6
    3a24:	f7ff f9ea 	bl	2dfc <ver_str>
    3a28:	f8b4 306c 	ldrh.w	r3, [r4, #108]	; 0x6c
    3a2c:	9002      	str	r0, [sp, #8]
    3a2e:	e9cd 6303 	strd	r6, r3, [sp, #12]
    3a32:	4b14      	ldr	r3, [pc, #80]	; (3a84 <bt_finalize_init+0xf8>)
    3a34:	4910      	ldr	r1, [pc, #64]	; (3a78 <bt_finalize_init+0xec>)
    3a36:	e9cd 5300 	strd	r5, r3, [sp]
    3a3a:	2203      	movs	r2, #3
    3a3c:	462b      	mov	r3, r5
    3a3e:	4628      	mov	r0, r5
    3a40:	f00a f85b 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
	if (IS_ENABLED(CONFIG_BT_OBSERVER)) {
		bt_le_scan_update(false);
	}

	bt_dev_show_info();
}
    3a44:	b007      	add	sp, #28
    3a46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_INFO("Identity[%d]: %s",
    3a4a:	4638      	mov	r0, r7
    3a4c:	f7ff f94c 	bl	2ce8 <bt_addr_le_str_real>
    3a50:	2300      	movs	r3, #0
    3a52:	e9cd 5002 	strd	r5, r0, [sp, #8]
    3a56:	e9cd 6800 	strd	r6, r8, [sp]
    3a5a:	2203      	movs	r2, #3
    3a5c:	4649      	mov	r1, r9
    3a5e:	4618      	mov	r0, r3
    3a60:	f00a f84b 	bl	dafa <z_log_msg2_runtime_create.constprop.0>
	for (i = 1; i < bt_dev.id_count; i++) {
    3a64:	3501      	adds	r5, #1
    3a66:	e7be      	b.n	39e6 <bt_finalize_init+0x5a>
    3a68:	20000000 	.word	0x20000000
    3a6c:	00010833 	.word	0x00010833
    3a70:	000111be 	.word	0x000111be
    3a74:	000111d1 	.word	0x000111d1
    3a78:	00010290 	.word	0x00010290
    3a7c:	000111c2 	.word	0x000111c2
    3a80:	000111e2 	.word	0x000111e2
    3a84:	00011220 	.word	0x00011220

00003a88 <init_work>:
	bt_finalize_init();
	return 0;
}

static void init_work(struct k_work *work)
{
    3a88:	b510      	push	{r4, lr}
	err = hci_init();
    3a8a:	f7ff fc0b 	bl	32a4 <hci_init>
	if (err) {
    3a8e:	4604      	mov	r4, r0
    3a90:	b908      	cbnz	r0, 3a96 <init_work+0xe>
	bt_finalize_init();
    3a92:	f7ff ff7b 	bl	398c <bt_finalize_init>
	int err;

	err = bt_init();
	if (ready_cb) {
    3a96:	4b04      	ldr	r3, [pc, #16]	; (3aa8 <init_work+0x20>)
    3a98:	681b      	ldr	r3, [r3, #0]
    3a9a:	b11b      	cbz	r3, 3aa4 <init_work+0x1c>
		ready_cb(err);
    3a9c:	4620      	mov	r0, r4
	}
}
    3a9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    3aa2:	4718      	bx	r3
}
    3aa4:	bd10      	pop	{r4, pc}
    3aa6:	bf00      	nop
    3aa8:	2000104c 	.word	0x2000104c

00003aac <bt_enable>:
	}
}
#endif /* !CONFIG_BT_RECV_IS_RX_THREAD */

int bt_enable(bt_ready_cb_t cb)
{
    3aac:	b570      	push	{r4, r5, r6, lr}
	int err;

	if (!bt_dev.drv) {
    3aae:	4d31      	ldr	r5, [pc, #196]	; (3b74 <bt_enable+0xc8>)
    3ab0:	f8d5 3114 	ldr.w	r3, [r5, #276]	; 0x114
{
    3ab4:	b090      	sub	sp, #64	; 0x40
    3ab6:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    3ab8:	b97b      	cbnz	r3, 3ada <bt_enable+0x2e>
		BT_ERR("No HCI driver registered");
    3aba:	4b2f      	ldr	r3, [pc, #188]	; (3b78 <bt_enable+0xcc>)
    3abc:	930e      	str	r3, [sp, #56]	; 0x38
    3abe:	482f      	ldr	r0, [pc, #188]	; (3b7c <bt_enable+0xd0>)
    3ac0:	2302      	movs	r3, #2
    3ac2:	aa0d      	add	r2, sp, #52	; 0x34
    3ac4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENODEV;
    3ac8:	f06f 0412 	mvn.w	r4, #18
		BT_ERR("No HCI driver registered");
    3acc:	9309      	str	r3, [sp, #36]	; 0x24
    3ace:	930d      	str	r3, [sp, #52]	; 0x34
    3ad0:	f00a f810 	bl	daf4 <z_log_msg2_static_create.constprop.0>
		return bt_init();
	}

	k_work_submit(&bt_dev.init);
	return 0;
}
    3ad4:	4620      	mov	r0, r4
    3ad6:	b010      	add	sp, #64	; 0x40
    3ad8:	bd70      	pop	{r4, r5, r6, pc}
    3ada:	f105 02cc 	add.w	r2, r5, #204	; 0xcc
    3ade:	f3bf 8f5b 	dmb	ish
    3ae2:	e852 3f00 	ldrex	r3, [r2]
    3ae6:	f043 0101 	orr.w	r1, r3, #1
    3aea:	e842 1000 	strex	r0, r1, [r2]
    3aee:	2800      	cmp	r0, #0
    3af0:	d1f7      	bne.n	3ae2 <bt_enable+0x36>
    3af2:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    3af6:	f013 0301 	ands.w	r3, r3, #1
    3afa:	d138      	bne.n	3b6e <bt_enable+0xc2>
	ready_cb = cb;
    3afc:	4a20      	ldr	r2, [pc, #128]	; (3b80 <bt_enable+0xd4>)
    3afe:	6016      	str	r6, [r2, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    3b00:	2000      	movs	r0, #0
    3b02:	2100      	movs	r1, #0
    3b04:	f06f 0208 	mvn.w	r2, #8
    3b08:	e9cd 0106 	strd	r0, r1, [sp, #24]
    3b0c:	e9cd 3202 	strd	r3, r2, [sp, #8]
    3b10:	e9cd 3300 	strd	r3, r3, [sp]
    3b14:	9304      	str	r3, [sp, #16]
    3b16:	491b      	ldr	r1, [pc, #108]	; (3b84 <bt_enable+0xd8>)
    3b18:	4b1b      	ldr	r3, [pc, #108]	; (3b88 <bt_enable+0xdc>)
    3b1a:	481c      	ldr	r0, [pc, #112]	; (3b8c <bt_enable+0xe0>)
    3b1c:	f44f 7220 	mov.w	r2, #640	; 0x280
    3b20:	f007 ff78 	bl	ba14 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    3b24:	491a      	ldr	r1, [pc, #104]	; (3b90 <bt_enable+0xe4>)
    3b26:	4819      	ldr	r0, [pc, #100]	; (3b8c <bt_enable+0xe0>)
    3b28:	f00b fd4c 	bl	f5c4 <z_impl_k_thread_name_set>
	err = bt_dev.drv->open();
    3b2c:	f8d5 3114 	ldr.w	r3, [r5, #276]	; 0x114
    3b30:	68db      	ldr	r3, [r3, #12]
    3b32:	4798      	blx	r3
	if (err) {
    3b34:	4604      	mov	r4, r0
    3b36:	b160      	cbz	r0, 3b52 <bt_enable+0xa6>
		BT_ERR("HCI driver open failed (%d)", err);
    3b38:	4b16      	ldr	r3, [pc, #88]	; (3b94 <bt_enable+0xe8>)
    3b3a:	aa0d      	add	r2, sp, #52	; 0x34
    3b3c:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
    3b40:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    3b44:	2303      	movs	r3, #3
    3b46:	480d      	ldr	r0, [pc, #52]	; (3b7c <bt_enable+0xd0>)
    3b48:	9309      	str	r3, [sp, #36]	; 0x24
    3b4a:	930d      	str	r3, [sp, #52]	; 0x34
    3b4c:	f009 ffd2 	bl	daf4 <z_log_msg2_static_create.constprop.0>
		return err;
    3b50:	e7c0      	b.n	3ad4 <bt_enable+0x28>
	if (!cb) {
    3b52:	b93e      	cbnz	r6, 3b64 <bt_enable+0xb8>
	err = hci_init();
    3b54:	f7ff fba6 	bl	32a4 <hci_init>
	if (err) {
    3b58:	4604      	mov	r4, r0
    3b5a:	2800      	cmp	r0, #0
    3b5c:	d1ba      	bne.n	3ad4 <bt_enable+0x28>
	bt_finalize_init();
    3b5e:	f7ff ff15 	bl	398c <bt_finalize_init>
	return 0;
    3b62:	e7b7      	b.n	3ad4 <bt_enable+0x28>
	k_work_submit(&bt_dev.init);
    3b64:	f105 00bc 	add.w	r0, r5, #188	; 0xbc
    3b68:	f008 fa1a 	bl	bfa0 <k_work_submit>
	return 0;
    3b6c:	e7b2      	b.n	3ad4 <bt_enable+0x28>
		return -EALREADY;
    3b6e:	f06f 0477 	mvn.w	r4, #119	; 0x77
    3b72:	e7af      	b.n	3ad4 <bt_enable+0x28>
    3b74:	20000000 	.word	0x20000000
    3b78:	00011247 	.word	0x00011247
    3b7c:	00010290 	.word	0x00010290
    3b80:	2000104c 	.word	0x2000104c
    3b84:	200025a0 	.word	0x200025a0
    3b88:	00003649 	.word	0x00003649
    3b8c:	20000b00 	.word	0x20000b00
    3b90:	00011260 	.word	0x00011260
    3b94:	00011266 	.word	0x00011266

00003b98 <bt_get_name>:
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	return bt_dev.name;
#else
	return CONFIG_BT_DEVICE_NAME;
#endif
}
    3b98:	4800      	ldr	r0, [pc, #0]	; (3b9c <bt_get_name+0x4>)
    3b9a:	4770      	bx	lr
    3b9c:	00010813 	.word	0x00010813

00003ba0 <id_find>:
		*count = bt_dev.id_count;
	}
}

static int id_find(const bt_addr_le_t *addr)
{
    3ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    3ba2:	4f0b      	ldr	r7, [pc, #44]	; (3bd0 <id_find+0x30>)
{
    3ba4:	4606      	mov	r6, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
    3ba6:	2500      	movs	r5, #0
    3ba8:	79fb      	ldrb	r3, [r7, #7]
    3baa:	b2ec      	uxtb	r4, r5
    3bac:	42a3      	cmp	r3, r4
    3bae:	d802      	bhi.n	3bb6 <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    3bb0:	f06f 0401 	mvn.w	r4, #1
    3bb4:	e009      	b.n	3bca <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    3bb6:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
    3bba:	2207      	movs	r2, #7
    3bbc:	4439      	add	r1, r7
    3bbe:	4630      	mov	r0, r6
    3bc0:	f009 ff10 	bl	d9e4 <memcmp>
    3bc4:	3501      	adds	r5, #1
    3bc6:	2800      	cmp	r0, #0
    3bc8:	d1ee      	bne.n	3ba8 <id_find+0x8>
}
    3bca:	4620      	mov	r0, r4
    3bcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3bce:	bf00      	nop
    3bd0:	20000000 	.word	0x20000000

00003bd4 <set_random_address>:
{
    3bd4:	b538      	push	{r3, r4, r5, lr}
	return memcmp(a, b, sizeof(*a));
    3bd6:	4914      	ldr	r1, [pc, #80]	; (3c28 <set_random_address+0x54>)
    3bd8:	2206      	movs	r2, #6
    3bda:	4605      	mov	r5, r0
    3bdc:	f009 ff02 	bl	d9e4 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    3be0:	4604      	mov	r4, r0
    3be2:	b1e0      	cbz	r0, 3c1e <set_random_address+0x4a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    3be4:	2106      	movs	r1, #6
    3be6:	f242 0005 	movw	r0, #8197	; 0x2005
    3bea:	f7ff faa1 	bl	3130 <bt_hci_cmd_create>
	if (!buf) {
    3bee:	4604      	mov	r4, r0
    3bf0:	b1b8      	cbz	r0, 3c22 <set_random_address+0x4e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    3bf2:	2206      	movs	r2, #6
    3bf4:	4629      	mov	r1, r5
    3bf6:	3008      	adds	r0, #8
    3bf8:	f00a ff9f 	bl	eb3a <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    3bfc:	4621      	mov	r1, r4
    3bfe:	2200      	movs	r2, #0
    3c00:	f242 0005 	movw	r0, #8197	; 0x2005
    3c04:	f7ff face 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3c08:	4604      	mov	r4, r0
    3c0a:	b940      	cbnz	r0, 3c1e <set_random_address+0x4a>
	memcpy(dst, src, sizeof(*dst));
    3c0c:	2206      	movs	r2, #6
    3c0e:	4806      	ldr	r0, [pc, #24]	; (3c28 <set_random_address+0x54>)
    3c10:	4629      	mov	r1, r5
    3c12:	f009 fef8 	bl	da06 <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    3c16:	4b05      	ldr	r3, [pc, #20]	; (3c2c <set_random_address+0x58>)
    3c18:	2201      	movs	r2, #1
    3c1a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
}
    3c1e:	4620      	mov	r0, r4
    3c20:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
    3c22:	f06f 0468 	mvn.w	r4, #104	; 0x68
    3c26:	e7fa      	b.n	3c1e <set_random_address+0x4a>
    3c28:	20000061 	.word	0x20000061
    3c2c:	20000000 	.word	0x20000000

00003c30 <id_create.constprop.0>:

static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
    3c30:	b530      	push	{r4, r5, lr}
    3c32:	4604      	mov	r4, r0
    3c34:	b085      	sub	sp, #20
{
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3c36:	460d      	mov	r5, r1
    3c38:	b1a1      	cbz	r1, 3c64 <id_create.constprop.0+0x34>
    3c3a:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    3c3c:	2207      	movs	r2, #7
    3c3e:	a902      	add	r1, sp, #8
    3c40:	4628      	mov	r0, r5
    3c42:	9302      	str	r3, [sp, #8]
    3c44:	f8cd 300b 	str.w	r3, [sp, #11]
    3c48:	f009 fecc 	bl	d9e4 <memcmp>
    3c4c:	b150      	cbz	r0, 3c64 <id_create.constprop.0+0x34>
	memcpy(dst, src, sizeof(*dst));
    3c4e:	4812      	ldr	r0, [pc, #72]	; (3c98 <id_create.constprop.0+0x68>)
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    3c50:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    3c54:	2207      	movs	r2, #7
    3c56:	4629      	mov	r1, r5
    3c58:	4420      	add	r0, r4
    3c5a:	f009 fed4 	bl	da06 <memcpy>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
	}

	return 0;
    3c5e:	2000      	movs	r0, #0
}
    3c60:	b005      	add	sp, #20
    3c62:	bd30      	pop	{r4, r5, pc}
			err = bt_addr_le_create_static(&new_addr);
    3c64:	4668      	mov	r0, sp
    3c66:	f009 ff37 	bl	dad8 <bt_addr_le_create_static>
			if (err) {
    3c6a:	2800      	cmp	r0, #0
    3c6c:	d1f8      	bne.n	3c60 <id_create.constprop.0+0x30>
		} while (id_find(&new_addr) >= 0);
    3c6e:	4668      	mov	r0, sp
    3c70:	f7ff ff96 	bl	3ba0 <id_find>
    3c74:	2800      	cmp	r0, #0
    3c76:	daf5      	bge.n	3c64 <id_create.constprop.0+0x34>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    3c78:	4807      	ldr	r0, [pc, #28]	; (3c98 <id_create.constprop.0+0x68>)
    3c7a:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    3c7e:	4404      	add	r4, r0
    3c80:	2207      	movs	r2, #7
    3c82:	4669      	mov	r1, sp
    3c84:	4620      	mov	r0, r4
    3c86:	f009 febe 	bl	da06 <memcpy>
		if (addr) {
    3c8a:	2d00      	cmp	r5, #0
    3c8c:	d0e7      	beq.n	3c5e <id_create.constprop.0+0x2e>
    3c8e:	2207      	movs	r2, #7
    3c90:	4621      	mov	r1, r4
    3c92:	4628      	mov	r0, r5
    3c94:	e7e1      	b.n	3c5a <id_create.constprop.0+0x2a>
    3c96:	bf00      	nop
    3c98:	20000000 	.word	0x20000000

00003c9c <bt_id_get>:
{
    3c9c:	b538      	push	{r3, r4, r5, lr}
    3c9e:	460d      	mov	r5, r1
		size_t to_copy = MIN(*count, bt_dev.id_count);
    3ca0:	4906      	ldr	r1, [pc, #24]	; (3cbc <bt_id_get+0x20>)
    3ca2:	79cc      	ldrb	r4, [r1, #7]
	if (addrs) {
    3ca4:	b138      	cbz	r0, 3cb6 <bt_id_get+0x1a>
		size_t to_copy = MIN(*count, bt_dev.id_count);
    3ca6:	682b      	ldr	r3, [r5, #0]
    3ca8:	429c      	cmp	r4, r3
    3caa:	bf28      	it	cs
    3cac:	461c      	movcs	r4, r3
		memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
    3cae:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
    3cb2:	f009 fea8 	bl	da06 <memcpy>
		*count = bt_dev.id_count;
    3cb6:	602c      	str	r4, [r5, #0]
}
    3cb8:	bd38      	pop	{r3, r4, r5, pc}
    3cba:	bf00      	nop
    3cbc:	20000000 	.word	0x20000000

00003cc0 <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
{
    3cc0:	b570      	push	{r4, r5, r6, lr}
    3cc2:	460c      	mov	r4, r1
    3cc4:	b08a      	sub	sp, #40	; 0x28
	int new_id, err;

	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3cc6:	4605      	mov	r5, r0
    3cc8:	b918      	cbnz	r0, 3cd2 <bt_id_create+0x12>
		if (id_find(addr) >= 0) {
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    3cca:	b354      	cbz	r4, 3d22 <bt_id_create+0x62>
		return -EINVAL;
    3ccc:	f06f 0015 	mvn.w	r0, #21
    3cd0:	e025      	b.n	3d1e <bt_id_create+0x5e>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3cd2:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    3cd4:	2207      	movs	r2, #7
    3cd6:	a902      	add	r1, sp, #8
    3cd8:	9302      	str	r3, [sp, #8]
    3cda:	f8cd 300b 	str.w	r3, [sp, #11]
    3cde:	f009 fe81 	bl	d9e4 <memcmp>
    3ce2:	2800      	cmp	r0, #0
    3ce4:	d0f1      	beq.n	3cca <bt_id_create+0xa>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    3ce6:	782b      	ldrb	r3, [r5, #0]
    3ce8:	2b01      	cmp	r3, #1
    3cea:	d104      	bne.n	3cf6 <bt_id_create+0x36>
    3cec:	79ab      	ldrb	r3, [r5, #6]
    3cee:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    3cf2:	2bc0      	cmp	r3, #192	; 0xc0
    3cf4:	d00c      	beq.n	3d10 <bt_id_create+0x50>
			BT_ERR("Only static random identity address supported");
    3cf6:	4b1e      	ldr	r3, [pc, #120]	; (3d70 <bt_id_create+0xb0>)
    3cf8:	9308      	str	r3, [sp, #32]
    3cfa:	2302      	movs	r3, #2
    3cfc:	9301      	str	r3, [sp, #4]
    3cfe:	9307      	str	r3, [sp, #28]
    3d00:	481c      	ldr	r0, [pc, #112]	; (3d74 <bt_id_create+0xb4>)
    3d02:	2300      	movs	r3, #0
    3d04:	aa07      	add	r2, sp, #28
    3d06:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    3d0a:	f009 fe13 	bl	d934 <z_impl_z_log_msg2_static_create>
			return -EINVAL;
    3d0e:	e7dd      	b.n	3ccc <bt_id_create+0xc>
		if (id_find(addr) >= 0) {
    3d10:	4628      	mov	r0, r5
    3d12:	f7ff ff45 	bl	3ba0 <id_find>
    3d16:	2800      	cmp	r0, #0
    3d18:	dbd7      	blt.n	3cca <bt_id_create+0xa>
			return -EALREADY;
    3d1a:	f06f 0077 	mvn.w	r0, #119	; 0x77
	if (err) {
		return err;
	}

	return new_id;
}
    3d1e:	b00a      	add	sp, #40	; 0x28
    3d20:	bd70      	pop	{r4, r5, r6, pc}
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    3d22:	4e15      	ldr	r6, [pc, #84]	; (3d78 <bt_id_create+0xb8>)
    3d24:	79f3      	ldrb	r3, [r6, #7]
    3d26:	2b01      	cmp	r3, #1
    3d28:	d01e      	beq.n	3d68 <bt_id_create+0xa8>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    3d2a:	f3bf 8f5b 	dmb	ish
    3d2e:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    3d32:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    3d36:	07db      	lsls	r3, r3, #31
    3d38:	d40b      	bmi.n	3d52 <bt_id_create+0x92>
		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
    3d3a:	2d00      	cmp	r5, #0
    3d3c:	d0c6      	beq.n	3ccc <bt_id_create+0xc>
    3d3e:	2207      	movs	r2, #7
    3d40:	a904      	add	r1, sp, #16
    3d42:	4628      	mov	r0, r5
    3d44:	9404      	str	r4, [sp, #16]
    3d46:	f8cd 4013 	str.w	r4, [sp, #19]
    3d4a:	f009 fe4b 	bl	d9e4 <memcmp>
    3d4e:	2800      	cmp	r0, #0
    3d50:	d0bc      	beq.n	3ccc <bt_id_create+0xc>
	new_id = bt_dev.id_count++;
    3d52:	79f4      	ldrb	r4, [r6, #7]
	err = id_create(new_id, addr, irk);
    3d54:	4629      	mov	r1, r5
	new_id = bt_dev.id_count++;
    3d56:	1c63      	adds	r3, r4, #1
	err = id_create(new_id, addr, irk);
    3d58:	4620      	mov	r0, r4
	new_id = bt_dev.id_count++;
    3d5a:	71f3      	strb	r3, [r6, #7]
	err = id_create(new_id, addr, irk);
    3d5c:	f7ff ff68 	bl	3c30 <id_create.constprop.0>
	new_id = bt_dev.id_count++;
    3d60:	2800      	cmp	r0, #0
    3d62:	bf08      	it	eq
    3d64:	4620      	moveq	r0, r4
    3d66:	e7da      	b.n	3d1e <bt_id_create+0x5e>
		return -ENOMEM;
    3d68:	f06f 000b 	mvn.w	r0, #11
    3d6c:	e7d7      	b.n	3d1e <bt_id_create+0x5e>
    3d6e:	bf00      	nop
    3d70:	00011282 	.word	0x00011282
    3d74:	00010298 	.word	0x00010298
    3d78:	20000000 	.word	0x20000000

00003d7c <bt_id_read_public_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
{
    3d7c:	b570      	push	{r4, r5, r6, lr}
    3d7e:	b08a      	sub	sp, #40	; 0x28
    3d80:	4606      	mov	r6, r0
	struct bt_hci_rp_read_bd_addr *rp;
	struct net_buf *rsp;
	int err;

	/* Read Bluetooth Address */
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    3d82:	aa01      	add	r2, sp, #4
    3d84:	2100      	movs	r1, #0
    3d86:	f241 0009 	movw	r0, #4105	; 0x1009
    3d8a:	f7ff fa0b 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3d8e:	4604      	mov	r4, r0
    3d90:	b170      	cbz	r0, 3db0 <bt_id_read_public_addr+0x34>
		BT_WARN("Failed to read public address");
    3d92:	4b1f      	ldr	r3, [pc, #124]	; (3e10 <bt_id_read_public_addr+0x94>)
    3d94:	9308      	str	r3, [sp, #32]
    3d96:	2302      	movs	r3, #2
    3d98:	9302      	str	r3, [sp, #8]
    3d9a:	9307      	str	r3, [sp, #28]
    3d9c:	481d      	ldr	r0, [pc, #116]	; (3e14 <bt_id_read_public_addr+0x98>)
    3d9e:	2300      	movs	r3, #0
    3da0:	aa07      	add	r2, sp, #28
    3da2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    3da6:	f009 fdc5 	bl	d934 <z_impl_z_log_msg2_static_create>

	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
		BT_DBG("Controller has no public address");
		net_buf_unref(rsp);
		return 0U;
    3daa:	2000      	movs	r0, #0
	bt_addr_copy(&addr->a, &rp->bdaddr);
	addr->type = BT_ADDR_LE_PUBLIC;

	net_buf_unref(rsp);
	return 1U;
}
    3dac:	b00a      	add	sp, #40	; 0x28
    3dae:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
    3db0:	9b01      	ldr	r3, [sp, #4]
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    3db2:	689d      	ldr	r5, [r3, #8]
    3db4:	9002      	str	r0, [sp, #8]
    3db6:	3501      	adds	r5, #1
    3db8:	f8ad 000c 	strh.w	r0, [sp, #12]
	return memcmp(a, b, sizeof(*a));
    3dbc:	2206      	movs	r2, #6
    3dbe:	a902      	add	r1, sp, #8
    3dc0:	4628      	mov	r0, r5
    3dc2:	f009 fe0f 	bl	d9e4 <memcmp>
    3dc6:	b918      	cbnz	r0, 3dd0 <bt_id_read_public_addr+0x54>
		net_buf_unref(rsp);
    3dc8:	9801      	ldr	r0, [sp, #4]
    3dca:	f004 febf 	bl	8b4c <net_buf_unref>
    3dce:	e7ec      	b.n	3daa <bt_id_read_public_addr+0x2e>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    3dd0:	23ff      	movs	r3, #255	; 0xff
    3dd2:	2206      	movs	r2, #6
    3dd4:	a904      	add	r1, sp, #16
    3dd6:	4628      	mov	r0, r5
    3dd8:	f88d 3010 	strb.w	r3, [sp, #16]
    3ddc:	f88d 3011 	strb.w	r3, [sp, #17]
    3de0:	f88d 3012 	strb.w	r3, [sp, #18]
    3de4:	f88d 3013 	strb.w	r3, [sp, #19]
    3de8:	f88d 3014 	strb.w	r3, [sp, #20]
    3dec:	f88d 3015 	strb.w	r3, [sp, #21]
    3df0:	f009 fdf8 	bl	d9e4 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    3df4:	2800      	cmp	r0, #0
    3df6:	d0e7      	beq.n	3dc8 <bt_id_read_public_addr+0x4c>
	memcpy(dst, src, sizeof(*dst));
    3df8:	2206      	movs	r2, #6
    3dfa:	4629      	mov	r1, r5
    3dfc:	1c70      	adds	r0, r6, #1
    3dfe:	f009 fe02 	bl	da06 <memcpy>
	net_buf_unref(rsp);
    3e02:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
    3e04:	7034      	strb	r4, [r6, #0]
	net_buf_unref(rsp);
    3e06:	f004 fea1 	bl	8b4c <net_buf_unref>
	return 1U;
    3e0a:	2001      	movs	r0, #1
    3e0c:	e7ce      	b.n	3dac <bt_id_read_public_addr+0x30>
    3e0e:	bf00      	nop
    3e10:	000112b0 	.word	0x000112b0
    3e14:	00010298 	.word	0x00010298

00003e18 <bt_setup_public_id_addr>:

int bt_setup_public_id_addr(void)
{
    3e18:	b507      	push	{r0, r1, r2, lr}
	bt_addr_le_t addr;
	uint8_t *irk = NULL;

	bt_dev.id_count = bt_id_read_public_addr(&addr);
    3e1a:	4668      	mov	r0, sp
    3e1c:	f7ff ffae 	bl	3d7c <bt_id_read_public_addr>
    3e20:	4b04      	ldr	r3, [pc, #16]	; (3e34 <bt_setup_public_id_addr+0x1c>)
    3e22:	71d8      	strb	r0, [r3, #7]

	if (!bt_dev.id_count) {
    3e24:	b118      	cbz	r0, 3e2e <bt_setup_public_id_addr+0x16>
	} else if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}
#endif /* defined(CONFIG_BT_PRIVACY) */

	return id_create(BT_ID_DEFAULT, &addr, irk);
    3e26:	4669      	mov	r1, sp
    3e28:	2000      	movs	r0, #0
    3e2a:	f7ff ff01 	bl	3c30 <id_create.constprop.0>
}
    3e2e:	b003      	add	sp, #12
    3e30:	f85d fb04 	ldr.w	pc, [sp], #4
    3e34:	20000000 	.word	0x20000000

00003e38 <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
uint8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t size)
{
    3e38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	uint8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    3e3c:	4b24      	ldr	r3, [pc, #144]	; (3ed0 <bt_read_static_addr+0x98>)
    3e3e:	f893 40ba 	ldrb.w	r4, [r3, #186]	; 0xba
    3e42:	f014 0401 	ands.w	r4, r4, #1
{
    3e46:	b088      	sub	sp, #32
    3e48:	4607      	mov	r7, r0
    3e4a:	460e      	mov	r6, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    3e4c:	d10c      	bne.n	3e68 <bt_read_static_addr+0x30>
		BT_WARN("Read Static Addresses command not available");
    3e4e:	4b21      	ldr	r3, [pc, #132]	; (3ed4 <bt_read_static_addr+0x9c>)
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
	}

	net_buf_unref(rsp);
	if (!cnt) {
		BT_WARN("No static addresses stored in controller");
    3e50:	9306      	str	r3, [sp, #24]
    3e52:	2302      	movs	r3, #2
    3e54:	9301      	str	r3, [sp, #4]
    3e56:	9305      	str	r3, [sp, #20]
    3e58:	481f      	ldr	r0, [pc, #124]	; (3ed8 <bt_read_static_addr+0xa0>)
    3e5a:	4623      	mov	r3, r4
    3e5c:	aa05      	add	r2, sp, #20
    3e5e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    3e62:	f009 fd67 	bl	d934 <z_impl_z_log_msg2_static_create>
    3e66:	e014      	b.n	3e92 <bt_read_static_addr+0x5a>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    3e68:	466a      	mov	r2, sp
    3e6a:	2100      	movs	r1, #0
    3e6c:	f64f 4009 	movw	r0, #64521	; 0xfc09
    3e70:	f7ff f998 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    3e74:	4605      	mov	r5, r0
    3e76:	b180      	cbz	r0, 3e9a <bt_read_static_addr+0x62>
		BT_WARN("Failed to read static addresses");
    3e78:	4b18      	ldr	r3, [pc, #96]	; (3edc <bt_read_static_addr+0xa4>)
    3e7a:	9306      	str	r3, [sp, #24]
    3e7c:	2302      	movs	r3, #2
    3e7e:	9301      	str	r3, [sp, #4]
    3e80:	9305      	str	r3, [sp, #20]
    3e82:	4815      	ldr	r0, [pc, #84]	; (3ed8 <bt_read_static_addr+0xa0>)
    3e84:	2300      	movs	r3, #0
    3e86:	aa05      	add	r2, sp, #20
    3e88:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		return 0;
    3e8c:	2400      	movs	r4, #0
    3e8e:	f009 fd51 	bl	d934 <z_impl_z_log_msg2_static_create>
	}

	return cnt;
}
    3e92:	4620      	mov	r0, r4
    3e94:	b008      	add	sp, #32
    3e96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	rp = (void *)rsp->data;
    3e9a:	9b00      	ldr	r3, [sp, #0]
    3e9c:	689b      	ldr	r3, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
    3e9e:	785c      	ldrb	r4, [r3, #1]
    3ea0:	42b4      	cmp	r4, r6
    3ea2:	bf28      	it	cs
    3ea4:	4634      	movcs	r4, r6
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    3ea6:	f04f 0816 	mov.w	r8, #22
    3eaa:	1c9e      	adds	r6, r3, #2
	for (i = 0; i < cnt; i++) {
    3eac:	42ac      	cmp	r4, r5
    3eae:	dc06      	bgt.n	3ebe <bt_read_static_addr+0x86>
	net_buf_unref(rsp);
    3eb0:	9800      	ldr	r0, [sp, #0]
    3eb2:	f004 fe4b 	bl	8b4c <net_buf_unref>
	if (!cnt) {
    3eb6:	2c00      	cmp	r4, #0
    3eb8:	d1eb      	bne.n	3e92 <bt_read_static_addr+0x5a>
		BT_WARN("No static addresses stored in controller");
    3eba:	4b09      	ldr	r3, [pc, #36]	; (3ee0 <bt_read_static_addr+0xa8>)
    3ebc:	e7c8      	b.n	3e50 <bt_read_static_addr+0x18>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    3ebe:	fb08 7005 	mla	r0, r8, r5, r7
    3ec2:	2216      	movs	r2, #22
    3ec4:	4631      	mov	r1, r6
    3ec6:	f009 fd9e 	bl	da06 <memcpy>
	for (i = 0; i < cnt; i++) {
    3eca:	3501      	adds	r5, #1
    3ecc:	e7ee      	b.n	3eac <bt_read_static_addr+0x74>
    3ece:	bf00      	nop
    3ed0:	20000000 	.word	0x20000000
    3ed4:	000112ce 	.word	0x000112ce
    3ed8:	00010298 	.word	0x00010298
    3edc:	000112fa 	.word	0x000112fa
    3ee0:	0001131a 	.word	0x0001131a

00003ee4 <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
    3ee4:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
    3ee6:	4e15      	ldr	r6, [pc, #84]	; (3f3c <bt_setup_random_id_addr+0x58>)
    3ee8:	79f4      	ldrb	r4, [r6, #7]
{
    3eea:	b089      	sub	sp, #36	; 0x24
	if (!bt_dev.id_count) {
    3eec:	b9f4      	cbnz	r4, 3f2c <bt_setup_random_id_addr+0x48>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    3eee:	2101      	movs	r1, #1
    3ef0:	a802      	add	r0, sp, #8
    3ef2:	f7ff ffa1 	bl	3e38 <bt_read_static_addr>
    3ef6:	71f0      	strb	r0, [r6, #7]

		if (bt_dev.id_count) {
    3ef8:	b1c0      	cbz	r0, 3f2c <bt_setup_random_id_addr+0x48>
					atomic_set_bit(bt_dev.flags,
						       BT_DEV_STORE_ID);
				}
#endif /* CONFIG_BT_PRIVACY */

				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    3efa:	2716      	movs	r7, #22
    3efc:	ab02      	add	r3, sp, #8
    3efe:	b2e5      	uxtb	r5, r4
    3f00:	fb07 3105 	mla	r1, r7, r5, r3
    3f04:	2206      	movs	r2, #6
    3f06:	f10d 0001 	add.w	r0, sp, #1
    3f0a:	f009 fd7c 	bl	da06 <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
    3f0e:	2301      	movs	r3, #1

				err = id_create(i, &addr, irk);
    3f10:	4669      	mov	r1, sp
    3f12:	4628      	mov	r0, r5
				addr.type = BT_ADDR_LE_RANDOM;
    3f14:	f88d 3000 	strb.w	r3, [sp]
				err = id_create(i, &addr, irk);
    3f18:	f7ff fe8a 	bl	3c30 <id_create.constprop.0>
				if (err) {
    3f1c:	b920      	cbnz	r0, 3f28 <bt_setup_random_id_addr+0x44>
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
    3f1e:	79f2      	ldrb	r2, [r6, #7]
    3f20:	3401      	adds	r4, #1
    3f22:	b2e3      	uxtb	r3, r4
    3f24:	429a      	cmp	r2, r3
    3f26:	d8e9      	bhi.n	3efc <bt_setup_random_id_addr+0x18>
	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
}
    3f28:	b009      	add	sp, #36	; 0x24
    3f2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return bt_id_create(NULL, NULL);
    3f2c:	2100      	movs	r1, #0
    3f2e:	4608      	mov	r0, r1
}
    3f30:	b009      	add	sp, #36	; 0x24
    3f32:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	return bt_id_create(NULL, NULL);
    3f36:	f7ff bec3 	b.w	3cc0 <bt_id_create>
    3f3a:	bf00      	nop
    3f3c:	20000000 	.word	0x20000000

00003f40 <bt_id_set_adv_own_addr>:
}
#endif /* defined(CONFIG_BT_OBSERVER) */

int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
			   bool dir_adv, uint8_t *own_addr_type)
{
    3f40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    3f44:	f011 0401 	ands.w	r4, r1, #1
	id_addr = &bt_dev.id_addr[adv->id];
    3f48:	7805      	ldrb	r5, [r0, #0]
{
    3f4a:	460e      	mov	r6, r1
    3f4c:	4690      	mov	r8, r2
    3f4e:	461f      	mov	r7, r3
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    3f50:	d026      	beq.n	3fa0 <bt_id_set_adv_own_addr+0x60>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    3f52:	4c23      	ldr	r4, [pc, #140]	; (3fe0 <bt_id_set_adv_own_addr+0xa0>)
    3f54:	b12a      	cbz	r2, 3f62 <bt_id_set_adv_own_addr+0x22>
    3f56:	0688      	lsls	r0, r1, #26
    3f58:	d503      	bpl.n	3f62 <bt_id_set_adv_own_addr+0x22>
    3f5a:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
    3f5e:	0659      	lsls	r1, r3, #25
    3f60:	d53a      	bpl.n	3fd8 <bt_id_set_adv_own_addr+0x98>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    3f62:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    3f66:	ea4f 09c5 	mov.w	r9, r5, lsl #3
    3f6a:	5ce3      	ldrb	r3, [r4, r3]
    3f6c:	2b01      	cmp	r3, #1
    3f6e:	d008      	beq.n	3f82 <bt_id_set_adv_own_addr+0x42>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
    3f70:	eba9 0505 	sub.w	r5, r9, r5
    3f74:	5d63      	ldrb	r3, [r4, r5]

			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    3f76:	f1b8 0f00 	cmp.w	r8, #0
    3f7a:	d10c      	bne.n	3f96 <bt_id_set_adv_own_addr+0x56>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    3f7c:	703b      	strb	r3, [r7, #0]
		if (err) {
			return err;
		}
	}

	return 0;
    3f7e:	2000      	movs	r0, #0
    3f80:	e007      	b.n	3f92 <bt_id_set_adv_own_addr+0x52>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    3f82:	2007      	movs	r0, #7
    3f84:	fb10 3005 	smlabb	r0, r0, r5, r3
		return set_random_address(addr);
    3f88:	4420      	add	r0, r4
    3f8a:	f7ff fe23 	bl	3bd4 <set_random_address>
				if (err) {
    3f8e:	2800      	cmp	r0, #0
    3f90:	d0ee      	beq.n	3f70 <bt_id_set_adv_own_addr+0x30>
}
    3f92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    3f96:	06b2      	lsls	r2, r6, #26
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    3f98:	bf48      	it	mi
    3f9a:	f043 0302 	orrmi.w	r3, r3, #2
    3f9e:	e7ed      	b.n	3f7c <bt_id_set_adv_own_addr+0x3c>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    3fa0:	074b      	lsls	r3, r1, #29
    3fa2:	d515      	bpl.n	3fd0 <bt_id_set_adv_own_addr+0x90>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    3fa4:	f8df 8038 	ldr.w	r8, [pc, #56]	; 3fe0 <bt_id_set_adv_own_addr+0xa0>
    3fa8:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    3fac:	00ee      	lsls	r6, r5, #3
    3fae:	f818 3003 	ldrb.w	r3, [r8, r3]
    3fb2:	2b01      	cmp	r3, #1
    3fb4:	d10a      	bne.n	3fcc <bt_id_set_adv_own_addr+0x8c>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    3fb6:	2007      	movs	r0, #7
    3fb8:	fb10 3005 	smlabb	r0, r0, r5, r3
		return set_random_address(addr);
    3fbc:	4440      	add	r0, r8
    3fbe:	f7ff fe09 	bl	3bd4 <set_random_address>
			*own_addr_type = id_addr->type;
    3fc2:	1b75      	subs	r5, r6, r5
    3fc4:	f818 3005 	ldrb.w	r3, [r8, r5]
			*own_addr_type = BT_ADDR_LE_RANDOM;
    3fc8:	703b      	strb	r3, [r7, #0]
		if (err) {
    3fca:	e7e2      	b.n	3f92 <bt_id_set_adv_own_addr+0x52>
	int err = 0;
    3fcc:	4620      	mov	r0, r4
    3fce:	e7f8      	b.n	3fc2 <bt_id_set_adv_own_addr+0x82>
			err = bt_id_set_adv_private_addr(adv);
    3fd0:	f009 fdd8 	bl	db84 <bt_id_set_adv_private_addr>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    3fd4:	2301      	movs	r3, #1
    3fd6:	e7f7      	b.n	3fc8 <bt_id_set_adv_own_addr+0x88>
			return -ENOTSUP;
    3fd8:	f06f 0085 	mvn.w	r0, #133	; 0x85
    3fdc:	e7d9      	b.n	3f92 <bt_id_set_adv_own_addr+0x52>
    3fde:	bf00      	nop
    3fe0:	20000000 	.word	0x20000000

00003fe4 <bt_id_init>:
}
#endif /* !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY) */
#endif /* defined(CONFIG_BT_SMP) */

int bt_id_init(void)
{
    3fe4:	b570      	push	{r4, r5, r6, lr}
	int err;

	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    3fe6:	4e14      	ldr	r6, [pc, #80]	; (4038 <bt_id_init+0x54>)
    3fe8:	79f5      	ldrb	r5, [r6, #7]
{
    3fea:	b088      	sub	sp, #32
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    3fec:	b11d      	cbz	r5, 3ff6 <bt_id_init+0x12>

#if defined(CONFIG_BT_PRIVACY)
	k_work_init_delayable(&bt_dev.rpa_update, rpa_timeout);
#endif

	return 0;
    3fee:	2400      	movs	r4, #0
}
    3ff0:	4620      	mov	r0, r4
    3ff2:	b008      	add	sp, #32
    3ff4:	bd70      	pop	{r4, r5, r6, pc}
		err = bt_setup_public_id_addr();
    3ff6:	f7ff ff0f 	bl	3e18 <bt_setup_public_id_addr>
		if (err) {
    3ffa:	4604      	mov	r4, r0
    3ffc:	b160      	cbz	r0, 4018 <bt_id_init+0x34>
			BT_ERR("Unable to set identity address");
    3ffe:	4b0f      	ldr	r3, [pc, #60]	; (403c <bt_id_init+0x58>)
			BT_ERR("Unable to set random address");
    4000:	9306      	str	r3, [sp, #24]
    4002:	2302      	movs	r3, #2
    4004:	9301      	str	r3, [sp, #4]
    4006:	9305      	str	r3, [sp, #20]
    4008:	480d      	ldr	r0, [pc, #52]	; (4040 <bt_id_init+0x5c>)
    400a:	462b      	mov	r3, r5
    400c:	aa05      	add	r2, sp, #20
    400e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4012:	f009 fc8f 	bl	d934 <z_impl_z_log_msg2_static_create>
			return err;
    4016:	e7eb      	b.n	3ff0 <bt_id_init+0xc>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    4018:	79f5      	ldrb	r5, [r6, #7]
    401a:	2d00      	cmp	r5, #0
    401c:	d1e7      	bne.n	3fee <bt_id_init+0xa>
		err = bt_setup_random_id_addr();
    401e:	f7ff ff61 	bl	3ee4 <bt_setup_random_id_addr>
		if (err) {
    4022:	4604      	mov	r4, r0
    4024:	2800      	cmp	r0, #0
    4026:	d1ea      	bne.n	3ffe <bt_id_init+0x1a>
		err = set_random_address(&bt_dev.id_addr[0].a);
    4028:	1c70      	adds	r0, r6, #1
    402a:	f7ff fdd3 	bl	3bd4 <set_random_address>
		if (err) {
    402e:	4604      	mov	r4, r0
    4030:	2800      	cmp	r0, #0
    4032:	d0dd      	beq.n	3ff0 <bt_id_init+0xc>
			BT_ERR("Unable to set random address");
    4034:	4b03      	ldr	r3, [pc, #12]	; (4044 <bt_id_init+0x60>)
    4036:	e7e3      	b.n	4000 <bt_id_init+0x1c>
    4038:	20000000 	.word	0x20000000
    403c:	00011343 	.word	0x00011343
    4040:	00010298 	.word	0x00010298
    4044:	00011362 	.word	0x00011362

00004048 <valid_adv_param>:
	return true;
}

static bool valid_adv_param(const struct bt_le_adv_param *param)
{
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    4048:	6843      	ldr	r3, [r0, #4]
{
    404a:	b537      	push	{r0, r1, r2, r4, r5, lr}
    404c:	4604      	mov	r4, r0
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    404e:	0558      	lsls	r0, r3, #21
    4050:	d502      	bpl.n	4058 <valid_adv_param+0x10>
		return false;
    4052:	2000      	movs	r0, #0
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
		return false;
	}

	return valid_adv_ext_param(param);
}
    4054:	b003      	add	sp, #12
    4056:	bd30      	pop	{r4, r5, pc}
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    4058:	6922      	ldr	r2, [r4, #16]
    405a:	b10a      	cbz	r2, 4060 <valid_adv_param+0x18>
    405c:	07d9      	lsls	r1, r3, #31
    405e:	d5f8      	bpl.n	4052 <valid_adv_param+0xa>
	if (param->id >= bt_dev.id_count ||
    4060:	4d1a      	ldr	r5, [pc, #104]	; (40cc <valid_adv_param+0x84>)
    4062:	7820      	ldrb	r0, [r4, #0]
    4064:	79eb      	ldrb	r3, [r5, #7]
    4066:	4283      	cmp	r3, r0
    4068:	d9f3      	bls.n	4052 <valid_adv_param+0xa>
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    406a:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    406e:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    4070:	2207      	movs	r2, #7
    4072:	4669      	mov	r1, sp
    4074:	4428      	add	r0, r5
    4076:	9300      	str	r3, [sp, #0]
    4078:	f8cd 3003 	str.w	r3, [sp, #3]
    407c:	f009 fcb2 	bl	d9e4 <memcmp>
	if (param->id >= bt_dev.id_count ||
    4080:	2800      	cmp	r0, #0
    4082:	d0e6      	beq.n	4052 <valid_adv_param+0xa>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    4084:	6860      	ldr	r0, [r4, #4]
    4086:	07c2      	lsls	r2, r0, #31
    4088:	d406      	bmi.n	4098 <valid_adv_param+0x50>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    408a:	f895 3068 	ldrb.w	r3, [r5, #104]	; 0x68
    408e:	2b08      	cmp	r3, #8
    4090:	d802      	bhi.n	4098 <valid_adv_param+0x50>
    4092:	68a3      	ldr	r3, [r4, #8]
    4094:	2b9f      	cmp	r3, #159	; 0x9f
    4096:	d9dc      	bls.n	4052 <valid_adv_param+0xa>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
    4098:	f010 0f30 	tst.w	r0, #48	; 0x30
    409c:	d002      	beq.n	40a4 <valid_adv_param+0x5c>
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
    409e:	6923      	ldr	r3, [r4, #16]
    40a0:	2b00      	cmp	r3, #0
    40a2:	d0d6      	beq.n	4052 <valid_adv_param+0xa>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    40a4:	06c3      	lsls	r3, r0, #27
    40a6:	d401      	bmi.n	40ac <valid_adv_param+0x64>
    40a8:	6923      	ldr	r3, [r4, #16]
    40aa:	b943      	cbnz	r3, 40be <valid_adv_param+0x76>
		if (param->interval_min > param->interval_max ||
    40ac:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    40b0:	429a      	cmp	r2, r3
    40b2:	d8ce      	bhi.n	4052 <valid_adv_param+0xa>
    40b4:	2a1f      	cmp	r2, #31
    40b6:	d9cc      	bls.n	4052 <valid_adv_param+0xa>
		    param->interval_min < 0x0020 ||
    40b8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    40bc:	d8c9      	bhi.n	4052 <valid_adv_param+0xa>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
    40be:	f400 3060 	and.w	r0, r0, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
    40c2:	f5b0 3060 	subs.w	r0, r0, #229376	; 0x38000
    40c6:	bf18      	it	ne
    40c8:	2001      	movne	r0, #1
    40ca:	e7c3      	b.n	4054 <valid_adv_param+0xc>
    40cc:	20000000 	.word	0x20000000

000040d0 <hci_set_ad>:
	*data_len = set_data_len;
	return 0;
}

static int hci_set_ad(uint16_t hci_op, const struct bt_ad *ad, size_t ad_len)
{
    40d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    40d4:	460c      	mov	r4, r1
    40d6:	b08b      	sub	sp, #44	; 0x2c
	struct bt_hci_cp_le_set_adv_data *set_data;
	struct net_buf *buf;
	int err;

	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    40d8:	2120      	movs	r1, #32
{
    40da:	4682      	mov	sl, r0
    40dc:	4616      	mov	r6, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    40de:	f7ff f827 	bl	3130 <bt_hci_cmd_create>
	if (!buf) {
    40e2:	4605      	mov	r5, r0
    40e4:	2800      	cmp	r0, #0
    40e6:	d05e      	beq.n	41a6 <hci_set_ad+0xd6>
	return net_buf_simple_add(&buf->b, len);
    40e8:	2120      	movs	r1, #32
    40ea:	3008      	adds	r0, #8
    40ec:	f00a fd1f 	bl	eb2e <net_buf_simple_add>
		return -ENOBUFS;
	}

	set_data = net_buf_add(buf, sizeof(*set_data));
	(void)memset(set_data, 0, sizeof(*set_data));
    40f0:	2220      	movs	r2, #32
    40f2:	2100      	movs	r1, #0
    40f4:	4681      	mov	r9, r0
    40f6:	f009 fc91 	bl	da1c <memset>

	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
    40fa:	eb04 03c6 	add.w	r3, r4, r6, lsl #3
    40fe:	f109 0b01 	add.w	fp, r9, #1
	for (size_t i = 0; i < ad_len; i++) {
    4102:	9300      	str	r3, [sp, #0]
	uint8_t set_data_len = 0;
    4104:	2600      	movs	r6, #0
		for (size_t j = 0; j < ad[i].len; j++) {
    4106:	f8d4 8000 	ldr.w	r8, [r4]
    410a:	2300      	movs	r3, #0
    410c:	6862      	ldr	r2, [r4, #4]
    410e:	4293      	cmp	r3, r2
    4110:	d30d      	bcc.n	412e <hci_set_ad+0x5e>
	for (size_t i = 0; i < ad_len; i++) {
    4112:	9b00      	ldr	r3, [sp, #0]
    4114:	3408      	adds	r4, #8
    4116:	42a3      	cmp	r3, r4
    4118:	d1f5      	bne.n	4106 <hci_set_ad+0x36>
	if (err) {
		net_buf_unref(buf);
		return err;
	}

	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    411a:	2200      	movs	r2, #0
    411c:	4629      	mov	r1, r5
    411e:	4650      	mov	r0, sl
	*data_len = set_data_len;
    4120:	f889 6000 	strb.w	r6, [r9]
}
    4124:	b00b      	add	sp, #44	; 0x2c
    4126:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    412a:	f7ff b83b 	b.w	31a4 <bt_hci_cmd_send_sync>
			size_t len = data[j].data_len;
    412e:	f898 2001 	ldrb.w	r2, [r8, #1]
			uint8_t type = data[j].type;
    4132:	f898 c000 	ldrb.w	ip, [r8]
			if ((set_data_len + len + 2) > set_data_len_max) {
    4136:	1cb0      	adds	r0, r6, #2
    4138:	1881      	adds	r1, r0, r2
    413a:	291f      	cmp	r1, #31
    413c:	d91c      	bls.n	4178 <hci_set_ad+0xa8>
				if (!(type == BT_DATA_NAME_COMPLETE &&
    413e:	f1bc 0f09 	cmp.w	ip, #9
				ssize_t shortened_len = set_data_len_max -
    4142:	f1c0 021f 	rsb	r2, r0, #31
				if (!(type == BT_DATA_NAME_COMPLETE &&
    4146:	d101      	bne.n	414c <hci_set_ad+0x7c>
    4148:	2a00      	cmp	r2, #0
    414a:	dc13      	bgt.n	4174 <hci_set_ad+0xa4>
					BT_ERR("Too big advertising data");
    414c:	4b17      	ldr	r3, [pc, #92]	; (41ac <hci_set_ad+0xdc>)
    414e:	9308      	str	r3, [sp, #32]
    4150:	2302      	movs	r3, #2
    4152:	9303      	str	r3, [sp, #12]
    4154:	9307      	str	r3, [sp, #28]
    4156:	4816      	ldr	r0, [pc, #88]	; (41b0 <hci_set_ad+0xe0>)
    4158:	2300      	movs	r3, #0
    415a:	aa07      	add	r2, sp, #28
    415c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4160:	f009 fbe8 	bl	d934 <z_impl_z_log_msg2_static_create>
		net_buf_unref(buf);
    4164:	4628      	mov	r0, r5
    4166:	f004 fcf1 	bl	8b4c <net_buf_unref>
					return -EINVAL;
    416a:	f06f 0015 	mvn.w	r0, #21
}
    416e:	b00b      	add	sp, #44	; 0x2c
    4170:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				type = BT_DATA_NAME_SHORTENED;
    4174:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
    4178:	b2d7      	uxtb	r7, r2
    417a:	1c79      	adds	r1, r7, #1
    417c:	f80b 1006 	strb.w	r1, [fp, r6]
    4180:	1c71      	adds	r1, r6, #1
			set_data[set_data_len++] = type;
    4182:	b2c9      	uxtb	r1, r1
			memcpy(&set_data[set_data_len], data[j].data, len);
    4184:	fa5b f080 	uxtab	r0, fp, r0
			set_data[set_data_len++] = type;
    4188:	f80b c001 	strb.w	ip, [fp, r1]
			memcpy(&set_data[set_data_len], data[j].data, len);
    418c:	f8d8 1004 	ldr.w	r1, [r8, #4]
    4190:	9301      	str	r3, [sp, #4]
			set_data_len += len;
    4192:	3702      	adds	r7, #2
			memcpy(&set_data[set_data_len], data[j].data, len);
    4194:	f009 fc37 	bl	da06 <memcpy>
		for (size_t j = 0; j < ad[i].len; j++) {
    4198:	9b01      	ldr	r3, [sp, #4]
			set_data_len += len;
    419a:	443e      	add	r6, r7
    419c:	b2f6      	uxtb	r6, r6
		for (size_t j = 0; j < ad[i].len; j++) {
    419e:	3301      	adds	r3, #1
    41a0:	f108 0808 	add.w	r8, r8, #8
    41a4:	e7b2      	b.n	410c <hci_set_ad+0x3c>
		return -ENOBUFS;
    41a6:	f06f 0068 	mvn.w	r0, #104	; 0x68
    41aa:	e7e0      	b.n	416e <hci_set_ad+0x9e>
    41ac:	00011385 	.word	0x00011385
    41b0:	00010200 	.word	0x00010200

000041b4 <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
    41b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable = false;
    41b8:	690f      	ldr	r7, [r1, #16]
{
    41ba:	b093      	sub	sp, #76	; 0x4c
	bool dir_adv = (param->peer != NULL), scannable = false;
    41bc:	1e3c      	subs	r4, r7, #0
{
    41be:	4606      	mov	r6, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    41c0:	487d      	ldr	r0, [pc, #500]	; (43b8 <bt_le_adv_start_legacy+0x204>)
    41c2:	9305      	str	r3, [sp, #20]
	bool dir_adv = (param->peer != NULL), scannable = false;
    41c4:	bf18      	it	ne
    41c6:	2401      	movne	r4, #1
    41c8:	f009 fcff 	bl	dbca <atomic_get>
{
    41cc:	4693      	mov	fp, r2
	enum adv_name_type name_type;

	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    41ce:	0782      	lsls	r2, r0, #30
{
    41d0:	460d      	mov	r5, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    41d2:	f140 80e8 	bpl.w	43a6 <bt_le_adv_start_legacy+0x1f2>
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
    41d6:	4608      	mov	r0, r1
    41d8:	f7ff ff36 	bl	4048 <valid_adv_param>
    41dc:	b928      	cbnz	r0, 41ea <bt_le_adv_start_legacy+0x36>
		return -EINVAL;
    41de:	f06f 0415 	mvn.w	r4, #21

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
}
    41e2:	4620      	mov	r0, r4
    41e4:	b013      	add	sp, #76	; 0x4c
    41e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!bt_id_adv_random_addr_check(param)) {
    41ea:	4628      	mov	r0, r5
    41ec:	f009 fcdc 	bl	dba8 <bt_id_adv_random_addr_check>
    41f0:	4681      	mov	r9, r0
    41f2:	2800      	cmp	r0, #0
    41f4:	d0f3      	beq.n	41de <bt_le_adv_start_legacy+0x2a>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    41f6:	f106 0810 	add.w	r8, r6, #16
    41fa:	4640      	mov	r0, r8
    41fc:	f009 fce5 	bl	dbca <atomic_get>
    4200:	0643      	lsls	r3, r0, #25
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    4202:	f3c0 1a80 	ubfx	sl, r0, #6, #1
    4206:	f100 80d1 	bmi.w	43ac <bt_le_adv_start_legacy+0x1f8>
	(void)memset(&set_param, 0, sizeof(set_param));
    420a:	220f      	movs	r2, #15
    420c:	4651      	mov	r1, sl
    420e:	a808      	add	r0, sp, #32
    4210:	f009 fc04 	bl	da1c <memset>
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    4214:	68ab      	ldr	r3, [r5, #8]
    4216:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.channel_map  = get_adv_channel_map(param->options);
    421a:	6868      	ldr	r0, [r5, #4]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    421c:	68eb      	ldr	r3, [r5, #12]
    421e:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = get_adv_channel_map(param->options);
    4222:	f009 fcc3 	bl	dbac <get_adv_channel_map>
	if (adv->id != param->id) {
    4226:	7832      	ldrb	r2, [r6, #0]
    4228:	782b      	ldrb	r3, [r5, #0]
	set_param.channel_map  = get_adv_channel_map(param->options);
    422a:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
	if (adv->id != param->id) {
    422e:	429a      	cmp	r2, r3
	set_param.filter_policy = get_filter_policy(param->options);
    4230:	f88d a02e 	strb.w	sl, [sp, #46]	; 0x2e
	if (adv->id != param->id) {
    4234:	d004      	beq.n	4240 <bt_le_adv_start_legacy+0x8c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    4236:	4860      	ldr	r0, [pc, #384]	; (43b8 <bt_le_adv_start_legacy+0x204>)
    4238:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
    423c:	f009 fccb 	bl	dbd6 <atomic_and>
	bt_dev.adv_conn_id = adv->id;
    4240:	4a5e      	ldr	r2, [pc, #376]	; (43bc <bt_le_adv_start_legacy+0x208>)
	adv->id = param->id;
    4242:	782b      	ldrb	r3, [r5, #0]
    4244:	7033      	strb	r3, [r6, #0]
	bt_dev.adv_conn_id = adv->id;
    4246:	f882 3067 	strb.w	r3, [r2, #103]	; 0x67
	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
    424a:	6869      	ldr	r1, [r5, #4]
    424c:	4622      	mov	r2, r4
    424e:	f10d 0325 	add.w	r3, sp, #37	; 0x25
    4252:	4630      	mov	r0, r6
    4254:	f7ff fe74 	bl	3f40 <bt_id_set_adv_own_addr>
	if (err) {
    4258:	4604      	mov	r4, r0
    425a:	2800      	cmp	r0, #0
    425c:	d1c1      	bne.n	41e2 <bt_le_adv_start_legacy+0x2e>
		bt_addr_le_copy(&adv->target_addr, param->peer);
    425e:	f106 0009 	add.w	r0, r6, #9
	if (dir_adv) {
    4262:	2f00      	cmp	r7, #0
    4264:	d047      	beq.n	42f6 <bt_le_adv_start_legacy+0x142>
	memcpy(dst, src, sizeof(*dst));
    4266:	6929      	ldr	r1, [r5, #16]
    4268:	2207      	movs	r2, #7
    426a:	f009 fbcc 	bl	da06 <memcpy>
	name_type = get_adv_name_type_param(param);
    426e:	4628      	mov	r0, r5
    4270:	f009 fd4e 	bl	dd10 <get_adv_name_type_param>
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    4274:	686b      	ldr	r3, [r5, #4]
    4276:	07dc      	lsls	r4, r3, #31
	name_type = get_adv_name_type_param(param);
    4278:	4682      	mov	sl, r0
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    427a:	d545      	bpl.n	4308 <bt_le_adv_start_legacy+0x154>
		if (dir_adv) {
    427c:	2f00      	cmp	r7, #0
    427e:	d040      	beq.n	4302 <bt_le_adv_start_legacy+0x14e>
				set_param.type = BT_HCI_ADV_DIRECT_IND;
    4280:	f013 0f10 	tst.w	r3, #16
    4284:	bf14      	ite	ne
    4286:	2304      	movne	r3, #4
    4288:	2301      	moveq	r3, #1
    428a:	6929      	ldr	r1, [r5, #16]
    428c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    4290:	2207      	movs	r2, #7
    4292:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    4296:	f009 fbb6 	bl	da06 <memcpy>
	bool dir_adv = (param->peer != NULL), scannable = false;
    429a:	f04f 0900 	mov.w	r9, #0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    429e:	210f      	movs	r1, #15
    42a0:	f242 0006 	movw	r0, #8198	; 0x2006
    42a4:	f7fe ff44 	bl	3130 <bt_hci_cmd_create>
	if (!buf) {
    42a8:	4604      	mov	r4, r0
    42aa:	2800      	cmp	r0, #0
    42ac:	f000 8081 	beq.w	43b2 <bt_le_adv_start_legacy+0x1fe>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    42b0:	220f      	movs	r2, #15
    42b2:	a908      	add	r1, sp, #32
    42b4:	3008      	adds	r0, #8
    42b6:	f00a fc40 	bl	eb3a <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    42ba:	4621      	mov	r1, r4
    42bc:	2200      	movs	r2, #0
    42be:	f242 0006 	movw	r0, #8198	; 0x2006
    42c2:	f7fe ff6f 	bl	31a4 <bt_hci_cmd_send_sync>
	if (err) {
    42c6:	4604      	mov	r4, r0
    42c8:	2800      	cmp	r0, #0
    42ca:	d18a      	bne.n	41e2 <bt_le_adv_start_legacy+0x2e>
	if (!dir_adv) {
    42cc:	b36f      	cbz	r7, 432a <bt_le_adv_start_legacy+0x176>
	return bt_le_adv_set_enable_legacy(adv, enable);
    42ce:	2101      	movs	r1, #1
    42d0:	4630      	mov	r0, r6
    42d2:	f009 fd2d 	bl	dd30 <bt_le_adv_set_enable_legacy>
	if (err) {
    42d6:	4604      	mov	r4, r0
    42d8:	2800      	cmp	r0, #0
    42da:	d034      	beq.n	4346 <bt_le_adv_start_legacy+0x192>
		BT_ERR("Failed to start advertiser");
    42dc:	4b38      	ldr	r3, [pc, #224]	; (43c0 <bt_le_adv_start_legacy+0x20c>)
    42de:	9310      	str	r3, [sp, #64]	; 0x40
    42e0:	2302      	movs	r3, #2
    42e2:	9307      	str	r3, [sp, #28]
    42e4:	930f      	str	r3, [sp, #60]	; 0x3c
    42e6:	4837      	ldr	r0, [pc, #220]	; (43c4 <bt_le_adv_start_legacy+0x210>)
    42e8:	2300      	movs	r3, #0
    42ea:	aa0f      	add	r2, sp, #60	; 0x3c
    42ec:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    42f0:	f009 fb20 	bl	d934 <z_impl_z_log_msg2_static_create>
		return err;
    42f4:	e775      	b.n	41e2 <bt_le_adv_start_legacy+0x2e>
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
    42f6:	970c      	str	r7, [sp, #48]	; 0x30
    42f8:	2207      	movs	r2, #7
    42fa:	f8cd 7033 	str.w	r7, [sp, #51]	; 0x33
    42fe:	a90c      	add	r1, sp, #48	; 0x30
    4300:	e7b3      	b.n	426a <bt_le_adv_start_legacy+0xb6>
			set_param.type = BT_HCI_ADV_IND;
    4302:	f88d 7024 	strb.w	r7, [sp, #36]	; 0x24
    4306:	e7ca      	b.n	429e <bt_le_adv_start_legacy+0xea>
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
    4308:	0598      	lsls	r0, r3, #22
    430a:	d404      	bmi.n	4316 <bt_le_adv_start_legacy+0x162>
    430c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    430e:	b913      	cbnz	r3, 4316 <bt_le_adv_start_legacy+0x162>
    4310:	f1ba 0f02 	cmp.w	sl, #2
    4314:	d103      	bne.n	431e <bt_le_adv_start_legacy+0x16a>
		set_param.type = BT_HCI_ADV_SCAN_IND;
    4316:	2302      	movs	r3, #2
    4318:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    431c:	e7bf      	b.n	429e <bt_le_adv_start_legacy+0xea>
		set_param.type = BT_HCI_ADV_NONCONN_IND;
    431e:	2303      	movs	r3, #3
	bool dir_adv = (param->peer != NULL), scannable = false;
    4320:	f8dd 9070 	ldr.w	r9, [sp, #112]	; 0x70
		set_param.type = BT_HCI_ADV_NONCONN_IND;
    4324:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    4328:	e7b9      	b.n	429e <bt_le_adv_start_legacy+0xea>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
    432a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    432c:	9300      	str	r3, [sp, #0]
    432e:	e9cd 9a01 	strd	r9, sl, [sp, #4]
    4332:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    4334:	9a05      	ldr	r2, [sp, #20]
    4336:	4659      	mov	r1, fp
    4338:	4630      	mov	r0, r6
    433a:	f009 fc72 	bl	dc22 <le_adv_update.constprop.0>
		if (err) {
    433e:	4604      	mov	r4, r0
    4340:	2800      	cmp	r0, #0
    4342:	d0c4      	beq.n	42ce <bt_le_adv_start_legacy+0x11a>
    4344:	e74d      	b.n	41e2 <bt_le_adv_start_legacy+0x2e>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    4346:	bb67      	cbnz	r7, 43a2 <bt_le_adv_start_legacy+0x1ee>
    4348:	686a      	ldr	r2, [r5, #4]
    434a:	f082 0202 	eor.w	r2, r2, #2
    434e:	f3c2 0240 	ubfx	r2, r2, #1, #1
    4352:	4640      	mov	r0, r8
    4354:	210d      	movs	r1, #13
    4356:	f009 fc4d 	bl	dbf4 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD,
    435a:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
    435e:	425a      	negs	r2, r3
    4360:	415a      	adcs	r2, r3
    4362:	4640      	mov	r0, r8
    4364:	2107      	movs	r1, #7
    4366:	f009 fc45 	bl	dbf4 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
    436a:	f1aa 0102 	sub.w	r1, sl, #2
    436e:	424a      	negs	r2, r1
    4370:	414a      	adcs	r2, r1
    4372:	4640      	mov	r0, r8
    4374:	2108      	movs	r1, #8
    4376:	f009 fc3d 	bl	dbf4 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
    437a:	686a      	ldr	r2, [r5, #4]
    437c:	4640      	mov	r0, r8
    437e:	f002 0201 	and.w	r2, r2, #1
    4382:	2109      	movs	r1, #9
    4384:	f009 fc36 	bl	dbf4 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);
    4388:	464a      	mov	r2, r9
    438a:	4640      	mov	r0, r8
    438c:	210a      	movs	r1, #10
    438e:	f009 fc31 	bl	dbf4 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
    4392:	686a      	ldr	r2, [r5, #4]
    4394:	210c      	movs	r1, #12
    4396:	f3c2 0280 	ubfx	r2, r2, #2, #1
    439a:	4640      	mov	r0, r8
    439c:	f009 fc2a 	bl	dbf4 <atomic_set_bit_to>
	return 0;
    43a0:	e71f      	b.n	41e2 <bt_le_adv_start_legacy+0x2e>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    43a2:	4602      	mov	r2, r0
    43a4:	e7d5      	b.n	4352 <bt_le_adv_start_legacy+0x19e>
		return -EAGAIN;
    43a6:	f06f 040a 	mvn.w	r4, #10
    43aa:	e71a      	b.n	41e2 <bt_le_adv_start_legacy+0x2e>
		return -EALREADY;
    43ac:	f06f 0477 	mvn.w	r4, #119	; 0x77
    43b0:	e717      	b.n	41e2 <bt_le_adv_start_legacy+0x2e>
		return -ENOBUFS;
    43b2:	f06f 0468 	mvn.w	r4, #104	; 0x68
    43b6:	e714      	b.n	41e2 <bt_le_adv_start_legacy+0x2e>
    43b8:	200000cc 	.word	0x200000cc
    43bc:	20000000 	.word	0x20000000
    43c0:	0001139e 	.word	0x0001139e
    43c4:	00010200 	.word	0x00010200

000043c8 <bt_le_adv_start>:
}

int bt_le_adv_start(const struct bt_le_adv_param *param,
		    const struct bt_data *ad, size_t ad_len,
		    const struct bt_data *sd, size_t sd_len)
{
    43c8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    43ca:	4615      	mov	r5, r2

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
    43cc:	9a06      	ldr	r2, [sp, #24]
{
    43ce:	460c      	mov	r4, r1
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
    43d0:	e9cd 3200 	strd	r3, r2, [sp]
    43d4:	462b      	mov	r3, r5
    43d6:	460a      	mov	r2, r1
    43d8:	4601      	mov	r1, r0
    43da:	4811      	ldr	r0, [pc, #68]	; (4420 <bt_le_adv_start+0x58>)
    43dc:	f7ff feea 	bl	41b4 <bt_le_adv_start_legacy>
    43e0:	4621      	mov	r1, r4
    43e2:	4606      	mov	r6, r0
	for (i = 0; i < ad_len; i++) {
    43e4:	2300      	movs	r3, #0
		if (ad[i].type == BT_DATA_FLAGS &&
    43e6:	f240 1001 	movw	r0, #257	; 0x101
	for (i = 0; i < ad_len; i++) {
    43ea:	429d      	cmp	r5, r3
    43ec:	d102      	bne.n	43f4 <bt_le_adv_start+0x2c>
		k_work_reschedule(&adv->lim_adv_timeout_work,
				  K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
	}

	return err;
}
    43ee:	4630      	mov	r0, r6
    43f0:	b002      	add	sp, #8
    43f2:	bd70      	pop	{r4, r5, r6, pc}
		if (ad[i].type == BT_DATA_FLAGS &&
    43f4:	880a      	ldrh	r2, [r1, #0]
    43f6:	4282      	cmp	r2, r0
    43f8:	d104      	bne.n	4404 <bt_le_adv_start+0x3c>
		    ad[i].data != NULL) {
    43fa:	684a      	ldr	r2, [r1, #4]
		    ad[i].data_len == sizeof(uint8_t) &&
    43fc:	b112      	cbz	r2, 4404 <bt_le_adv_start+0x3c>
			if (ad[i].data[0] & BT_LE_AD_LIMITED) {
    43fe:	7812      	ldrb	r2, [r2, #0]
    4400:	07d2      	lsls	r2, r2, #31
    4402:	d402      	bmi.n	440a <bt_le_adv_start+0x42>
	for (i = 0; i < ad_len; i++) {
    4404:	3301      	adds	r3, #1
    4406:	3108      	adds	r1, #8
    4408:	e7ef      	b.n	43ea <bt_le_adv_start+0x22>
		k_work_init_delayable(&adv->lim_adv_timeout_work, adv_timeout);
    440a:	4906      	ldr	r1, [pc, #24]	; (4424 <bt_le_adv_start+0x5c>)
    440c:	4806      	ldr	r0, [pc, #24]	; (4428 <bt_le_adv_start+0x60>)
    440e:	f00b fa4d 	bl	f8ac <k_work_init_delayable>
		k_work_reschedule(&adv->lim_adv_timeout_work,
    4412:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    4416:	2300      	movs	r3, #0
    4418:	4803      	ldr	r0, [pc, #12]	; (4428 <bt_le_adv_start+0x60>)
    441a:	f007 fe5d 	bl	c0d8 <k_work_reschedule>
    441e:	e7e6      	b.n	43ee <bt_le_adv_start+0x26>
    4420:	20000018 	.word	0x20000018
    4424:	00004465 	.word	0x00004465
    4428:	20000030 	.word	0x20000030

0000442c <bt_le_adv_stop>:

int bt_le_adv_stop(void)
{
    442c:	b508      	push	{r3, lr}
	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
	int err;

	(void)bt_le_lim_adv_cancel_timeout(adv);
    442e:	480b      	ldr	r0, [pc, #44]	; (445c <bt_le_adv_stop+0x30>)
    4430:	f009 fca3 	bl	dd7a <bt_le_lim_adv_cancel_timeout>
    4434:	480a      	ldr	r0, [pc, #40]	; (4460 <bt_le_adv_stop+0x34>)
    4436:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
    443a:	f009 fbcc 	bl	dbd6 <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    443e:	4808      	ldr	r0, [pc, #32]	; (4460 <bt_le_adv_stop+0x34>)
    4440:	f009 fbc3 	bl	dbca <atomic_get>
    4444:	4603      	mov	r3, r0
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    4446:	065b      	lsls	r3, r3, #25
    4448:	f3c0 1080 	ubfx	r0, r0, #6, #1
    444c:	d505      	bpl.n	445a <bt_le_adv_stop+0x2e>
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
    444e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		err = bt_le_adv_set_enable_legacy(adv, false);
    4452:	4802      	ldr	r0, [pc, #8]	; (445c <bt_le_adv_stop+0x30>)
    4454:	2100      	movs	r1, #0
    4456:	f009 bc6b 	b.w	dd30 <bt_le_adv_set_enable_legacy>
}
    445a:	bd08      	pop	{r3, pc}
    445c:	20000018 	.word	0x20000018
    4460:	20000028 	.word	0x20000028

00004464 <adv_timeout>:
}
#endif /* defined(CONFIG_BT_EXT_ADV) */


static void adv_timeout(struct k_work *work)
{
    4464:	b500      	push	{lr}
    4466:	b089      	sub	sp, #36	; 0x24
		err = bt_le_adv_stop();
	} else {
		err = bt_le_ext_adv_stop(adv);
	}
#else
	err = bt_le_adv_stop();
    4468:	f7ff ffe0 	bl	442c <bt_le_adv_stop>
#endif
	BT_WARN("Failed to stop advertising: %d", err);
    446c:	4b07      	ldr	r3, [pc, #28]	; (448c <adv_timeout+0x28>)
    446e:	e9cd 3006 	strd	r3, r0, [sp, #24]
    4472:	2303      	movs	r3, #3
    4474:	9301      	str	r3, [sp, #4]
    4476:	9305      	str	r3, [sp, #20]
    4478:	4805      	ldr	r0, [pc, #20]	; (4490 <adv_timeout+0x2c>)
    447a:	2300      	movs	r3, #0
    447c:	aa05      	add	r2, sp, #20
    447e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    4482:	f009 fa57 	bl	d934 <z_impl_z_log_msg2_static_create>
}
    4486:	b009      	add	sp, #36	; 0x24
    4488:	f85d fb04 	ldr.w	pc, [sp], #4
    448c:	000113b9 	.word	0x000113b9
    4490:	00010200 	.word	0x00010200

00004494 <mayfly_init>:
#if defined(MAYFLY_UT)
static uint8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
    4494:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		uint8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
    4498:	4f11      	ldr	r7, [pc, #68]	; (44e0 <mayfly_init+0x4c>)
    449a:	f8df a048 	ldr.w	sl, [pc, #72]	; 44e4 <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
    449e:	2404      	movs	r4, #4
	while (callee_id--) {
    44a0:	3c01      	subs	r4, #1
    44a2:	b2e4      	uxtb	r4, r4
    44a4:	2cff      	cmp	r4, #255	; 0xff
    44a6:	d018      	beq.n	44da <mayfly_init+0x46>
    44a8:	eb04 0644 	add.w	r6, r4, r4, lsl #1
    44ac:	ea4f 0984 	mov.w	r9, r4, lsl #2
    44b0:	0136      	lsls	r6, r6, #4
		caller_id = MAYFLY_CALLER_COUNT;
    44b2:	2504      	movs	r5, #4
    44b4:	f04f 080c 	mov.w	r8, #12
    44b8:	e00a      	b.n	44d0 <mayfly_init+0x3c>
			memq_init(&mfl[callee_id][caller_id],
    44ba:	fb18 6105 	smlabb	r1, r8, r5, r6
    44be:	1d0a      	adds	r2, r1, #4
    44c0:	eb05 0009 	add.w	r0, r5, r9
    44c4:	443a      	add	r2, r7
    44c6:	4439      	add	r1, r7
    44c8:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
    44cc:	f009 fcc8 	bl	de60 <memq_init>
		while (caller_id--) {
    44d0:	3d01      	subs	r5, #1
    44d2:	b2ed      	uxtb	r5, r5
    44d4:	2dff      	cmp	r5, #255	; 0xff
    44d6:	d1f0      	bne.n	44ba <mayfly_init+0x26>
    44d8:	e7e2      	b.n	44a0 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
    44da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    44de:	bf00      	nop
    44e0:	200010d0 	.word	0x200010d0
    44e4:	20001050 	.word	0x20001050

000044e8 <mayfly_enqueue>:
	}
}

uint32_t mayfly_enqueue(uint8_t caller_id, uint8_t callee_id, uint8_t chain,
			struct mayfly *m)
{
    44e8:	b570      	push	{r4, r5, r6, lr}
    44ea:	4606      	mov	r6, r0
    44ec:	460d      	mov	r5, r1
    44ee:	461c      	mov	r4, r3
	uint8_t state;
	uint8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
    44f0:	b1a2      	cbz	r2, 451c <mayfly_enqueue+0x34>
    44f2:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
    44f4:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
    44f6:	7820      	ldrb	r0, [r4, #0]
    44f8:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
    44fa:	f010 0003 	ands.w	r0, r0, #3
    44fe:	d02c      	beq.n	455a <mayfly_enqueue+0x72>
		if (chain) {
    4500:	b31b      	cbz	r3, 454a <mayfly_enqueue+0x62>
			if (state != 1U) {
    4502:	2801      	cmp	r0, #1
    4504:	d028      	beq.n	4558 <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
    4506:	3201      	adds	r2, #1
    4508:	b2d2      	uxtb	r2, r2
    450a:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
    450c:	4b1c      	ldr	r3, [pc, #112]	; (4580 <mayfly_enqueue+0x98>)
    450e:	2201      	movs	r2, #1
    4510:	555a      	strb	r2, [r3, r5]

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
    4512:	4629      	mov	r1, r5
    4514:	4630      	mov	r0, r6
    4516:	f004 f9a3 	bl	8860 <mayfly_pend>
    451a:	e01c      	b.n	4556 <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    451c:	f00a fa1b 	bl	e956 <mayfly_prio_is_equal>
    4520:	2800      	cmp	r0, #0
    4522:	d0e6      	beq.n	44f2 <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
    4524:	4629      	mov	r1, r5
    4526:	4630      	mov	r0, r6
    4528:	f004 f97a 	bl	8820 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    452c:	2800      	cmp	r0, #0
    452e:	d0e0      	beq.n	44f2 <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
    4530:	2330      	movs	r3, #48	; 0x30
    4532:	220c      	movs	r2, #12
    4534:	436b      	muls	r3, r5
    4536:	fb02 3306 	mla	r3, r2, r6, r3
    453a:	4a12      	ldr	r2, [pc, #72]	; (4584 <mayfly_enqueue+0x9c>)
    453c:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
    453e:	7a93      	ldrb	r3, [r2, #10]
    4540:	7ad2      	ldrb	r2, [r2, #11]
    4542:	1a9b      	subs	r3, r3, r2
    4544:	bf18      	it	ne
    4546:	2301      	movne	r3, #1
    4548:	e7d4      	b.n	44f4 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
    454a:	3202      	adds	r2, #2
    454c:	b2d2      	uxtb	r2, r2
    454e:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
    4550:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
    4554:	4798      	blx	r3

	return 0;
    4556:	2000      	movs	r0, #0
}
    4558:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
    455a:	2b00      	cmp	r3, #0
    455c:	d0f8      	beq.n	4550 <mayfly_enqueue+0x68>
	m->_req = ack + 1;
    455e:	3201      	adds	r2, #1
    4560:	b2d2      	uxtb	r2, r2
    4562:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
    4564:	2304      	movs	r3, #4
    4566:	2230      	movs	r2, #48	; 0x30
    4568:	fb12 3205 	smlabb	r2, r2, r5, r3
    456c:	230c      	movs	r3, #12
    456e:	fb13 2306 	smlabb	r3, r3, r6, r2
    4572:	4a04      	ldr	r2, [pc, #16]	; (4584 <mayfly_enqueue+0x9c>)
    4574:	6860      	ldr	r0, [r4, #4]
    4576:	441a      	add	r2, r3
    4578:	4621      	mov	r1, r4
    457a:	f009 fc74 	bl	de66 <memq_enqueue>
    457e:	e7c5      	b.n	450c <mayfly_enqueue+0x24>
    4580:	20001cba 	.word	0x20001cba
    4584:	200010d0 	.word	0x200010d0

00004588 <mayfly_run>:
		}
	}
}

void mayfly_run(uint8_t callee_id)
{
    4588:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t disable = 0U;
	uint8_t enable = 0U;
	uint8_t caller_id;

	if (!mfp[callee_id]) {
    458c:	4b55      	ldr	r3, [pc, #340]	; (46e4 <mayfly_run+0x15c>)
    458e:	5c1a      	ldrb	r2, [r3, r0]
{
    4590:	b089      	sub	sp, #36	; 0x24
    4592:	4604      	mov	r4, r0
	if (!mfp[callee_id]) {
    4594:	2a00      	cmp	r2, #0
    4596:	f000 809e 	beq.w	46d6 <mayfly_run+0x14e>
		return;
	}
	mfp[callee_id] = 0U;
    459a:	f04f 0800 	mov.w	r8, #0
    459e:	f803 8000 	strb.w	r8, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
    45a2:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    45a6:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    45a8:	4e4f      	ldr	r6, [pc, #316]	; (46e8 <mayfly_run+0x160>)
    45aa:	9304      	str	r3, [sp, #16]
    45ac:	2504      	movs	r5, #4
    45ae:	233c      	movs	r3, #60	; 0x3c
    45b0:	fb13 5300 	smlabb	r3, r3, r0, r5
    45b4:	18f3      	adds	r3, r6, r3
    45b6:	9303      	str	r3, [sp, #12]
	uint8_t disable = 0U;
    45b8:	46c3      	mov	fp, r8
	while (caller_id--) {
    45ba:	3d01      	subs	r5, #1
    45bc:	b2ed      	uxtb	r5, r5
    45be:	2dff      	cmp	r5, #255	; 0xff
    45c0:	d10f      	bne.n	45e2 <mayfly_run+0x5a>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
    45c2:	f1bb 0f00 	cmp.w	fp, #0
    45c6:	f000 8086 	beq.w	46d6 <mayfly_run+0x14e>
    45ca:	f1b8 0f00 	cmp.w	r8, #0
    45ce:	f040 8082 	bne.w	46d6 <mayfly_run+0x14e>
		mayfly_enable_cb(callee_id, callee_id, 0);
    45d2:	4642      	mov	r2, r8
    45d4:	4621      	mov	r1, r4
    45d6:	4620      	mov	r0, r4
	}
}
    45d8:	b009      	add	sp, #36	; 0x24
    45da:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		mayfly_enable_cb(callee_id, callee_id, 0);
    45de:	f004 b8ff 	b.w	87e0 <mayfly_enable_cb>
		struct mayfly *m = 0;
    45e2:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
    45e4:	f04f 090c 	mov.w	r9, #12
		struct mayfly *m = 0;
    45e8:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
    45ea:	fb09 fa05 	mul.w	sl, r9, r5
    45ee:	2330      	movs	r3, #48	; 0x30
    45f0:	fb03 a304 	mla	r3, r3, r4, sl
    45f4:	18f1      	adds	r1, r6, r3
    45f6:	58f0      	ldr	r0, [r6, r3]
    45f8:	6849      	ldr	r1, [r1, #4]
    45fa:	aa07      	add	r2, sp, #28
    45fc:	f009 fc3a 	bl	de74 <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
    4600:	9b04      	ldr	r3, [sp, #16]
    4602:	fb19 3905 	smlabb	r9, r9, r5, r3
    4606:	eb06 0309 	add.w	r3, r6, r9
		link = memq_peek(mft[callee_id][caller_id].head,
    460a:	4607      	mov	r7, r0
		memq_dequeue(mft[callee_id][caller_id].tail,
    460c:	9302      	str	r3, [sp, #8]
		while (link) {
    460e:	2f00      	cmp	r7, #0
    4610:	d043      	beq.n	469a <mayfly_run+0x112>
			state = (m->_req - m->_ack) & 0x03;
    4612:	9b07      	ldr	r3, [sp, #28]
    4614:	f893 9000 	ldrb.w	r9, [r3]
    4618:	785a      	ldrb	r2, [r3, #1]
    461a:	eba9 0902 	sub.w	r9, r9, r2
    461e:	f009 0903 	and.w	r9, r9, #3
			if (state == 1U) {
    4622:	f1b9 0f01 	cmp.w	r9, #1
    4626:	d104      	bne.n	4632 <mayfly_run+0xaa>
				m->_ack--;
    4628:	3a01      	subs	r2, #1
    462a:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
    462c:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
    4630:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
    4632:	9b07      	ldr	r3, [sp, #28]
	if (((req - m->_ack) & 0x03) != 1U) {
    4634:	9305      	str	r3, [sp, #20]
	req = m->_req;
    4636:	781a      	ldrb	r2, [r3, #0]
    4638:	b2d1      	uxtb	r1, r2
    463a:	9101      	str	r1, [sp, #4]
	if (((req - m->_ack) & 0x03) != 1U) {
    463c:	7859      	ldrb	r1, [r3, #1]
    463e:	1a52      	subs	r2, r2, r1
    4640:	f002 0203 	and.w	r2, r2, #3
    4644:	2a01      	cmp	r2, #1
    4646:	d019      	beq.n	467c <mayfly_run+0xf4>
		memq_dequeue(mft[callee_id][caller_id].tail,
    4648:	2030      	movs	r0, #48	; 0x30
    464a:	fb00 a004 	mla	r0, r0, r4, sl
    464e:	4430      	add	r0, r6
    4650:	9902      	ldr	r1, [sp, #8]
    4652:	6840      	ldr	r0, [r0, #4]
    4654:	2200      	movs	r2, #0
    4656:	f009 fc15 	bl	de84 <memq_dequeue>
		m->_link = link;
    465a:	9b05      	ldr	r3, [sp, #20]
		m->_ack = req;
    465c:	9a01      	ldr	r2, [sp, #4]
		ack = m->_ack;
    465e:	7859      	ldrb	r1, [r3, #1]
		m->_ack = req;
    4660:	705a      	strb	r2, [r3, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
    4662:	781a      	ldrb	r2, [r3, #0]
		m->_link = link;
    4664:	605f      	str	r7, [r3, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
    4666:	1a52      	subs	r2, r2, r1
    4668:	f002 0203 	and.w	r2, r2, #3
    466c:	2a01      	cmp	r2, #1
    466e:	d105      	bne.n	467c <mayfly_run+0xf4>
			m->_ack = ack;
    4670:	7059      	strb	r1, [r3, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    4672:	9a03      	ldr	r2, [sp, #12]
    4674:	4619      	mov	r1, r3
    4676:	4638      	mov	r0, r7
    4678:	f009 fbf5 	bl	de66 <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
    467c:	2330      	movs	r3, #48	; 0x30
    467e:	fb03 a304 	mla	r3, r3, r4, sl
    4682:	18f1      	adds	r1, r6, r3
    4684:	58f0      	ldr	r0, [r6, r3]
    4686:	6849      	ldr	r1, [r1, #4]
    4688:	aa07      	add	r2, sp, #28
    468a:	f009 fbf3 	bl	de74 <memq_peek>
			if (state == 1U) {
    468e:	f1b9 0f01 	cmp.w	r9, #1
			link = memq_peek(mft[callee_id][caller_id].head,
    4692:	4607      	mov	r7, r0
			if (state == 1U) {
    4694:	d1bb      	bne.n	460e <mayfly_run+0x86>
				if (caller_id || link) {
    4696:	b9bd      	cbnz	r5, 46c8 <mayfly_run+0x140>
    4698:	b9b0      	cbnz	r0, 46c8 <mayfly_run+0x140>
		if (mft[callee_id][caller_id].disable_req !=
    469a:	2230      	movs	r2, #48	; 0x30
    469c:	210c      	movs	r1, #12
    469e:	4362      	muls	r2, r4
    46a0:	fb01 2205 	mla	r2, r1, r5, r2
    46a4:	4432      	add	r2, r6
    46a6:	7a93      	ldrb	r3, [r2, #10]
    46a8:	7ad0      	ldrb	r0, [r2, #11]
    46aa:	4298      	cmp	r0, r3
    46ac:	d116      	bne.n	46dc <mayfly_run+0x154>
		if (mft[callee_id][caller_id].enable_req !=
    46ae:	2330      	movs	r3, #48	; 0x30
    46b0:	4363      	muls	r3, r4
    46b2:	fb01 3305 	mla	r3, r1, r5, r3
    46b6:	4433      	add	r3, r6
    46b8:	7a1a      	ldrb	r2, [r3, #8]
    46ba:	7a59      	ldrb	r1, [r3, #9]
    46bc:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
    46be:	bf1c      	itt	ne
    46c0:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
    46c2:	f04f 0801 	movne.w	r8, #1
    46c6:	e778      	b.n	45ba <mayfly_run+0x32>
					mfp[callee_id] = 1U;
    46c8:	4b06      	ldr	r3, [pc, #24]	; (46e4 <mayfly_run+0x15c>)
    46ca:	2201      	movs	r2, #1
    46cc:	551a      	strb	r2, [r3, r4]
					mayfly_pend(callee_id, callee_id);
    46ce:	4621      	mov	r1, r4
    46d0:	4620      	mov	r0, r4
    46d2:	f004 f8c5 	bl	8860 <mayfly_pend>
}
    46d6:	b009      	add	sp, #36	; 0x24
    46d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
    46dc:	72d3      	strb	r3, [r2, #11]
			disable = 1U;
    46de:	f04f 0b01 	mov.w	fp, #1
    46e2:	e7e4      	b.n	46ae <mayfly_run+0x126>
    46e4:	20001cba 	.word	0x20001cba
    46e8:	200010d0 	.word	0x200010d0

000046ec <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
    46ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer job, as worker is running */
	if (instance->worker_trigger) {
    46f0:	7fc3      	ldrb	r3, [r0, #31]
{
    46f2:	b08b      	sub	sp, #44	; 0x2c
    46f4:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
    46f6:	2b00      	cmp	r3, #0
    46f8:	f040 83bd 	bne.w	4e76 <ticker_job+0x78a>
		DEBUG_TICKER_JOB(0);
		return;
	}

	/* Defer job, as job is already running */
	if (instance->job_guard) {
    46fc:	7f82      	ldrb	r2, [r0, #30]
    46fe:	b14a      	cbz	r2, 4714 <ticker_job+0x28>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_JOB, 1,
    4700:	6a45      	ldr	r5, [r0, #36]	; 0x24
    4702:	4603      	mov	r3, r0
    4704:	2201      	movs	r2, #1
    4706:	2104      	movs	r1, #4
	/* Permit worker to run */
	instance->job_guard = 0U;

	/* trigger worker if deferred */
	if (instance->worker_trigger) {
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    4708:	2004      	movs	r0, #4
    470a:	46ac      	mov	ip, r5
				   instance);
	}

	DEBUG_TICKER_JOB(0);
}
    470c:	b00b      	add	sp, #44	; 0x2c
    470e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    4712:	4760      	bx	ip
	ticks_previous = instance->ticks_current;
    4714:	6943      	ldr	r3, [r0, #20]
    4716:	9304      	str	r3, [sp, #16]
	instance->job_guard = 1U;
    4718:	2101      	movs	r1, #1
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    471a:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
    471c:	7781      	strb	r1, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    471e:	7ac0      	ldrb	r0, [r0, #11]
    4720:	4298      	cmp	r0, r3
    4722:	d057      	beq.n	47d4 <ticker_job+0xe8>
	uint8_t idx = *ticks_elapsed_index + 1;
    4724:	440b      	add	r3, r1
    4726:	b2db      	uxtb	r3, r3
		idx = 0U;
    4728:	2b02      	cmp	r3, #2
    472a:	bf08      	it	eq
    472c:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
    472e:	72a3      	strb	r3, [r4, #10]
		ticks_elapsed =
    4730:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		flag_elapsed = 1U;
    4734:	9101      	str	r1, [sp, #4]
		ticks_elapsed =
    4736:	68db      	ldr	r3, [r3, #12]
    4738:	9300      	str	r3, [sp, #0]
		instance->ticks_current += ticks_elapsed;
    473a:	9a00      	ldr	r2, [sp, #0]
    473c:	9b04      	ldr	r3, [sp, #16]
    473e:	4413      	add	r3, r2
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
    4740:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    4744:	6163      	str	r3, [r4, #20]
	ticker_id_old_head = instance->ticker_id_head;
    4746:	7f63      	ldrb	r3, [r4, #29]
    4748:	9303      	str	r3, [sp, #12]
	node = &instance->nodes[0];
    474a:	6823      	ldr	r3, [r4, #0]
    474c:	9302      	str	r3, [sp, #8]
	users = &instance->users[0];
    474e:	6863      	ldr	r3, [r4, #4]
    4750:	9308      	str	r3, [sp, #32]
	while (count_user--) {
    4752:	7a63      	ldrb	r3, [r4, #9]
    4754:	3b01      	subs	r3, #1
    4756:	fa5f fb83 	uxtb.w	fp, r3
	pending = 0U;
    475a:	2300      	movs	r3, #0
    475c:	9305      	str	r3, [sp, #20]
	insert_head = TICKER_NULL;
    475e:	f04f 09ff 	mov.w	r9, #255	; 0xff
	while (count_user--) {
    4762:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
    4766:	d138      	bne.n	47da <ticker_job+0xee>
	if (instance->ticker_id_head != ticker_id_old_head) {
    4768:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
    476a:	9a03      	ldr	r2, [sp, #12]
    476c:	1a9b      	subs	r3, r3, r2
    476e:	bf18      	it	ne
    4770:	2301      	movne	r3, #1
    4772:	9302      	str	r3, [sp, #8]
	if (flag_elapsed) {
    4774:	9b01      	ldr	r3, [sp, #4]
    4776:	2b00      	cmp	r3, #0
    4778:	f000 8223 	beq.w	4bc2 <ticker_job+0x4d6>
	ticks_now = cntr_cnt_get();
    477c:	f003 fcbc 	bl	80f8 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
uint32_t ticker_ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4780:	9b04      	ldr	r3, [sp, #16]
	while (instance->ticker_id_head != TICKER_NULL) {
    4782:	9f00      	ldr	r7, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4784:	eba0 0b03 	sub.w	fp, r0, r3
	node = &instance->nodes[0];
    4788:	6823      	ldr	r3, [r4, #0]
    478a:	9306      	str	r3, [sp, #24]
	ticks_expired = 0U;
    478c:	2300      	movs	r3, #0
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    478e:	f02b 4b7f 	bic.w	fp, fp, #4278190080	; 0xff000000
	ticks_expired = 0U;
    4792:	9307      	str	r3, [sp, #28]
	while (instance->ticker_id_head != TICKER_NULL) {
    4794:	7f66      	ldrb	r6, [r4, #29]
    4796:	2eff      	cmp	r6, #255	; 0xff
    4798:	d00d      	beq.n	47b6 <ticker_job+0xca>
		ticker = &node[id_expired];
    479a:	b235      	sxth	r5, r6
    479c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    47a0:	012b      	lsls	r3, r5, #4
    47a2:	9308      	str	r3, [sp, #32]
    47a4:	9b06      	ldr	r3, [sp, #24]
    47a6:	eb03 1505 	add.w	r5, r3, r5, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
    47aa:	68ab      	ldr	r3, [r5, #8]
		if (ticks_elapsed < ticks_to_expire) {
    47ac:	42bb      	cmp	r3, r7
    47ae:	f240 80c8 	bls.w	4942 <ticker_job+0x256>
			ticker->ticks_to_expire -= ticks_elapsed;
    47b2:	1bdb      	subs	r3, r3, r7
    47b4:	60ab      	str	r3, [r5, #8]
			flag_compare_update = 1U;
    47b6:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
    47ba:	9903      	ldr	r1, [sp, #12]
		ticker_job_list_insert(instance, insert_head);
    47bc:	4620      	mov	r0, r4
			flag_compare_update = 1U;
    47be:	42b1      	cmp	r1, r6
    47c0:	bf18      	it	ne
    47c2:	4613      	movne	r3, r2
		ticker_job_list_insert(instance, insert_head);
    47c4:	4649      	mov	r1, r9
			flag_compare_update = 1U;
    47c6:	9302      	str	r3, [sp, #8]
		ticker_job_list_insert(instance, insert_head);
    47c8:	f009 fbcf 	bl	df6a <ticker_job_list_insert>
	nodes = &instance->nodes[0];
    47cc:	6825      	ldr	r5, [r4, #0]
	uint8_t  rescheduled = 0U;
    47ce:	2300      	movs	r3, #0
		ticker_id_head = instance->ticker_id_head;
    47d0:	7f67      	ldrb	r7, [r4, #29]
		while (ticker_id_head != TICKER_NULL) {
    47d2:	e16b      	b.n	4aac <ticker_job+0x3c0>
		flag_elapsed = 0U;
    47d4:	9201      	str	r2, [sp, #4]
		ticks_elapsed = 0U;
    47d6:	9200      	str	r2, [sp, #0]
    47d8:	e7b5      	b.n	4746 <ticker_job+0x5a>
		user = &users[count_user];
    47da:	9b08      	ldr	r3, [sp, #32]
    47dc:	eb03 08cb 	add.w	r8, r3, fp, lsl #3
		user_ops = &user->user_op[0];
    47e0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    47e4:	9306      	str	r3, [sp, #24]
		while (user->middle != user->last) {
    47e6:	f898 1003 	ldrb.w	r1, [r8, #3]
			user_op = &user_ops[user->middle];
    47ea:	2034      	movs	r0, #52	; 0x34
		while (user->middle != user->last) {
    47ec:	f898 7002 	ldrb.w	r7, [r8, #2]
    47f0:	428f      	cmp	r7, r1
    47f2:	f000 82da 	beq.w	4daa <ticker_job+0x6be>
			user_op = &user_ops[user->middle];
    47f6:	9b06      	ldr	r3, [sp, #24]
			if (middle == user->count_user_op) {
    47f8:	f898 5000 	ldrb.w	r5, [r8]
			user_op = &user_ops[user->middle];
    47fc:	fb17 f200 	smulbb	r2, r7, r0
    4800:	189e      	adds	r6, r3, r2
			middle = user->middle + 1;
    4802:	1c7b      	adds	r3, r7, #1
    4804:	b2db      	uxtb	r3, r3
				middle = 0U;
    4806:	429d      	cmp	r5, r3
    4808:	bf08      	it	eq
    480a:	2300      	moveq	r3, #0
			user->middle = middle;
    480c:	f888 3002 	strb.w	r3, [r8, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
    4810:	9b06      	ldr	r3, [sp, #24]
    4812:	5c9a      	ldrb	r2, [r3, r2]
    4814:	2a04      	cmp	r2, #4
    4816:	d9e9      	bls.n	47ec <ticker_job+0x100>
			ticker = &node[user_op->id];
    4818:	7871      	ldrb	r1, [r6, #1]
    481a:	eb01 0541 	add.w	r5, r1, r1, lsl #1
    481e:	012b      	lsls	r3, r5, #4
    4820:	9309      	str	r3, [sp, #36]	; 0x24
    4822:	9b02      	ldr	r3, [sp, #8]
    4824:	eb03 1505 	add.w	r5, r3, r5, lsl #4
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
    4828:	2a08      	cmp	r2, #8
			state = (ticker->req - ticker->ack) & 0xff;
    482a:	786b      	ldrb	r3, [r5, #1]
    482c:	78a8      	ldrb	r0, [r5, #2]
    482e:	eba3 0300 	sub.w	r3, r3, r0
    4832:	b2db      	uxtb	r3, r3
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
    4834:	d818      	bhi.n	4868 <ticker_job+0x17c>
    4836:	b1bb      	cbz	r3, 4868 <ticker_job+0x17c>
			    (state == 0U) ||
    4838:	2a05      	cmp	r2, #5
    483a:	f040 82a9 	bne.w	4d90 <ticker_job+0x6a4>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
    483e:	6872      	ldr	r2, [r6, #4]
    4840:	2a00      	cmp	r2, #0
    4842:	f040 82b7 	bne.w	4db4 <ticker_job+0x6c8>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
    4846:	68b2      	ldr	r2, [r6, #8]
    4848:	2a00      	cmp	r2, #0
    484a:	f040 82b3 	bne.w	4db4 <ticker_job+0x6c8>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
    484e:	68f2      	ldr	r2, [r6, #12]
    4850:	2a00      	cmp	r2, #0
    4852:	f040 82af 	bne.w	4db4 <ticker_job+0x6c8>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
    4856:	6932      	ldr	r2, [r6, #16]
    4858:	2a00      	cmp	r2, #0
    485a:	f040 82ab 	bne.w	4db4 <ticker_job+0x6c8>
			     (user_op->params.update.lazy == 0U) &&
    485e:	6972      	ldr	r2, [r6, #20]
    4860:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    4864:	f040 82a6 	bne.w	4db4 <ticker_job+0x6c8>
				ticker_job_op_cb(user_op,
    4868:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    486a:	4630      	mov	r0, r6
    486c:	f009 fb73 	bl	df56 <ticker_job_op_cb>
}
    4870:	e7b9      	b.n	47e6 <ticker_job+0xfa>
	if ((ticker->remainder_current >= BIT(31)) ||
    4872:	6a69      	ldr	r1, [r5, #36]	; 0x24
    4874:	4f91      	ldr	r7, [pc, #580]	; (4abc <ticker_job+0x3d0>)
    4876:	f8df a248 	ldr.w	sl, [pc, #584]	; 4ac0 <ticker_job+0x3d4>
    487a:	19cf      	adds	r7, r1, r7
    487c:	4557      	cmp	r7, sl
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
    487e:	bf81      	itttt	hi
    4880:	f101 71e8 	addhi.w	r1, r1, #30408704	; 0x1d00000
    4884:	f501 31d4 	addhi.w	r1, r1, #108544	; 0x1a800
    4888:	f501 71a5 	addhi.w	r1, r1, #330	; 0x14a
    488c:	6269      	strhi	r1, [r5, #36]	; 0x24
	ticker->remainder_current -= ticker->remainder_periodic;
    488e:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
		decrement++;
    4892:	bf8c      	ite	hi
    4894:	f04f 0a01 	movhi.w	sl, #1
	uint8_t decrement = 0U;
    4898:	f04f 0a00 	movls.w	sl, #0
	ticker->remainder_current -= ticker->remainder_periodic;
    489c:	1a79      	subs	r1, r7, r1
			ticks_to_expire -= ticker->ticks_periodic +
    489e:	4482      	add	sl, r0
			ticker->lazy_current--;
    48a0:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
	ticker->remainder_current -= ticker->remainder_periodic;
    48a4:	6269      	str	r1, [r5, #36]	; 0x24
			ticks_to_expire -= ticker->ticks_periodic +
    48a6:	eba3 030a 	sub.w	r3, r3, sl
			ticker->lazy_current--;
    48aa:	f8a5 e01e 	strh.w	lr, [r5, #30]
    48ae:	e2a7      	b.n	4e00 <ticker_job+0x714>
	ticker->remainder_current += ticker->remainder_periodic;
    48b0:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
    48b4:	4439      	add	r1, r7
	if ((ticker->remainder_current < BIT(31)) &&
    48b6:	4f81      	ldr	r7, [pc, #516]	; (4abc <ticker_job+0x3d0>)
    48b8:	f8df a204 	ldr.w	sl, [pc, #516]	; 4ac0 <ticker_job+0x3d4>
    48bc:	19cf      	adds	r7, r1, r7
    48be:	4557      	cmp	r7, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    48c0:	bf9d      	ittte	ls
    48c2:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
    48c6:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
    48ca:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
	ticker->remainder_current += ticker->remainder_periodic;
    48ce:	6269      	strhi	r1, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    48d0:	bf96      	itet	ls
    48d2:	6269      	strls	r1, [r5, #36]	; 0x24
	return 0;
    48d4:	2100      	movhi	r1, #0
		return 1;
    48d6:	2101      	movls	r1, #1
			ticks_to_expire += ticker->ticks_periodic +
    48d8:	4401      	add	r1, r0
			ticker->lazy_current++;
    48da:	f10e 0e01 	add.w	lr, lr, #1
			ticks_to_expire += ticker->ticks_periodic +
    48de:	440b      	add	r3, r1
			ticker->lazy_current++;
    48e0:	f8a5 e01e 	strh.w	lr, [r5, #30]
    48e4:	e293      	b.n	4e0e <ticker_job+0x722>
		if (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS) {
    48e6:	2a06      	cmp	r2, #6
    48e8:	d005      	beq.n	48f6 <ticker_job+0x20a>
			ticker->ticks_to_expire = ticker_dequeue(instance,
    48ea:	4620      	mov	r0, r4
    48ec:	f009 faea 	bl	dec4 <ticker_dequeue>
			ticker->req = ticker->ack;
    48f0:	78ab      	ldrb	r3, [r5, #2]
			ticker->ticks_to_expire = ticker_dequeue(instance,
    48f2:	60a8      	str	r0, [r5, #8]
			ticker->req = ticker->ack;
    48f4:	706b      	strb	r3, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
    48f6:	7f22      	ldrb	r2, [r4, #28]
    48f8:	7873      	ldrb	r3, [r6, #1]
    48fa:	429a      	cmp	r2, r3
    48fc:	f040 82b9 	bne.w	4e72 <ticker_job+0x786>
			instance->ticker_id_slot_previous = TICKER_NULL;
    4900:	23ff      	movs	r3, #255	; 0xff
    4902:	7723      	strb	r3, [r4, #28]
			if ((user_op->op == TICKER_USER_OP_TYPE_YIELD_ABS) ||
    4904:	7833      	ldrb	r3, [r6, #0]
    4906:	2b06      	cmp	r3, #6
    4908:	d001      	beq.n	490e <ticker_job+0x222>
    490a:	2b08      	cmp	r3, #8
    490c:	d10d      	bne.n	492a <ticker_job+0x23e>
				ticks_at_yield =
    490e:	6870      	ldr	r0, [r6, #4]
			ticks_current = instance->ticks_current;
    4910:	6963      	ldr	r3, [r4, #20]
			if (!((ticks_at_yield - ticks_current) &
    4912:	1ac2      	subs	r2, r0, r3
    4914:	0211      	lsls	r1, r2, #8
    4916:	d40b      	bmi.n	4930 <ticker_job+0x244>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4918:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
    491c:	9a00      	ldr	r2, [sp, #0]
    491e:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
    4920:	69a2      	ldr	r2, [r4, #24]
    4922:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
    4924:	bf88      	it	hi
    4926:	61a3      	strhi	r3, [r4, #24]
    4928:	e2a3      	b.n	4e72 <ticker_job+0x786>
				ticks_at_yield = cntr_cnt_get();
    492a:	f003 fbe5 	bl	80f8 <cntr_cnt_get>
    492e:	e7ef      	b.n	4910 <ticker_job+0x224>
				if (ticks_elapsed > ticks_used) {
    4930:	9a00      	ldr	r2, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4932:	1a1b      	subs	r3, r3, r0
    4934:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
    4938:	429a      	cmp	r2, r3
					ticks_used = ticks_elapsed -
    493a:	bf8c      	ite	hi
    493c:	1ad3      	subhi	r3, r2, r3
					ticks_used = 0;
    493e:	2300      	movls	r3, #0
    4940:	e7ee      	b.n	4920 <ticker_job+0x234>
		ticks_expired += ticks_to_expire;
    4942:	9a07      	ldr	r2, [sp, #28]
		skip_collision = (ticker->lazy_current != 0U);
    4944:	f8b5 c01e 	ldrh.w	ip, [r5, #30]
		ticks_expired += ticks_to_expire;
    4948:	441a      	add	r2, r3
    494a:	9207      	str	r2, [sp, #28]
		if (instance->ticks_slot_previous > ticks_to_expire) {
    494c:	69a2      	ldr	r2, [r4, #24]
    494e:	4293      	cmp	r3, r2
		ticks_elapsed -= ticks_to_expire;
    4950:	eba7 0703 	sub.w	r7, r7, r3
		ticks_latency -= ticks_to_expire;
    4954:	ebab 0b03 	sub.w	fp, fp, r3
			instance->ticker_id_slot_previous = TICKER_NULL;
    4958:	bf25      	ittet	cs
    495a:	23ff      	movcs	r3, #255	; 0xff
    495c:	7723      	strbcs	r3, [r4, #28]
			instance->ticks_slot_previous -= ticks_to_expire;
    495e:	1ad3      	subcc	r3, r2, r3
			instance->ticks_slot_previous = 0U;
    4960:	2300      	movcs	r3, #0
    4962:	61a3      	str	r3, [r4, #24]
		state = (ticker->req - ticker->ack) & 0xff;
    4964:	78a9      	ldrb	r1, [r5, #2]
    4966:	786b      	ldrb	r3, [r5, #1]
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
    4968:	69a8      	ldr	r0, [r5, #24]
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
    496a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
		state = (ticker->req - ticker->ack) & 0xff;
    496c:	1a5b      	subs	r3, r3, r1
    496e:	b2db      	uxtb	r3, r3
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
    4970:	b160      	cbz	r0, 498c <ticker_job+0x2a0>
    4972:	2b02      	cmp	r3, #2
    4974:	d10a      	bne.n	498c <ticker_job+0x2a0>
    4976:	f1bc 0f00 	cmp.w	ip, #0
    497a:	d107      	bne.n	498c <ticker_job+0x2a0>
    497c:	b122      	cbz	r2, 4988 <ticker_job+0x29c>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
    497e:	f892 e008 	ldrb.w	lr, [r2, #8]
    4982:	f1be 0f01 	cmp.w	lr, #1
    4986:	d001      	beq.n	498c <ticker_job+0x2a0>
			instance->ticker_id_slot_previous = id_expired;
    4988:	7726      	strb	r6, [r4, #28]
			instance->ticks_slot_previous = ticker->ticks_slot;
    498a:	61a0      	str	r0, [r4, #24]
		ticker->ticks_to_expire = 0U;
    498c:	2000      	movs	r0, #0
    498e:	60a8      	str	r0, [r5, #8]
		instance->ticker_id_head = ticker->next;
    4990:	f8dd e020 	ldr.w	lr, [sp, #32]
    4994:	9806      	ldr	r0, [sp, #24]
    4996:	f810 000e 	ldrb.w	r0, [r0, lr]
    499a:	7760      	strb	r0, [r4, #29]
		if ((ticker->ticks_periodic != 0U) ||
    499c:	f8d5 e004 	ldr.w	lr, [r5, #4]
    49a0:	f1be 0f00 	cmp.w	lr, #0
    49a4:	d119      	bne.n	49da <ticker_job+0x2ee>
    49a6:	2a00      	cmp	r2, #0
    49a8:	d063      	beq.n	4a72 <ticker_job+0x386>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
    49aa:	7a10      	ldrb	r0, [r2, #8]
    49ac:	2801      	cmp	r0, #1
    49ae:	d160      	bne.n	4a72 <ticker_job+0x386>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
    49b0:	7a13      	ldrb	r3, [r2, #8]
    49b2:	2b01      	cmp	r3, #1
    49b4:	d113      	bne.n	49de <ticker_job+0x2f2>
				ticker->ticks_to_expire = ticks_elapsed;
    49b6:	60af      	str	r7, [r5, #8]
				ticker->req = ticker->ack;
    49b8:	7069      	strb	r1, [r5, #1]
			ticks_to_expire_prep(ticker, instance->ticks_current,
    49ba:	9b04      	ldr	r3, [sp, #16]
    49bc:	9a07      	ldr	r2, [sp, #28]
    49be:	6961      	ldr	r1, [r4, #20]
    49c0:	189a      	adds	r2, r3, r2
    49c2:	4628      	mov	r0, r5
    49c4:	f009 faa9 	bl	df1a <ticks_to_expire_prep>
			ticker->next = *insert_head;
    49c8:	9b06      	ldr	r3, [sp, #24]
    49ca:	9a08      	ldr	r2, [sp, #32]
    49cc:	f803 9002 	strb.w	r9, [r3, r2]
			ticker->req++;
    49d0:	786b      	ldrb	r3, [r5, #1]
    49d2:	3301      	adds	r3, #1
    49d4:	706b      	strb	r3, [r5, #1]
			ticker->req = ticker->ack;
    49d6:	46b1      	mov	r9, r6
    49d8:	e6dc      	b.n	4794 <ticker_job+0xa8>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
    49da:	2a00      	cmp	r2, #0
    49dc:	d1e8      	bne.n	49b0 <ticker_job+0x2c4>
				if (!ticker->lazy_current) {
    49de:	f1bc 0f00 	cmp.w	ip, #0
    49e2:	d124      	bne.n	4a2e <ticker_job+0x342>
					lazy_periodic = ticker->lazy_periodic;
    49e4:	8ba8      	ldrh	r0, [r5, #28]
				while (count--) {
    49e6:	4680      	mov	r8, r0
				ticks_to_expire = 0U;
    49e8:	2200      	movs	r2, #0
	ticker->remainder_current += ticker->remainder_periodic;
    49ea:	e9d5 1308 	ldrd	r1, r3, [r5, #32]
    49ee:	440b      	add	r3, r1
	if ((ticker->remainder_current < BIT(31)) &&
    49f0:	4932      	ldr	r1, [pc, #200]	; (4abc <ticker_job+0x3d0>)
    49f2:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 4ac0 <ticker_job+0x3d4>
    49f6:	1859      	adds	r1, r3, r1
    49f8:	4551      	cmp	r1, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    49fa:	bf9f      	itttt	ls
    49fc:	f1a3 73e8 	subls.w	r3, r3, #30408704	; 0x1d00000
    4a00:	f5a3 33d4 	subls.w	r3, r3, #108544	; 0x1a800
    4a04:	f5a3 73a5 	subls.w	r3, r3, #330	; 0x14a
    4a08:	626b      	strls	r3, [r5, #36]	; 0x24
		return 1;
    4a0a:	bf92      	itee	ls
    4a0c:	9b01      	ldrls	r3, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
    4a0e:	626b      	strhi	r3, [r5, #36]	; 0x24
	return 0;
    4a10:	2300      	movhi	r3, #0
					ticks_to_expire +=
    4a12:	4473      	add	r3, lr
				while (count--) {
    4a14:	f1b8 0801 	subs.w	r8, r8, #1
					ticks_to_expire +=
    4a18:	441a      	add	r2, r3
				while (count--) {
    4a1a:	d2e6      	bcs.n	49ea <ticker_job+0x2fe>
				} else if (!ticker->must_expire) {
    4a1c:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    4a20:	b32b      	cbz	r3, 4a6e <ticker_job+0x382>
				lazy = 0U;
    4a22:	2300      	movs	r3, #0
				ticker->lazy_current += (lazy_periodic + lazy);
    4a24:	4460      	add	r0, ip
    4a26:	4418      	add	r0, r3
				ticker->ticks_to_expire = ticks_to_expire;
    4a28:	60aa      	str	r2, [r5, #8]
				ticker->lazy_current += (lazy_periodic + lazy);
    4a2a:	83e8      	strh	r0, [r5, #30]
    4a2c:	e7c5      	b.n	49ba <ticker_job+0x2ce>
					ticker->req = ticker->ack;
    4a2e:	7069      	strb	r1, [r5, #1]
					lazy_periodic = 0U;
    4a30:	2000      	movs	r0, #0
    4a32:	e7d8      	b.n	49e6 <ticker_job+0x2fa>
	ticker->remainder_current += ticker->remainder_periodic;
    4a34:	e9d5 1308 	ldrd	r1, r3, [r5, #32]
    4a38:	440b      	add	r3, r1
	if ((ticker->remainder_current < BIT(31)) &&
    4a3a:	4920      	ldr	r1, [pc, #128]	; (4abc <ticker_job+0x3d0>)
    4a3c:	f8df a080 	ldr.w	sl, [pc, #128]	; 4ac0 <ticker_job+0x3d4>
    4a40:	1859      	adds	r1, r3, r1
    4a42:	4551      	cmp	r1, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    4a44:	bf9f      	itttt	ls
    4a46:	f1a3 73e8 	subls.w	r3, r3, #30408704	; 0x1d00000
    4a4a:	f5a3 33d4 	subls.w	r3, r3, #108544	; 0x1a800
    4a4e:	f5a3 73a5 	subls.w	r3, r3, #330	; 0x14a
    4a52:	626b      	strls	r3, [r5, #36]	; 0x24
		return 1;
    4a54:	bf92      	itee	ls
    4a56:	9b01      	ldrls	r3, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
    4a58:	626b      	strhi	r3, [r5, #36]	; 0x24
	return 0;
    4a5a:	2300      	movhi	r3, #0
						ticks_to_expire +=
    4a5c:	4473      	add	r3, lr
    4a5e:	441a      	add	r2, r3
						lazy++;
    4a60:	f108 0801 	add.w	r8, r8, #1
					while (ticks_to_expire <
    4a64:	4593      	cmp	fp, r2
    4a66:	fa1f f388 	uxth.w	r3, r8
    4a6a:	d8e3      	bhi.n	4a34 <ticker_job+0x348>
    4a6c:	e7da      	b.n	4a24 <ticker_job+0x338>
    4a6e:	4698      	mov	r8, r3
    4a70:	e7f8      	b.n	4a64 <ticker_job+0x378>
			if (state && ((state == 1U) || skip_collision) &&
    4a72:	b14b      	cbz	r3, 4a88 <ticker_job+0x39c>
    4a74:	2b01      	cmp	r3, #1
    4a76:	d002      	beq.n	4a7e <ticker_job+0x392>
    4a78:	f1bc 0f00 	cmp.w	ip, #0
    4a7c:	d004      	beq.n	4a88 <ticker_job+0x39c>
			    ticker->fp_op_func) {
    4a7e:	6a2b      	ldr	r3, [r5, #32]
			if (state && ((state == 1U) || skip_collision) &&
    4a80:	b113      	cbz	r3, 4a88 <ticker_job+0x39c>
				ticker->fp_op_func(TICKER_STATUS_FAILURE,
    4a82:	6a69      	ldr	r1, [r5, #36]	; 0x24
    4a84:	2001      	movs	r0, #1
    4a86:	4798      	blx	r3
			ticker->req = ticker->ack;
    4a88:	78ab      	ldrb	r3, [r5, #2]
    4a8a:	706b      	strb	r3, [r5, #1]
    4a8c:	464e      	mov	r6, r9
    4a8e:	e7a2      	b.n	49d6 <ticker_job+0x2ea>
			ticker = &nodes[ticker_id_head];
    4a90:	eb07 0247 	add.w	r2, r7, r7, lsl #1
    4a94:	0111      	lsls	r1, r2, #4
    4a96:	eb05 1202 	add.w	r2, r5, r2, lsl #4
			ext_data = ticker->ext_data;
    4a9a:	f815 e001 	ldrb.w	lr, [r5, r1]
    4a9e:	6a96      	ldr	r6, [r2, #40]	; 0x28
			if (ext_data && ext_data->reschedule_state ==
    4aa0:	b11e      	cbz	r6, 4aaa <ticker_job+0x3be>
    4aa2:	7a31      	ldrb	r1, [r6, #8]
    4aa4:	2901      	cmp	r1, #1
    4aa6:	f000 816d 	beq.w	4d84 <ticker_job+0x698>
			ticker_id_head = ticker->next;
    4aaa:	4677      	mov	r7, lr
		while (ticker_id_head != TICKER_NULL) {
    4aac:	2fff      	cmp	r7, #255	; 0xff
    4aae:	d1ef      	bne.n	4a90 <ticker_job+0x3a4>
			flag_compare_update = 1U;
    4ab0:	2b00      	cmp	r3, #0
    4ab2:	9a02      	ldr	r2, [sp, #8]
    4ab4:	bf18      	it	ne
    4ab6:	461a      	movne	r2, r3
    4ab8:	9202      	str	r2, [sp, #8]
    4aba:	e086      	b.n	4bca <ticker_job+0x4de>
    4abc:	ff172b5a 	.word	0xff172b5a
    4ac0:	7f172b59 	.word	0x7f172b59
			instance->ticks_slot_previous > ticks_elapsed) {
    4ac4:	69a0      	ldr	r0, [r4, #24]
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    4ac6:	9b00      	ldr	r3, [sp, #0]
    4ac8:	4283      	cmp	r3, r0
    4aca:	f080 815f 	bcs.w	4d8c <ticker_job+0x6a0>
			window_start_ticks = instance->ticks_slot_previous -
    4ace:	1ac3      	subs	r3, r0, r3
		window_start_ticks = 0U;
    4ad0:	9301      	str	r3, [sp, #4]
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
    4ad2:	e9d6 3a00 	ldrd	r3, sl, [r6]
    4ad6:	459a      	cmp	sl, r3
    4ad8:	d25b      	bcs.n	4b92 <ticker_job+0x4a6>
			ticks_slot_window = ext_data->ticks_slot_window -
    4ada:	f04f 0c00 	mov.w	ip, #0
    4ade:	eba3 0b0a 	sub.w	fp, r3, sl
		ticker_id_iter = nodes[ticker_id_head].next;
    4ae2:	4671      	mov	r1, lr
			ticks_slot_window = ext_data->ticks_slot_window -
    4ae4:	4663      	mov	r3, ip
		while (ticker_id_iter != TICKER_NULL &&
    4ae6:	29ff      	cmp	r1, #255	; 0xff
    4ae8:	d006      	beq.n	4af8 <ticker_job+0x40c>
		       ticks_start_offset + ticker->ticks_slot <=
    4aea:	f8d2 8018 	ldr.w	r8, [r2, #24]
    4aee:	eb0c 0008 	add.w	r0, ip, r8
		while (ticker_id_iter != TICKER_NULL &&
    4af2:	4583      	cmp	fp, r0
		       ticks_start_offset + ticker->ticks_slot <=
    4af4:	9006      	str	r0, [sp, #24]
		while (ticker_id_iter != TICKER_NULL &&
    4af6:	d21c      	bcs.n	4b32 <ticker_job+0x446>
		ticker->ext_data->ticks_drift += ticks_to_expire -
    4af8:	6891      	ldr	r1, [r2, #8]
    4afa:	ebaa 0101 	sub.w	r1, sl, r1
    4afe:	4419      	add	r1, r3
    4b00:	6071      	str	r1, [r6, #4]
		ticker->ticks_to_expire = ticks_to_expire;
    4b02:	6093      	str	r3, [r2, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
    4b04:	4671      	mov	r1, lr
		ticker_id_prev = TICKER_NULL;
    4b06:	23ff      	movs	r3, #255	; 0xff
		while (ticker_id_iter != TICKER_NULL) {
    4b08:	29ff      	cmp	r1, #255	; 0xff
    4b0a:	d047      	beq.n	4b9c <ticker_job+0x4b0>
			node = &nodes[ticker_id_iter];
    4b0c:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    4b10:	ea4f 1900 	mov.w	r9, r0, lsl #4
    4b14:	eb05 1000 	add.w	r0, r5, r0, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
    4b18:	f8d2 8008 	ldr.w	r8, [r2, #8]
    4b1c:	f8d0 c008 	ldr.w	ip, [r0, #8]
    4b20:	45e0      	cmp	r8, ip
    4b22:	d938      	bls.n	4b96 <ticker_job+0x4aa>
				ticker->ticks_to_expire -=
    4b24:	eba8 030c 	sub.w	r3, r8, ip
    4b28:	6093      	str	r3, [r2, #8]
			ticker_id_iter = node->next;
    4b2a:	460b      	mov	r3, r1
    4b2c:	f815 1009 	ldrb.w	r1, [r5, r9]
    4b30:	e7ea      	b.n	4b08 <ticker_job+0x41c>
			node = &nodes[ticker_id_iter];
    4b32:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    4b36:	0108      	lsls	r0, r1, #4
    4b38:	eb05 1101 	add.w	r1, r5, r1, lsl #4
    4b3c:	9004      	str	r0, [sp, #16]
			if (node->ext_data &&
    4b3e:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
    4b42:	f1b9 0f00 	cmp.w	r9, #0
    4b46:	d007      	beq.n	4b58 <ticker_job+0x46c>
    4b48:	f899 9008 	ldrb.w	r9, [r9, #8]
    4b4c:	f1b9 0f01 	cmp.w	r9, #1
    4b50:	d102      	bne.n	4b58 <ticker_job+0x46c>
				ticker_id_iter = node->next;
    4b52:	4601      	mov	r1, r0
			ticker_id_iter = node->next;
    4b54:	5c69      	ldrb	r1, [r5, r1]
    4b56:	e7c6      	b.n	4ae6 <ticker_job+0x3fa>
			if (node->ticks_to_expire >
    4b58:	f8d1 9008 	ldr.w	r9, [r1, #8]
    4b5c:	f1b9 0f04 	cmp.w	r9, #4
    4b60:	d90e      	bls.n	4b80 <ticker_job+0x494>
					MIN(ticks_slot_window,
    4b62:	f1ac 0304 	sub.w	r3, ip, #4
    4b66:	444b      	add	r3, r9
				window_end_ticks =
    4b68:	455b      	cmp	r3, fp
			if (window_end_ticks > ticks_start_offset +
    4b6a:	9806      	ldr	r0, [sp, #24]
				window_end_ticks =
    4b6c:	bf28      	it	cs
    4b6e:	465b      	movcs	r3, fp
			if (window_end_ticks > ticks_start_offset +
    4b70:	4283      	cmp	r3, r0
    4b72:	d905      	bls.n	4b80 <ticker_job+0x494>
			if (ticks_to_expire != 0U &&
    4b74:	ebb3 0308 	subs.w	r3, r3, r8
    4b78:	d002      	beq.n	4b80 <ticker_job+0x494>
    4b7a:	9801      	ldr	r0, [sp, #4]
    4b7c:	4283      	cmp	r3, r0
    4b7e:	d2bb      	bcs.n	4af8 <ticker_job+0x40c>
			window_start_ticks  = node->ticks_to_expire +
    4b80:	6988      	ldr	r0, [r1, #24]
			ticker_id_iter = node->next;
    4b82:	9904      	ldr	r1, [sp, #16]
			window_start_ticks  = node->ticks_to_expire +
    4b84:	eb00 0309 	add.w	r3, r0, r9
    4b88:	9301      	str	r3, [sp, #4]
			ticks_start_offset += node->ticks_to_expire;
    4b8a:	44cc      	add	ip, r9
			ticks_to_expire     = ticks_slot_window -
    4b8c:	ebab 0308 	sub.w	r3, fp, r8
			ticker_id_iter = node->next;
    4b90:	e7e0      	b.n	4b54 <ticker_job+0x468>
    4b92:	2300      	movs	r3, #0
    4b94:	e7b0      	b.n	4af8 <ticker_job+0x40c>
				node->ticks_to_expire -=
    4b96:	ebac 0108 	sub.w	r1, ip, r8
    4b9a:	6081      	str	r1, [r0, #8]
		if (ticker_id_prev != TICKER_NULL) {
    4b9c:	2bff      	cmp	r3, #255	; 0xff
    4b9e:	d008      	beq.n	4bb2 <ticker_job+0x4c6>
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
    4ba0:	b21b      	sxth	r3, r3
    4ba2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    4ba6:	011b      	lsls	r3, r3, #4
			instance->ticker_id_head = nodes[ticker_id_head].next;
    4ba8:	f884 e01d 	strb.w	lr, [r4, #29]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
    4bac:	5ce9      	ldrb	r1, [r5, r3]
    4bae:	7011      	strb	r1, [r2, #0]
			nodes[ticker_id_prev].next = ticker_id_head;
    4bb0:	54ef      	strb	r7, [r5, r3]
		ticker->lazy_current--;
    4bb2:	8bd3      	ldrh	r3, [r2, #30]
    4bb4:	3b01      	subs	r3, #1
    4bb6:	83d3      	strh	r3, [r2, #30]
		ext_data->reschedule_state =
    4bb8:	f04f 0302 	mov.w	r3, #2
    4bbc:	7233      	strb	r3, [r6, #8]
		rescheduled  = 1U;
    4bbe:	2301      	movs	r3, #1
    4bc0:	e606      	b.n	47d0 <ticker_job+0xe4>
		ticker_job_list_insert(instance, insert_head);
    4bc2:	4649      	mov	r1, r9
    4bc4:	4620      	mov	r0, r4
    4bc6:	f009 f9d0 	bl	df6a <ticker_job_list_insert>
	if (instance->ticker_id_head != ticker_id_old_head) {
    4bca:	7f63      	ldrb	r3, [r4, #29]
    4bcc:	9a03      	ldr	r2, [sp, #12]
    4bce:	4293      	cmp	r3, r2
	if (!pending) {
    4bd0:	9b05      	ldr	r3, [sp, #20]
	if (instance->ticker_id_head != ticker_id_old_head) {
    4bd2:	f040 80d1 	bne.w	4d78 <ticker_job+0x68c>
	if (!pending) {
    4bd6:	b93b      	cbnz	r3, 4be8 <ticker_job+0x4fc>
	users = &instance->users[0];
    4bd8:	7a65      	ldrb	r5, [r4, #9]
    4bda:	6863      	ldr	r3, [r4, #4]
    4bdc:	9300      	str	r3, [sp, #0]
	while (count_user--) {
    4bde:	3d01      	subs	r5, #1
    4be0:	b2ed      	uxtb	r5, r5
		uop->status = TICKER_STATUS_SUCCESS;
    4be2:	2700      	movs	r7, #0
	while (count_user--) {
    4be4:	2dff      	cmp	r5, #255	; 0xff
    4be6:	d116      	bne.n	4c16 <ticker_job+0x52a>
	if (flag_compare_update) {
    4be8:	9b02      	ldr	r3, [sp, #8]
    4bea:	b14b      	cbz	r3, 4c00 <ticker_job+0x514>
	if (instance->ticker_id_head == TICKER_NULL) {
    4bec:	7f63      	ldrb	r3, [r4, #29]
    4bee:	2bff      	cmp	r3, #255	; 0xff
    4bf0:	d179      	bne.n	4ce6 <ticker_job+0x5fa>
		if (cntr_stop() == 0) {
    4bf2:	f003 fa5b 	bl	80ac <cntr_stop>
    4bf6:	b918      	cbnz	r0, 4c00 <ticker_job+0x514>
			instance->ticks_slot_previous = 0U;
    4bf8:	61a0      	str	r0, [r4, #24]
			instance->ticks_current = cntr_cnt_get();
    4bfa:	f003 fa7d 	bl	80f8 <cntr_cnt_get>
    4bfe:	6160      	str	r0, [r4, #20]
	instance->job_guard = 0U;
    4c00:	2300      	movs	r3, #0
    4c02:	77a3      	strb	r3, [r4, #30]
	if (instance->worker_trigger) {
    4c04:	7fe3      	ldrb	r3, [r4, #31]
    4c06:	2b00      	cmp	r3, #0
    4c08:	f000 8135 	beq.w	4e76 <ticker_job+0x78a>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    4c0c:	6a65      	ldr	r5, [r4, #36]	; 0x24
    4c0e:	4623      	mov	r3, r4
    4c10:	2201      	movs	r2, #1
    4c12:	2103      	movs	r1, #3
    4c14:	e578      	b.n	4708 <ticker_job+0x1c>
		user = &users[count_user];
    4c16:	9b00      	ldr	r3, [sp, #0]
    4c18:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
    4c1c:	f8d6 8004 	ldr.w	r8, [r6, #4]
		while (user->first != user->last) {
    4c20:	7873      	ldrb	r3, [r6, #1]
    4c22:	78f2      	ldrb	r2, [r6, #3]
    4c24:	429a      	cmp	r2, r3
    4c26:	d102      	bne.n	4c2e <ticker_job+0x542>
    4c28:	3d01      	subs	r5, #1
    4c2a:	b2ed      	uxtb	r5, r5
    4c2c:	e7da      	b.n	4be4 <ticker_job+0x4f8>
			ticker_job_op_inquire(instance, &user_op[user->first]);
    4c2e:	2234      	movs	r2, #52	; 0x34
    4c30:	fb13 f202 	smulbb	r2, r3, r2
    4c34:	eb08 0302 	add.w	r3, r8, r2
	switch (uop->op) {
    4c38:	f818 2002 	ldrb.w	r2, [r8, r2]
    4c3c:	2a02      	cmp	r2, #2
    4c3e:	d012      	beq.n	4c66 <ticker_job+0x57a>
    4c40:	2a03      	cmp	r2, #3
    4c42:	d040      	beq.n	4cc6 <ticker_job+0x5da>
    4c44:	2a01      	cmp	r2, #1
    4c46:	d105      	bne.n	4c54 <ticker_job+0x568>
			uop->status = TICKER_STATUS_SUCCESS;
    4c48:	629f      	str	r7, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
    4c4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	if (fp_op_func) {
    4c4c:	b112      	cbz	r2, 4c54 <ticker_job+0x568>
		fp_op_func(uop->status, uop->op_context);
    4c4e:	6b19      	ldr	r1, [r3, #48]	; 0x30
    4c50:	6a98      	ldr	r0, [r3, #40]	; 0x28
    4c52:	4790      	blx	r2
			first = user->first + 1;
    4c54:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
    4c56:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
    4c58:	3301      	adds	r3, #1
    4c5a:	b2db      	uxtb	r3, r3
				first = 0U;
    4c5c:	429a      	cmp	r2, r3
    4c5e:	bf08      	it	eq
    4c60:	2300      	moveq	r3, #0
			user->first = first;
    4c62:	7073      	strb	r3, [r6, #1]
    4c64:	e7dc      	b.n	4c20 <ticker_job+0x534>
		ticker_by_next_slot_get(instance,
    4c66:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
    4c6a:	f899 2000 	ldrb.w	r2, [r9]
		ticker_by_next_slot_get(instance,
    4c6e:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
    4c72:	f8d4 c000 	ldr.w	ip, [r4]
	    (*ticks_current != instance->ticks_current)) {
    4c76:	6961      	ldr	r1, [r4, #20]
	if ((_ticker_id_head == TICKER_NULL) ||
    4c78:	2aff      	cmp	r2, #255	; 0xff
    4c7a:	d003      	beq.n	4c84 <ticker_job+0x598>
    4c7c:	f8d0 a000 	ldr.w	sl, [r0]
    4c80:	4551      	cmp	r1, sl
    4c82:	d009      	beq.n	4c98 <ticker_job+0x5ac>
		_ticker_id_head = instance->ticker_id_head;
    4c84:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
    4c86:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
    4c88:	2000      	movs	r0, #0
	while (_ticker_id_head != TICKER_NULL) {
    4c8a:	2aff      	cmp	r2, #255	; 0xff
    4c8c:	d10c      	bne.n	4ca8 <ticker_job+0x5bc>
	*ticker_id_head = _ticker_id_head;
    4c8e:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
    4c92:	f8ce 0000 	str.w	r0, [lr]
}
    4c96:	e7d7      	b.n	4c48 <ticker_job+0x55c>
		ticker = &node[_ticker_id_head];
    4c98:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    4c9c:	0112      	lsls	r2, r2, #4
	_ticks_to_expire = *ticks_to_expire;
    4c9e:	f8de 0000 	ldr.w	r0, [lr]
		_ticker_id_head = ticker->next;
    4ca2:	f81c 2002 	ldrb.w	r2, [ip, r2]
    4ca6:	e7f0      	b.n	4c8a <ticker_job+0x59e>
		ticker = &node[_ticker_id_head];
    4ca8:	eb02 0142 	add.w	r1, r2, r2, lsl #1
    4cac:	ea4f 1b01 	mov.w	fp, r1, lsl #4
    4cb0:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
		_ticks_to_expire += ticker->ticks_to_expire;
    4cb4:	f8d1 a008 	ldr.w	sl, [r1, #8]
			if (ticker->ticks_slot) {
    4cb8:	6989      	ldr	r1, [r1, #24]
		_ticks_to_expire += ticker->ticks_to_expire;
    4cba:	4450      	add	r0, sl
			if (ticker->ticks_slot) {
    4cbc:	2900      	cmp	r1, #0
    4cbe:	d1e6      	bne.n	4c8e <ticker_job+0x5a2>
		_ticker_id_head = ticker->next;
    4cc0:	f81c 200b 	ldrb.w	r2, [ip, fp]
    4cc4:	e7e1      	b.n	4c8a <ticker_job+0x59e>
		if (uop->id < instance->count_node) {
    4cc6:	785a      	ldrb	r2, [r3, #1]
    4cc8:	7a21      	ldrb	r1, [r4, #8]
    4cca:	4291      	cmp	r1, r2
    4ccc:	d908      	bls.n	4ce0 <ticker_job+0x5f4>
			node[uop->id].priority =
    4cce:	6821      	ldr	r1, [r4, #0]
    4cd0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    4cd4:	eb01 1202 	add.w	r2, r1, r2, lsl #4
    4cd8:	7919      	ldrb	r1, [r3, #4]
    4cda:	f882 102d 	strb.w	r1, [r2, #45]	; 0x2d
    4cde:	e7b3      	b.n	4c48 <ticker_job+0x55c>
			uop->status = TICKER_STATUS_FAILURE;
    4ce0:	2201      	movs	r2, #1
    4ce2:	629a      	str	r2, [r3, #40]	; 0x28
    4ce4:	e7b1      	b.n	4c4a <ticker_job+0x55e>
	if (ticker_id_old_head == TICKER_NULL) {
    4ce6:	9b03      	ldr	r3, [sp, #12]
    4ce8:	2bff      	cmp	r3, #255	; 0xff
    4cea:	d106      	bne.n	4cfa <ticker_job+0x60e>
		ticks_current = cntr_cnt_get();
    4cec:	f003 fa04 	bl	80f8 <cntr_cnt_get>
    4cf0:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
    4cf2:	f003 f9cd 	bl	8090 <cntr_start>
    4cf6:	b900      	cbnz	r0, 4cfa <ticker_job+0x60e>
			instance->ticks_current = ticks_current;
    4cf8:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
    4cfa:	7f63      	ldrb	r3, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
    4cfc:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
    4cfe:	f8df 817c 	ldr.w	r8, [pc, #380]	; 4e7c <ticker_job+0x790>
    4d02:	f8df 917c 	ldr.w	r9, [pc, #380]	; 4e80 <ticker_job+0x794>
    4d06:	f8df a17c 	ldr.w	sl, [pc, #380]	; 4e84 <ticker_job+0x798>
	ticker = &instance->nodes[instance->ticker_id_head];
    4d0a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	ticks_to_expire = ticker->ticks_to_expire;
    4d0e:	eb02 1303 	add.w	r3, r2, r3, lsl #4
	i = 10U;
    4d12:	260a      	movs	r6, #10
	ticks_to_expire = ticker->ticks_to_expire;
    4d14:	689f      	ldr	r7, [r3, #8]
		ctr = cntr_cnt_get();
    4d16:	f003 f9ef 	bl	80f8 <cntr_cnt_get>
		cc = instance->ticks_current;
    4d1a:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4d1c:	1b43      	subs	r3, r0, r5
    4d1e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
    4d22:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
    4d24:	42bb      	cmp	r3, r7
    4d26:	bf2c      	ite	cs
    4d28:	18ed      	addcs	r5, r5, r3
    4d2a:	19ed      	addcc	r5, r5, r7
		cc &= HAL_TICKER_CNTR_MASK;
    4d2c:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
    4d30:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		ctr = cntr_cnt_get();
    4d32:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
    4d34:	4628      	mov	r0, r5
    4d36:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
    4d38:	f003 f9de 	bl	80f8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4d3c:	eba0 030b 	sub.w	r3, r0, fp
    4d40:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    4d44:	eba5 050b 	sub.w	r5, r5, fp
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
    4d48:	3303      	adds	r3, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4d4a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
    4d4e:	42ab      	cmp	r3, r5
		i--;
    4d50:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
    4d54:	f67f af54 	bls.w	4c00 <ticker_job+0x514>
		LL_ASSERT(i);
    4d58:	2e00      	cmp	r6, #0
    4d5a:	d1dc      	bne.n	4d16 <ticker_job+0x62a>
    4d5c:	f640 133e 	movw	r3, #2366	; 0x93e
    4d60:	4642      	mov	r2, r8
    4d62:	4649      	mov	r1, r9
    4d64:	4650      	mov	r0, sl
    4d66:	f008 f84a 	bl	cdfe <printk>
    4d6a:	4040      	eors	r0, r0
    4d6c:	f380 8811 	msr	BASEPRI, r0
    4d70:	f04f 0003 	mov.w	r0, #3
    4d74:	df02      	svc	2
    4d76:	e7ce      	b.n	4d16 <ticker_job+0x62a>
	if (!pending) {
    4d78:	2b00      	cmp	r3, #0
    4d7a:	f47f af37 	bne.w	4bec <ticker_job+0x500>
		flag_compare_update = 1U;
    4d7e:	2301      	movs	r3, #1
    4d80:	9302      	str	r3, [sp, #8]
    4d82:	e729      	b.n	4bd8 <ticker_job+0x4ec>
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    4d84:	7f23      	ldrb	r3, [r4, #28]
    4d86:	2bff      	cmp	r3, #255	; 0xff
    4d88:	f47f ae9c 	bne.w	4ac4 <ticker_job+0x3d8>
		window_start_ticks = 0U;
    4d8c:	2300      	movs	r3, #0
    4d8e:	e69f      	b.n	4ad0 <ticker_job+0x3e4>
			if (state == 1U) {
    4d90:	2b01      	cmp	r3, #1
    4d92:	f43f ada8 	beq.w	48e6 <ticker_job+0x1fa>
				instance->sched_cb(TICKER_CALL_ID_JOB,
    4d96:	2104      	movs	r1, #4
    4d98:	4623      	mov	r3, r4
    4d9a:	6a65      	ldr	r5, [r4, #36]	; 0x24
    4d9c:	2201      	movs	r2, #1
    4d9e:	4608      	mov	r0, r1
    4da0:	47a8      	blx	r5
				pending = 1U;
    4da2:	2301      	movs	r3, #1
				user->middle = prev;
    4da4:	f888 7002 	strb.w	r7, [r8, #2]
				pending = 1U;
    4da8:	9305      	str	r3, [sp, #20]
    4daa:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    4dae:	fa5f fb83 	uxtb.w	fp, r3
    4db2:	e4d6      	b.n	4762 <ticker_job+0x76>
			if (state == 1U) {
    4db4:	2b01      	cmp	r3, #1
    4db6:	d1ee      	bne.n	4d96 <ticker_job+0x6aa>
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
    4db8:	4620      	mov	r0, r4
    4dba:	f009 f883 	bl	dec4 <ticker_dequeue>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
    4dbe:	6963      	ldr	r3, [r4, #20]
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
    4dc0:	60a8      	str	r0, [r5, #8]
    4dc2:	4607      	mov	r7, r0
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
    4dc4:	9307      	str	r3, [sp, #28]
	ticks_now = cntr_cnt_get();
    4dc6:	f003 f997 	bl	80f8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4dca:	9b07      	ldr	r3, [sp, #28]
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    4dcc:	9900      	ldr	r1, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4dce:	1ac3      	subs	r3, r0, r3
    4dd0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    4dd4:	440b      	add	r3, r1
	if (ticks_to_expire > ticks_elapsed) {
    4dd6:	429f      	cmp	r7, r3
		ticker->ticks_to_expire_minus += ticks_elapsed -
    4dd8:	bf98      	it	ls
    4dda:	6969      	ldrls	r1, [r5, #20]
	ticks_now = cntr_cnt_get();
    4ddc:	4602      	mov	r2, r0
		ticker->ticks_to_expire_minus += ticks_elapsed -
    4dde:	bf98      	it	ls
    4de0:	1bc9      	subls	r1, r1, r7
	if ((ticker->ticks_periodic != 0U) &&
    4de2:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
    4de4:	bf9b      	ittet	ls
    4de6:	185b      	addls	r3, r3, r1
    4de8:	616b      	strls	r3, [r5, #20]
		ticks_to_expire -= ticks_elapsed;
    4dea:	1afb      	subhi	r3, r7, r3
		ticks_to_expire = 0U;
    4dec:	2300      	movls	r3, #0
	if ((ticker->ticks_periodic != 0U) &&
    4dee:	b1a8      	cbz	r0, 4e1c <ticker_job+0x730>
	    (user_op->params.update.lazy != 0U)) {
    4df0:	8ab1      	ldrh	r1, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
    4df2:	b199      	cbz	r1, 4e1c <ticker_job+0x730>
		user_op->params.update.lazy--;
    4df4:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
    4df8:	fa1f fc8c 	uxth.w	ip, ip
    4dfc:	f8a6 c014 	strh.w	ip, [r6, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    4e00:	4298      	cmp	r0, r3
		       (ticker->lazy_current > user_op->params.update.lazy)) {
    4e02:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    4e06:	d202      	bcs.n	4e0e <ticker_job+0x722>
    4e08:	45e6      	cmp	lr, ip
    4e0a:	f63f ad32 	bhi.w	4872 <ticker_job+0x186>
		while (ticker->lazy_current < user_op->params.update.lazy) {
    4e0e:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
    4e12:	45f4      	cmp	ip, lr
    4e14:	f63f ad4c 	bhi.w	48b0 <ticker_job+0x1c4>
		ticker->lazy_periodic = user_op->params.update.lazy;
    4e18:	f8a5 c01c 	strh.w	ip, [r5, #28]
				  user_op->params.update.ticks_drift_plus;
    4e1c:	6871      	ldr	r1, [r6, #4]
				user_op->params.update.ticks_drift_minus;
    4e1e:	68b0      	ldr	r0, [r6, #8]
	struct ticker_ext *ext_data = ticker->ext_data;
    4e20:	6aaf      	ldr	r7, [r5, #40]	; 0x28
	ticker->ticks_to_expire = ticks_to_expire +
    4e22:	440b      	add	r3, r1
    4e24:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus +=
    4e26:	696b      	ldr	r3, [r5, #20]
    4e28:	4403      	add	r3, r0
    4e2a:	616b      	str	r3, [r5, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
    4e2c:	b11f      	cbz	r7, 4e36 <ticker_job+0x74a>
    4e2e:	683b      	ldr	r3, [r7, #0]
    4e30:	b10b      	cbz	r3, 4e36 <ticker_job+0x74a>
			user_op->params.update.ticks_drift_plus -
    4e32:	1a09      	subs	r1, r1, r0
		ext_data->ticks_drift =
    4e34:	6079      	str	r1, [r7, #4]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
    4e36:	9907      	ldr	r1, [sp, #28]
    4e38:	4628      	mov	r0, r5
    4e3a:	f009 f86e 	bl	df1a <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
    4e3e:	68f2      	ldr	r2, [r6, #12]
    4e40:	69ab      	ldr	r3, [r5, #24]
    4e42:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
    4e44:	6932      	ldr	r2, [r6, #16]
    4e46:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
    4e48:	bf8c      	ite	hi
    4e4a:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
    4e4c:	2300      	movls	r3, #0
    4e4e:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
    4e50:	7db3      	ldrb	r3, [r6, #22]
    4e52:	b103      	cbz	r3, 4e56 <ticker_job+0x76a>
		ticker->force = user_op->params.update.force;
    4e54:	70eb      	strb	r3, [r5, #3]
	if (user_op->params.update.must_expire) {
    4e56:	7df3      	ldrb	r3, [r6, #23]
    4e58:	b113      	cbz	r3, 4e60 <ticker_job+0x774>
		ticker->must_expire = (user_op->params.update.must_expire - 1);
    4e5a:	3b01      	subs	r3, #1
    4e5c:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
	ticker->next = *insert_head;
    4e60:	9b02      	ldr	r3, [sp, #8]
    4e62:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4e64:	f803 9002 	strb.w	r9, [r3, r2]
		ticker->req++;
    4e68:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
    4e6a:	f896 9001 	ldrb.w	r9, [r6, #1]
		ticker->req++;
    4e6e:	3301      	adds	r3, #1
    4e70:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    4e72:	2100      	movs	r1, #0
    4e74:	e4f9      	b.n	486a <ticker_job+0x17e>
}
    4e76:	b00b      	add	sp, #44	; 0x2c
    4e78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4e7c:	000113df 	.word	0x000113df
    4e80:	00011569 	.word	0x00011569
    4e84:	00010f78 	.word	0x00010f78

00004e88 <ticker_init>:
{
    4e88:	b5f0      	push	{r4, r5, r6, r7, lr}
    4e8a:	9f05      	ldr	r7, [sp, #20]
    4e8c:	f89d 5018 	ldrb.w	r5, [sp, #24]
    4e90:	f8dd c01c 	ldr.w	ip, [sp, #28]
	if (instance_index >= TICKER_INSTANCE_MAX) {
    4e94:	b108      	cbz	r0, 4e9a <ticker_init+0x12>
		return TICKER_STATUS_FAILURE;
    4e96:	2001      	movs	r0, #1
}
    4e98:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
    4e9a:	4c18      	ldr	r4, [pc, #96]	; (4efc <ticker_init+0x74>)
    4e9c:	7221      	strb	r1, [r4, #8]
	instance->nodes = node;
    4e9e:	6022      	str	r2, [r4, #0]
	while (count_node--) {
    4ea0:	3901      	subs	r1, #1
    4ea2:	b2c9      	uxtb	r1, r1
    4ea4:	29ff      	cmp	r1, #255	; 0xff
    4ea6:	d116      	bne.n	4ed6 <ticker_init+0x4e>
	instance->count_user = count_user;
    4ea8:	7263      	strb	r3, [r4, #9]
	instance->users = user;
    4eaa:	6067      	str	r7, [r4, #4]
		user_op_ += users[count_user].count_user_op;
    4eac:	2234      	movs	r2, #52	; 0x34
	while (count_user--) {
    4eae:	3b01      	subs	r3, #1
    4eb0:	b2db      	uxtb	r3, r3
    4eb2:	2bff      	cmp	r3, #255	; 0xff
    4eb4:	d116      	bne.n	4ee4 <ticker_init+0x5c>
	if (count_op) {
    4eb6:	2d00      	cmp	r5, #0
    4eb8:	d1ed      	bne.n	4e96 <ticker_init+0xe>
	instance->caller_id_get_cb = caller_id_get_cb;
    4eba:	9b08      	ldr	r3, [sp, #32]
    4ebc:	6223      	str	r3, [r4, #32]
	instance->sched_cb = sched_cb;
    4ebe:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4ec0:	6263      	str	r3, [r4, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
    4ec2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4ec4:	62a3      	str	r3, [r4, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
    4ec6:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
    4eca:	e9c4 5505 	strd	r5, r5, [r4, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
    4ece:	83a3      	strh	r3, [r4, #28]
	instance->ticks_elapsed_first = 0U;
    4ed0:	8165      	strh	r5, [r4, #10]
	return TICKER_STATUS_SUCCESS;
    4ed2:	4628      	mov	r0, r5
    4ed4:	e7e0      	b.n	4e98 <ticker_init+0x10>
		instance->nodes[count_node].priority = 0;
    4ed6:	eb01 0641 	add.w	r6, r1, r1, lsl #1
    4eda:	eb02 1606 	add.w	r6, r2, r6, lsl #4
    4ede:	f886 002d 	strb.w	r0, [r6, #45]	; 0x2d
    4ee2:	e7dd      	b.n	4ea0 <ticker_init+0x18>
		users[count_user].user_op = user_op_;
    4ee4:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
    4ee8:	f8c1 c004 	str.w	ip, [r1, #4]
		user_op_ += users[count_user].count_user_op;
    4eec:	f817 0033 	ldrb.w	r0, [r7, r3, lsl #3]
		count_op -= users[count_user].count_user_op;
    4ef0:	1a2d      	subs	r5, r5, r0
		user_op_ += users[count_user].count_user_op;
    4ef2:	fb00 cc02 	mla	ip, r0, r2, ip
		count_op -= users[count_user].count_user_op;
    4ef6:	b2ed      	uxtb	r5, r5
    4ef8:	e7d9      	b.n	4eae <ticker_init+0x26>
    4efa:	bf00      	nop
    4efc:	20001190 	.word	0x20001190

00004f00 <ticker_trigger>:
	if (instance->sched_cb) {
    4f00:	4b07      	ldr	r3, [pc, #28]	; (4f20 <ticker_trigger+0x20>)
    4f02:	222c      	movs	r2, #44	; 0x2c
    4f04:	fb02 3100 	mla	r1, r2, r0, r3
{
    4f08:	b410      	push	{r4}
	if (instance->sched_cb) {
    4f0a:	6a4c      	ldr	r4, [r1, #36]	; 0x24
    4f0c:	b134      	cbz	r4, 4f1c <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    4f0e:	460b      	mov	r3, r1
    4f10:	46a4      	mov	ip, r4
    4f12:	2201      	movs	r2, #1
}
    4f14:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    4f16:	2103      	movs	r1, #3
    4f18:	2002      	movs	r0, #2
    4f1a:	4760      	bx	ip
}
    4f1c:	bc10      	pop	{r4}
    4f1e:	4770      	bx	lr
    4f20:	20001190 	.word	0x20001190

00004f24 <ticker_start_ext>:
{
    4f24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4f28:	4606      	mov	r6, r0
    4f2a:	4608      	mov	r0, r1
    4f2c:	4611      	mov	r1, r2
    4f2e:	461a      	mov	r2, r3
	struct ticker_instance *instance = &_instance[instance_index];
    4f30:	4b22      	ldr	r3, [pc, #136]	; (4fbc <ticker_start_ext+0x98>)
    4f32:	242c      	movs	r4, #44	; 0x2c
    4f34:	fb06 3904 	mla	r9, r6, r4, r3
	user = &instance->users[user_id];
    4f38:	f8d9 3004 	ldr.w	r3, [r9, #4]
    4f3c:	eb03 0cc0 	add.w	ip, r3, r0, lsl #3
	if (last >= user->count_user_op) {
    4f40:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
    4f44:	f89c 7003 	ldrb.w	r7, [ip, #3]
    4f48:	1c7d      	adds	r5, r7, #1
    4f4a:	b2ed      	uxtb	r5, r5
		last = 0U;
    4f4c:	42ab      	cmp	r3, r5
    4f4e:	bf98      	it	ls
    4f50:	2500      	movls	r5, #0
	if (last == user->first) {
    4f52:	f89c 3001 	ldrb.w	r3, [ip, #1]
    4f56:	42ab      	cmp	r3, r5
    4f58:	d02e      	beq.n	4fb8 <ticker_start_ext+0x94>
	user_op = &user->user_op[user->last];
    4f5a:	2334      	movs	r3, #52	; 0x34
    4f5c:	fb17 f703 	smulbb	r7, r7, r3
    4f60:	f8dc 3004 	ldr.w	r3, [ip, #4]
	user_op->op = TICKER_USER_OP_TYPE_START;
    4f64:	f04f 0804 	mov.w	r8, #4
	user_op = &user->user_op[user->last];
    4f68:	19dc      	adds	r4, r3, r7
	user_op->op = TICKER_USER_OP_TYPE_START;
    4f6a:	f803 8007 	strb.w	r8, [r3, r7]
	user_op->params.start.ticks_first = ticks_first;
    4f6e:	9b08      	ldr	r3, [sp, #32]
    4f70:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
    4f72:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4f74:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
    4f76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4f78:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
    4f7a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4f7c:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
    4f7e:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    4f82:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.ext_data = ext_data;
    4f84:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4f86:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
    4f88:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4f8a:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
    4f8c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4f8e:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
    4f90:	2302      	movs	r3, #2
    4f92:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    4f94:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    4f96:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    4f98:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
    4f9a:	7061      	strb	r1, [r4, #1]
	user_op->params.start.ticks_at_start = ticks_anchor;
    4f9c:	6062      	str	r2, [r4, #4]
	user_op->op_context = op_context;
    4f9e:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
    4fa0:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4fa4:	e9d9 3508 	ldrd	r3, r5, [r9, #32]
    4fa8:	4798      	blx	r3
    4faa:	464b      	mov	r3, r9
    4fac:	2200      	movs	r2, #0
    4fae:	4641      	mov	r1, r8
    4fb0:	47a8      	blx	r5
	return user_op->status;
    4fb2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    4fb4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
    4fb8:	2001      	movs	r0, #1
    4fba:	e7fb      	b.n	4fb4 <ticker_start_ext+0x90>
    4fbc:	20001190 	.word	0x20001190

00004fc0 <ticker_update_ext>:
{
    4fc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    4fc4:	4c23      	ldr	r4, [pc, #140]	; (5054 <ticker_update_ext+0x94>)
{
    4fc6:	4606      	mov	r6, r0
    4fc8:	4608      	mov	r0, r1
    4fca:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
    4fcc:	222c      	movs	r2, #44	; 0x2c
    4fce:	fb06 4802 	mla	r8, r6, r2, r4
	user = &instance->users[user_id];
    4fd2:	f8d8 4004 	ldr.w	r4, [r8, #4]
    4fd6:	eb04 0cc0 	add.w	ip, r4, r0, lsl #3
	if (last >= user->count_user_op) {
    4fda:	f814 2030 	ldrb.w	r2, [r4, r0, lsl #3]
	last = user->last + 1;
    4fde:	f89c 7003 	ldrb.w	r7, [ip, #3]
    4fe2:	1c7d      	adds	r5, r7, #1
    4fe4:	b2ed      	uxtb	r5, r5
		last = 0U;
    4fe6:	42aa      	cmp	r2, r5
    4fe8:	bf98      	it	ls
    4fea:	2500      	movls	r5, #0
	if (last == user->first) {
    4fec:	f89c 2001 	ldrb.w	r2, [ip, #1]
    4ff0:	42aa      	cmp	r2, r5
    4ff2:	d02c      	beq.n	504e <ticker_update_ext+0x8e>
	user_op = &user->user_op[user->last];
    4ff4:	2234      	movs	r2, #52	; 0x34
    4ff6:	fb17 f702 	smulbb	r7, r7, r2
    4ffa:	f8dc 2004 	ldr.w	r2, [ip, #4]
    4ffe:	19d4      	adds	r4, r2, r7
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
    5000:	f04f 0e05 	mov.w	lr, #5
    5004:	f802 e007 	strb.w	lr, [r2, r7]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
    5008:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
    500a:	9b06      	ldr	r3, [sp, #24]
    500c:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
    500e:	9b07      	ldr	r3, [sp, #28]
    5010:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
    5012:	9b08      	ldr	r3, [sp, #32]
    5014:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
    5016:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    501a:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
    501c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    5020:	75a3      	strb	r3, [r4, #22]
	user_op->params.update.must_expire = must_expire;
    5022:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
    5026:	75e3      	strb	r3, [r4, #23]
	user_op->status = TICKER_STATUS_BUSY;
    5028:	2302      	movs	r3, #2
    502a:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    502c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    502e:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    5030:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
    5032:	7061      	strb	r1, [r4, #1]
	user_op->op_context = op_context;
    5034:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
    5036:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    503a:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
    503e:	4798      	blx	r3
    5040:	4643      	mov	r3, r8
    5042:	2200      	movs	r2, #0
    5044:	2104      	movs	r1, #4
    5046:	47a8      	blx	r5
	return user_op->status;
    5048:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    504a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    504e:	2001      	movs	r0, #1
    5050:	e7fb      	b.n	504a <ticker_update_ext+0x8a>
    5052:	bf00      	nop
    5054:	20001190 	.word	0x20001190

00005058 <ticker_stop>:
{
    5058:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    505c:	4c1a      	ldr	r4, [pc, #104]	; (50c8 <ticker_stop+0x70>)
{
    505e:	4605      	mov	r5, r0
    5060:	4608      	mov	r0, r1
    5062:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
    5064:	222c      	movs	r2, #44	; 0x2c
    5066:	fb05 4902 	mla	r9, r5, r2, r4
	user = &instance->users[user_id];
    506a:	f8d9 2004 	ldr.w	r2, [r9, #4]
    506e:	eb02 07c0 	add.w	r7, r2, r0, lsl #3
	if (last >= user->count_user_op) {
    5072:	f812 2030 	ldrb.w	r2, [r2, r0, lsl #3]
	last = user->last + 1;
    5076:	78fe      	ldrb	r6, [r7, #3]
    5078:	1c74      	adds	r4, r6, #1
    507a:	b2e4      	uxtb	r4, r4
		last = 0U;
    507c:	42a2      	cmp	r2, r4
    507e:	bf98      	it	ls
    5080:	2400      	movls	r4, #0
	if (last == user->first) {
    5082:	787a      	ldrb	r2, [r7, #1]
    5084:	42a2      	cmp	r2, r4
    5086:	d01d      	beq.n	50c4 <ticker_stop+0x6c>
	user_op = &user->user_op[user->last];
    5088:	2234      	movs	r2, #52	; 0x34
    508a:	fb16 f602 	smulbb	r6, r6, r2
    508e:	687a      	ldr	r2, [r7, #4]
	user_op->op = TICKER_USER_OP_TYPE_STOP;
    5090:	f04f 0c07 	mov.w	ip, #7
    5094:	f802 c006 	strb.w	ip, [r2, r6]
	user_op = &user->user_op[user->last];
    5098:	eb02 0806 	add.w	r8, r2, r6
	user_op->status = TICKER_STATUS_BUSY;
    509c:	2202      	movs	r2, #2
	user_op->fp_op_func = fp_op_func;
    509e:	e9c8 230a 	strd	r2, r3, [r8, #40]	; 0x28
	user_op->op_context = op_context;
    50a2:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
    50a4:	f888 1001 	strb.w	r1, [r8, #1]
	user_op->op_context = op_context;
    50a8:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
	user->last = last;
    50ac:	70fc      	strb	r4, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    50ae:	e9d9 3408 	ldrd	r3, r4, [r9, #32]
    50b2:	4798      	blx	r3
    50b4:	464b      	mov	r3, r9
    50b6:	2200      	movs	r2, #0
    50b8:	2104      	movs	r1, #4
    50ba:	47a0      	blx	r4
	return user_op->status;
    50bc:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
}
    50c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
    50c4:	2001      	movs	r0, #1
    50c6:	e7fb      	b.n	50c0 <ticker_stop+0x68>
    50c8:	20001190 	.word	0x20001190

000050cc <ll_addr_set>:

static uint8_t pub_addr[BDADDR_SIZE];
static uint8_t rnd_addr[BDADDR_SIZE];

uint8_t ll_addr_set(uint8_t addr_type, uint8_t const *const bdaddr)
{
    50cc:	b570      	push	{r4, r5, r6, lr}
    50ce:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER)) {
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		if (ull_adv_is_enabled(0) && !ll_adv_cmds_is_ext()) {
#else /* !CONFIG_BT_CTLR_ADV_EXT */
		if (ull_adv_is_enabled(0)) {
    50d0:	2000      	movs	r0, #0
{
    50d2:	460d      	mov	r5, r1
		if (ull_adv_is_enabled(0)) {
    50d4:	f009 fa42 	bl	e55c <ull_adv_is_enabled>
    50d8:	4606      	mov	r6, r0
    50da:	b960      	cbnz	r0, 50f6 <ll_addr_set+0x2a>
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    50dc:	2206      	movs	r2, #6
    50de:	4629      	mov	r1, r5
	if (addr_type) {
    50e0:	b12c      	cbz	r4, 50ee <ll_addr_set+0x22>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    50e2:	4806      	ldr	r0, [pc, #24]	; (50fc <ll_addr_set+0x30>)
    50e4:	f008 fc8f 	bl	da06 <memcpy>
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
	}

	return 0;
    50e8:	4634      	mov	r4, r6
}
    50ea:	4620      	mov	r0, r4
    50ec:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
    50ee:	4804      	ldr	r0, [pc, #16]	; (5100 <ll_addr_set+0x34>)
    50f0:	f008 fc89 	bl	da06 <memcpy>
    50f4:	e7f9      	b.n	50ea <ll_addr_set+0x1e>
			return BT_HCI_ERR_CMD_DISALLOWED;
    50f6:	240c      	movs	r4, #12
    50f8:	e7f7      	b.n	50ea <ll_addr_set+0x1e>
    50fa:	bf00      	nop
    50fc:	20001cc4 	.word	0x20001cc4
    5100:	20001cbe 	.word	0x20001cbe

00005104 <ll_addr_get>:

uint8_t *ll_addr_get(uint8_t addr_type)
{
	if (addr_type > BT_ADDR_LE_RANDOM) {
    5104:	2801      	cmp	r0, #1
{
    5106:	4602      	mov	r2, r0
	if (addr_type > BT_ADDR_LE_RANDOM) {
    5108:	d805      	bhi.n	5116 <ll_addr_get+0x12>
		return NULL;
	}

	if (addr_type) {
		return rnd_addr;
    510a:	4b04      	ldr	r3, [pc, #16]	; (511c <ll_addr_get+0x18>)
    510c:	4804      	ldr	r0, [pc, #16]	; (5120 <ll_addr_get+0x1c>)
    510e:	2a00      	cmp	r2, #0
    5110:	bf08      	it	eq
    5112:	4618      	moveq	r0, r3
    5114:	4770      	bx	lr
		return NULL;
    5116:	2000      	movs	r0, #0
	}

	return pub_addr;
}
    5118:	4770      	bx	lr
    511a:	bf00      	nop
    511c:	20001cbe 	.word	0x20001cbe
    5120:	20001cc4 	.word	0x20001cc4

00005124 <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(const struct device *unused)
{
    5124:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
    5126:	4802      	ldr	r0, [pc, #8]	; (5130 <hci_driver_init+0xc>)
    5128:	f7fe fc1c 	bl	3964 <bt_hci_driver_register>

	return 0;
}
    512c:	2000      	movs	r0, #0
    512e:	bd08      	pop	{r3, pc}
    5130:	0001052c 	.word	0x0001052c

00005134 <recv_thread>:
{
    5134:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_queue_get(queue, timeout);
    5136:	4e28      	ldr	r6, [pc, #160]	; (51d8 <recv_thread+0xa4>)
	struct net_buf *buf = NULL;
    5138:	2700      	movs	r7, #0
    513a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    513e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5142:	4630      	mov	r0, r6
    5144:	f006 fdc4 	bl	bcd0 <z_impl_k_queue_get>
		if (node_rx && !buf) {
    5148:	2800      	cmp	r0, #0
    514a:	d0f6      	beq.n	513a <recv_thread+0x6>
	buf = encode_node(node_rx, class);
    514c:	f990 3005 	ldrsb.w	r3, [r0, #5]
    5150:	9001      	str	r0, [sp, #4]
	switch (class) {
    5152:	1e5a      	subs	r2, r3, #1
    5154:	2a03      	cmp	r2, #3
    5156:	d82d      	bhi.n	51b4 <recv_thread+0x80>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
    5158:	2b02      	cmp	r3, #2
    515a:	d123      	bne.n	51a4 <recv_thread+0x70>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
    515c:	2200      	movs	r2, #0
    515e:	2300      	movs	r3, #0
    5160:	2101      	movs	r1, #1
    5162:	2000      	movs	r0, #0
    5164:	f7fd fe28 	bl	2db8 <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    5168:	4604      	mov	r4, r0
		if (buf) {
    516a:	b118      	cbz	r0, 5174 <recv_thread+0x40>
			hci_evt_encode(node_rx, buf);
    516c:	4601      	mov	r1, r0
    516e:	9801      	ldr	r0, [sp, #4]
    5170:	f000 fc1a 	bl	59a8 <hci_evt_encode>
	node_rx->hdr.next = NULL;
    5174:	9b01      	ldr	r3, [sp, #4]
	ll_rx_mem_release((void **)&node_rx);
    5176:	a801      	add	r0, sp, #4
	node_rx->hdr.next = NULL;
    5178:	601f      	str	r7, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
    517a:	f000 fcef 	bl	5b5c <ll_rx_mem_release>
		while (buf) {
    517e:	2c00      	cmp	r4, #0
    5180:	d0db      	beq.n	513a <recv_thread+0x6>
			frag = net_buf_ref(buf);
    5182:	4620      	mov	r0, r4
    5184:	f009 fcc3 	bl	eb0e <net_buf_ref>
			buf = net_buf_frag_del(NULL, buf);
    5188:	4621      	mov	r1, r4
			frag = net_buf_ref(buf);
    518a:	4605      	mov	r5, r0
			buf = net_buf_frag_del(NULL, buf);
    518c:	2000      	movs	r0, #0
    518e:	f009 fcc2 	bl	eb16 <net_buf_frag_del>
			if (frag->len) {
    5192:	89ab      	ldrh	r3, [r5, #12]
			buf = net_buf_frag_del(NULL, buf);
    5194:	4604      	mov	r4, r0
				bt_recv(frag);
    5196:	4628      	mov	r0, r5
			if (frag->len) {
    5198:	b1db      	cbz	r3, 51d2 <recv_thread+0x9e>
				bt_recv(frag);
    519a:	f7fe fb65 	bl	3868 <bt_recv>
	z_impl_k_yield();
    519e:	f007 f9ef 	bl	c580 <z_impl_k_yield>
}
    51a2:	e7ec      	b.n	517e <recv_thread+0x4a>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    51a4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    51a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    51ac:	2001      	movs	r0, #1
    51ae:	f7fd fdd9 	bl	2d64 <bt_buf_get_rx>
    51b2:	e7d9      	b.n	5168 <recv_thread+0x34>
		LL_ASSERT(0);
    51b4:	4a09      	ldr	r2, [pc, #36]	; (51dc <recv_thread+0xa8>)
    51b6:	490a      	ldr	r1, [pc, #40]	; (51e0 <recv_thread+0xac>)
    51b8:	480a      	ldr	r0, [pc, #40]	; (51e4 <recv_thread+0xb0>)
    51ba:	f44f 73cd 	mov.w	r3, #410	; 0x19a
    51be:	f007 fe1e 	bl	cdfe <printk>
    51c2:	4040      	eors	r0, r0
    51c4:	f380 8811 	msr	BASEPRI, r0
    51c8:	f04f 0003 	mov.w	r0, #3
    51cc:	df02      	svc	2
	struct net_buf *buf = NULL;
    51ce:	2400      	movs	r4, #0
		break;
    51d0:	e7d0      	b.n	5174 <recv_thread+0x40>
				net_buf_unref(frag);
    51d2:	f003 fcbb 	bl	8b4c <net_buf_unref>
    51d6:	e7e2      	b.n	519e <recv_thread+0x6a>
    51d8:	200005ac 	.word	0x200005ac
    51dc:	0001142d 	.word	0x0001142d
    51e0:	00011d2c 	.word	0x00011d2c
    51e4:	00010f78 	.word	0x00010f78

000051e8 <prio_recv_thread>:
{
    51e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return z_impl_k_sem_take(sem, timeout);
    51ea:	4d10      	ldr	r5, [pc, #64]	; (522c <prio_recv_thread+0x44>)
				k_fifo_put(&recv_fifo, node_rx);
    51ec:	4e10      	ldr	r6, [pc, #64]	; (5230 <prio_recv_thread+0x48>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
    51ee:	f10d 0102 	add.w	r1, sp, #2
    51f2:	a801      	add	r0, sp, #4
    51f4:	f000 fc60 	bl	5ab8 <ll_rx_get>
    51f8:	2800      	cmp	r0, #0
    51fa:	d1f8      	bne.n	51ee <prio_recv_thread+0x6>
		if (node_rx) {
    51fc:	9b01      	ldr	r3, [sp, #4]
    51fe:	b16b      	cbz	r3, 521c <prio_recv_thread+0x34>
			ll_rx_dequeue();
    5200:	f000 fc6c 	bl	5adc <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    5204:	9c01      	ldr	r4, [sp, #4]
    5206:	4620      	mov	r0, r4
    5208:	f009 f906 	bl	e418 <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
    520c:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    520e:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
    5210:	4630      	mov	r0, r6
    5212:	f00a fa5d 	bl	f6d0 <k_queue_append>
		if (iso_received || node_rx) {
    5216:	9b01      	ldr	r3, [sp, #4]
    5218:	2b00      	cmp	r3, #0
    521a:	d1e8      	bne.n	51ee <prio_recv_thread+0x6>
    521c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5220:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5224:	4628      	mov	r0, r5
    5226:	f006 fdad 	bl	bd84 <z_impl_k_sem_take>
		BT_DBG("sem taken");
    522a:	e7e0      	b.n	51ee <prio_recv_thread+0x6>
    522c:	20000594 	.word	0x20000594
    5230:	200005ac 	.word	0x200005ac

00005234 <hci_driver_open>:
{
    5234:	b5d0      	push	{r4, r6, r7, lr}
	err = ll_init(&sem_prio_recv);
    5236:	4821      	ldr	r0, [pc, #132]	; (52bc <hci_driver_open+0x88>)
{
    5238:	b090      	sub	sp, #64	; 0x40
	err = ll_init(&sem_prio_recv);
    523a:	f000 fee1 	bl	6000 <ll_init>
	if (err) {
    523e:	4604      	mov	r4, r0
    5240:	b178      	cbz	r0, 5262 <hci_driver_open+0x2e>
		BT_ERR("LL initialization failed: %d", err);
    5242:	4b1f      	ldr	r3, [pc, #124]	; (52c0 <hci_driver_open+0x8c>)
    5244:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
    5248:	2303      	movs	r3, #3
    524a:	9309      	str	r3, [sp, #36]	; 0x24
    524c:	930d      	str	r3, [sp, #52]	; 0x34
    524e:	481d      	ldr	r0, [pc, #116]	; (52c4 <hci_driver_open+0x90>)
    5250:	2300      	movs	r3, #0
    5252:	aa0d      	add	r2, sp, #52	; 0x34
    5254:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    5258:	f008 fb6c 	bl	d934 <z_impl_z_log_msg2_static_create>
}
    525c:	4620      	mov	r0, r4
    525e:	b010      	add	sp, #64	; 0x40
    5260:	bdd0      	pop	{r4, r6, r7, pc}
	hci_init(NULL);
    5262:	f009 f8db 	bl	e41c <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
    5266:	2600      	movs	r6, #0
    5268:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    526a:	f06f 0309 	mvn.w	r3, #9
    526e:	e9cd 4302 	strd	r4, r3, [sp, #8]
    5272:	e9cd 6706 	strd	r6, r7, [sp, #24]
    5276:	e9cd 4400 	strd	r4, r4, [sp]
    527a:	4b13      	ldr	r3, [pc, #76]	; (52c8 <hci_driver_open+0x94>)
    527c:	4913      	ldr	r1, [pc, #76]	; (52cc <hci_driver_open+0x98>)
    527e:	9404      	str	r4, [sp, #16]
    5280:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
    5284:	4812      	ldr	r0, [pc, #72]	; (52d0 <hci_driver_open+0x9c>)
    5286:	f006 fbc5 	bl	ba14 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    528a:	4912      	ldr	r1, [pc, #72]	; (52d4 <hci_driver_open+0xa0>)
    528c:	4810      	ldr	r0, [pc, #64]	; (52d0 <hci_driver_open+0x9c>)
    528e:	f00a f999 	bl	f5c4 <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    5292:	f06f 0307 	mvn.w	r3, #7
    5296:	e9cd 4302 	strd	r4, r3, [sp, #8]
    529a:	e9cd 6706 	strd	r6, r7, [sp, #24]
    529e:	e9cd 4400 	strd	r4, r4, [sp]
    52a2:	4b0d      	ldr	r3, [pc, #52]	; (52d8 <hci_driver_open+0xa4>)
    52a4:	490d      	ldr	r1, [pc, #52]	; (52dc <hci_driver_open+0xa8>)
    52a6:	9404      	str	r4, [sp, #16]
    52a8:	f44f 6280 	mov.w	r2, #1024	; 0x400
    52ac:	480c      	ldr	r0, [pc, #48]	; (52e0 <hci_driver_open+0xac>)
    52ae:	f006 fbb1 	bl	ba14 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    52b2:	490c      	ldr	r1, [pc, #48]	; (52e4 <hci_driver_open+0xb0>)
    52b4:	480a      	ldr	r0, [pc, #40]	; (52e0 <hci_driver_open+0xac>)
    52b6:	f00a f985 	bl	f5c4 <z_impl_k_thread_name_set>
    52ba:	e7cf      	b.n	525c <hci_driver_open+0x28>
    52bc:	20000594 	.word	0x20000594
    52c0:	0001146d 	.word	0x0001146d
    52c4:	00010240 	.word	0x00010240
    52c8:	000051e9 	.word	0x000051e9
    52cc:	20002840 	.word	0x20002840
    52d0:	20000b80 	.word	0x20000b80
    52d4:	0001148a 	.word	0x0001148a
    52d8:	00005135 	.word	0x00005135
    52dc:	20002a20 	.word	0x20002a20
    52e0:	20000c00 	.word	0x20000c00
    52e4:	00011494 	.word	0x00011494

000052e8 <hci_driver_send>:
{
    52e8:	b530      	push	{r4, r5, lr}
	if (!buf->len) {
    52ea:	8983      	ldrh	r3, [r0, #12]
{
    52ec:	b089      	sub	sp, #36	; 0x24
    52ee:	4604      	mov	r4, r0
	if (!buf->len) {
    52f0:	b96b      	cbnz	r3, 530e <hci_driver_send+0x26>
		BT_ERR("Empty HCI packet");
    52f2:	4a19      	ldr	r2, [pc, #100]	; (5358 <hci_driver_send+0x70>)
    52f4:	9206      	str	r2, [sp, #24]
    52f6:	2202      	movs	r2, #2
    52f8:	9201      	str	r2, [sp, #4]
    52fa:	9205      	str	r2, [sp, #20]
    52fc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    5300:	aa05      	add	r2, sp, #20
    5302:	4816      	ldr	r0, [pc, #88]	; (535c <hci_driver_send+0x74>)
    5304:	f008 fb16 	bl	d934 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
    5308:	f06f 0015 	mvn.w	r0, #21
    530c:	e016      	b.n	533c <hci_driver_send+0x54>
    530e:	7d03      	ldrb	r3, [r0, #20]
	switch (type) {
    5310:	b9b3      	cbnz	r3, 5340 <hci_driver_send+0x58>
	evt = hci_cmd_handle(buf, (void **) &node_rx);
    5312:	a902      	add	r1, sp, #8
	struct node_rx_pdu *node_rx = NULL;
    5314:	9302      	str	r3, [sp, #8]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
    5316:	f000 f8d3 	bl	54c0 <hci_cmd_handle>
	if (evt) {
    531a:	b158      	cbz	r0, 5334 <hci_driver_send+0x4c>
		bt_recv_prio(evt);
    531c:	f7fe fb04 	bl	3928 <bt_recv_prio>
		if (node_rx) {
    5320:	9d02      	ldr	r5, [sp, #8]
    5322:	b13d      	cbz	r5, 5334 <hci_driver_send+0x4c>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    5324:	4628      	mov	r0, r5
    5326:	f009 f877 	bl	e418 <hci_get_class>
    532a:	7168      	strb	r0, [r5, #5]
			k_fifo_put(&recv_fifo, node_rx);
    532c:	9902      	ldr	r1, [sp, #8]
    532e:	480c      	ldr	r0, [pc, #48]	; (5360 <hci_driver_send+0x78>)
    5330:	f00a f9ce 	bl	f6d0 <k_queue_append>
		net_buf_unref(buf);
    5334:	4620      	mov	r0, r4
    5336:	f003 fc09 	bl	8b4c <net_buf_unref>
	return err;
    533a:	2000      	movs	r0, #0
}
    533c:	b009      	add	sp, #36	; 0x24
    533e:	bd30      	pop	{r4, r5, pc}
		BT_ERR("Unknown HCI type %u", type);
    5340:	4a08      	ldr	r2, [pc, #32]	; (5364 <hci_driver_send+0x7c>)
	switch (type) {
    5342:	e9cd 2306 	strd	r2, r3, [sp, #24]
		BT_ERR("Unknown HCI type %u", type);
    5346:	2303      	movs	r3, #3
    5348:	9301      	str	r3, [sp, #4]
    534a:	9305      	str	r3, [sp, #20]
    534c:	2300      	movs	r3, #0
    534e:	aa05      	add	r2, sp, #20
    5350:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    5354:	e7d5      	b.n	5302 <hci_driver_send+0x1a>
    5356:	bf00      	nop
    5358:	0001149a 	.word	0x0001149a
    535c:	00010240 	.word	0x00010240
    5360:	200005ac 	.word	0x200005ac
    5364:	000114ab 	.word	0x000114ab

00005368 <cmd_complete_status>:
{
	return bt_hci_cmd_status_create(_opcode, status);
}

static struct net_buf *cmd_complete_status(uint8_t status)
{
    5368:	b538      	push	{r3, r4, r5, lr}
	struct net_buf *buf;
	struct bt_hci_evt_cc_status *ccst;

	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
    536a:	4b07      	ldr	r3, [pc, #28]	; (5388 <cmd_complete_status+0x20>)
{
    536c:	4605      	mov	r5, r0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
    536e:	2101      	movs	r1, #1
    5370:	8818      	ldrh	r0, [r3, #0]
    5372:	f008 fbe3 	bl	db3c <bt_hci_cmd_complete_create>
	return net_buf_simple_add(&buf->b, len);
    5376:	2101      	movs	r1, #1
    5378:	4604      	mov	r4, r0
    537a:	3008      	adds	r0, #8
    537c:	f009 fbd7 	bl	eb2e <net_buf_simple_add>
	ccst = net_buf_add(buf, sizeof(*ccst));
	ccst->status = status;
    5380:	7005      	strb	r5, [r0, #0]

	return buf;
}
    5382:	4620      	mov	r0, r4
    5384:	bd38      	pop	{r3, r4, r5, pc}
    5386:	bf00      	nop
    5388:	20001c04 	.word	0x20001c04

0000538c <hci_cmd_complete>:
{
    538c:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    538e:	4b06      	ldr	r3, [pc, #24]	; (53a8 <hci_cmd_complete+0x1c>)
{
    5390:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    5392:	8818      	ldrh	r0, [r3, #0]
{
    5394:	460c      	mov	r4, r1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    5396:	f008 fbd1 	bl	db3c <bt_hci_cmd_complete_create>
    539a:	4621      	mov	r1, r4
    539c:	6028      	str	r0, [r5, #0]
}
    539e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    53a2:	3008      	adds	r0, #8
    53a4:	f009 bbc3 	b.w	eb2e <net_buf_simple_add>
    53a8:	20001c04 	.word	0x20001c04

000053ac <hci_vendor_cmd_handle_common>:
}
#endif /* CONFIG_BT_HCI_MESH_EXT */

int hci_vendor_cmd_handle_common(uint16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
    53ac:	b5f0      	push	{r4, r5, r6, r7, lr}
	switch (ocf) {
    53ae:	3801      	subs	r0, #1
{
    53b0:	b087      	sub	sp, #28
    53b2:	4614      	mov	r4, r2
	switch (ocf) {
    53b4:	2809      	cmp	r0, #9
    53b6:	d87e      	bhi.n	54b6 <hci_vendor_cmd_handle_common+0x10a>
    53b8:	e8df f000 	tbb	[pc, r0]
    53bc:	7d321b05 	.word	0x7d321b05
    53c0:	3e7d5b7d 	.word	0x3e7d5b7d
    53c4:	7164      	.short	0x7164
	rp = hci_cmd_complete(evt, sizeof(*rp));
    53c6:	210d      	movs	r1, #13
    53c8:	4610      	mov	r0, r2
    53ca:	f7ff ffdf 	bl	538c <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    53ce:	2302      	movs	r3, #2
	rp->status = 0x00;
    53d0:	2100      	movs	r1, #0
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    53d2:	7043      	strb	r3, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    53d4:	70c3      	strb	r3, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
    53d6:	2303      	movs	r3, #3
	rp->status = 0x00;
    53d8:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    53da:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    53dc:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
    53de:	7141      	strb	r1, [r0, #5]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
    53e0:	7183      	strb	r3, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    53e2:	71c1      	strb	r1, [r0, #7]
    53e4:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    53e6:	7241      	strb	r1, [r0, #9]
    53e8:	7281      	strb	r1, [r0, #10]
    53ea:	72c1      	strb	r1, [r0, #11]
    53ec:	7301      	strb	r1, [r0, #12]

	default:
		return -EINVAL;
	}

	return 0;
    53ee:	2400      	movs	r4, #0
}
    53f0:	e013      	b.n	541a <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    53f2:	2141      	movs	r1, #65	; 0x41
    53f4:	4610      	mov	r0, r2
    53f6:	f7ff ffc9 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    53fa:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    53fc:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    53fe:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    5400:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    5404:	4621      	mov	r1, r4
    5406:	f008 fb09 	bl	da1c <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
    540a:	786b      	ldrb	r3, [r5, #1]
    540c:	f063 0358 	orn	r3, r3, #88	; 0x58
    5410:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
    5412:	78ab      	ldrb	r3, [r5, #2]
    5414:	f043 0303 	orr.w	r3, r3, #3
    5418:	70ab      	strb	r3, [r5, #2]
}
    541a:	4620      	mov	r0, r4
    541c:	b007      	add	sp, #28
    541e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5420:	2109      	movs	r1, #9
    5422:	4610      	mov	r0, r2
    5424:	f7ff ffb2 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    5428:	2400      	movs	r4, #0
    542a:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    542e:	2208      	movs	r2, #8
    5430:	4621      	mov	r1, r4
    5432:	f008 faf3 	bl	da1c <memset>
}
    5436:	e7f0      	b.n	541a <hci_vendor_cmd_handle_common+0x6e>
	const char build_info[] = HCI_VS_BUILD_INFO;
    5438:	4b20      	ldr	r3, [pc, #128]	; (54bc <hci_vendor_cmd_handle_common+0x110>)
    543a:	466a      	mov	r2, sp
    543c:	f103 0710 	add.w	r7, r3, #16
    5440:	4616      	mov	r6, r2
    5442:	6818      	ldr	r0, [r3, #0]
    5444:	6859      	ldr	r1, [r3, #4]
    5446:	4615      	mov	r5, r2
    5448:	c503      	stmia	r5!, {r0, r1}
    544a:	3308      	adds	r3, #8
    544c:	42bb      	cmp	r3, r7
    544e:	462a      	mov	r2, r5
    5450:	d1f7      	bne.n	5442 <hci_vendor_cmd_handle_common+0x96>
    5452:	6818      	ldr	r0, [r3, #0]
    5454:	791b      	ldrb	r3, [r3, #4]
    5456:	6028      	str	r0, [r5, #0]
    5458:	712b      	strb	r3, [r5, #4]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
    545a:	2116      	movs	r1, #22
    545c:	4620      	mov	r0, r4
    545e:	f7ff ff95 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    5462:	2400      	movs	r4, #0
    5464:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
    5468:	2215      	movs	r2, #21
    546a:	4631      	mov	r1, r6
    546c:	f008 facb 	bl	da06 <memcpy>
}
    5470:	e7d3      	b.n	541a <hci_vendor_cmd_handle_common+0x6e>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
    5472:	6889      	ldr	r1, [r1, #8]
    5474:	2000      	movs	r0, #0
    5476:	f7ff fe29 	bl	50cc <ll_addr_set>
	*evt = cmd_complete_status(0x00);
    547a:	2000      	movs	r0, #0
    547c:	f7ff ff74 	bl	5368 <cmd_complete_status>
    5480:	6020      	str	r0, [r4, #0]
    5482:	e7b4      	b.n	53ee <hci_vendor_cmd_handle_common+0x42>
	rp = hci_cmd_complete(evt, sizeof(*rp) +
    5484:	2118      	movs	r1, #24
    5486:	4610      	mov	r0, r2
    5488:	f7ff ff80 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    548c:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp) +
    548e:	4605      	mov	r5, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
    5490:	2101      	movs	r1, #1
	rp->status = 0x00;
    5492:	f800 4b02 	strb.w	r4, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
    5496:	f009 fa7c 	bl	e992 <hci_vendor_read_static_addr>
    549a:	7068      	strb	r0, [r5, #1]
}
    549c:	e7bd      	b.n	541a <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    549e:	2121      	movs	r1, #33	; 0x21
    54a0:	4610      	mov	r0, r2
    54a2:	f7ff ff73 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    54a6:	4601      	mov	r1, r0
    54a8:	2400      	movs	r4, #0
    54aa:	f801 4b11 	strb.w	r4, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
    54ae:	3001      	adds	r0, #1
    54b0:	f009 fac5 	bl	ea3e <hci_vendor_read_key_hierarchy_roots>
}
    54b4:	e7b1      	b.n	541a <hci_vendor_cmd_handle_common+0x6e>
	switch (ocf) {
    54b6:	f06f 0415 	mvn.w	r4, #21
    54ba:	e7ae      	b.n	541a <hci_vendor_cmd_handle_common+0x6e>
    54bc:	000114dd 	.word	0x000114dd

000054c0 <hci_cmd_handle>:
#endif

struct net_buf *hci_cmd_handle(struct net_buf *cmd, void **node_rx)
{
    54c0:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_cmd_hdr *chdr;
	struct net_buf *evt = NULL;
	uint16_t ocf;
	int err;

	if (cmd->len < sizeof(*chdr)) {
    54c2:	8983      	ldrh	r3, [r0, #12]
{
    54c4:	b08c      	sub	sp, #48	; 0x30
	struct net_buf *evt = NULL;
    54c6:	2500      	movs	r5, #0
	if (cmd->len < sizeof(*chdr)) {
    54c8:	2b02      	cmp	r3, #2
{
    54ca:	4604      	mov	r4, r0
	struct net_buf *evt = NULL;
    54cc:	9504      	str	r5, [sp, #16]
	if (cmd->len < sizeof(*chdr)) {
    54ce:	d80e      	bhi.n	54ee <hci_cmd_handle+0x2e>
		BT_ERR("No HCI Command header");
    54d0:	4bd8      	ldr	r3, [pc, #864]	; (5834 <hci_cmd_handle+0x374>)
		return NULL;
	}

	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
	if (cmd->len < chdr->param_len) {
		BT_ERR("Invalid HCI CMD packet length");
    54d2:	930a      	str	r3, [sp, #40]	; 0x28
    54d4:	2302      	movs	r3, #2
    54d6:	9305      	str	r3, [sp, #20]
    54d8:	9309      	str	r3, [sp, #36]	; 0x24
    54da:	48d7      	ldr	r0, [pc, #860]	; (5838 <hci_cmd_handle+0x378>)
    54dc:	462b      	mov	r3, r5
    54de:	aa09      	add	r2, sp, #36	; 0x24
    54e0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    54e4:	f008 fa26 	bl	d934 <z_impl_z_log_msg2_static_create>
		return NULL;
    54e8:	4628      	mov	r0, r5
	if (err == -EINVAL) {
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
	}

	return evt;
}
    54ea:	b00c      	add	sp, #48	; 0x30
    54ec:	bd70      	pop	{r4, r5, r6, pc}
	return net_buf_simple_pull_mem(&buf->b, len);
    54ee:	2103      	movs	r1, #3
    54f0:	3008      	adds	r0, #8
    54f2:	f009 fb33 	bl	eb5c <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
    54f6:	89a2      	ldrh	r2, [r4, #12]
    54f8:	7883      	ldrb	r3, [r0, #2]
    54fa:	429a      	cmp	r2, r3
    54fc:	d201      	bcs.n	5502 <hci_cmd_handle+0x42>
		BT_ERR("Invalid HCI CMD packet length");
    54fe:	4bcf      	ldr	r3, [pc, #828]	; (583c <hci_cmd_handle+0x37c>)
    5500:	e7e7      	b.n	54d2 <hci_cmd_handle+0x12>
	_opcode = sys_le16_to_cpu(chdr->opcode);
    5502:	8803      	ldrh	r3, [r0, #0]
    5504:	4ece      	ldr	r6, [pc, #824]	; (5840 <hci_cmd_handle+0x380>)
	ocf = BT_OCF(_opcode);
    5506:	f3c3 0009 	ubfx	r0, r3, #0, #10
	_opcode = sys_le16_to_cpu(chdr->opcode);
    550a:	8033      	strh	r3, [r6, #0]
	switch (BT_OGF(_opcode)) {
    550c:	f3c3 2385 	ubfx	r3, r3, #10, #6
    5510:	2b08      	cmp	r3, #8
    5512:	f000 80ae 	beq.w	5672 <hci_cmd_handle+0x1b2>
    5516:	d808      	bhi.n	552a <hci_cmd_handle+0x6a>
    5518:	2b03      	cmp	r3, #3
    551a:	d00f      	beq.n	553c <hci_cmd_handle+0x7c>
    551c:	2b04      	cmp	r3, #4
    551e:	d018      	beq.n	5552 <hci_cmd_handle+0x92>
	return bt_hci_cmd_status_create(_opcode, status);
    5520:	8830      	ldrh	r0, [r6, #0]
    5522:	2101      	movs	r1, #1
    5524:	f008 fb1c 	bl	db60 <bt_hci_cmd_status_create>
    5528:	e176      	b.n	5818 <hci_cmd_handle+0x358>
	switch (BT_OGF(_opcode)) {
    552a:	2b3f      	cmp	r3, #63	; 0x3f
    552c:	d1f8      	bne.n	5520 <hci_cmd_handle+0x60>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(uint16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
    552e:	aa04      	add	r2, sp, #16
    5530:	4621      	mov	r1, r4
    5532:	f7ff ff3b 	bl	53ac <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
    5536:	3016      	adds	r0, #22
    5538:	d0f2      	beq.n	5520 <hci_cmd_handle+0x60>
    553a:	e07f      	b.n	563c <hci_cmd_handle+0x17c>
	switch (ocf) {
    553c:	2803      	cmp	r0, #3
    553e:	d005      	beq.n	554c <hci_cmd_handle+0x8c>
    5540:	2863      	cmp	r0, #99	; 0x63
    5542:	d001      	beq.n	5548 <hci_cmd_handle+0x88>
    5544:	2801      	cmp	r0, #1
    5546:	d1eb      	bne.n	5520 <hci_cmd_handle+0x60>
	*evt = cmd_complete_status(0x00);
    5548:	2000      	movs	r0, #0
    554a:	e163      	b.n	5814 <hci_cmd_handle+0x354>
		ll_reset();
    554c:	f000 fdb6 	bl	60bc <ll_reset>
		*evt = cmd_complete_status(0x00);
    5550:	e7fa      	b.n	5548 <hci_cmd_handle+0x88>
	switch (ocf) {
    5552:	3801      	subs	r0, #1
    5554:	2808      	cmp	r0, #8
    5556:	d8e3      	bhi.n	5520 <hci_cmd_handle+0x60>
    5558:	a301      	add	r3, pc, #4	; (adr r3, 5560 <hci_cmd_handle+0xa0>)
    555a:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
    555e:	bf00      	nop
    5560:	00005585 	.word	0x00005585
    5564:	000055af 	.word	0x000055af
    5568:	00005641 	.word	0x00005641
    556c:	00005521 	.word	0x00005521
    5570:	00005521 	.word	0x00005521
    5574:	00005521 	.word	0x00005521
    5578:	00005521 	.word	0x00005521
    557c:	00005521 	.word	0x00005521
    5580:	0000565d 	.word	0x0000565d
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5584:	2109      	movs	r1, #9
    5586:	a804      	add	r0, sp, #16
    5588:	f7ff ff00 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    558c:	2300      	movs	r3, #0
    558e:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
    5590:	7083      	strb	r3, [r0, #2]
    5592:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    5594:	f06f 030e 	mvn.w	r3, #14
	rp->hci_version = LL_VERSION_NUMBER;
    5598:	220c      	movs	r2, #12
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    559a:	7143      	strb	r3, [r0, #5]
    559c:	2305      	movs	r3, #5
    559e:	7183      	strb	r3, [r0, #6]
	rp->hci_version = LL_VERSION_NUMBER;
    55a0:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
    55a2:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
    55a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	dst[0] = val;
    55a8:	71c3      	strb	r3, [r0, #7]
	dst[1] = val >> 8;
    55aa:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
    55ac:	e046      	b.n	563c <hci_cmd_handle+0x17c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    55ae:	2141      	movs	r1, #65	; 0x41
    55b0:	a804      	add	r0, sp, #16
    55b2:	f7ff feeb 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    55b6:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    55b8:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    55ba:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    55bc:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    55c0:	f008 fa2c 	bl	da1c <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
    55c4:	79a3      	ldrb	r3, [r4, #6]
	rp->commands[27] |= BIT(6) | BIT(7);
    55c6:	7f21      	ldrb	r1, [r4, #28]
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
    55c8:	7ea2      	ldrb	r2, [r4, #26]
	rp->commands[5] |= BIT(6) | BIT(7);
    55ca:	f063 033f 	orn	r3, r3, #63	; 0x3f
    55ce:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
    55d0:	7ae3      	ldrb	r3, [r4, #11]
    55d2:	f043 0304 	orr.w	r3, r3, #4
    55d6:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
    55d8:	7be3      	ldrb	r3, [r4, #15]
    55da:	f043 0328 	orr.w	r3, r3, #40	; 0x28
    55de:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
    55e0:	7c23      	ldrb	r3, [r4, #16]
    55e2:	f043 0302 	orr.w	r3, r3, #2
    55e6:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
    55e8:	7de3      	ldrb	r3, [r4, #23]
    55ea:	f043 0304 	orr.w	r3, r3, #4
    55ee:	75e3      	strb	r3, [r4, #23]
	rp->commands[26] |= BIT(6) | BIT(7);
    55f0:	7ee3      	ldrb	r3, [r4, #27]
	rp->commands[26] |= BIT(0) | BIT(1);
    55f2:	f063 033c 	orn	r3, r3, #60	; 0x3c
    55f6:	76e3      	strb	r3, [r4, #27]
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
    55f8:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    55fc:	f063 0307 	orn	r3, r3, #7
    5600:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
    5604:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    5608:	f043 0307 	orr.w	r3, r3, #7
    560c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	rp->commands[39] |= BIT(2);
    5610:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
	rp->commands[27] |= BIT(6) | BIT(7);
    5614:	f061 013c 	orn	r1, r1, #60	; 0x3c
	rp->commands[39] |= BIT(2);
    5618:	f043 0304 	orr.w	r3, r3, #4
	rp->commands[27] |= BIT(6) | BIT(7);
    561c:	7721      	strb	r1, [r4, #28]
	rp->commands[39] |= BIT(2);
    561e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	rp->commands[28] |= BIT(3);
    5622:	7f61      	ldrb	r1, [r4, #29]
	rp->commands[38] |= BIT(7);
    5624:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
	rp->commands[28] |= BIT(3);
    5628:	f041 0108 	orr.w	r1, r1, #8
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    562c:	f062 0208 	orn	r2, r2, #8
	rp->commands[38] |= BIT(7);
    5630:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[28] |= BIT(3);
    5634:	7761      	strb	r1, [r4, #29]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    5636:	76a2      	strb	r2, [r4, #26]
	rp->commands[38] |= BIT(7);
    5638:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
	return evt;
    563c:	9804      	ldr	r0, [sp, #16]
    563e:	e754      	b.n	54ea <hci_cmd_handle+0x2a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5640:	2109      	movs	r1, #9
    5642:	a804      	add	r0, sp, #16
    5644:	f7ff fea2 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    5648:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    564a:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    564c:	2208      	movs	r2, #8
	rp->status = 0x00;
    564e:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    5652:	f008 f9e3 	bl	da1c <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
    5656:	2360      	movs	r3, #96	; 0x60
    5658:	7163      	strb	r3, [r4, #5]
	if (err == -EINVAL) {
    565a:	e7ef      	b.n	563c <hci_cmd_handle+0x17c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    565c:	2107      	movs	r1, #7
    565e:	a804      	add	r0, sp, #16
    5660:	f7ff fe94 	bl	538c <hci_cmd_complete>
    5664:	4601      	mov	r1, r0
	rp->status = 0x00;
    5666:	2000      	movs	r0, #0
    5668:	f801 0b01 	strb.w	r0, [r1], #1
	(void)ll_addr_read(0, &rp->bdaddr.val[0]);
    566c:	f008 fec3 	bl	e3f6 <ll_addr_read>
	if (err == -EINVAL) {
    5670:	e7e4      	b.n	563c <hci_cmd_handle+0x17c>
	switch (ocf) {
    5672:	3801      	subs	r0, #1
    5674:	284d      	cmp	r0, #77	; 0x4d
    5676:	f63f af53 	bhi.w	5520 <hci_cmd_handle+0x60>
    567a:	a301      	add	r3, pc, #4	; (adr r3, 5680 <hci_cmd_handle+0x1c0>)
    567c:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
    5680:	00005549 	.word	0x00005549
    5684:	000057b9 	.word	0x000057b9
    5688:	000057d1 	.word	0x000057d1
    568c:	00005521 	.word	0x00005521
    5690:	0000580d 	.word	0x0000580d
    5694:	000058b3 	.word	0x000058b3
    5698:	000058cf 	.word	0x000058cf
    569c:	000058df 	.word	0x000058df
    56a0:	000058eb 	.word	0x000058eb
    56a4:	000058f7 	.word	0x000058f7
    56a8:	00005521 	.word	0x00005521
    56ac:	00005521 	.word	0x00005521
    56b0:	00005521 	.word	0x00005521
    56b4:	00005521 	.word	0x00005521
    56b8:	0000581d 	.word	0x0000581d
    56bc:	00005845 	.word	0x00005845
    56c0:	0000584b 	.word	0x0000584b
    56c4:	00005853 	.word	0x00005853
    56c8:	00005521 	.word	0x00005521
    56cc:	00005521 	.word	0x00005521
    56d0:	00005521 	.word	0x00005521
    56d4:	00005521 	.word	0x00005521
    56d8:	0000585b 	.word	0x0000585b
    56dc:	00005881 	.word	0x00005881
    56e0:	00005521 	.word	0x00005521
    56e4:	00005521 	.word	0x00005521
    56e8:	00005521 	.word	0x00005521
    56ec:	00005897 	.word	0x00005897
    56f0:	00005521 	.word	0x00005521
    56f4:	00005521 	.word	0x00005521
    56f8:	00005521 	.word	0x00005521
    56fc:	00005521 	.word	0x00005521
    5700:	00005521 	.word	0x00005521
    5704:	00005521 	.word	0x00005521
    5708:	00005521 	.word	0x00005521
    570c:	00005521 	.word	0x00005521
    5710:	00005521 	.word	0x00005521
    5714:	00005521 	.word	0x00005521
    5718:	00005901 	.word	0x00005901
    571c:	0000590f 	.word	0x0000590f
    5720:	00005917 	.word	0x00005917
    5724:	0000591d 	.word	0x0000591d
    5728:	00005933 	.word	0x00005933
    572c:	00005953 	.word	0x00005953
    5730:	00005971 	.word	0x00005971
    5734:	0000597b 	.word	0x0000597b
    5738:	00005521 	.word	0x00005521
    573c:	00005521 	.word	0x00005521
    5740:	00005521 	.word	0x00005521
    5744:	00005521 	.word	0x00005521
    5748:	00005521 	.word	0x00005521
    574c:	00005521 	.word	0x00005521
    5750:	00005521 	.word	0x00005521
    5754:	00005521 	.word	0x00005521
    5758:	00005521 	.word	0x00005521
    575c:	00005521 	.word	0x00005521
    5760:	00005521 	.word	0x00005521
    5764:	00005521 	.word	0x00005521
    5768:	00005521 	.word	0x00005521
    576c:	00005521 	.word	0x00005521
    5770:	00005521 	.word	0x00005521
    5774:	00005521 	.word	0x00005521
    5778:	00005521 	.word	0x00005521
    577c:	00005521 	.word	0x00005521
    5780:	00005521 	.word	0x00005521
    5784:	00005521 	.word	0x00005521
    5788:	00005521 	.word	0x00005521
    578c:	00005521 	.word	0x00005521
    5790:	00005521 	.word	0x00005521
    5794:	00005521 	.word	0x00005521
    5798:	00005521 	.word	0x00005521
    579c:	00005521 	.word	0x00005521
    57a0:	00005521 	.word	0x00005521
    57a4:	00005521 	.word	0x00005521
    57a8:	0000598f 	.word	0x0000598f
    57ac:	00005521 	.word	0x00005521
    57b0:	00005521 	.word	0x00005521
    57b4:	00005985 	.word	0x00005985
	rp = hci_cmd_complete(evt, sizeof(*rp));
    57b8:	2104      	movs	r1, #4
    57ba:	a804      	add	r0, sp, #16
    57bc:	f7ff fde6 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    57c0:	2300      	movs	r3, #0
    57c2:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
    57c4:	221b      	movs	r2, #27
    57c6:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
    57c8:	2303      	movs	r3, #3
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
    57ca:	7042      	strb	r2, [r0, #1]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
    57cc:	70c3      	strb	r3, [r0, #3]
	if (err == -EINVAL) {
    57ce:	e735      	b.n	563c <hci_cmd_handle+0x17c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    57d0:	2109      	movs	r1, #9
    57d2:	a804      	add	r0, sp, #16
    57d4:	f7ff fdda 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    57d8:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    57da:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    57dc:	2208      	movs	r2, #8
	rp->status = 0x00;
    57de:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    57e2:	f008 f91b 	bl	da1c <memset>
	sys_put_le64(ll_feat_get(), rp->features);
    57e6:	f008 fe22 	bl	e42e <ll_feat_get>
    57ea:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
    57ee:	7060      	strb	r0, [r4, #1]
	dst[1] = val >> 8;
    57f0:	70a3      	strb	r3, [r4, #2]
	sys_put_le16(val >> 16, &dst[2]);
    57f2:	0c00      	lsrs	r0, r0, #16
	dst[1] = val >> 8;
    57f4:	f3c1 2307 	ubfx	r3, r1, #8, #8
	dst[0] = val;
    57f8:	7161      	strb	r1, [r4, #5]
	sys_put_le16(val >> 16, &dst[2]);
    57fa:	0c09      	lsrs	r1, r1, #16
	dst[0] = val;
    57fc:	70e0      	strb	r0, [r4, #3]
    57fe:	71e1      	strb	r1, [r4, #7]
	dst[1] = val >> 8;
    5800:	0a00      	lsrs	r0, r0, #8
    5802:	0a09      	lsrs	r1, r1, #8
    5804:	7120      	strb	r0, [r4, #4]
    5806:	71a3      	strb	r3, [r4, #6]
    5808:	7221      	strb	r1, [r4, #8]
	if (err == -EINVAL) {
    580a:	e717      	b.n	563c <hci_cmd_handle+0x17c>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
    580c:	68a1      	ldr	r1, [r4, #8]
    580e:	2001      	movs	r0, #1
    5810:	f7ff fc5c 	bl	50cc <ll_addr_set>
	*evt = cmd_complete_status(status);
    5814:	f7ff fda8 	bl	5368 <cmd_complete_status>
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
    5818:	9004      	str	r0, [sp, #16]
    581a:	e70f      	b.n	563c <hci_cmd_handle+0x17c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    581c:	2102      	movs	r1, #2
    581e:	a804      	add	r0, sp, #16
    5820:	f7ff fdb4 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    5824:	2300      	movs	r3, #0
    5826:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5828:	4604      	mov	r4, r0
	rp->fal_size = ll_fal_size_get();
    582a:	f008 ff6a 	bl	e702 <ll_fal_size_get>
    582e:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
    5830:	e704      	b.n	563c <hci_cmd_handle+0x17c>
    5832:	bf00      	nop
    5834:	000114f2 	.word	0x000114f2
    5838:	00010238 	.word	0x00010238
    583c:	00011508 	.word	0x00011508
    5840:	20001c04 	.word	0x20001c04
	status = ll_fal_clear();
    5844:	f008 ff5f 	bl	e706 <ll_fal_clear>
	*evt = cmd_complete_status(status);
    5848:	e7e4      	b.n	5814 <hci_cmd_handle+0x354>
	status = ll_fal_add(&cmd->addr);
    584a:	68a0      	ldr	r0, [r4, #8]
    584c:	f001 fa42 	bl	6cd4 <ll_fal_add>
	*evt = cmd_complete_status(status);
    5850:	e7e0      	b.n	5814 <hci_cmd_handle+0x354>
	status = ll_fal_remove(&cmd->addr);
    5852:	68a0      	ldr	r0, [r4, #8]
    5854:	f001 f830 	bl	68b8 <ll_fal_remove>
	*evt = cmd_complete_status(status);
    5858:	e7dc      	b.n	5814 <hci_cmd_handle+0x354>
	struct bt_hci_cp_le_encrypt *cmd = (void *)buf->data;
    585a:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
    585c:	aa06      	add	r2, sp, #24
    585e:	2300      	movs	r3, #0
    5860:	f100 0110 	add.w	r1, r0, #16
    5864:	f009 f82d 	bl	e8c2 <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5868:	2111      	movs	r1, #17
    586a:	a804      	add	r0, sp, #16
    586c:	f7ff fd8e 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    5870:	2300      	movs	r3, #0
    5872:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
    5876:	2210      	movs	r2, #16
    5878:	a906      	add	r1, sp, #24
    587a:	f008 f8c4 	bl	da06 <memcpy>
	if (err == -EINVAL) {
    587e:	e6dd      	b.n	563c <hci_cmd_handle+0x17c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5880:	2109      	movs	r1, #9
    5882:	a804      	add	r0, sp, #16
    5884:	f7ff fd82 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    5888:	2300      	movs	r3, #0
    588a:	f800 3b01 	strb.w	r3, [r0], #1
	lll_csrand_get(rp->rand, count);
    588e:	2108      	movs	r1, #8
    5890:	f001 fed2 	bl	7638 <lll_csrand_get>
	if (err == -EINVAL) {
    5894:	e6d2      	b.n	563c <hci_cmd_handle+0x17c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5896:	2109      	movs	r1, #9
    5898:	a804      	add	r0, sp, #16
    589a:	f7ff fd77 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    589e:	2300      	movs	r3, #0
	dst[0] = val;
    58a0:	2203      	movs	r2, #3
    58a2:	7003      	strb	r3, [r0, #0]
    58a4:	7042      	strb	r2, [r0, #1]
	dst[1] = val >> 8;
    58a6:	7083      	strb	r3, [r0, #2]
	dst[0] = val;
    58a8:	70c3      	strb	r3, [r0, #3]
	dst[1] = val >> 8;
    58aa:	7103      	strb	r3, [r0, #4]
	dst[0] = val;
    58ac:	7143      	strb	r3, [r0, #5]
	dst[1] = val >> 8;
    58ae:	7183      	strb	r3, [r0, #6]
    58b0:	e67a      	b.n	55a8 <hci_cmd_handle+0xe8>
	struct bt_hci_cp_le_set_adv_param *cmd = (void *)buf->data;
    58b2:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
    58b4:	7ba5      	ldrb	r5, [r4, #14]
    58b6:	79a3      	ldrb	r3, [r4, #6]
    58b8:	7962      	ldrb	r2, [r4, #5]
    58ba:	7921      	ldrb	r1, [r4, #4]
    58bc:	8820      	ldrh	r0, [r4, #0]
    58be:	9502      	str	r5, [sp, #8]
    58c0:	7b65      	ldrb	r5, [r4, #13]
    58c2:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
    58c4:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
    58c6:	9400      	str	r4, [sp, #0]
    58c8:	f000 fdca 	bl	6460 <ll_adv_params_set>
	*evt = cmd_complete_status(status);
    58cc:	e7a2      	b.n	5814 <hci_cmd_handle+0x354>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    58ce:	2102      	movs	r1, #2
    58d0:	a804      	add	r0, sp, #16
    58d2:	f7ff fd5b 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    58d6:	2300      	movs	r3, #0
    58d8:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
    58da:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
    58dc:	e6ae      	b.n	563c <hci_cmd_handle+0x17c>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
    58de:	68a1      	ldr	r1, [r4, #8]
    58e0:	f811 0b01 	ldrb.w	r0, [r1], #1
    58e4:	f000 fede 	bl	66a4 <ll_adv_data_set>
	*evt = cmd_complete_status(status);
    58e8:	e794      	b.n	5814 <hci_cmd_handle+0x354>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
    58ea:	68a1      	ldr	r1, [r4, #8]
    58ec:	f811 0b01 	ldrb.w	r0, [r1], #1
    58f0:	f000 fee0 	bl	66b4 <ll_adv_scan_rsp_set>
	*evt = cmd_complete_status(status);
    58f4:	e78e      	b.n	5814 <hci_cmd_handle+0x354>
	status = ll_adv_enable(cmd->enable);
    58f6:	68a3      	ldr	r3, [r4, #8]
    58f8:	7818      	ldrb	r0, [r3, #0]
    58fa:	f7fa fd61 	bl	3c0 <ll_adv_enable>
	*evt = cmd_complete_status(status);
    58fe:	e789      	b.n	5814 <hci_cmd_handle+0x354>
	struct bt_hci_cp_le_add_dev_to_rl *cmd = (void *)buf->data;
    5900:	68a0      	ldr	r0, [r4, #8]
	status = ll_rl_add(&cmd->peer_id_addr, cmd->peer_irk, cmd->local_irk);
    5902:	f100 0217 	add.w	r2, r0, #23
    5906:	1dc1      	adds	r1, r0, #7
    5908:	f001 fa34 	bl	6d74 <ll_rl_add>
	*evt = cmd_complete_status(status);
    590c:	e782      	b.n	5814 <hci_cmd_handle+0x354>
	status = ll_rl_remove(&cmd->peer_id_addr);
    590e:	68a0      	ldr	r0, [r4, #8]
    5910:	f001 fad0 	bl	6eb4 <ll_rl_remove>
	*evt = cmd_complete_status(status);
    5914:	e77e      	b.n	5814 <hci_cmd_handle+0x354>
	status = ll_rl_clear();
    5916:	f008 ff04 	bl	e722 <ll_rl_clear>
	*evt = cmd_complete_status(status);
    591a:	e77b      	b.n	5814 <hci_cmd_handle+0x354>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    591c:	2102      	movs	r1, #2
    591e:	a804      	add	r0, sp, #16
    5920:	f7ff fd34 	bl	538c <hci_cmd_complete>
    5924:	4604      	mov	r4, r0
	rp->rl_size = ll_rl_size_get();
    5926:	f008 fefa 	bl	e71e <ll_rl_size_get>
	rp->status = 0x00;
    592a:	2300      	movs	r3, #0
	rp->rl_size = ll_rl_size_get();
    592c:	7060      	strb	r0, [r4, #1]
	rp->status = 0x00;
    592e:	7023      	strb	r3, [r4, #0]
	if (err == -EINVAL) {
    5930:	e684      	b.n	563c <hci_cmd_handle+0x17c>
    5932:	68a1      	ldr	r1, [r4, #8]
    5934:	2207      	movs	r2, #7
    5936:	a806      	add	r0, sp, #24
    5938:	f008 f865 	bl	da06 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    593c:	2107      	movs	r1, #7
    593e:	a804      	add	r0, sp, #16
    5940:	f7ff fd24 	bl	538c <hci_cmd_complete>
    5944:	4604      	mov	r4, r0
	rp->status = ll_rl_crpa_get(&peer_id_addr, &rp->peer_rpa);
    5946:	1c41      	adds	r1, r0, #1
    5948:	a806      	add	r0, sp, #24
    594a:	f001 fb29 	bl	6fa0 <ll_rl_crpa_get>
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
    594e:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
    5950:	e674      	b.n	563c <hci_cmd_handle+0x17c>
    5952:	68a1      	ldr	r1, [r4, #8]
    5954:	2207      	movs	r2, #7
    5956:	a806      	add	r0, sp, #24
    5958:	f008 f855 	bl	da06 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    595c:	2107      	movs	r1, #7
    595e:	a804      	add	r0, sp, #16
    5960:	f7ff fd14 	bl	538c <hci_cmd_complete>
    5964:	4604      	mov	r4, r0
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
    5966:	1c41      	adds	r1, r0, #1
    5968:	a806      	add	r0, sp, #24
    596a:	f001 fb3b 	bl	6fe4 <ll_rl_lrpa_get>
    596e:	e7ee      	b.n	594e <hci_cmd_handle+0x48e>
	status = ll_rl_enable(cmd->enable);
    5970:	68a3      	ldr	r3, [r4, #8]
    5972:	7818      	ldrb	r0, [r3, #0]
    5974:	f000 ffd0 	bl	6918 <ll_rl_enable>
	*evt = cmd_complete_status(status);
    5978:	e74c      	b.n	5814 <hci_cmd_handle+0x354>
	uint16_t timeout = sys_le16_to_cpu(cmd->rpa_timeout);
    597a:	68a3      	ldr	r3, [r4, #8]
	ll_rl_timeout_set(timeout);
    597c:	8818      	ldrh	r0, [r3, #0]
    597e:	f000 ffe3 	bl	6948 <ll_rl_timeout_set>
    5982:	e5e1      	b.n	5548 <hci_cmd_handle+0x88>
	struct bt_hci_cp_le_set_privacy_mode *cmd = (void *)buf->data;
    5984:	68a0      	ldr	r0, [r4, #8]
	status = ll_priv_mode_set(&cmd->id_addr, cmd->mode);
    5986:	79c1      	ldrb	r1, [r0, #7]
    5988:	f001 fb46 	bl	7018 <ll_priv_mode_set>
    598c:	e742      	b.n	5814 <hci_cmd_handle+0x354>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    598e:	2103      	movs	r1, #3
    5990:	a804      	add	r0, sp, #16
    5992:	f7ff fcfb 	bl	538c <hci_cmd_complete>
	rp->status = 0x00;
    5996:	4601      	mov	r1, r0
    5998:	2300      	movs	r3, #0
    599a:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
    599e:	3001      	adds	r0, #1
    59a0:	f008 fd36 	bl	e410 <ll_tx_pwr_get>
	if (err == -EINVAL) {
    59a4:	e64a      	b.n	563c <hci_cmd_handle+0x17c>
    59a6:	bf00      	nop

000059a8 <hci_evt_encode>:
	}
}
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
    59a8:	b508      	push	{r3, lr}
	struct pdu_data *pdu_data = (void *)node_rx->pdu;

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    59aa:	7903      	ldrb	r3, [r0, #4]
    59ac:	2b03      	cmp	r3, #3
    59ae:	d00c      	beq.n	59ca <hci_evt_encode+0x22>
		LL_ASSERT(0);
    59b0:	4a06      	ldr	r2, [pc, #24]	; (59cc <hci_evt_encode+0x24>)
    59b2:	4907      	ldr	r1, [pc, #28]	; (59d0 <hci_evt_encode+0x28>)
    59b4:	4807      	ldr	r0, [pc, #28]	; (59d4 <hci_evt_encode+0x2c>)
    59b6:	f641 43ab 	movw	r3, #7339	; 0x1cab
    59ba:	f007 fa20 	bl	cdfe <printk>
    59be:	4040      	eors	r0, r0
    59c0:	f380 8811 	msr	BASEPRI, r0
    59c4:	f04f 0003 	mov.w	r0, #3
    59c8:	df02      	svc	2
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
    59ca:	bd08      	pop	{r3, pc}
    59cc:	00011526 	.word	0x00011526
    59d0:	00011d2c 	.word	0x00011d2c
    59d4:	00010f78 	.word	0x00010f78

000059d8 <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
    59d8:	b510      	push	{r4, lr}
    59da:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
    59dc:	f008 fec1 	bl	e762 <lll_reset>
	LL_ASSERT(!err);
    59e0:	b160      	cbz	r0, 59fc <perform_lll_reset+0x24>
    59e2:	4a11      	ldr	r2, [pc, #68]	; (5a28 <perform_lll_reset+0x50>)
    59e4:	4911      	ldr	r1, [pc, #68]	; (5a2c <perform_lll_reset+0x54>)
    59e6:	4812      	ldr	r0, [pc, #72]	; (5a30 <perform_lll_reset+0x58>)
    59e8:	f640 031c 	movw	r3, #2076	; 0x81c
    59ec:	f007 fa07 	bl	cdfe <printk>
    59f0:	4040      	eors	r0, r0
    59f2:	f380 8811 	msr	BASEPRI, r0
    59f6:	f04f 0003 	mov.w	r0, #3
    59fa:	df02      	svc	2

#if defined(CONFIG_BT_BROADCASTER)
	/* Reset adv state */
	err = lll_adv_reset();
    59fc:	f008 fef4 	bl	e7e8 <lll_adv_reset>
	LL_ASSERT(!err);
    5a00:	b160      	cbz	r0, 5a1c <perform_lll_reset+0x44>
    5a02:	4a09      	ldr	r2, [pc, #36]	; (5a28 <perform_lll_reset+0x50>)
    5a04:	4909      	ldr	r1, [pc, #36]	; (5a2c <perform_lll_reset+0x54>)
    5a06:	480a      	ldr	r0, [pc, #40]	; (5a30 <perform_lll_reset+0x58>)
    5a08:	f640 0321 	movw	r3, #2081	; 0x821
    5a0c:	f007 f9f7 	bl	cdfe <printk>
    5a10:	4040      	eors	r0, r0
    5a12:	f380 8811 	msr	BASEPRI, r0
    5a16:	f04f 0003 	mov.w	r0, #3
    5a1a:	df02      	svc	2
	z_impl_k_sem_give(sem);
    5a1c:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CTLR_DF */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
    5a1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    5a22:	f006 b989 	b.w	bd38 <z_impl_k_sem_give>
    5a26:	bf00      	nop
    5a28:	0001158a 	.word	0x0001158a
    5a2c:	000115c5 	.word	0x000115c5
    5a30:	00010f78 	.word	0x00010f78

00005a34 <rx_alloc.constprop.0>:
static inline void *mark_get(void *m)
{
	return m;
}

static inline void rx_alloc(uint8_t max)
    5a34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
{
	uint8_t idx;

	if (max > mem_link_rx.quota_pdu) {
    5a38:	f8df 9060 	ldr.w	r9, [pc, #96]	; 5a9c <rx_alloc.constprop.0+0x68>
		max = mem_link_rx.quota_pdu;
	}

	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    5a3c:	4e18      	ldr	r6, [pc, #96]	; (5aa0 <rx_alloc.constprop.0+0x6c>)
	if (max > mem_link_rx.quota_pdu) {
    5a3e:	46c8      	mov	r8, r9
    5a40:	f818 7b04 	ldrb.w	r7, [r8], #4
	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    5a44:	b177      	cbz	r7, 5a64 <rx_alloc.constprop.0+0x30>
 */
static inline bool mfifo_enqueue_idx_get(uint8_t count, uint8_t first, uint8_t last,
					 uint8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
    5a46:	78f4      	ldrb	r4, [r6, #3]
	if (last == count) {
    5a48:	7872      	ldrb	r2, [r6, #1]
    5a4a:	78b3      	ldrb	r3, [r6, #2]
	last = last + 1;
    5a4c:	3401      	adds	r4, #1
    5a4e:	b2e4      	uxtb	r4, r4
		last = 0U;
    5a50:	42a2      	cmp	r2, r4
    5a52:	bf08      	it	eq
    5a54:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
    5a56:	429c      	cmp	r4, r3
    5a58:	d004      	beq.n	5a64 <rx_alloc.constprop.0+0x30>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
    5a5a:	4640      	mov	r0, r8
    5a5c:	f008 f9b8 	bl	ddd0 <mem_acquire>
		if (!link) {
    5a60:	4605      	mov	r5, r0
    5a62:	b908      	cbnz	r0, 5a68 <rx_alloc.constprop.0+0x34>
		MFIFO_BY_IDX_ENQUEUE(ll_pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */
}
    5a64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		rx = mem_acquire(&mem_pdu_rx.free);
    5a68:	480e      	ldr	r0, [pc, #56]	; (5aa4 <rx_alloc.constprop.0+0x70>)
    5a6a:	f008 f9b1 	bl	ddd0 <mem_acquire>
		if (!rx) {
    5a6e:	b928      	cbnz	r0, 5a7c <rx_alloc.constprop.0+0x48>
			mem_release(link, &mem_link_rx.free);
    5a70:	4628      	mov	r0, r5
    5a72:	490d      	ldr	r1, [pc, #52]	; (5aa8 <rx_alloc.constprop.0+0x74>)
}
    5a74:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			mem_release(link, &mem_link_rx.free);
    5a78:	f008 b9c3 	b.w	de02 <mem_release>
		rx->link = link;
    5a7c:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(uint8_t *fifo, uint8_t size, uint8_t idx,
					void *mem, uint8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    5a7e:	78f2      	ldrb	r2, [r6, #3]
    5a80:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    5a82:	fb02 6303 	mla	r3, r2, r3, r6
    5a86:	6058      	str	r0, [r3, #4]
	mem_link_rx.quota_pdu += delta;
    5a88:	f899 3000 	ldrb.w	r3, [r9]

	cpu_dmb(); /* Ensure data accesses are synchronized */
	*last = idx; /* Commit: Update write index */
    5a8c:	70f4      	strb	r4, [r6, #3]
    5a8e:	3b01      	subs	r3, #1
		max--;
    5a90:	3f01      	subs	r7, #1
	mem_link_rx.quota_pdu += delta;
    5a92:	f889 3000 	strb.w	r3, [r9]
		max--;
    5a96:	b2ff      	uxtb	r7, r7
    5a98:	e7d4      	b.n	5a44 <rx_alloc.constprop.0+0x10>
    5a9a:	bf00      	nop
    5a9c:	2000120c 	.word	0x2000120c
    5aa0:	200001f8 	.word	0x200001f8
    5aa4:	2000124c 	.word	0x2000124c
    5aa8:	20001210 	.word	0x20001210

00005aac <ull_ticker_status_give>:
	*((uint32_t volatile *)param) = status;
    5aac:	6008      	str	r0, [r1, #0]
    5aae:	4801      	ldr	r0, [pc, #4]	; (5ab4 <ull_ticker_status_give+0x8>)
    5ab0:	f006 b942 	b.w	bd38 <z_impl_k_sem_give>
    5ab4:	200013c0 	.word	0x200013c0

00005ab8 <ll_rx_get>:
{
    5ab8:	b513      	push	{r0, r1, r4, lr}
	*node_rx = NULL;
    5aba:	2300      	movs	r3, #0
    5abc:	6003      	str	r3, [r0, #0]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    5abe:	4b06      	ldr	r3, [pc, #24]	; (5ad8 <ll_rx_get+0x20>)
{
    5ac0:	4604      	mov	r4, r0
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    5ac2:	aa01      	add	r2, sp, #4
    5ac4:	e9d3 0100 	ldrd	r0, r1, [r3]
    5ac8:	f008 f9d4 	bl	de74 <memq_peek>
	if (link) {
    5acc:	b108      	cbz	r0, 5ad2 <ll_rx_get+0x1a>
			*node_rx = rx;
    5ace:	9b01      	ldr	r3, [sp, #4]
    5ad0:	6023      	str	r3, [r4, #0]
}
    5ad2:	2000      	movs	r0, #0
    5ad4:	b002      	add	sp, #8
    5ad6:	bd10      	pop	{r4, pc}
    5ad8:	200013a4 	.word	0x200013a4

00005adc <ll_rx_dequeue>:
{
    5adc:	b513      	push	{r0, r1, r4, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    5ade:	4918      	ldr	r1, [pc, #96]	; (5b40 <ll_rx_dequeue+0x64>)
	struct node_rx_hdr *rx = NULL;
    5ae0:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    5ae2:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
    5ae4:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    5ae6:	aa01      	add	r2, sp, #4
    5ae8:	f008 f9cc 	bl	de84 <memq_dequeue>
	LL_ASSERT(link);
    5aec:	4604      	mov	r4, r0
    5aee:	b960      	cbnz	r0, 5b0a <ll_rx_dequeue+0x2e>
    5af0:	4a14      	ldr	r2, [pc, #80]	; (5b44 <ll_rx_dequeue+0x68>)
    5af2:	4915      	ldr	r1, [pc, #84]	; (5b48 <ll_rx_dequeue+0x6c>)
    5af4:	4815      	ldr	r0, [pc, #84]	; (5b4c <ll_rx_dequeue+0x70>)
    5af6:	f240 33a1 	movw	r3, #929	; 0x3a1
    5afa:	f007 f980 	bl	cdfe <printk>
    5afe:	4040      	eors	r0, r0
    5b00:	f380 8811 	msr	BASEPRI, r0
    5b04:	f04f 0003 	mov.w	r0, #3
    5b08:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
    5b0a:	4911      	ldr	r1, [pc, #68]	; (5b50 <ll_rx_dequeue+0x74>)
    5b0c:	4620      	mov	r0, r4
    5b0e:	f008 f978 	bl	de02 <mem_release>
	switch (rx->type) {
    5b12:	9b01      	ldr	r3, [sp, #4]
    5b14:	791b      	ldrb	r3, [r3, #4]
    5b16:	b973      	cbnz	r3, 5b36 <ll_rx_dequeue+0x5a>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
    5b18:	4a0a      	ldr	r2, [pc, #40]	; (5b44 <ll_rx_dequeue+0x68>)
    5b1a:	490e      	ldr	r1, [pc, #56]	; (5b54 <ll_rx_dequeue+0x78>)
    5b1c:	f240 43c3 	movw	r3, #1219	; 0x4c3
		LL_ASSERT(0);
    5b20:	480a      	ldr	r0, [pc, #40]	; (5b4c <ll_rx_dequeue+0x70>)
    5b22:	f007 f96c 	bl	cdfe <printk>
    5b26:	4040      	eors	r0, r0
    5b28:	f380 8811 	msr	BASEPRI, r0
    5b2c:	f04f 0003 	mov.w	r0, #3
    5b30:	df02      	svc	2
}
    5b32:	b002      	add	sp, #8
    5b34:	bd10      	pop	{r4, pc}
		LL_ASSERT(0);
    5b36:	4a03      	ldr	r2, [pc, #12]	; (5b44 <ll_rx_dequeue+0x68>)
    5b38:	4907      	ldr	r1, [pc, #28]	; (5b58 <ll_rx_dequeue+0x7c>)
    5b3a:	f240 43c7 	movw	r3, #1223	; 0x4c7
    5b3e:	e7ef      	b.n	5b20 <ll_rx_dequeue+0x44>
    5b40:	200013a4 	.word	0x200013a4
    5b44:	0001158a 	.word	0x0001158a
    5b48:	000115ca 	.word	0x000115ca
    5b4c:	00010f78 	.word	0x00010f78
    5b50:	20001210 	.word	0x20001210
    5b54:	000115cf 	.word	0x000115cf
    5b58:	00011d2c 	.word	0x00011d2c

00005b5c <ll_rx_mem_release>:
{
    5b5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	rx = *node_rx;
    5b60:	6804      	ldr	r4, [r0, #0]
			LL_ASSERT(0);
    5b62:	4e20      	ldr	r6, [pc, #128]	; (5be4 <ll_rx_mem_release+0x88>)
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    5b64:	4f20      	ldr	r7, [pc, #128]	; (5be8 <ll_rx_mem_release+0x8c>)
{
    5b66:	4605      	mov	r5, r0
	while (rx) {
    5b68:	b924      	cbnz	r4, 5b74 <ll_rx_mem_release+0x18>
	*node_rx = rx;
    5b6a:	602c      	str	r4, [r5, #0]
}
    5b6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	rx_alloc(UINT8_MAX);
    5b70:	f7ff bf60 	b.w	5a34 <rx_alloc.constprop.0>
		switch (rx_free->type) {
    5b74:	7923      	ldrb	r3, [r4, #4]
		rx = rx->next;
    5b76:	f8d4 8000 	ldr.w	r8, [r4]
		switch (rx_free->type) {
    5b7a:	bb2b      	cbnz	r3, 5bc8 <ll_rx_mem_release+0x6c>
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
    5b7c:	491b      	ldr	r1, [pc, #108]	; (5bec <ll_rx_mem_release+0x90>)
    5b7e:	481c      	ldr	r0, [pc, #112]	; (5bf0 <ll_rx_mem_release+0x94>)
    5b80:	f240 537d 	movw	r3, #1405	; 0x57d
    5b84:	4632      	mov	r2, r6
    5b86:	f007 f93a 	bl	cdfe <printk>
    5b8a:	4040      	eors	r0, r0
    5b8c:	f380 8811 	msr	BASEPRI, r0
    5b90:	f04f 0003 	mov.w	r0, #3
    5b94:	df02      	svc	2
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    5b96:	783b      	ldrb	r3, [r7, #0]
    5b98:	2b03      	cmp	r3, #3
    5b9a:	d90c      	bls.n	5bb6 <ll_rx_mem_release+0x5a>
    5b9c:	4915      	ldr	r1, [pc, #84]	; (5bf4 <ll_rx_mem_release+0x98>)
    5b9e:	4814      	ldr	r0, [pc, #80]	; (5bf0 <ll_rx_mem_release+0x94>)
    5ba0:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    5ba4:	4632      	mov	r2, r6
    5ba6:	f007 f92a 	bl	cdfe <printk>
    5baa:	4040      	eors	r0, r0
    5bac:	f380 8811 	msr	BASEPRI, r0
    5bb0:	f04f 0003 	mov.w	r0, #3
    5bb4:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
    5bb6:	783b      	ldrb	r3, [r7, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
    5bb8:	490f      	ldr	r1, [pc, #60]	; (5bf8 <ll_rx_mem_release+0x9c>)
	mem_link_rx.quota_pdu += delta;
    5bba:	3301      	adds	r3, #1
			mem_release(rx_free, &mem_pdu_rx.free);
    5bbc:	4620      	mov	r0, r4
	mem_link_rx.quota_pdu += delta;
    5bbe:	703b      	strb	r3, [r7, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
    5bc0:	f008 f91f 	bl	de02 <mem_release>
{
    5bc4:	4644      	mov	r4, r8
    5bc6:	e7cf      	b.n	5b68 <ll_rx_mem_release+0xc>
			LL_ASSERT(0);
    5bc8:	490c      	ldr	r1, [pc, #48]	; (5bfc <ll_rx_mem_release+0xa0>)
    5bca:	4809      	ldr	r0, [pc, #36]	; (5bf0 <ll_rx_mem_release+0x94>)
    5bcc:	f240 53f4 	movw	r3, #1524	; 0x5f4
    5bd0:	4632      	mov	r2, r6
    5bd2:	f007 f914 	bl	cdfe <printk>
    5bd6:	4040      	eors	r0, r0
    5bd8:	f380 8811 	msr	BASEPRI, r0
    5bdc:	f04f 0003 	mov.w	r0, #3
    5be0:	df02      	svc	2
			break;
    5be2:	e7ef      	b.n	5bc4 <ll_rx_mem_release+0x68>
    5be4:	0001158a 	.word	0x0001158a
    5be8:	2000120c 	.word	0x2000120c
    5bec:	000115ed 	.word	0x000115ed
    5bf0:	00010f78 	.word	0x00010f78
    5bf4:	00011610 	.word	0x00011610
    5bf8:	2000124c 	.word	0x2000124c
    5bfc:	00011d2c 	.word	0x00011d2c

00005c00 <ull_ticker_status_take>:
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    5c00:	f030 0302 	bics.w	r3, r0, #2
{
    5c04:	b510      	push	{r4, lr}
    5c06:	460c      	mov	r4, r1
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    5c08:	d00f      	beq.n	5c2a <ull_ticker_status_take+0x2a>
    5c0a:	680b      	ldr	r3, [r1, #0]
    5c0c:	2b02      	cmp	r3, #2
    5c0e:	d10c      	bne.n	5c2a <ull_ticker_status_take+0x2a>
    5c10:	4a0a      	ldr	r2, [pc, #40]	; (5c3c <ull_ticker_status_take+0x3c>)
    5c12:	490b      	ldr	r1, [pc, #44]	; (5c40 <ull_ticker_status_take+0x40>)
    5c14:	480b      	ldr	r0, [pc, #44]	; (5c44 <ull_ticker_status_take+0x44>)
    5c16:	f240 637c 	movw	r3, #1660	; 0x67c
    5c1a:	f007 f8f0 	bl	cdfe <printk>
    5c1e:	4040      	eors	r0, r0
    5c20:	f380 8811 	msr	BASEPRI, r0
    5c24:	f04f 0003 	mov.w	r0, #3
    5c28:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    5c2a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5c2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5c32:	4805      	ldr	r0, [pc, #20]	; (5c48 <ull_ticker_status_take+0x48>)
    5c34:	f006 f8a6 	bl	bd84 <z_impl_k_sem_take>
	return *ret_cb;
    5c38:	6820      	ldr	r0, [r4, #0]
}
    5c3a:	bd10      	pop	{r4, pc}
    5c3c:	0001158a 	.word	0x0001158a
    5c40:	0001164d 	.word	0x0001164d
    5c44:	00010f78 	.word	0x00010f78
    5c48:	200013c0 	.word	0x200013c0

00005c4c <ull_disable_mark>:
	if (!*m) {
    5c4c:	4b02      	ldr	r3, [pc, #8]	; (5c58 <ull_disable_mark+0xc>)
    5c4e:	681a      	ldr	r2, [r3, #0]
    5c50:	b902      	cbnz	r2, 5c54 <ull_disable_mark+0x8>
		*m = param;
    5c52:	6018      	str	r0, [r3, #0]
}
    5c54:	6818      	ldr	r0, [r3, #0]
    5c56:	4770      	bx	lr
    5c58:	200011dc 	.word	0x200011dc

00005c5c <ull_disable_unmark>:
	if (*m && *m == param) {
    5c5c:	4a05      	ldr	r2, [pc, #20]	; (5c74 <ull_disable_unmark+0x18>)
{
    5c5e:	4603      	mov	r3, r0
	if (*m && *m == param) {
    5c60:	6810      	ldr	r0, [r2, #0]
    5c62:	b130      	cbz	r0, 5c72 <ull_disable_unmark+0x16>
    5c64:	4283      	cmp	r3, r0
    5c66:	f04f 0300 	mov.w	r3, #0
    5c6a:	d101      	bne.n	5c70 <ull_disable_unmark+0x14>
		*m = NULL;
    5c6c:	6013      	str	r3, [r2, #0]
		return param;
    5c6e:	4770      	bx	lr
	return NULL;
    5c70:	4618      	mov	r0, r3
}
    5c72:	4770      	bx	lr
    5c74:	200011dc 	.word	0x200011dc

00005c78 <ull_disable_mark_get>:
}
    5c78:	4b01      	ldr	r3, [pc, #4]	; (5c80 <ull_disable_mark_get+0x8>)
    5c7a:	6818      	ldr	r0, [r3, #0]
    5c7c:	4770      	bx	lr
    5c7e:	bf00      	nop
    5c80:	200011dc 	.word	0x200011dc

00005c84 <ull_disable>:
{
    5c84:	b530      	push	{r4, r5, lr}
	hdr = HDR_LLL2ULL(lll);
    5c86:	6804      	ldr	r4, [r0, #0]
{
    5c88:	b087      	sub	sp, #28
    5c8a:	4605      	mov	r5, r0
	if (!hdr || !ull_ref_get(hdr)) {
    5c8c:	b914      	cbnz	r4, 5c94 <ull_disable+0x10>
		return 0;
    5c8e:	2000      	movs	r0, #0
}
    5c90:	b007      	add	sp, #28
    5c92:	bd30      	pop	{r4, r5, pc}
	return hdr->ref;
    5c94:	7823      	ldrb	r3, [r4, #0]
	if (!hdr || !ull_ref_get(hdr)) {
    5c96:	2b00      	cmp	r3, #0
    5c98:	d0f9      	beq.n	5c8e <ull_disable+0xa>
	return z_impl_k_sem_init(sem, initial_count, limit);
    5c9a:	2201      	movs	r2, #1
    5c9c:	2100      	movs	r1, #0
    5c9e:	4668      	mov	r0, sp
    5ca0:	f009 fd67 	bl	f772 <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
    5ca4:	4b11      	ldr	r3, [pc, #68]	; (5cec <ull_disable+0x68>)
    5ca6:	6163      	str	r3, [r4, #20]
    5ca8:	7823      	ldrb	r3, [r4, #0]
	hdr->disabled_param = &sem;
    5caa:	f8c4 d018 	str.w	sp, [r4, #24]
	if (!ull_ref_get(hdr)) {
    5cae:	2b00      	cmp	r3, #0
    5cb0:	d0ed      	beq.n	5c8e <ull_disable+0xa>
	mfy.param = lll;
    5cb2:	4b0f      	ldr	r3, [pc, #60]	; (5cf0 <ull_disable+0x6c>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
    5cb4:	2200      	movs	r2, #0
    5cb6:	4611      	mov	r1, r2
    5cb8:	2003      	movs	r0, #3
	mfy.param = lll;
    5cba:	609d      	str	r5, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
    5cbc:	f7fe fc14 	bl	44e8 <mayfly_enqueue>
	LL_ASSERT(!ret);
    5cc0:	b160      	cbz	r0, 5cdc <ull_disable+0x58>
    5cc2:	4a0c      	ldr	r2, [pc, #48]	; (5cf4 <ull_disable+0x70>)
    5cc4:	490c      	ldr	r1, [pc, #48]	; (5cf8 <ull_disable+0x74>)
    5cc6:	480d      	ldr	r0, [pc, #52]	; (5cfc <ull_disable+0x78>)
    5cc8:	f240 63f7 	movw	r3, #1783	; 0x6f7
    5ccc:	f007 f897 	bl	cdfe <printk>
    5cd0:	4040      	eors	r0, r0
    5cd2:	f380 8811 	msr	BASEPRI, r0
    5cd6:	f04f 0003 	mov.w	r0, #3
    5cda:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    5cdc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5ce0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5ce4:	4668      	mov	r0, sp
    5ce6:	f006 f84d 	bl	bd84 <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
    5cea:	e7d1      	b.n	5c90 <ull_disable+0xc>
    5cec:	0000e435 	.word	0x0000e435
    5cf0:	20000344 	.word	0x20000344
    5cf4:	0001158a 	.word	0x0001158a
    5cf8:	00011648 	.word	0x00011648
    5cfc:	00010f78 	.word	0x00010f78

00005d00 <ull_pdu_rx_alloc_peek>:
{
    5d00:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
    5d02:	4a0a      	ldr	r2, [pc, #40]	; (5d2c <ull_pdu_rx_alloc_peek+0x2c>)
    5d04:	7891      	ldrb	r1, [r2, #2]
    5d06:	78d4      	ldrb	r4, [r2, #3]
    5d08:	7853      	ldrb	r3, [r2, #1]
 * @details API 1 and 2
 *   Empty if first == last
 */
static inline uint8_t mfifo_avail_count_get(uint8_t count, uint8_t first, uint8_t last)
{
	if (last >= first) {
    5d0a:	42a1      	cmp	r1, r4
		return last - first;
	} else {
		return count - first + last;
    5d0c:	bf8a      	itet	hi
    5d0e:	191b      	addhi	r3, r3, r4
		return last - first;
    5d10:	1a63      	subls	r3, r4, r1
		return count - first + last;
    5d12:	1a5b      	subhi	r3, r3, r1
    5d14:	b2db      	uxtb	r3, r3
    5d16:	4298      	cmp	r0, r3
    5d18:	d806      	bhi.n	5d28 <ull_pdu_rx_alloc_peek+0x28>
 * @details API 2
 */
static inline void *mfifo_dequeue_peek(uint8_t *fifo, uint8_t size, uint8_t first,
				       uint8_t last)
{
	if (first == last) {
    5d1a:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
    5d1c:	7813      	ldrb	r3, [r2, #0]
    5d1e:	d003      	beq.n	5d28 <ull_pdu_rx_alloc_peek+0x28>
		return NULL; /* Queue is empty */
	}

	/* API 2: fifo is array of void-ptrs */
	return *((void **)(fifo + first * size));
    5d20:	fb01 2203 	mla	r2, r1, r3, r2
    5d24:	6850      	ldr	r0, [r2, #4]
}
    5d26:	bd10      	pop	{r4, pc}
		return NULL;
    5d28:	2000      	movs	r0, #0
    5d2a:	e7fc      	b.n	5d26 <ull_pdu_rx_alloc_peek+0x26>
    5d2c:	200001f8 	.word	0x200001f8

00005d30 <ull_rx_put_done>:
	memq_enqueue(link, done, &memq_ull_done.tail);
    5d30:	4a01      	ldr	r2, [pc, #4]	; (5d38 <ull_rx_put_done+0x8>)
    5d32:	f008 b898 	b.w	de66 <memq_enqueue>
    5d36:	bf00      	nop
    5d38:	200013b0 	.word	0x200013b0

00005d3c <ull_rx_sched_done>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
    5d3c:	2201      	movs	r2, #1
    5d3e:	4b02      	ldr	r3, [pc, #8]	; (5d48 <ull_rx_sched_done+0xc>)
    5d40:	4611      	mov	r1, r2
    5d42:	2000      	movs	r0, #0
    5d44:	f7fe bbd0 	b.w	44e8 <mayfly_enqueue>
    5d48:	20000334 	.word	0x20000334

00005d4c <ull_prepare_enqueue>:
{
    5d4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    5d50:	4e14      	ldr	r6, [pc, #80]	; (5da4 <ull_prepare_enqueue+0x58>)
{
    5d52:	4699      	mov	r9, r3
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    5d54:	78f3      	ldrb	r3, [r6, #3]
	if (last == count) {
    5d56:	7874      	ldrb	r4, [r6, #1]
	last = last + 1;
    5d58:	1c5d      	adds	r5, r3, #1
{
    5d5a:	4680      	mov	r8, r0
    5d5c:	b2ed      	uxtb	r5, r5
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    5d5e:	78b0      	ldrb	r0, [r6, #2]
		last = 0U;
    5d60:	42ac      	cmp	r4, r5
    5d62:	bf08      	it	eq
    5d64:	2500      	moveq	r5, #0
	if (last == first) {
    5d66:	42a8      	cmp	r0, r5
{
    5d68:	460f      	mov	r7, r1
    5d6a:	4611      	mov	r1, r2
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    5d6c:	7832      	ldrb	r2, [r6, #0]
    5d6e:	d016      	beq.n	5d9e <ull_prepare_enqueue+0x52>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
    5d70:	1d34      	adds	r4, r6, #4
    5d72:	fb03 4402 	mla	r4, r3, r2, r4
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
    5d76:	4620      	mov	r0, r4
    5d78:	2210      	movs	r2, #16
    5d7a:	f007 fe44 	bl	da06 <memcpy>
	e->is_resume = is_resume;
    5d7e:	7f23      	ldrb	r3, [r4, #28]
    5d80:	f89d 2020 	ldrb.w	r2, [sp, #32]
	e->abort_cb = abort_cb;
    5d84:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
    5d86:	f002 0201 	and.w	r2, r2, #1
    5d8a:	f023 0303 	bic.w	r3, r3, #3
    5d8e:	4313      	orrs	r3, r2
	e->is_abort_cb = is_abort_cb;
    5d90:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_resume = is_resume;
    5d94:	7723      	strb	r3, [r4, #28]
	*last = idx; /* Commit: Update write index */
    5d96:	70f5      	strb	r5, [r6, #3]
}
    5d98:	4620      	mov	r0, r4
    5d9a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return NULL;
    5d9e:	2400      	movs	r4, #0
    5da0:	e7fa      	b.n	5d98 <ull_prepare_enqueue+0x4c>
    5da2:	bf00      	nop
    5da4:	20000210 	.word	0x20000210

00005da8 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
    5da8:	4b05      	ldr	r3, [pc, #20]	; (5dc0 <ull_prepare_dequeue_get+0x18>)
    5daa:	7898      	ldrb	r0, [r3, #2]
	if (first == last) {
    5dac:	78d9      	ldrb	r1, [r3, #3]
    5dae:	781a      	ldrb	r2, [r3, #0]
    5db0:	4281      	cmp	r1, r0
	return (void *)(fifo + first * size);
    5db2:	bf1a      	itte	ne
    5db4:	3304      	addne	r3, #4
    5db6:	fb00 3002 	mlane	r0, r0, r2, r3
		return NULL;
    5dba:	2000      	moveq	r0, #0
}
    5dbc:	4770      	bx	lr
    5dbe:	bf00      	nop
    5dc0:	20000210 	.word	0x20000210

00005dc4 <ull_prepare_dequeue_iter>:
{
    5dc4:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    5dc6:	4a0c      	ldr	r2, [pc, #48]	; (5df8 <ull_prepare_dequeue_iter+0x34>)
{
    5dc8:	4603      	mov	r3, r0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    5dca:	7854      	ldrb	r4, [r2, #1]
					   uint8_t first, uint8_t last, uint8_t *idx)
{
	void *p;
	uint8_t i;

	if (*idx >= count) {
    5dcc:	7819      	ldrb	r1, [r3, #0]
    5dce:	78d0      	ldrb	r0, [r2, #3]
    5dd0:	7815      	ldrb	r5, [r2, #0]
    5dd2:	42a1      	cmp	r1, r4
    5dd4:	bf24      	itt	cs
    5dd6:	7892      	ldrbcs	r2, [r2, #2]
		*idx = first;
    5dd8:	701a      	strbcs	r2, [r3, #0]
	}

	if (*idx == last) {
    5dda:	7819      	ldrb	r1, [r3, #0]
    5ddc:	4288      	cmp	r0, r1
    5dde:	d009      	beq.n	5df4 <ull_prepare_dequeue_iter+0x30>
		return NULL;
	}

	i = *idx + 1;
    5de0:	1c4a      	adds	r2, r1, #1
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
    5de2:	4806      	ldr	r0, [pc, #24]	; (5dfc <ull_prepare_dequeue_iter+0x38>)
	i = *idx + 1;
    5de4:	b2d2      	uxtb	r2, r2
		i = 0U;
    5de6:	4294      	cmp	r4, r2
    5de8:	bf08      	it	eq
    5dea:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
    5dec:	fb01 0005 	mla	r0, r1, r5, r0

	*idx = i;
    5df0:	701a      	strb	r2, [r3, #0]
}
    5df2:	bd30      	pop	{r4, r5, pc}
		return NULL;
    5df4:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    5df6:	e7fc      	b.n	5df2 <ull_prepare_dequeue_iter+0x2e>
    5df8:	20000210 	.word	0x20000210
    5dfc:	20000214 	.word	0x20000214

00005e00 <ull_prepare_dequeue>:
{
    5e00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5e04:	4605      	mov	r5, r0
	next = ull_prepare_dequeue_get();
    5e06:	f7ff ffcf 	bl	5da8 <ull_prepare_dequeue_get>
			mfy.param = next;
    5e0a:	4f1c      	ldr	r7, [pc, #112]	; (5e7c <ull_prepare_dequeue+0x7c>)
		MFIFO_DEQUEUE(prep);
    5e0c:	4c1c      	ldr	r4, [pc, #112]	; (5e80 <ull_prepare_dequeue+0x80>)
	while (next) {
    5e0e:	2800      	cmp	r0, #0
    5e10:	d031      	beq.n	5e76 <ull_prepare_dequeue+0x76>
		uint8_t is_aborted = next->is_aborted;
    5e12:	7f03      	ldrb	r3, [r0, #28]
		if (!is_aborted) {
    5e14:	079a      	lsls	r2, r3, #30
		uint8_t is_aborted = next->is_aborted;
    5e16:	f3c3 0640 	ubfx	r6, r3, #1, #1
		uint8_t is_resume = next->is_resume;
    5e1a:	f003 0801 	and.w	r8, r3, #1
		if (!is_aborted) {
    5e1e:	d414      	bmi.n	5e4a <ull_prepare_dequeue+0x4a>
			mfy.param = next;
    5e20:	60b8      	str	r0, [r7, #8]
			ret = mayfly_enqueue(caller_id, TICKER_USER_ID_LLL, 0,
    5e22:	4b16      	ldr	r3, [pc, #88]	; (5e7c <ull_prepare_dequeue+0x7c>)
    5e24:	4632      	mov	r2, r6
    5e26:	4631      	mov	r1, r6
    5e28:	4628      	mov	r0, r5
    5e2a:	f7fe fb5d 	bl	44e8 <mayfly_enqueue>
			LL_ASSERT(!ret);
    5e2e:	b160      	cbz	r0, 5e4a <ull_prepare_dequeue+0x4a>
    5e30:	4a14      	ldr	r2, [pc, #80]	; (5e84 <ull_prepare_dequeue+0x84>)
    5e32:	4915      	ldr	r1, [pc, #84]	; (5e88 <ull_prepare_dequeue+0x88>)
    5e34:	4815      	ldr	r0, [pc, #84]	; (5e8c <ull_prepare_dequeue+0x8c>)
    5e36:	f240 736e 	movw	r3, #1902	; 0x76e
    5e3a:	f006 ffe0 	bl	cdfe <printk>
    5e3e:	4040      	eors	r0, r0
    5e40:	f380 8811 	msr	BASEPRI, r0
    5e44:	f04f 0003 	mov.w	r0, #3
    5e48:	df02      	svc	2
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(uint8_t *fifo, uint8_t size, uint8_t count,
				  uint8_t last, uint8_t *first)
{
	uint8_t _first = *first; /* Copy read-index */
    5e4a:	78a3      	ldrb	r3, [r4, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
    5e4c:	78e1      	ldrb	r1, [r4, #3]
		MFIFO_DEQUEUE(prep);
    5e4e:	7862      	ldrb	r2, [r4, #1]
    5e50:	4299      	cmp	r1, r3
    5e52:	d005      	beq.n	5e60 <ull_prepare_dequeue+0x60>
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
    5e54:	3301      	adds	r3, #1
    5e56:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
    5e58:	429a      	cmp	r2, r3
    5e5a:	bf08      	it	eq
    5e5c:	2300      	moveq	r3, #0
	}

	*first = _first; /* Write back read-index */
    5e5e:	70a3      	strb	r3, [r4, #2]
		next = ull_prepare_dequeue_get();
    5e60:	f7ff ffa2 	bl	5da8 <ull_prepare_dequeue_get>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
    5e64:	b138      	cbz	r0, 5e76 <ull_prepare_dequeue+0x76>
    5e66:	2e00      	cmp	r6, #0
    5e68:	d1d1      	bne.n	5e0e <ull_prepare_dequeue+0xe>
    5e6a:	f1b8 0f00 	cmp.w	r8, #0
    5e6e:	d002      	beq.n	5e76 <ull_prepare_dequeue+0x76>
    5e70:	7f03      	ldrb	r3, [r0, #28]
    5e72:	07db      	lsls	r3, r3, #31
    5e74:	d5cb      	bpl.n	5e0e <ull_prepare_dequeue+0xe>
}
    5e76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5e7a:	bf00      	nop
    5e7c:	20000314 	.word	0x20000314
    5e80:	20000210 	.word	0x20000210
    5e84:	0001158a 	.word	0x0001158a
    5e88:	00011648 	.word	0x00011648
    5e8c:	00010f78 	.word	0x00010f78

00005e90 <ull_event_done>:
{
    5e90:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
    5e92:	4a10      	ldr	r2, [pc, #64]	; (5ed4 <ull_event_done+0x44>)
	uint8_t _first = *first; /* Copy read-index */
    5e94:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
    5e96:	78d4      	ldrb	r4, [r2, #3]
    5e98:	7855      	ldrb	r5, [r2, #1]
    5e9a:	429c      	cmp	r4, r3
{
    5e9c:	4601      	mov	r1, r0
	evdone = MFIFO_DEQUEUE(done);
    5e9e:	7810      	ldrb	r0, [r2, #0]
    5ea0:	d016      	beq.n	5ed0 <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
    5ea2:	fb03 2000 	mla	r0, r3, r0, r2
	_first += 1U;
    5ea6:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
    5ea8:	6844      	ldr	r4, [r0, #4]
	_first += 1U;
    5eaa:	b2db      	uxtb	r3, r3
		_first = 0U;
    5eac:	429d      	cmp	r5, r3
    5eae:	bf08      	it	eq
    5eb0:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    5eb2:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
    5eb4:	b154      	cbz	r4, 5ecc <ull_event_done+0x3c>
	evdone->hdr.link = NULL;
    5eb6:	2300      	movs	r3, #0
	link = evdone->hdr.link;
    5eb8:	6820      	ldr	r0, [r4, #0]
	evdone->hdr.link = NULL;
    5eba:	6023      	str	r3, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
    5ebc:	2302      	movs	r3, #2
    5ebe:	7123      	strb	r3, [r4, #4]
	evdone->param = param;
    5ec0:	61e1      	str	r1, [r4, #28]
	ull_rx_put_done(link, evdone);
    5ec2:	4621      	mov	r1, r4
    5ec4:	f7ff ff34 	bl	5d30 <ull_rx_put_done>
	ull_rx_sched_done();
    5ec8:	f7ff ff38 	bl	5d3c <ull_rx_sched_done>
}
    5ecc:	4620      	mov	r0, r4
    5ece:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
    5ed0:	2400      	movs	r4, #0
    5ed2:	e7fb      	b.n	5ecc <ull_event_done+0x3c>
    5ed4:	200001e0 	.word	0x200001e0

00005ed8 <init_reset>:
{
    5ed8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	RXFIFO_INIT_ALLOC(done);
    5eda:	4c3d      	ldr	r4, [pc, #244]	; (5fd0 <init_reset+0xf8>)
    5edc:	4d3d      	ldr	r5, [pc, #244]	; (5fd4 <init_reset+0xfc>)
    5ede:	79a2      	ldrb	r2, [r4, #6]
    5ee0:	88a1      	ldrh	r1, [r4, #4]
    5ee2:	4e3d      	ldr	r6, [pc, #244]	; (5fd8 <init_reset+0x100>)
    5ee4:	2300      	movs	r3, #0
    5ee6:	f104 0008 	add.w	r0, r4, #8
    5eea:	806b      	strh	r3, [r5, #2]
    5eec:	4623      	mov	r3, r4
    5eee:	f007 ff47 	bl	dd80 <mem_init>
    5ef2:	79a1      	ldrb	r1, [r4, #6]
    5ef4:	79e2      	ldrb	r2, [r4, #7]
    5ef6:	4633      	mov	r3, r6
    5ef8:	440a      	add	r2, r1
    5efa:	1d30      	adds	r0, r6, #4
    5efc:	2108      	movs	r1, #8
    5efe:	f007 ff3f 	bl	dd80 <mem_init>
    5f02:	462a      	mov	r2, r5
    5f04:	79a3      	ldrb	r3, [r4, #6]
    5f06:	f812 0b04 	ldrb.w	r0, [r2], #4
    5f0a:	7869      	ldrb	r1, [r5, #1]
    5f0c:	e9cd 2400 	strd	r2, r4, [sp]
    5f10:	e9cd 6302 	strd	r6, r3, [sp, #8]
    5f14:	78aa      	ldrb	r2, [r5, #2]
    5f16:	1ceb      	adds	r3, r5, #3
    5f18:	f008 fa8e 	bl	e438 <ull_rxfifo_alloc>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
    5f1c:	4b2f      	ldr	r3, [pc, #188]	; (5fdc <init_reset+0x104>)
    5f1e:	2205      	movs	r2, #5
    5f20:	1d18      	adds	r0, r3, #4
    5f22:	2144      	movs	r1, #68	; 0x44
    5f24:	f007 ff2c 	bl	dd80 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
    5f28:	4b2d      	ldr	r3, [pc, #180]	; (5fe0 <init_reset+0x108>)
    5f2a:	2207      	movs	r2, #7
    5f2c:	1d18      	adds	r0, r3, #4
    5f2e:	2108      	movs	r1, #8
    5f30:	f007 ff26 	bl	dd80 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
    5f34:	482a      	ldr	r0, [pc, #168]	; (5fe0 <init_reset+0x108>)
    5f36:	f007 ff4b 	bl	ddd0 <mem_acquire>
	LL_ASSERT(link);
    5f3a:	4604      	mov	r4, r0
    5f3c:	b960      	cbnz	r0, 5f58 <init_reset+0x80>
    5f3e:	4a29      	ldr	r2, [pc, #164]	; (5fe4 <init_reset+0x10c>)
    5f40:	4929      	ldr	r1, [pc, #164]	; (5fe8 <init_reset+0x110>)
    5f42:	482a      	ldr	r0, [pc, #168]	; (5fec <init_reset+0x114>)
    5f44:	f240 73fa 	movw	r3, #2042	; 0x7fa
    5f48:	f006 ff59 	bl	cdfe <printk>
    5f4c:	4040      	eors	r0, r0
    5f4e:	f380 8811 	msr	BASEPRI, r0
    5f52:	f04f 0003 	mov.w	r0, #3
    5f56:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
    5f58:	4a25      	ldr	r2, [pc, #148]	; (5ff0 <init_reset+0x118>)
    5f5a:	4620      	mov	r0, r4
    5f5c:	1f11      	subs	r1, r2, #4
    5f5e:	f007 ff7f 	bl	de60 <memq_init>
	link = mem_acquire(&mem_link_done.free);
    5f62:	481d      	ldr	r0, [pc, #116]	; (5fd8 <init_reset+0x100>)
    5f64:	f007 ff34 	bl	ddd0 <mem_acquire>
	LL_ASSERT(link);
    5f68:	4604      	mov	r4, r0
    5f6a:	b960      	cbnz	r0, 5f86 <init_reset+0xae>
    5f6c:	4a1d      	ldr	r2, [pc, #116]	; (5fe4 <init_reset+0x10c>)
    5f6e:	491e      	ldr	r1, [pc, #120]	; (5fe8 <init_reset+0x110>)
    5f70:	481e      	ldr	r0, [pc, #120]	; (5fec <init_reset+0x114>)
    5f72:	f640 0302 	movw	r3, #2050	; 0x802
    5f76:	f006 ff42 	bl	cdfe <printk>
    5f7a:	4040      	eors	r0, r0
    5f7c:	f380 8811 	msr	BASEPRI, r0
    5f80:	f04f 0003 	mov.w	r0, #3
    5f84:	df02      	svc	2
	MEMQ_INIT(ull_done, link);
    5f86:	4a1b      	ldr	r2, [pc, #108]	; (5ff4 <init_reset+0x11c>)
    5f88:	4620      	mov	r0, r4
    5f8a:	1f11      	subs	r1, r2, #4
    5f8c:	f007 ff68 	bl	de60 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
    5f90:	4813      	ldr	r0, [pc, #76]	; (5fe0 <init_reset+0x108>)
    5f92:	f007 ff1d 	bl	ddd0 <mem_acquire>
	LL_ASSERT(link);
    5f96:	4604      	mov	r4, r0
    5f98:	b960      	cbnz	r0, 5fb4 <init_reset+0xdc>
    5f9a:	4a12      	ldr	r2, [pc, #72]	; (5fe4 <init_reset+0x10c>)
    5f9c:	4912      	ldr	r1, [pc, #72]	; (5fe8 <init_reset+0x110>)
    5f9e:	4813      	ldr	r0, [pc, #76]	; (5fec <init_reset+0x114>)
    5fa0:	f640 030a 	movw	r3, #2058	; 0x80a
    5fa4:	f006 ff2b 	bl	cdfe <printk>
    5fa8:	4040      	eors	r0, r0
    5faa:	f380 8811 	msr	BASEPRI, r0
    5fae:	f04f 0003 	mov.w	r0, #3
    5fb2:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
    5fb4:	4a10      	ldr	r2, [pc, #64]	; (5ff8 <init_reset+0x120>)
    5fb6:	4620      	mov	r0, r4
    5fb8:	1f11      	subs	r1, r2, #4
    5fba:	f007 ff51 	bl	de60 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
    5fbe:	4b0f      	ldr	r3, [pc, #60]	; (5ffc <init_reset+0x124>)
    5fc0:	2204      	movs	r2, #4
    5fc2:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
    5fc4:	f7ff fd36 	bl	5a34 <rx_alloc.constprop.0>
}
    5fc8:	2000      	movs	r0, #0
    5fca:	b004      	add	sp, #16
    5fcc:	bd70      	pop	{r4, r5, r6, pc}
    5fce:	bf00      	nop
    5fd0:	20000138 	.word	0x20000138
    5fd4:	200001e0 	.word	0x200001e0
    5fd8:	200011e0 	.word	0x200011e0
    5fdc:	2000124c 	.word	0x2000124c
    5fe0:	20001210 	.word	0x20001210
    5fe4:	0001158a 	.word	0x0001158a
    5fe8:	000115ca 	.word	0x000115ca
    5fec:	00010f78 	.word	0x00010f78
    5ff0:	200013b8 	.word	0x200013b8
    5ff4:	200013b0 	.word	0x200013b0
    5ff8:	200013a8 	.word	0x200013a8
    5ffc:	2000120c 	.word	0x2000120c

00006000 <ll_init>:
{
    6000:	b510      	push	{r4, lr}
	sem_recv = sem_rx;
    6002:	4b23      	ldr	r3, [pc, #140]	; (6090 <ll_init+0x90>)
{
    6004:	b086      	sub	sp, #24
	sem_recv = sem_rx;
    6006:	6018      	str	r0, [r3, #0]
	cntr_init();
    6008:	f002 f834 	bl	8074 <cntr_init>
	mayfly_init();
    600c:	f7fe fa42 	bl	4494 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    6010:	4a20      	ldr	r2, [pc, #128]	; (6094 <ll_init+0x94>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
    6012:	2102      	movs	r1, #2
    6014:	7411      	strb	r1, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_THREAD_OPS;
    6016:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    6018:	2304      	movs	r3, #4
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    601a:	491f      	ldr	r1, [pc, #124]	; (6098 <ll_init+0x98>)
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    601c:	7013      	strb	r3, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
    601e:	7213      	strb	r3, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    6020:	9105      	str	r1, [sp, #20]
    6022:	491e      	ldr	r1, [pc, #120]	; (609c <ll_init+0x9c>)
    6024:	9104      	str	r1, [sp, #16]
    6026:	491e      	ldr	r1, [pc, #120]	; (60a0 <ll_init+0xa0>)
    6028:	9103      	str	r1, [sp, #12]
    602a:	491e      	ldr	r1, [pc, #120]	; (60a4 <ll_init+0xa4>)
    602c:	9102      	str	r1, [sp, #8]
    602e:	210c      	movs	r1, #12
    6030:	e9cd 2100 	strd	r2, r1, [sp]
    6034:	2000      	movs	r0, #0
    6036:	4a1c      	ldr	r2, [pc, #112]	; (60a8 <ll_init+0xa8>)
    6038:	2103      	movs	r1, #3
    603a:	f7fe ff25 	bl	4e88 <ticker_init>
	LL_ASSERT(!err);
    603e:	b160      	cbz	r0, 605a <ll_init+0x5a>
    6040:	4a1a      	ldr	r2, [pc, #104]	; (60ac <ll_init+0xac>)
    6042:	491b      	ldr	r1, [pc, #108]	; (60b0 <ll_init+0xb0>)
    6044:	481b      	ldr	r0, [pc, #108]	; (60b4 <ll_init+0xb4>)
    6046:	f240 230d 	movw	r3, #525	; 0x20d
    604a:	f006 fed8 	bl	cdfe <printk>
    604e:	4040      	eors	r0, r0
    6050:	f380 8811 	msr	BASEPRI, r0
    6054:	f04f 0003 	mov.w	r0, #3
    6058:	df02      	svc	2
	return z_impl_k_sem_init(sem, initial_count, limit);
    605a:	2201      	movs	r2, #1
    605c:	2100      	movs	r1, #0
    605e:	4816      	ldr	r0, [pc, #88]	; (60b8 <ll_init+0xb8>)
    6060:	f009 fb87 	bl	f772 <z_impl_k_sem_init>
	err = lll_init();
    6064:	f001 fab4 	bl	75d0 <lll_init>
	if (err) {
    6068:	4604      	mov	r4, r0
    606a:	b970      	cbnz	r0, 608a <ll_init+0x8a>
	err = init_reset();
    606c:	f7ff ff34 	bl	5ed8 <init_reset>
	if (err) {
    6070:	4604      	mov	r4, r0
    6072:	b950      	cbnz	r0, 608a <ll_init+0x8a>
	err = lll_adv_init();
    6074:	f001 fd5a 	bl	7b2c <lll_adv_init>
	if (err) {
    6078:	4604      	mov	r4, r0
    607a:	b930      	cbnz	r0, 608a <ll_init+0x8a>
	err = ull_adv_init();
    607c:	f008 fa67 	bl	e54e <ull_adv_init>
	if (err) {
    6080:	4604      	mov	r4, r0
    6082:	b910      	cbnz	r0, 608a <ll_init+0x8a>
		ull_filter_reset(true);
    6084:	2001      	movs	r0, #1
    6086:	f000 fc67 	bl	6958 <ull_filter_reset>
}
    608a:	4620      	mov	r0, r4
    608c:	b006      	add	sp, #24
    608e:	bd10      	pop	{r4, pc}
    6090:	200013bc 	.word	0x200013bc
    6094:	200016d8 	.word	0x200016d8
    6098:	0000e979 	.word	0x0000e979
    609c:	00008905 	.word	0x00008905
    60a0:	000088ad 	.word	0x000088ad
    60a4:	20001468 	.word	0x20001468
    60a8:	200013d8 	.word	0x200013d8
    60ac:	0001158a 	.word	0x0001158a
    60b0:	000115c5 	.word	0x000115c5
    60b4:	00010f78 	.word	0x00010f78
    60b8:	200013c0 	.word	0x200013c0

000060bc <ll_reset>:
{
    60bc:	b510      	push	{r4, lr}
    60be:	b086      	sub	sp, #24
	err = ull_adv_reset();
    60c0:	f008 fa47 	bl	e552 <ull_adv_reset>
	LL_ASSERT(!err);
    60c4:	b160      	cbz	r0, 60e0 <ll_reset+0x24>
    60c6:	4a2c      	ldr	r2, [pc, #176]	; (6178 <ll_reset+0xbc>)
    60c8:	492c      	ldr	r1, [pc, #176]	; (617c <ll_reset+0xc0>)
    60ca:	482d      	ldr	r0, [pc, #180]	; (6180 <ll_reset+0xc4>)
    60cc:	f240 23ad 	movw	r3, #685	; 0x2ad
    60d0:	f006 fe95 	bl	cdfe <printk>
    60d4:	4040      	eors	r0, r0
    60d6:	f380 8811 	msr	BASEPRI, r0
    60da:	f04f 0003 	mov.w	r0, #3
    60de:	df02      	svc	2
		ull_filter_reset(false);
    60e0:	2000      	movs	r0, #0
    60e2:	f000 fc39 	bl	6958 <ull_filter_reset>
	MFIFO_INIT(prep);
    60e6:	4b27      	ldr	r3, [pc, #156]	; (6184 <ll_reset+0xc8>)
    60e8:	2400      	movs	r4, #0
    60ea:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
    60ec:	4b26      	ldr	r3, [pc, #152]	; (6188 <ll_reset+0xcc>)
    60ee:	805c      	strh	r4, [r3, #2]
    60f0:	2201      	movs	r2, #1
    60f2:	4621      	mov	r1, r4
    60f4:	4668      	mov	r0, sp
    60f6:	f009 fb3c 	bl	f772 <z_impl_k_sem_init>
		mfy.param = &sem;
    60fa:	4b24      	ldr	r3, [pc, #144]	; (618c <ll_reset+0xd0>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    60fc:	4622      	mov	r2, r4
    60fe:	4621      	mov	r1, r4
    6100:	2003      	movs	r0, #3
		mfy.param = &sem;
    6102:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    6106:	f7fe f9ef 	bl	44e8 <mayfly_enqueue>
		LL_ASSERT(!retval);
    610a:	b160      	cbz	r0, 6126 <ll_reset+0x6a>
    610c:	4a1a      	ldr	r2, [pc, #104]	; (6178 <ll_reset+0xbc>)
    610e:	4920      	ldr	r1, [pc, #128]	; (6190 <ll_reset+0xd4>)
    6110:	481b      	ldr	r0, [pc, #108]	; (6180 <ll_reset+0xc4>)
    6112:	f240 330d 	movw	r3, #781	; 0x30d
    6116:	f006 fe72 	bl	cdfe <printk>
    611a:	4040      	eors	r0, r0
    611c:	f380 8811 	msr	BASEPRI, r0
    6120:	f04f 0003 	mov.w	r0, #3
    6124:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    6126:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    612a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    612e:	4668      	mov	r0, sp
    6130:	f005 fe28 	bl	bd84 <z_impl_k_sem_take>
	err = ull_adv_reset_finalize();
    6134:	f000 fa1c 	bl	6570 <ull_adv_reset_finalize>
	LL_ASSERT(!err);
    6138:	b160      	cbz	r0, 6154 <ll_reset+0x98>
    613a:	4a0f      	ldr	r2, [pc, #60]	; (6178 <ll_reset+0xbc>)
    613c:	490f      	ldr	r1, [pc, #60]	; (617c <ll_reset+0xc0>)
    613e:	4810      	ldr	r0, [pc, #64]	; (6180 <ll_reset+0xc4>)
    6140:	f240 331a 	movw	r3, #794	; 0x31a
    6144:	f006 fe5b 	bl	cdfe <printk>
    6148:	4040      	eors	r0, r0
    614a:	f380 8811 	msr	BASEPRI, r0
    614e:	f04f 0003 	mov.w	r0, #3
    6152:	df02      	svc	2
	err = init_reset();
    6154:	f7ff fec0 	bl	5ed8 <init_reset>
	LL_ASSERT(!err);
    6158:	b160      	cbz	r0, 6174 <ll_reset+0xb8>
    615a:	4a07      	ldr	r2, [pc, #28]	; (6178 <ll_reset+0xbc>)
    615c:	4907      	ldr	r1, [pc, #28]	; (617c <ll_reset+0xc0>)
    615e:	4808      	ldr	r0, [pc, #32]	; (6180 <ll_reset+0xc4>)
    6160:	f240 3327 	movw	r3, #807	; 0x327
    6164:	f006 fe4b 	bl	cdfe <printk>
    6168:	4040      	eors	r0, r0
    616a:	f380 8811 	msr	BASEPRI, r0
    616e:	f04f 0003 	mov.w	r0, #3
    6172:	df02      	svc	2
}
    6174:	b006      	add	sp, #24
    6176:	bd10      	pop	{r4, pc}
    6178:	0001158a 	.word	0x0001158a
    617c:	000115c5 	.word	0x000115c5
    6180:	00010f78 	.word	0x00010f78
    6184:	20000210 	.word	0x20000210
    6188:	200001f8 	.word	0x200001f8
    618c:	20000324 	.word	0x20000324
    6190:	0001166a 	.word	0x0001166a

00006194 <ull_done>:
}
#endif /* CONFIG_BT_CONN */

#if !defined(CONFIG_BT_CTLR_LOW_LAT_ULL)
static void ull_done(void *param)
{
    6194:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		break;
	}

	/* Release done */
	done->extra.type = 0U;
	release = RXFIFO_RELEASE(done, link, done);
    6198:	4f30      	ldr	r7, [pc, #192]	; (625c <ull_done+0xc8>)
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
    619a:	4e31      	ldr	r6, [pc, #196]	; (6260 <ull_done+0xcc>)
{
    619c:	b087      	sub	sp, #28
	release = RXFIFO_RELEASE(done, link, done);
    619e:	f107 0904 	add.w	r9, r7, #4
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
    61a2:	e9d6 0100 	ldrd	r0, r1, [r6]
    61a6:	aa05      	add	r2, sp, #20
    61a8:	f007 fe64 	bl	de74 <memq_peek>
		if (link) {
    61ac:	4680      	mov	r8, r0
    61ae:	2800      	cmp	r0, #0
    61b0:	d051      	beq.n	6256 <ull_done+0xc2>
			(void)memq_dequeue(memq_ull_done.tail,
    61b2:	6870      	ldr	r0, [r6, #4]
    61b4:	2200      	movs	r2, #0
    61b6:	4631      	mov	r1, r6
    61b8:	f007 fe64 	bl	de84 <memq_dequeue>
			rx_demux_event_done(link, done);
    61bc:	9d05      	ldr	r5, [sp, #20]
	ull_hdr = done->param;
    61be:	69ec      	ldr	r4, [r5, #28]
	if (ull_hdr) {
    61c0:	b194      	cbz	r4, 61e8 <ull_done+0x54>
    61c2:	7823      	ldrb	r3, [r4, #0]
		LL_ASSERT(ull_ref_get(ull_hdr));
    61c4:	b963      	cbnz	r3, 61e0 <ull_done+0x4c>
    61c6:	4a27      	ldr	r2, [pc, #156]	; (6264 <ull_done+0xd0>)
    61c8:	4927      	ldr	r1, [pc, #156]	; (6268 <ull_done+0xd4>)
    61ca:	4828      	ldr	r0, [pc, #160]	; (626c <ull_done+0xd8>)
    61cc:	f640 230a 	movw	r3, #2570	; 0xa0a
    61d0:	f006 fe15 	bl	cdfe <printk>
    61d4:	4040      	eors	r0, r0
    61d6:	f380 8811 	msr	BASEPRI, r0
    61da:	f04f 0003 	mov.w	r0, #3
    61de:	df02      	svc	2
	return hdr->ref--;
    61e0:	7823      	ldrb	r3, [r4, #0]
    61e2:	3b01      	subs	r3, #1
    61e4:	b2db      	uxtb	r3, r3
    61e6:	7023      	strb	r3, [r4, #0]
	switch (done->extra.type) {
    61e8:	f895 3020 	ldrb.w	r3, [r5, #32]
    61ec:	b163      	cbz	r3, 6208 <ull_done+0x74>
		LL_ASSERT(0);
    61ee:	4a1d      	ldr	r2, [pc, #116]	; (6264 <ull_done+0xd0>)
    61f0:	491f      	ldr	r1, [pc, #124]	; (6270 <ull_done+0xdc>)
    61f2:	481e      	ldr	r0, [pc, #120]	; (626c <ull_done+0xd8>)
    61f4:	f640 2361 	movw	r3, #2657	; 0xa61
    61f8:	f006 fe01 	bl	cdfe <printk>
    61fc:	4040      	eors	r0, r0
    61fe:	f380 8811 	msr	BASEPRI, r0
    6202:	f04f 0003 	mov.w	r0, #3
    6206:	df02      	svc	2
	done->extra.type = 0U;
    6208:	2300      	movs	r3, #0
    620a:	f885 3020 	strb.w	r3, [r5, #32]
	release = RXFIFO_RELEASE(done, link, done);
    620e:	78ba      	ldrb	r2, [r7, #2]
    6210:	4b18      	ldr	r3, [pc, #96]	; (6274 <ull_done+0xe0>)
    6212:	7879      	ldrb	r1, [r7, #1]
    6214:	7838      	ldrb	r0, [r7, #0]
    6216:	f8cd 9000 	str.w	r9, [sp]
    621a:	e9cd 8501 	strd	r8, r5, [sp, #4]
    621e:	f008 f943 	bl	e4a8 <ull_rxfifo_release>
	LL_ASSERT(release == done);
    6222:	4285      	cmp	r5, r0
    6224:	d00c      	beq.n	6240 <ull_done+0xac>
    6226:	4a0f      	ldr	r2, [pc, #60]	; (6264 <ull_done+0xd0>)
    6228:	4913      	ldr	r1, [pc, #76]	; (6278 <ull_done+0xe4>)
    622a:	4810      	ldr	r0, [pc, #64]	; (626c <ull_done+0xd8>)
    622c:	f640 2368 	movw	r3, #2664	; 0xa68
    6230:	f006 fde5 	bl	cdfe <printk>
    6234:	4040      	eors	r0, r0
    6236:	f380 8811 	msr	BASEPRI, r0
    623a:	f04f 0003 	mov.w	r0, #3
    623e:	df02      	svc	2
	/* LLL done synchronize count */
	lll_done_ull_inc();
#endif /* CONFIG_BT_CTLR_LOW_LAT_ULL_DONE */

	/* If disable initiated, signal the semaphore */
	if (ull_hdr && !ull_ref_get(ull_hdr) && ull_hdr->disabled_cb) {
    6240:	2c00      	cmp	r4, #0
    6242:	d0ae      	beq.n	61a2 <ull_done+0xe>
	return hdr->ref;
    6244:	7823      	ldrb	r3, [r4, #0]
    6246:	2b00      	cmp	r3, #0
    6248:	d1ab      	bne.n	61a2 <ull_done+0xe>
    624a:	6963      	ldr	r3, [r4, #20]
    624c:	2b00      	cmp	r3, #0
    624e:	d0a8      	beq.n	61a2 <ull_done+0xe>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
    6250:	69a0      	ldr	r0, [r4, #24]
    6252:	4798      	blx	r3
    6254:	e7a5      	b.n	61a2 <ull_done+0xe>
}
    6256:	b007      	add	sp, #28
    6258:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    625c:	200001e0 	.word	0x200001e0
    6260:	200013ac 	.word	0x200013ac
    6264:	0001158a 	.word	0x0001158a
    6268:	00011672 	.word	0x00011672
    626c:	00010f78 	.word	0x00010f78
    6270:	00011d2c 	.word	0x00011d2c
    6274:	200001e3 	.word	0x200001e3
    6278:	00011687 	.word	0x00011687

0000627c <lll_resume>:
	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
				   prepare_param, 0, 0);
}

void lll_resume(void *param)
{
    627c:	b507      	push	{r0, r1, r2, lr}
	struct lll_event *next;
	int ret;

	next = param;
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
    627e:	2201      	movs	r2, #1
    6280:	9201      	str	r2, [sp, #4]
				  next->prepare_cb, &next->prepare_param,
				  next->is_resume, 1);
    6282:	7f02      	ldrb	r2, [r0, #28]
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
    6284:	f002 0201 	and.w	r2, r2, #1
    6288:	9200      	str	r2, [sp, #0]
    628a:	6902      	ldr	r2, [r0, #16]
{
    628c:	4603      	mov	r3, r0
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
    628e:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
    6292:	f001 fad9 	bl	7848 <lll_prepare_resolve>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
    6296:	b168      	cbz	r0, 62b4 <lll_resume+0x38>
    6298:	3077      	adds	r0, #119	; 0x77
    629a:	d00b      	beq.n	62b4 <lll_resume+0x38>
    629c:	4a07      	ldr	r2, [pc, #28]	; (62bc <lll_resume+0x40>)
    629e:	4908      	ldr	r1, [pc, #32]	; (62c0 <lll_resume+0x44>)
    62a0:	4808      	ldr	r0, [pc, #32]	; (62c4 <lll_resume+0x48>)
    62a2:	234f      	movs	r3, #79	; 0x4f
    62a4:	f006 fdab 	bl	cdfe <printk>
    62a8:	4040      	eors	r0, r0
    62aa:	f380 8811 	msr	BASEPRI, r0
    62ae:	f04f 0003 	mov.w	r0, #3
    62b2:	df02      	svc	2
}
    62b4:	b003      	add	sp, #12
    62b6:	f85d fb04 	ldr.w	pc, [sp], #4
    62ba:	bf00      	nop
    62bc:	000116a3 	.word	0x000116a3
    62c0:	000116e5 	.word	0x000116e5
    62c4:	00010f78 	.word	0x00010f78

000062c8 <ticker_update_op_cb>:
{
    62c8:	b510      	push	{r4, lr}
    62ca:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
    62cc:	b180      	cbz	r0, 62f0 <ticker_update_op_cb+0x28>
    62ce:	f7ff fcd3 	bl	5c78 <ull_disable_mark_get>
    62d2:	4284      	cmp	r4, r0
    62d4:	d00c      	beq.n	62f0 <ticker_update_op_cb+0x28>
    62d6:	4a07      	ldr	r2, [pc, #28]	; (62f4 <ticker_update_op_cb+0x2c>)
    62d8:	4907      	ldr	r1, [pc, #28]	; (62f8 <ticker_update_op_cb+0x30>)
    62da:	4808      	ldr	r0, [pc, #32]	; (62fc <ticker_update_op_cb+0x34>)
    62dc:	f640 03bf 	movw	r3, #2239	; 0x8bf
    62e0:	f006 fd8d 	bl	cdfe <printk>
    62e4:	4040      	eors	r0, r0
    62e6:	f380 8811 	msr	BASEPRI, r0
    62ea:	f04f 0003 	mov.w	r0, #3
    62ee:	df02      	svc	2
}
    62f0:	bd10      	pop	{r4, pc}
    62f2:	bf00      	nop
    62f4:	0001170c 	.word	0x0001170c
    62f8:	0001174b 	.word	0x0001174b
    62fc:	00010f78 	.word	0x00010f78

00006300 <init_reset>:
{
    6300:	b510      	push	{r4, lr}
		lll_adv_data_init(&ll_adv[handle].lll.adv_data);
    6302:	4c16      	ldr	r4, [pc, #88]	; (635c <init_reset+0x5c>)
    6304:	f104 0024 	add.w	r0, r4, #36	; 0x24
    6308:	f001 fc28 	bl	7b5c <lll_adv_data_init>
		lll_adv_data_init(&ll_adv[handle].lll.scan_rsp);
    630c:	f104 0030 	add.w	r0, r4, #48	; 0x30
    6310:	f001 fc24 	bl	7b5c <lll_adv_data_init>
	pdu->len = BDADDR_SIZE;
}

static void init_set(struct ll_adv_set *adv)
{
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
    6314:	f44f 6300 	mov.w	r3, #2048	; 0x800
    6318:	87a3      	strh	r3, [r4, #60]	; 0x3c
#if defined(CONFIG_BT_CTLR_PRIVACY)
	adv->own_addr_type = BT_ADDR_LE_PUBLIC;
    631a:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    631e:	f36f 0342 	bfc	r3, #1, #2
    6322:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
#endif /* CONFIG_BT_CTLR_PRIVACY */
	adv->lll.chan_map = BT_LE_ADV_CHAN_MAP_ALL;
    6326:	f894 3020 	ldrb.w	r3, [r4, #32]
    632a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    632e:	f043 0307 	orr.w	r3, r3, #7
    6332:	f884 3020 	strb.w	r3, [r4, #32]
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    6336:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    633a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	pdu->len = BDADDR_SIZE;
    633e:	2206      	movs	r2, #6
    6340:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	pdu->type = pdu_type;
    6342:	2000      	movs	r0, #0
	pdu->len = BDADDR_SIZE;
    6344:	705a      	strb	r2, [r3, #1]
	pdu->type = pdu_type;
    6346:	7018      	strb	r0, [r3, #0]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    6348:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    634c:	eb04 0483 	add.w	r4, r4, r3, lsl #2
    6350:	2104      	movs	r1, #4
    6352:	6b63      	ldr	r3, [r4, #52]	; 0x34
	pdu->len = BDADDR_SIZE;
    6354:	705a      	strb	r2, [r3, #1]
	pdu->type = pdu_type;
    6356:	7019      	strb	r1, [r3, #0]
}
    6358:	bd10      	pop	{r4, pc}
    635a:	bf00      	nop
    635c:	20001700 	.word	0x20001700

00006360 <ticker_cb>:
{
    6360:	b5f0      	push	{r4, r5, r6, r7, lr}
    6362:	461d      	mov	r5, r3
    6364:	b08b      	sub	sp, #44	; 0x2c
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
    6366:	f64f 73ff 	movw	r3, #65535	; 0xffff
    636a:	429d      	cmp	r5, r3
{
    636c:	9c11      	ldr	r4, [sp, #68]	; 0x44
    636e:	4607      	mov	r7, r0
    6370:	4616      	mov	r6, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
    6372:	d030      	beq.n	63d6 <ticker_cb+0x76>
	return ++hdr->ref;
    6374:	7821      	ldrb	r1, [r4, #0]
    6376:	3101      	adds	r1, #1
    6378:	b2c9      	uxtb	r1, r1
    637a:	7021      	strb	r1, [r4, #0]
		LL_ASSERT(ref);
    637c:	b961      	cbnz	r1, 6398 <ticker_cb+0x38>
    637e:	4a2f      	ldr	r2, [pc, #188]	; (643c <ticker_cb+0xdc>)
    6380:	492f      	ldr	r1, [pc, #188]	; (6440 <ticker_cb+0xe0>)
    6382:	4830      	ldr	r0, [pc, #192]	; (6444 <ticker_cb+0xe4>)
    6384:	f640 0385 	movw	r3, #2181	; 0x885
    6388:	f006 fd39 	bl	cdfe <printk>
    638c:	4040      	eors	r0, r0
    638e:	f380 8811 	msr	BASEPRI, r0
    6392:	f04f 0003 	mov.w	r0, #3
    6396:	df02      	svc	2
		p.ticks_at_expire = ticks_at_expire;
    6398:	492b      	ldr	r1, [pc, #172]	; (6448 <ticker_cb+0xe8>)
		p.force = force;
    639a:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
    639e:	728b      	strb	r3, [r1, #10]
	lll = &adv->lll;
    63a0:	f104 031c 	add.w	r3, r4, #28
		p.param = lll;
    63a4:	60cb      	str	r3, [r1, #12]
		mfy.param = &p;
    63a6:	4b29      	ldr	r3, [pc, #164]	; (644c <ticker_cb+0xec>)
		p.lazy = lazy;
    63a8:	810d      	strh	r5, [r1, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    63aa:	2200      	movs	r2, #0
		p.remainder = remainder;
    63ac:	e9c1 7600 	strd	r7, r6, [r1]
		mfy.param = &p;
    63b0:	6099      	str	r1, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    63b2:	2001      	movs	r0, #1
    63b4:	4611      	mov	r1, r2
    63b6:	f7fe f897 	bl	44e8 <mayfly_enqueue>
		LL_ASSERT(!ret);
    63ba:	b160      	cbz	r0, 63d6 <ticker_cb+0x76>
    63bc:	4a1f      	ldr	r2, [pc, #124]	; (643c <ticker_cb+0xdc>)
    63be:	4924      	ldr	r1, [pc, #144]	; (6450 <ticker_cb+0xf0>)
    63c0:	4820      	ldr	r0, [pc, #128]	; (6444 <ticker_cb+0xe4>)
    63c2:	f640 0392 	movw	r3, #2194	; 0x892
    63c6:	f006 fd1a 	bl	cdfe <printk>
    63ca:	4040      	eors	r0, r0
    63cc:	f380 8811 	msr	BASEPRI, r0
    63d0:	f04f 0003 	mov.w	r0, #3
    63d4:	df02      	svc	2
	lll_rand_isr_get(&random_delay, sizeof(random_delay));
    63d6:	2104      	movs	r1, #4
    63d8:	a809      	add	r0, sp, #36	; 0x24
    63da:	f008 f9c0 	bl	e75e <lll_rand_isr_get>
	random_delay %= ticks_delay_window;
    63de:	9b09      	ldr	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    63e0:	9406      	str	r4, [sp, #24]
	random_delay %= ticks_delay_window;
    63e2:	f240 1247 	movw	r2, #327	; 0x147
    63e6:	fbb3 f1f2 	udiv	r1, r3, r2
    63ea:	fb02 3311 	mls	r3, r2, r1, r3
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
    63ee:	4a19      	ldr	r2, [pc, #100]	; (6454 <ticker_cb+0xf4>)
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    63f0:	2000      	movs	r0, #0
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
    63f2:	2148      	movs	r1, #72	; 0x48
    63f4:	1aa2      	subs	r2, r4, r2
    63f6:	fbb2 f2f1 	udiv	r2, r2, r1
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    63fa:	4917      	ldr	r1, [pc, #92]	; (6458 <ticker_cb+0xf8>)
    63fc:	9105      	str	r1, [sp, #20]
    63fe:	3202      	adds	r2, #2
	random_delay += (ticks_delay_window_offset + 1);
    6400:	3301      	adds	r3, #1
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    6402:	e9cd 0003 	strd	r0, r0, [sp, #12]
    6406:	e9cd 0001 	strd	r0, r0, [sp, #4]
    640a:	9000      	str	r0, [sp, #0]
    640c:	b2d2      	uxtb	r2, r2
    640e:	2101      	movs	r1, #1
	random_delay += (ticks_delay_window_offset + 1);
    6410:	9309      	str	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    6412:	f007 ffd6 	bl	e3c2 <ticker_update>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    6416:	f030 0302 	bics.w	r3, r0, #2
    641a:	d00c      	beq.n	6436 <ticker_cb+0xd6>
    641c:	4a07      	ldr	r2, [pc, #28]	; (643c <ticker_cb+0xdc>)
    641e:	490f      	ldr	r1, [pc, #60]	; (645c <ticker_cb+0xfc>)
    6420:	4808      	ldr	r0, [pc, #32]	; (6444 <ticker_cb+0xe4>)
    6422:	f240 732c 	movw	r3, #1836	; 0x72c
    6426:	f006 fcea 	bl	cdfe <printk>
    642a:	4040      	eors	r0, r0
    642c:	f380 8811 	msr	BASEPRI, r0
    6430:	f04f 0003 	mov.w	r0, #3
    6434:	df02      	svc	2
}
    6436:	b00b      	add	sp, #44	; 0x2c
    6438:	bdf0      	pop	{r4, r5, r6, r7, pc}
    643a:	bf00      	nop
    643c:	0001170c 	.word	0x0001170c
    6440:	0001177a 	.word	0x0001177a
    6444:	00010f78 	.word	0x00010f78
    6448:	20001754 	.word	0x20001754
    644c:	20000354 	.word	0x20000354
    6450:	00011648 	.word	0x00011648
    6454:	20001700 	.word	0x20001700
    6458:	000062c9 	.word	0x000062c9
    645c:	0001177e 	.word	0x0001177e

00006460 <ll_adv_params_set>:
{
    6460:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (!adv || adv->is_enabled) {
    6464:	4d40      	ldr	r5, [pc, #256]	; (6568 <ll_adv_params_set+0x108>)
{
    6466:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
	if (!adv || adv->is_enabled) {
    646a:	f895 803e 	ldrb.w	r8, [r5, #62]	; 0x3e
{
    646e:	4699      	mov	r9, r3
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    6470:	4b3e      	ldr	r3, [pc, #248]	; (656c <ll_adv_params_set+0x10c>)
{
    6472:	4604      	mov	r4, r0
	if (!adv || adv->is_enabled) {
    6474:	f018 0801 	ands.w	r8, r8, #1
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    6478:	6818      	ldr	r0, [r3, #0]
    647a:	791b      	ldrb	r3, [r3, #4]
    647c:	9000      	str	r0, [sp, #0]
{
    647e:	4616      	mov	r6, r2
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    6480:	f88d 3004 	strb.w	r3, [sp, #4]
	if (!adv || adv->is_enabled) {
    6484:	d16c      	bne.n	6560 <ll_adv_params_set+0x100>
	adv->lll.chan_map = chan_map;
    6486:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
    648a:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    648e:	f002 0207 	and.w	r2, r2, #7
    6492:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
    6496:	f895 3020 	ldrb.w	r3, [r5, #32]
    649a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    649e:	431a      	orrs	r2, r3
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    64a0:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
    64a4:	f885 2020 	strb.w	r2, [r5, #32]
    64a8:	eb05 0383 	add.w	r3, r5, r3, lsl #2
		adv->interval = 0;
    64ac:	2901      	cmp	r1, #1
    64ae:	6a9f      	ldr	r7, [r3, #40]	; 0x28
	pdu->type = pdu_adv_type[adv_type];
    64b0:	ab02      	add	r3, sp, #8
    64b2:	4419      	add	r1, r3
    64b4:	783a      	ldrb	r2, [r7, #0]
    64b6:	f811 3c08 	ldrb.w	r3, [r1, #-8]
    64ba:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
    64be:	f003 030f 	and.w	r3, r3, #15
    64c2:	ea43 0302 	orr.w	r3, r3, r2
	adv->own_addr_type = own_addr_type;
    64c6:	f895 203e 	ldrb.w	r2, [r5, #62]	; 0x3e
		adv->interval = 0;
    64ca:	bf08      	it	eq
    64cc:	2400      	moveq	r4, #0
	adv->own_addr_type = own_addr_type;
    64ce:	f366 0242 	bfi	r2, r6, #1, #2
    64d2:	87ac      	strh	r4, [r5, #60]	; 0x3c
	pdu->type = pdu_adv_type[adv_type];
    64d4:	703b      	strb	r3, [r7, #0]
	adv->own_addr_type = own_addr_type;
    64d6:	f885 203e 	strb.w	r2, [r5, #62]	; 0x3e
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
    64da:	b2d3      	uxtb	r3, r2
    64dc:	0752      	lsls	r2, r2, #29
    64de:	d509      	bpl.n	64f4 <ll_adv_params_set+0x94>
		adv->peer_addr_type = direct_addr_type;
    64e0:	f369 03c3 	bfi	r3, r9, #3, #1
    64e4:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
		memcpy(&adv->peer_addr, direct_addr, BDADDR_SIZE);
    64e8:	2206      	movs	r2, #6
    64ea:	4651      	mov	r1, sl
    64ec:	f105 003f 	add.w	r0, r5, #63	; 0x3f
    64f0:	f007 fa89 	bl	da06 <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
    64f4:	783c      	ldrb	r4, [r7, #0]
    64f6:	f004 020f 	and.w	r2, r4, #15
    64fa:	2a01      	cmp	r2, #1
		pdu->tx_addr = own_addr_type & 0x1;
    64fc:	f006 0301 	and.w	r3, r6, #1
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
    6500:	d121      	bne.n	6546 <ll_adv_params_set+0xe6>
		pdu->tx_addr = own_addr_type & 0x1;
    6502:	f363 1486 	bfi	r4, r3, #6, #1
		pdu->rx_addr = direct_addr_type;
    6506:	4638      	mov	r0, r7
    6508:	f369 14c7 	bfi	r4, r9, #7, #1
    650c:	f800 4b08 	strb.w	r4, [r0], #8
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
    6510:	2206      	movs	r2, #6
    6512:	4651      	mov	r1, sl
    6514:	f007 fa77 	bl	da06 <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
    6518:	230c      	movs	r3, #12
		pdu->len = BDADDR_SIZE;
    651a:	707b      	strb	r3, [r7, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    651c:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31

static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
    6520:	61ed      	str	r5, [r5, #28]
    6522:	eb05 0583 	add.w	r5, r5, r3, lsl #2
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
    6526:	01b6      	lsls	r6, r6, #6
    6528:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    652a:	f006 0640 	and.w	r6, r6, #64	; 0x40
		if (pdu->len == 0) {
    652e:	785a      	ldrb	r2, [r3, #1]
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
    6530:	f046 0604 	orr.w	r6, r6, #4
    6534:	701e      	strb	r6, [r3, #0]
		if (pdu->len == 0) {
    6536:	b912      	cbnz	r2, 653e <ll_adv_params_set+0xde>
			pdu->len = BDADDR_SIZE;
    6538:	2106      	movs	r1, #6
    653a:	7059      	strb	r1, [r3, #1]
	return 0;
    653c:	4690      	mov	r8, r2
}
    653e:	4640      	mov	r0, r8
    6540:	b002      	add	sp, #8
    6542:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	} else if (pdu->len == 0) {
    6546:	787a      	ldrb	r2, [r7, #1]
		pdu->tx_addr = own_addr_type & 0x1;
    6548:	f363 1486 	bfi	r4, r3, #6, #1
	} else if (pdu->len == 0) {
    654c:	b922      	cbnz	r2, 6558 <ll_adv_params_set+0xf8>
		pdu->rx_addr = 0;
    654e:	f362 14c7 	bfi	r4, r2, #7, #1
    6552:	703c      	strb	r4, [r7, #0]
		pdu->len = BDADDR_SIZE;
    6554:	2306      	movs	r3, #6
    6556:	e7e0      	b.n	651a <ll_adv_params_set+0xba>
		pdu->rx_addr = 0;
    6558:	f36f 14c7 	bfc	r4, #7, #1
    655c:	703c      	strb	r4, [r7, #0]
    655e:	e7dd      	b.n	651c <ll_adv_params_set+0xbc>
		return BT_HCI_ERR_CMD_DISALLOWED;
    6560:	f04f 080c 	mov.w	r8, #12
    6564:	e7eb      	b.n	653e <ll_adv_params_set+0xde>
    6566:	bf00      	nop
    6568:	20001700 	.word	0x20001700
    656c:	000103d8 	.word	0x000103d8

00006570 <ull_adv_reset_finalize>:
{
    6570:	b510      	push	{r4, lr}
		lll_adv_data_reset(&lll->adv_data);
    6572:	4c06      	ldr	r4, [pc, #24]	; (658c <ull_adv_reset_finalize+0x1c>)
    6574:	f104 0024 	add.w	r0, r4, #36	; 0x24
    6578:	f008 f938 	bl	e7ec <lll_adv_data_reset>
		lll_adv_data_reset(&lll->scan_rsp);
    657c:	f104 0030 	add.w	r0, r4, #48	; 0x30
    6580:	f008 f934 	bl	e7ec <lll_adv_data_reset>
}
    6584:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	err = init_reset();
    6588:	f7ff beba 	b.w	6300 <init_reset>
    658c:	20001700 	.word	0x20001700

00006590 <ull_adv_lll_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
    6590:	6800      	ldr	r0, [r0, #0]
    6592:	4b03      	ldr	r3, [pc, #12]	; (65a0 <ull_adv_lll_handle_get+0x10>)
    6594:	1ac0      	subs	r0, r0, r3
    6596:	2348      	movs	r3, #72	; 0x48
    6598:	fbb0 f0f3 	udiv	r0, r0, r3
}
    659c:	b280      	uxth	r0, r0
    659e:	4770      	bx	lr
    65a0:	20001700 	.word	0x20001700

000065a4 <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_SET) {
    65a4:	b938      	cbnz	r0, 65b6 <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
    65a6:	4805      	ldr	r0, [pc, #20]	; (65bc <ull_adv_is_enabled_get+0x18>)
    65a8:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
	return &ll_adv[handle];
    65ac:	f013 0f01 	tst.w	r3, #1
    65b0:	bf08      	it	eq
    65b2:	2000      	moveq	r0, #0
    65b4:	4770      	bx	lr
		return NULL;
    65b6:	2000      	movs	r0, #0
}
    65b8:	4770      	bx	lr
    65ba:	bf00      	nop
    65bc:	20001700 	.word	0x20001700

000065c0 <disable.constprop.0>:
static inline uint8_t disable(uint8_t handle)
    65c0:	b530      	push	{r4, r5, lr}
	adv = ull_adv_is_enabled_get(handle);
    65c2:	2000      	movs	r0, #0
static inline uint8_t disable(uint8_t handle)
    65c4:	b085      	sub	sp, #20
	adv = ull_adv_is_enabled_get(handle);
    65c6:	f7ff ffed 	bl	65a4 <ull_adv_is_enabled_get>
	if (!adv) {
    65ca:	4604      	mov	r4, r0
    65cc:	2800      	cmp	r0, #0
    65ce:	d05b      	beq.n	6688 <disable.constprop.0+0xc8>
	mark = ull_disable_mark(adv);
    65d0:	f7ff fb3c 	bl	5c4c <ull_disable_mark>
	LL_ASSERT(mark == adv);
    65d4:	4284      	cmp	r4, r0
    65d6:	d00c      	beq.n	65f2 <disable.constprop.0+0x32>
    65d8:	4a2d      	ldr	r2, [pc, #180]	; (6690 <disable.constprop.0+0xd0>)
    65da:	492e      	ldr	r1, [pc, #184]	; (6694 <disable.constprop.0+0xd4>)
    65dc:	482e      	ldr	r0, [pc, #184]	; (6698 <disable.constprop.0+0xd8>)
    65de:	f640 13fe 	movw	r3, #2558	; 0x9fe
    65e2:	f006 fc0c 	bl	cdfe <printk>
    65e6:	4040      	eors	r0, r0
    65e8:	f380 8811 	msr	BASEPRI, r0
    65ec:	f04f 0003 	mov.w	r0, #3
    65f0:	df02      	svc	2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    65f2:	ad03      	add	r5, sp, #12
	ret_cb = TICKER_STATUS_BUSY;
    65f4:	2202      	movs	r2, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    65f6:	2103      	movs	r1, #3
    65f8:	4b28      	ldr	r3, [pc, #160]	; (669c <disable.constprop.0+0xdc>)
    65fa:	9500      	str	r5, [sp, #0]
    65fc:	2000      	movs	r0, #0
	ret_cb = TICKER_STATUS_BUSY;
    65fe:	9203      	str	r2, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    6600:	f7fe fd2a 	bl	5058 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
    6604:	4629      	mov	r1, r5
    6606:	f7ff fafb 	bl	5c00 <ull_ticker_status_take>
	if (ret) {
    660a:	b198      	cbz	r0, 6634 <disable.constprop.0+0x74>
		mark = ull_disable_unmark(adv);
    660c:	4620      	mov	r0, r4
    660e:	f7ff fb25 	bl	5c5c <ull_disable_unmark>
		LL_ASSERT(mark == adv);
    6612:	4284      	cmp	r4, r0
    6614:	d00c      	beq.n	6630 <disable.constprop.0+0x70>
    6616:	4a1e      	ldr	r2, [pc, #120]	; (6690 <disable.constprop.0+0xd0>)
    6618:	491e      	ldr	r1, [pc, #120]	; (6694 <disable.constprop.0+0xd4>)
    661a:	481f      	ldr	r0, [pc, #124]	; (6698 <disable.constprop.0+0xd8>)
    661c:	f640 2317 	movw	r3, #2583	; 0xa17
    6620:	f006 fbed 	bl	cdfe <printk>
    6624:	4040      	eors	r0, r0
    6626:	f380 8811 	msr	BASEPRI, r0
    662a:	f04f 0003 	mov.w	r0, #3
    662e:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
    6630:	200c      	movs	r0, #12
    6632:	e02a      	b.n	668a <disable.constprop.0+0xca>
	ret = ull_disable(&adv->lll);
    6634:	f104 001c 	add.w	r0, r4, #28
    6638:	f7ff fb24 	bl	5c84 <ull_disable>
	LL_ASSERT(!ret);
    663c:	b160      	cbz	r0, 6658 <disable.constprop.0+0x98>
    663e:	4a14      	ldr	r2, [pc, #80]	; (6690 <disable.constprop.0+0xd0>)
    6640:	4917      	ldr	r1, [pc, #92]	; (66a0 <disable.constprop.0+0xe0>)
    6642:	4815      	ldr	r0, [pc, #84]	; (6698 <disable.constprop.0+0xd8>)
    6644:	f640 231d 	movw	r3, #2589	; 0xa1d
    6648:	f006 fbd9 	bl	cdfe <printk>
    664c:	4040      	eors	r0, r0
    664e:	f380 8811 	msr	BASEPRI, r0
    6652:	f04f 0003 	mov.w	r0, #3
    6656:	df02      	svc	2
	mark = ull_disable_unmark(adv);
    6658:	4620      	mov	r0, r4
    665a:	f7ff faff 	bl	5c5c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
    665e:	4284      	cmp	r4, r0
    6660:	d00c      	beq.n	667c <disable.constprop.0+0xbc>
    6662:	4a0b      	ldr	r2, [pc, #44]	; (6690 <disable.constprop.0+0xd0>)
    6664:	490b      	ldr	r1, [pc, #44]	; (6694 <disable.constprop.0+0xd4>)
    6666:	480c      	ldr	r0, [pc, #48]	; (6698 <disable.constprop.0+0xd8>)
    6668:	f44f 6322 	mov.w	r3, #2592	; 0xa20
    666c:	f006 fbc7 	bl	cdfe <printk>
    6670:	4040      	eors	r0, r0
    6672:	f380 8811 	msr	BASEPRI, r0
    6676:	f04f 0003 	mov.w	r0, #3
    667a:	df02      	svc	2
	adv->is_enabled = 0U;
    667c:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    6680:	f36f 0300 	bfc	r3, #0, #1
    6684:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
	return 0;
    6688:	2000      	movs	r0, #0
}
    668a:	b005      	add	sp, #20
    668c:	bd30      	pop	{r4, r5, pc}
    668e:	bf00      	nop
    6690:	0001170c 	.word	0x0001170c
    6694:	00011797 	.word	0x00011797
    6698:	00010f78 	.word	0x00010f78
    669c:	00005aad 	.word	0x00005aad
    66a0:	00011648 	.word	0x00011648

000066a4 <ll_adv_data_set>:
{
    66a4:	460a      	mov	r2, r1
	return ull_adv_data_set(adv, len, data);
    66a6:	4601      	mov	r1, r0
    66a8:	4801      	ldr	r0, [pc, #4]	; (66b0 <ll_adv_data_set+0xc>)
    66aa:	f007 bf95 	b.w	e5d8 <ull_adv_data_set>
    66ae:	bf00      	nop
    66b0:	20001700 	.word	0x20001700

000066b4 <ll_adv_scan_rsp_set>:
{
    66b4:	460a      	mov	r2, r1
	return ull_scan_rsp_set(adv, len, data);
    66b6:	4601      	mov	r1, r0
    66b8:	4801      	ldr	r0, [pc, #4]	; (66c0 <ll_adv_scan_rsp_set+0xc>)
    66ba:	f007 bfda 	b.w	e672 <ull_scan_rsp_set>
    66be:	bf00      	nop
    66c0:	20001700 	.word	0x20001700

000066c4 <fal_clear>:
#endif /* CONFIG_BT_CTLR_SW_DEFERRED_PRIVACY */

static void fal_clear(void)
{
	for (int i = 0; i < FAL_SIZE; i++) {
		uint8_t j = fal[i].rl_idx;
    66c4:	490c      	ldr	r1, [pc, #48]	; (66f8 <fal_clear+0x34>)

		if (j < ARRAY_SIZE(rl)) {
			rl[j].fal = 0U;
    66c6:	480d      	ldr	r0, [pc, #52]	; (66fc <fal_clear+0x38>)
{
    66c8:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < FAL_SIZE; i++) {
    66ca:	2300      	movs	r3, #0
			rl[j].fal = 0U;
    66cc:	2528      	movs	r5, #40	; 0x28
		uint8_t j = fal[i].rl_idx;
    66ce:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
    66d2:	7852      	ldrb	r2, [r2, #1]
		if (j < ARRAY_SIZE(rl)) {
    66d4:	2a07      	cmp	r2, #7
			rl[j].fal = 0U;
    66d6:	bf9f      	itttt	ls
    66d8:	436a      	mulls	r2, r5
    66da:	5c84      	ldrbls	r4, [r0, r2]
    66dc:	f36f 1445 	bfcls	r4, #5, #1
    66e0:	5484      	strbls	r4, [r0, r2]
		}
		fal[i].taken = 0U;
    66e2:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
    66e6:	f36f 0200 	bfc	r2, #0, #1
    66ea:	f801 2033 	strb.w	r2, [r1, r3, lsl #3]
	for (int i = 0; i < FAL_SIZE; i++) {
    66ee:	3301      	adds	r3, #1
    66f0:	2b08      	cmp	r3, #8
    66f2:	d1ec      	bne.n	66ce <fal_clear+0xa>
	}
}
    66f4:	bd30      	pop	{r4, r5, pc}
    66f6:	bf00      	nop
    66f8:	20001cca 	.word	0x20001cca
    66fc:	20001764 	.word	0x20001764

00006700 <rl_clear>:
#endif /* CONFIG_BT_BROADCASTER */

static void rl_clear(void)
{
	for (uint8_t i = 0; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
		rl[i].taken = 0U;
    6700:	4b19      	ldr	r3, [pc, #100]	; (6768 <rl_clear+0x68>)
    6702:	781a      	ldrb	r2, [r3, #0]
    6704:	f36f 0200 	bfc	r2, #0, #1
    6708:	701a      	strb	r2, [r3, #0]
    670a:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    670e:	f36f 0200 	bfc	r2, #0, #1
    6712:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    6716:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
    671a:	f36f 0200 	bfc	r2, #0, #1
    671e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
    6722:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
    6726:	f36f 0200 	bfc	r2, #0, #1
    672a:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
    672e:	f893 20a0 	ldrb.w	r2, [r3, #160]	; 0xa0
    6732:	f36f 0200 	bfc	r2, #0, #1
    6736:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
    673a:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
    673e:	f36f 0200 	bfc	r2, #0, #1
    6742:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
    6746:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
    674a:	f36f 0200 	bfc	r2, #0, #1
    674e:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
    6752:	f893 2118 	ldrb.w	r2, [r3, #280]	; 0x118
    6756:	f36f 0200 	bfc	r2, #0, #1
    675a:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	}

	peer_irk_count = 0U;
    675e:	4b03      	ldr	r3, [pc, #12]	; (676c <rl_clear+0x6c>)
    6760:	2200      	movs	r2, #0
    6762:	701a      	strb	r2, [r3, #0]
}
    6764:	4770      	bx	lr
    6766:	bf00      	nop
    6768:	20001764 	.word	0x20001764
    676c:	20001d6c 	.word	0x20001d6c

00006770 <fal_find>:
{
    6770:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6774:	4688      	mov	r8, r1
	if (free_idx) {
    6776:	4615      	mov	r5, r2
    6778:	b10a      	cbz	r2, 677e <fal_find+0xe>
		*free_idx = FILTER_IDX_NONE;
    677a:	23ff      	movs	r3, #255	; 0xff
    677c:	7013      	strb	r3, [r2, #0]
    677e:	4f15      	ldr	r7, [pc, #84]	; (67d4 <fal_find+0x64>)
{
    6780:	2400      	movs	r4, #0
		if (LIST_MATCH(fal, i, addr_type, addr)) {
    6782:	f1a7 0902 	sub.w	r9, r7, #2
    6786:	f000 0601 	and.w	r6, r0, #1
    678a:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
    678e:	07da      	lsls	r2, r3, #31
    6790:	d51c      	bpl.n	67cc <fal_find+0x5c>
    6792:	f3c3 0340 	ubfx	r3, r3, #1, #1
    6796:	42b3      	cmp	r3, r6
    6798:	d111      	bne.n	67be <fal_find+0x4e>
    679a:	2206      	movs	r2, #6
    679c:	4641      	mov	r1, r8
    679e:	4638      	mov	r0, r7
    67a0:	f007 f920 	bl	d9e4 <memcmp>
    67a4:	b910      	cbnz	r0, 67ac <fal_find+0x3c>
			return i;
    67a6:	b2e0      	uxtb	r0, r4
}
    67a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		} else if (free_idx && !fal[i].taken &&
    67ac:	b13d      	cbz	r5, 67be <fal_find+0x4e>
    67ae:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
    67b2:	07db      	lsls	r3, r3, #31
    67b4:	d403      	bmi.n	67be <fal_find+0x4e>
    67b6:	782b      	ldrb	r3, [r5, #0]
    67b8:	2bff      	cmp	r3, #255	; 0xff
			*free_idx = i;
    67ba:	bf08      	it	eq
    67bc:	702c      	strbeq	r4, [r5, #0]
	for (i = 0; i < FAL_SIZE; i++) {
    67be:	3401      	adds	r4, #1
    67c0:	2c08      	cmp	r4, #8
    67c2:	f107 0708 	add.w	r7, r7, #8
    67c6:	d1e0      	bne.n	678a <fal_find+0x1a>
	return FILTER_IDX_NONE;
    67c8:	20ff      	movs	r0, #255	; 0xff
    67ca:	e7ed      	b.n	67a8 <fal_find+0x38>
		} else if (free_idx && !fal[i].taken &&
    67cc:	2d00      	cmp	r5, #0
    67ce:	d1f2      	bne.n	67b6 <fal_find+0x46>
    67d0:	e7f5      	b.n	67be <fal_find+0x4e>
    67d2:	bf00      	nop
    67d4:	20001ccc 	.word	0x20001ccc

000067d8 <fal_update>:
{
    67d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    67dc:	4d1a      	ldr	r5, [pc, #104]	; (6848 <fal_update+0x70>)
    67de:	4e1b      	ldr	r6, [pc, #108]	; (684c <fal_update+0x74>)
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
    67e0:	f8df 806c 	ldr.w	r8, [pc, #108]	; 6850 <fal_update+0x78>
{
    67e4:	2400      	movs	r4, #0
		if (!fal[i].taken) {
    67e6:	1eaf      	subs	r7, r5, #2
    67e8:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
    67ec:	07d9      	lsls	r1, r3, #31
    67ee:	d522      	bpl.n	6836 <fal_update+0x5e>
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
    67f0:	f898 3000 	ldrb.w	r3, [r8]
    67f4:	b15b      	cbz	r3, 680e <fal_update+0x36>
		j = fal[i].rl_idx;
    67f6:	f815 3c01 	ldrb.w	r3, [r5, #-1]
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
    67fa:	2b07      	cmp	r3, #7
    67fc:	d807      	bhi.n	680e <fal_update+0x36>
    67fe:	2228      	movs	r2, #40	; 0x28
    6800:	4353      	muls	r3, r2
    6802:	4a14      	ldr	r2, [pc, #80]	; (6854 <fal_update+0x7c>)
    6804:	5cd3      	ldrb	r3, [r2, r3]
    6806:	075a      	lsls	r2, r3, #29
    6808:	d501      	bpl.n	680e <fal_update+0x36>
    680a:	06db      	lsls	r3, r3, #27
    680c:	d513      	bpl.n	6836 <fal_update+0x5e>
}

static void filter_insert(struct lll_filter *const filter, int index,
			  uint8_t addr_type, const uint8_t *const bdaddr)
{
	filter->enable_bitmask |= BIT(index);
    680e:	4a12      	ldr	r2, [pc, #72]	; (6858 <fal_update+0x80>)
			filter_insert(&fal_filter, i, fal[i].id_addr_type,
    6810:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
	filter->enable_bitmask |= BIT(index);
    6814:	2101      	movs	r1, #1
    6816:	fa01 f004 	lsl.w	r0, r1, r4
    681a:	7811      	ldrb	r1, [r2, #0]
    681c:	4301      	orrs	r1, r0
    681e:	7011      	strb	r1, [r2, #0]
			filter_insert(&fal_filter, i, fal[i].id_addr_type,
    6820:	f3c3 0340 	ubfx	r3, r3, #1, #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    6824:	7851      	ldrb	r1, [r2, #1]
    6826:	40a3      	lsls	r3, r4
    6828:	430b      	orrs	r3, r1
    682a:	7053      	strb	r3, [r2, #1]
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    682c:	4629      	mov	r1, r5
    682e:	2206      	movs	r2, #6
    6830:	4630      	mov	r0, r6
    6832:	f007 f8e8 	bl	da06 <memcpy>
	for (i = 0U; i < FAL_SIZE; i++) {
    6836:	3401      	adds	r4, #1
    6838:	2c08      	cmp	r4, #8
    683a:	f106 0606 	add.w	r6, r6, #6
    683e:	f105 0508 	add.w	r5, r5, #8
    6842:	d1d1      	bne.n	67e8 <fal_update+0x10>
}
    6844:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6848:	20001ccc 	.word	0x20001ccc
    684c:	20001d0c 	.word	0x20001d0c
    6850:	20001df5 	.word	0x20001df5
    6854:	20001764 	.word	0x20001764
    6858:	20001d0a 	.word	0x20001d0a

0000685c <rl_update>:
{
    685c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6860:	4e13      	ldr	r6, [pc, #76]	; (68b0 <rl_update+0x54>)
    6862:	4d14      	ldr	r5, [pc, #80]	; (68b4 <rl_update+0x58>)
    6864:	2400      	movs	r4, #0
		if (rl[i].taken) {
    6866:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
    686a:	f04f 0928 	mov.w	r9, #40	; 0x28
	filter->enable_bitmask |= BIT(index);
    686e:	1eb7      	subs	r7, r6, #2
		if (rl[i].taken) {
    6870:	fb09 f304 	mul.w	r3, r9, r4
    6874:	f818 3003 	ldrb.w	r3, [r8, r3]
    6878:	07da      	lsls	r2, r3, #31
    687a:	d510      	bpl.n	689e <rl_update+0x42>
	filter->enable_bitmask |= BIT(index);
    687c:	2201      	movs	r2, #1
    687e:	fa02 f104 	lsl.w	r1, r2, r4
    6882:	783a      	ldrb	r2, [r7, #0]
    6884:	430a      	orrs	r2, r1
			filter_insert(&rl_filter, i, rl[i].id_addr_type,
    6886:	f3c3 1380 	ubfx	r3, r3, #6, #1
	filter->enable_bitmask |= BIT(index);
    688a:	703a      	strb	r2, [r7, #0]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    688c:	787a      	ldrb	r2, [r7, #1]
    688e:	40a3      	lsls	r3, r4
    6890:	4313      	orrs	r3, r2
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    6892:	4629      	mov	r1, r5
    6894:	2206      	movs	r2, #6
    6896:	4630      	mov	r0, r6
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    6898:	707b      	strb	r3, [r7, #1]
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    689a:	f007 f8b4 	bl	da06 <memcpy>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    689e:	3401      	adds	r4, #1
    68a0:	2c08      	cmp	r4, #8
    68a2:	f106 0606 	add.w	r6, r6, #6
    68a6:	f105 0528 	add.w	r5, r5, #40	; 0x28
    68aa:	d1e1      	bne.n	6870 <rl_update+0x14>
}
    68ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    68b0:	20001df8 	.word	0x20001df8
    68b4:	20001765 	.word	0x20001765

000068b8 <ll_fal_remove>:
{
    68b8:	b538      	push	{r3, r4, r5, lr}
    68ba:	4605      	mov	r5, r0
	if (ull_adv_filter_pol_get(0)) {
    68bc:	2000      	movs	r0, #0
    68be:	f007 fe54 	bl	e56a <ull_adv_filter_pol_get>
    68c2:	4604      	mov	r4, r0
    68c4:	b9f8      	cbnz	r0, 6906 <ll_fal_remove+0x4e>
	if (addr->type == ADDR_TYPE_ANON) {
    68c6:	7828      	ldrb	r0, [r5, #0]
    68c8:	28ff      	cmp	r0, #255	; 0xff
    68ca:	d01e      	beq.n	690a <ll_fal_remove+0x52>
	uint8_t i = fal_find(id_addr->type, id_addr->a.val, NULL);
    68cc:	4622      	mov	r2, r4
    68ce:	1c69      	adds	r1, r5, #1
    68d0:	f7ff ff4e 	bl	6770 <fal_find>
	if (i < ARRAY_SIZE(fal)) {
    68d4:	2807      	cmp	r0, #7
    68d6:	d814      	bhi.n	6902 <ll_fal_remove+0x4a>
		uint8_t j = fal[i].rl_idx;
    68d8:	4a0d      	ldr	r2, [pc, #52]	; (6910 <ll_fal_remove+0x58>)
    68da:	eb02 03c0 	add.w	r3, r2, r0, lsl #3
    68de:	785b      	ldrb	r3, [r3, #1]
		if (j < ARRAY_SIZE(rl)) {
    68e0:	2b07      	cmp	r3, #7
    68e2:	d806      	bhi.n	68f2 <ll_fal_remove+0x3a>
			rl[j].fal = 0U;
    68e4:	2528      	movs	r5, #40	; 0x28
    68e6:	490b      	ldr	r1, [pc, #44]	; (6914 <ll_fal_remove+0x5c>)
    68e8:	436b      	muls	r3, r5
    68ea:	5ccd      	ldrb	r5, [r1, r3]
    68ec:	f364 1545 	bfi	r5, r4, #5, #1
    68f0:	54cd      	strb	r5, [r1, r3]
		fal[i].taken = 0U;
    68f2:	f812 3030 	ldrb.w	r3, [r2, r0, lsl #3]
    68f6:	f36f 0300 	bfc	r3, #0, #1
    68fa:	f802 3030 	strb.w	r3, [r2, r0, lsl #3]
	return fal_remove(addr);
    68fe:	b2e0      	uxtb	r0, r4
}
    6900:	bd38      	pop	{r3, r4, r5, pc}
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    6902:	2402      	movs	r4, #2
    6904:	e7fb      	b.n	68fe <ll_fal_remove+0x46>
		return BT_HCI_ERR_CMD_DISALLOWED;
    6906:	200c      	movs	r0, #12
    6908:	e7fa      	b.n	6900 <ll_fal_remove+0x48>
		return 0;
    690a:	4620      	mov	r0, r4
    690c:	e7f8      	b.n	6900 <ll_fal_remove+0x48>
    690e:	bf00      	nop
    6910:	20001cca 	.word	0x20001cca
    6914:	20001764 	.word	0x20001764

00006918 <ll_rl_enable>:
{
    6918:	b510      	push	{r4, lr}
    691a:	4604      	mov	r4, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
    691c:	2000      	movs	r0, #0
    691e:	f007 fe1d 	bl	e55c <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
    6922:	b960      	cbnz	r0, 693e <ll_rl_enable+0x26>
	switch (enable) {
    6924:	b124      	cbz	r4, 6930 <ll_rl_enable+0x18>
    6926:	2c01      	cmp	r4, #1
    6928:	d005      	beq.n	6936 <ll_rl_enable+0x1e>
    692a:	2412      	movs	r4, #18
}
    692c:	4620      	mov	r0, r4
    692e:	bd10      	pop	{r4, pc}
		rl_enable = 0U;
    6930:	4b04      	ldr	r3, [pc, #16]	; (6944 <ll_rl_enable+0x2c>)
    6932:	701c      	strb	r4, [r3, #0]
		break;
    6934:	e7fa      	b.n	692c <ll_rl_enable+0x14>
		rl_enable = 1U;
    6936:	4b03      	ldr	r3, [pc, #12]	; (6944 <ll_rl_enable+0x2c>)
    6938:	701c      	strb	r4, [r3, #0]
	return 0;
    693a:	4604      	mov	r4, r0
		break;
    693c:	e7f6      	b.n	692c <ll_rl_enable+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
    693e:	240c      	movs	r4, #12
    6940:	e7f4      	b.n	692c <ll_rl_enable+0x14>
    6942:	bf00      	nop
    6944:	20001df5 	.word	0x20001df5

00006948 <ll_rl_timeout_set>:
	rpa_timeout_ms = timeout * 1000U;
    6948:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    694c:	4358      	muls	r0, r3
    694e:	4b01      	ldr	r3, [pc, #4]	; (6954 <ll_rl_timeout_set+0xc>)
    6950:	6018      	str	r0, [r3, #0]
}
    6952:	4770      	bx	lr
    6954:	200018a4 	.word	0x200018a4

00006958 <ull_filter_reset>:
{
    6958:	b510      	push	{r4, lr}
    695a:	4604      	mov	r4, r0
	fal_clear();
    695c:	f7ff feb2 	bl	66c4 <fal_clear>
	rl_enable = 0U;
    6960:	4b0d      	ldr	r3, [pc, #52]	; (6998 <ull_filter_reset+0x40>)
    6962:	2200      	movs	r2, #0
    6964:	701a      	strb	r2, [r3, #0]
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
    6966:	4b0d      	ldr	r3, [pc, #52]	; (699c <ull_filter_reset+0x44>)
    6968:	4a0d      	ldr	r2, [pc, #52]	; (69a0 <ull_filter_reset+0x48>)
    696a:	601a      	str	r2, [r3, #0]
	rpa_last_ms = -1;
    696c:	4b0d      	ldr	r3, [pc, #52]	; (69a4 <ull_filter_reset+0x4c>)
    696e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6972:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    6976:	e9c3 0100 	strd	r0, r1, [r3]
	rl_clear();
    697a:	f7ff fec1 	bl	6700 <rl_clear>
	if (init) {
    697e:	b12c      	cbz	r4, 698c <ull_filter_reset+0x34>
}
    6980:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_work_init_delayable(&rpa_work, rpa_timeout);
    6984:	4908      	ldr	r1, [pc, #32]	; (69a8 <ull_filter_reset+0x50>)
    6986:	4809      	ldr	r0, [pc, #36]	; (69ac <ull_filter_reset+0x54>)
    6988:	f008 bf90 	b.w	f8ac <k_work_init_delayable>
}
    698c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_work_cancel_delayable(&rpa_work);
    6990:	4806      	ldr	r0, [pc, #24]	; (69ac <ull_filter_reset+0x54>)
    6992:	f008 bf97 	b.w	f8c4 <k_work_cancel_delayable>
    6996:	bf00      	nop
    6998:	20001df5 	.word	0x20001df5
    699c:	200018a4 	.word	0x200018a4
    69a0:	000dbba0 	.word	0x000dbba0
    69a4:	20000c80 	.word	0x20000c80
    69a8:	00006ba9 	.word	0x00006ba9
    69ac:	20000c88 	.word	0x20000c88

000069b0 <ull_filter_lll_get>:
}
    69b0:	4a03      	ldr	r2, [pc, #12]	; (69c0 <ull_filter_lll_get+0x10>)
    69b2:	4b04      	ldr	r3, [pc, #16]	; (69c4 <ull_filter_lll_get+0x14>)
    69b4:	2800      	cmp	r0, #0
    69b6:	bf0c      	ite	eq
    69b8:	4610      	moveq	r0, r2
    69ba:	4618      	movne	r0, r3
    69bc:	4770      	bx	lr
    69be:	bf00      	nop
    69c0:	20001df6 	.word	0x20001df6
    69c4:	20001d0a 	.word	0x20001d0a

000069c8 <ull_filter_adv_update>:
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
    69c8:	4b09      	ldr	r3, [pc, #36]	; (69f0 <ull_filter_adv_update+0x28>)
{
    69ca:	b510      	push	{r4, lr}
	filter->enable_bitmask = 0;
    69cc:	2400      	movs	r4, #0
    69ce:	701c      	strb	r4, [r3, #0]
	filter->addr_type_bitmask = 0;
    69d0:	705c      	strb	r4, [r3, #1]
	if (adv_fp &&
    69d2:	b108      	cbz	r0, 69d8 <ull_filter_adv_update+0x10>
		fal_update();
    69d4:	f7ff ff00 	bl	67d8 <fal_update>
	filter->enable_bitmask = 0;
    69d8:	4b06      	ldr	r3, [pc, #24]	; (69f4 <ull_filter_adv_update+0x2c>)
    69da:	701c      	strb	r4, [r3, #0]
	filter->addr_type_bitmask = 0;
    69dc:	705c      	strb	r4, [r3, #1]
	if (rl_enable &&
    69de:	4b06      	ldr	r3, [pc, #24]	; (69f8 <ull_filter_adv_update+0x30>)
    69e0:	781b      	ldrb	r3, [r3, #0]
    69e2:	b11b      	cbz	r3, 69ec <ull_filter_adv_update+0x24>
}
    69e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		rl_update();
    69e8:	f7ff bf38 	b.w	685c <rl_update>
}
    69ec:	bd10      	pop	{r4, pc}
    69ee:	bf00      	nop
    69f0:	20001d0a 	.word	0x20001d0a
    69f4:	20001df6 	.word	0x20001df6
    69f8:	20001df5 	.word	0x20001df5

000069fc <ull_filter_rpa_update>:
{
    69fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6a00:	b087      	sub	sp, #28
    6a02:	9000      	str	r0, [sp, #0]
	return z_impl_k_uptime_ticks();
    6a04:	f009 f8c7 	bl	fb96 <z_impl_k_uptime_ticks>
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
    6a08:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    6a0c:	fba0 4003 	umull	r4, r0, r0, r3
    6a10:	fb03 0101 	mla	r1, r3, r1, r0
    6a14:	0bcb      	lsrs	r3, r1, #15
    6a16:	9301      	str	r3, [sp, #4]
	bool all = timeout || (rpa_last_ms == -1) ||
    6a18:	9b00      	ldr	r3, [sp, #0]
    6a1a:	0be4      	lsrs	r4, r4, #15
    6a1c:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
    6a20:	2b00      	cmp	r3, #0
    6a22:	f040 80ad 	bne.w	6b80 <ull_filter_rpa_update+0x184>
    6a26:	4a58      	ldr	r2, [pc, #352]	; (6b88 <ull_filter_rpa_update+0x18c>)
    6a28:	e9d2 3200 	ldrd	r3, r2, [r2]
    6a2c:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    6a30:	bf08      	it	eq
    6a32:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
    6a36:	f000 80a3 	beq.w	6b80 <ull_filter_rpa_update+0x184>
		   (now - rpa_last_ms >= rpa_timeout_ms);
    6a3a:	9901      	ldr	r1, [sp, #4]
    6a3c:	1ae3      	subs	r3, r4, r3
    6a3e:	eb61 0202 	sbc.w	r2, r1, r2
    6a42:	4952      	ldr	r1, [pc, #328]	; (6b8c <ull_filter_rpa_update+0x190>)
    6a44:	6809      	ldr	r1, [r1, #0]
	bool all = timeout || (rpa_last_ms == -1) ||
    6a46:	428b      	cmp	r3, r1
    6a48:	f172 0300 	sbcs.w	r3, r2, #0
    6a4c:	bfac      	ite	ge
    6a4e:	f04f 0801 	movge.w	r8, #1
    6a52:	f04f 0800 	movlt.w	r8, #0
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    6a56:	4d4e      	ldr	r5, [pc, #312]	; (6b90 <ull_filter_rpa_update+0x194>)
    6a58:	f8df 9138 	ldr.w	r9, [pc, #312]	; 6b94 <ull_filter_rpa_update+0x198>
				LL_ASSERT(!err);
    6a5c:	f8df a138 	ldr.w	sl, [pc, #312]	; 6b98 <ull_filter_rpa_update+0x19c>
    6a60:	f8df b138 	ldr.w	fp, [pc, #312]	; 6b9c <ull_filter_rpa_update+0x1a0>
	bool all = timeout || (rpa_last_ms == -1) ||
    6a64:	2600      	movs	r6, #0
    6a66:	462f      	mov	r7, r5
		if ((rl[i].taken) && (all || !rl[i].rpas_ready)) {
    6a68:	2328      	movs	r3, #40	; 0x28
    6a6a:	4373      	muls	r3, r6
    6a6c:	5cfb      	ldrb	r3, [r7, r3]
    6a6e:	07da      	lsls	r2, r3, #31
    6a70:	d54f      	bpl.n	6b12 <ull_filter_rpa_update+0x116>
    6a72:	f1b8 0f00 	cmp.w	r8, #0
    6a76:	d101      	bne.n	6a7c <ull_filter_rpa_update+0x80>
    6a78:	0798      	lsls	r0, r3, #30
    6a7a:	d44a      	bmi.n	6b12 <ull_filter_rpa_update+0x116>
			if (rl[i].pirk) {
    6a7c:	2328      	movs	r3, #40	; 0x28
    6a7e:	4373      	muls	r3, r6
    6a80:	5cfb      	ldrb	r3, [r7, r3]
    6a82:	0759      	lsls	r1, r3, #29
    6a84:	d51f      	bpl.n	6ac6 <ull_filter_rpa_update+0xca>
				sys_memcpy_swap(irk, peer_irks[rl[i].pirk_idx],
    6a86:	7dea      	ldrb	r2, [r5, #23]
    6a88:	4b45      	ldr	r3, [pc, #276]	; (6ba0 <ull_filter_rpa_update+0x1a4>)
    6a8a:	a902      	add	r1, sp, #8
    6a8c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
		  (psrc > pdst && (pdst + length) <= psrc)),
		 "Source and destination buffers must not overlap");

	psrc += length - 1;

	for (; length > 0; length--) {
    6a90:	f103 0210 	add.w	r2, r3, #16
    6a94:	4608      	mov	r0, r1
		*pdst++ = *psrc--;
    6a96:	f812 cd01 	ldrb.w	ip, [r2, #-1]!
    6a9a:	f801 cb01 	strb.w	ip, [r1], #1
	for (; length > 0; length--) {
    6a9e:	429a      	cmp	r2, r3
    6aa0:	d1f9      	bne.n	6a96 <ull_filter_rpa_update+0x9a>
				err = bt_rpa_create(irk, &rl[i].peer_rpa);
    6aa2:	f105 011e 	add.w	r1, r5, #30
    6aa6:	f007 f800 	bl	daaa <bt_rpa_create>
				LL_ASSERT(!err);
    6aaa:	b160      	cbz	r0, 6ac6 <ull_filter_rpa_update+0xca>
    6aac:	4a3d      	ldr	r2, [pc, #244]	; (6ba4 <ull_filter_rpa_update+0x1a8>)
    6aae:	f240 23eb 	movw	r3, #747	; 0x2eb
    6ab2:	4651      	mov	r1, sl
    6ab4:	4658      	mov	r0, fp
    6ab6:	f006 f9a2 	bl	cdfe <printk>
    6aba:	4040      	eors	r0, r0
    6abc:	f380 8811 	msr	BASEPRI, r0
    6ac0:	f04f 0003 	mov.w	r0, #3
    6ac4:	df02      	svc	2
			if (rl[i].lirk) {
    6ac6:	2328      	movs	r3, #40	; 0x28
    6ac8:	4373      	muls	r3, r6
    6aca:	5cfb      	ldrb	r3, [r7, r3]
    6acc:	071a      	lsls	r2, r3, #28
    6ace:	d51a      	bpl.n	6b06 <ull_filter_rpa_update+0x10a>
				err = bt_rpa_create(rl[i].local_irk, &rpa);
    6ad0:	a902      	add	r1, sp, #8
    6ad2:	1de8      	adds	r0, r5, #7
    6ad4:	f006 ffe9 	bl	daaa <bt_rpa_create>
				LL_ASSERT(!err);
    6ad8:	b160      	cbz	r0, 6af4 <ull_filter_rpa_update+0xf8>
    6ada:	4a32      	ldr	r2, [pc, #200]	; (6ba4 <ull_filter_rpa_update+0x1a8>)
    6adc:	f44f 733e 	mov.w	r3, #760	; 0x2f8
    6ae0:	4651      	mov	r1, sl
    6ae2:	4658      	mov	r0, fp
    6ae4:	f006 f98b 	bl	cdfe <printk>
    6ae8:	4040      	eors	r0, r0
    6aea:	f380 8811 	msr	BASEPRI, r0
    6aee:	f04f 0003 	mov.w	r0, #3
    6af2:	df02      	svc	2
				rl[i].local_rpa = &rpa;
    6af4:	ab02      	add	r3, sp, #8
    6af6:	626b      	str	r3, [r5, #36]	; 0x24
	memcpy(dst, src, sizeof(*dst));
    6af8:	2206      	movs	r2, #6
    6afa:	4619      	mov	r1, r3
    6afc:	4648      	mov	r0, r9
    6afe:	f006 ff82 	bl	da06 <memcpy>
				rl[i].local_rpa = &local_rpas[i];
    6b02:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
			rl[i].rpas_ready = 1U;
    6b06:	2328      	movs	r3, #40	; 0x28
    6b08:	4373      	muls	r3, r6
    6b0a:	5cfa      	ldrb	r2, [r7, r3]
    6b0c:	f042 0202 	orr.w	r2, r2, #2
    6b10:	54fa      	strb	r2, [r7, r3]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    6b12:	3601      	adds	r6, #1
    6b14:	2e08      	cmp	r6, #8
    6b16:	f105 0528 	add.w	r5, r5, #40	; 0x28
    6b1a:	f109 0906 	add.w	r9, r9, #6
    6b1e:	d1a3      	bne.n	6a68 <ull_filter_rpa_update+0x6c>
	if (all) {
    6b20:	f1b8 0f00 	cmp.w	r8, #0
    6b24:	d003      	beq.n	6b2e <ull_filter_rpa_update+0x132>
		rpa_last_ms = now;
    6b26:	4b18      	ldr	r3, [pc, #96]	; (6b88 <ull_filter_rpa_update+0x18c>)
    6b28:	9a01      	ldr	r2, [sp, #4]
    6b2a:	601c      	str	r4, [r3, #0]
    6b2c:	605a      	str	r2, [r3, #4]
	if (timeout) {
    6b2e:	9b00      	ldr	r3, [sp, #0]
    6b30:	b31b      	cbz	r3, 6b7a <ull_filter_rpa_update+0x17e>
		adv = ull_adv_is_enabled_get(0);
    6b32:	2000      	movs	r0, #0
    6b34:	f7ff fd36 	bl	65a4 <ull_adv_is_enabled_get>
		if (adv) {
    6b38:	4604      	mov	r4, r0
    6b3a:	b1f0      	cbz	r0, 6b7a <ull_filter_rpa_update+0x17e>
	if (adv->own_addr_type != BT_ADDR_LE_PUBLIC_ID &&
    6b3c:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
    6b40:	075b      	lsls	r3, r3, #29
    6b42:	d51a      	bpl.n	6b7a <ull_filter_rpa_update+0x17e>
	if (adv->lll.rl_idx >= ARRAY_SIZE(rl)) {
    6b44:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
    6b48:	2b07      	cmp	r3, #7
    6b4a:	d816      	bhi.n	6b7a <ull_filter_rpa_update+0x17e>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    6b4c:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
    6b50:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
    6b54:	a902      	add	r1, sp, #8
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    6b56:	6a9e      	ldr	r6, [r3, #40]	; 0x28
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
    6b58:	3024      	adds	r0, #36	; 0x24
    6b5a:	f007 fe4d 	bl	e7f8 <lll_adv_pdu_alloc>
	(void)memcpy(pdu, prev, PDU_AC_LL_HEADER_SIZE + prev->len);
    6b5e:	7872      	ldrb	r2, [r6, #1]
    6b60:	4605      	mov	r5, r0
    6b62:	3202      	adds	r2, #2
    6b64:	4631      	mov	r1, r6
    6b66:	f006 ff4e 	bl	da06 <memcpy>
	ull_adv_pdu_update_addrs(adv, pdu);
    6b6a:	4629      	mov	r1, r5
    6b6c:	4620      	mov	r0, r4
    6b6e:	f007 fd04 	bl	e57a <ull_adv_pdu_update_addrs>
	pdu->last = idx;
    6b72:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6b76:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
}
    6b7a:	b007      	add	sp, #28
    6b7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bool all = timeout || (rpa_last_ms == -1) ||
    6b80:	f04f 0801 	mov.w	r8, #1
    6b84:	e767      	b.n	6a56 <ull_filter_rpa_update+0x5a>
    6b86:	bf00      	nop
    6b88:	20000c80 	.word	0x20000c80
    6b8c:	200018a4 	.word	0x200018a4
    6b90:	20001764 	.word	0x20001764
    6b94:	20001d3c 	.word	0x20001d3c
    6b98:	000115c5 	.word	0x000115c5
    6b9c:	00010f78 	.word	0x00010f78
    6ba0:	20001d75 	.word	0x20001d75
    6ba4:	000117b3 	.word	0x000117b3

00006ba8 <rpa_timeout>:
{
    6ba8:	b570      	push	{r4, r5, r6, lr}
	ull_filter_rpa_update(true);
    6baa:	2001      	movs	r0, #1
    6bac:	f7ff ff26 	bl	69fc <ull_filter_rpa_update>
	k_work_schedule(&rpa_work, K_MSEC(rpa_timeout_ms));
    6bb0:	4b0a      	ldr	r3, [pc, #40]	; (6bdc <rpa_timeout+0x34>)
    6bb2:	681d      	ldr	r5, [r3, #0]
    6bb4:	f44f 4400 	mov.w	r4, #32768	; 0x8000
    6bb8:	f240 30e7 	movw	r0, #999	; 0x3e7
    6bbc:	2100      	movs	r1, #0
    6bbe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6bc2:	2300      	movs	r3, #0
    6bc4:	fbe5 0104 	umlal	r0, r1, r5, r4
    6bc8:	f7f9 fa8a 	bl	e0 <__aeabi_uldivmod>
}
    6bcc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    6bd0:	4602      	mov	r2, r0
    6bd2:	460b      	mov	r3, r1
	k_work_schedule(&rpa_work, K_MSEC(rpa_timeout_ms));
    6bd4:	4802      	ldr	r0, [pc, #8]	; (6be0 <rpa_timeout+0x38>)
    6bd6:	f005 ba4b 	b.w	c070 <k_work_schedule>
    6bda:	bf00      	nop
    6bdc:	200018a4 	.word	0x200018a4
    6be0:	20000c88 	.word	0x20000c88

00006be4 <ull_filter_adva_get>:
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].lirk) {
    6be4:	2807      	cmp	r0, #7
{
    6be6:	b538      	push	{r3, r4, r5, lr}
    6be8:	4604      	mov	r4, r0
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].lirk) {
    6bea:	d81b      	bhi.n	6c24 <ull_filter_adva_get+0x40>
    6bec:	2328      	movs	r3, #40	; 0x28
    6bee:	4343      	muls	r3, r0
    6bf0:	4d0d      	ldr	r5, [pc, #52]	; (6c28 <ull_filter_adva_get+0x44>)
    6bf2:	5ceb      	ldrb	r3, [r5, r3]
    6bf4:	071a      	lsls	r2, r3, #28
    6bf6:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    6bfa:	d512      	bpl.n	6c22 <ull_filter_adva_get+0x3e>
		LL_ASSERT(rl[rl_idx].rpas_ready);
    6bfc:	079b      	lsls	r3, r3, #30
    6bfe:	d40c      	bmi.n	6c1a <ull_filter_adva_get+0x36>
    6c00:	4a0a      	ldr	r2, [pc, #40]	; (6c2c <ull_filter_adva_get+0x48>)
    6c02:	490b      	ldr	r1, [pc, #44]	; (6c30 <ull_filter_adva_get+0x4c>)
    6c04:	480b      	ldr	r0, [pc, #44]	; (6c34 <ull_filter_adva_get+0x50>)
    6c06:	f44f 7347 	mov.w	r3, #796	; 0x31c
    6c0a:	f006 f8f8 	bl	cdfe <printk>
    6c0e:	4040      	eors	r0, r0
    6c10:	f380 8811 	msr	BASEPRI, r0
    6c14:	f04f 0003 	mov.w	r0, #3
    6c18:	df02      	svc	2
		return rl[rl_idx].local_rpa->val;
    6c1a:	2028      	movs	r0, #40	; 0x28
    6c1c:	fb00 5404 	mla	r4, r0, r4, r5
    6c20:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
    6c22:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
    6c24:	2000      	movs	r0, #0
    6c26:	e7fc      	b.n	6c22 <ull_filter_adva_get+0x3e>
    6c28:	20001764 	.word	0x20001764
    6c2c:	000117b3 	.word	0x000117b3
    6c30:	00011811 	.word	0x00011811
    6c34:	00010f78 	.word	0x00010f78

00006c38 <ull_filter_tgta_get>:
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].pirk) {
    6c38:	2807      	cmp	r0, #7
{
    6c3a:	b510      	push	{r4, lr}
    6c3c:	4603      	mov	r3, r0
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].pirk) {
    6c3e:	d80b      	bhi.n	6c58 <ull_filter_tgta_get+0x20>
    6c40:	2128      	movs	r1, #40	; 0x28
    6c42:	4348      	muls	r0, r1
    6c44:	4a05      	ldr	r2, [pc, #20]	; (6c5c <ull_filter_tgta_get+0x24>)
    6c46:	5c14      	ldrb	r4, [r2, r0]
    6c48:	f3c4 0080 	ubfx	r0, r4, #2, #1
    6c4c:	0764      	lsls	r4, r4, #29
    6c4e:	d502      	bpl.n	6c56 <ull_filter_tgta_get+0x1e>
		return rl[rl_idx].peer_rpa.val;
    6c50:	fb01 2003 	mla	r0, r1, r3, r2
    6c54:	301e      	adds	r0, #30
}
    6c56:	bd10      	pop	{r4, pc}
	return NULL;
    6c58:	2000      	movs	r0, #0
    6c5a:	e7fc      	b.n	6c56 <ull_filter_tgta_get+0x1e>
    6c5c:	20001764 	.word	0x20001764

00006c60 <ull_filter_rl_find>:
{
    6c60:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6c64:	468b      	mov	fp, r1
	if (free_idx) {
    6c66:	4614      	mov	r4, r2
    6c68:	b10a      	cbz	r2, 6c6e <ull_filter_rl_find+0xe>
		*free_idx = FILTER_IDX_NONE;
    6c6a:	23ff      	movs	r3, #255	; 0xff
    6c6c:	7013      	strb	r3, [r2, #0]
    6c6e:	4f18      	ldr	r7, [pc, #96]	; (6cd0 <ull_filter_rl_find+0x70>)
{
    6c70:	2500      	movs	r5, #0
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
    6c72:	f107 3aff 	add.w	sl, r7, #4294967295	; 0xffffffff
    6c76:	f000 0601 	and.w	r6, r0, #1
    6c7a:	f04f 0828 	mov.w	r8, #40	; 0x28
    6c7e:	fb08 f805 	mul.w	r8, r8, r5
    6c82:	fa5f f985 	uxtb.w	r9, r5
    6c86:	f81a 3008 	ldrb.w	r3, [sl, r8]
    6c8a:	07da      	lsls	r2, r3, #31
    6c8c:	d51d      	bpl.n	6cca <ull_filter_rl_find+0x6a>
    6c8e:	f3c3 1380 	ubfx	r3, r3, #6, #1
    6c92:	42b3      	cmp	r3, r6
    6c94:	d10f      	bne.n	6cb6 <ull_filter_rl_find+0x56>
    6c96:	2206      	movs	r2, #6
    6c98:	4659      	mov	r1, fp
    6c9a:	4638      	mov	r0, r7
    6c9c:	f006 fea2 	bl	d9e4 <memcmp>
    6ca0:	b180      	cbz	r0, 6cc4 <ull_filter_rl_find+0x64>
		} else if (free_idx && !rl[i].taken &&
    6ca2:	b144      	cbz	r4, 6cb6 <ull_filter_rl_find+0x56>
    6ca4:	f81a 3008 	ldrb.w	r3, [sl, r8]
    6ca8:	07db      	lsls	r3, r3, #31
    6caa:	d404      	bmi.n	6cb6 <ull_filter_rl_find+0x56>
    6cac:	7823      	ldrb	r3, [r4, #0]
    6cae:	2bff      	cmp	r3, #255	; 0xff
			*free_idx = i;
    6cb0:	bf08      	it	eq
    6cb2:	f884 9000 	strbeq.w	r9, [r4]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    6cb6:	3501      	adds	r5, #1
    6cb8:	2d08      	cmp	r5, #8
    6cba:	f107 0728 	add.w	r7, r7, #40	; 0x28
    6cbe:	d1dc      	bne.n	6c7a <ull_filter_rl_find+0x1a>
	return FILTER_IDX_NONE;
    6cc0:	f04f 09ff 	mov.w	r9, #255	; 0xff
}
    6cc4:	4648      	mov	r0, r9
    6cc6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (free_idx && !rl[i].taken &&
    6cca:	2c00      	cmp	r4, #0
    6ccc:	d1ee      	bne.n	6cac <ull_filter_rl_find+0x4c>
    6cce:	e7f2      	b.n	6cb6 <ull_filter_rl_find+0x56>
    6cd0:	20001765 	.word	0x20001765

00006cd4 <ll_fal_add>:
{
    6cd4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6cd8:	4607      	mov	r7, r0
	if (ull_adv_filter_pol_get(0)) {
    6cda:	2000      	movs	r0, #0
    6cdc:	f007 fc45 	bl	e56a <ull_adv_filter_pol_get>
    6ce0:	4604      	mov	r4, r0
    6ce2:	2800      	cmp	r0, #0
    6ce4:	d13e      	bne.n	6d64 <ll_fal_add+0x90>
	if (addr->type == ADDR_TYPE_ANON) {
    6ce6:	7838      	ldrb	r0, [r7, #0]
    6ce8:	28ff      	cmp	r0, #255	; 0xff
    6cea:	d03d      	beq.n	6d68 <ll_fal_add+0x94>
	i = fal_find(id_addr->type, id_addr->a.val, &j);
    6cec:	f107 0801 	add.w	r8, r7, #1
    6cf0:	f10d 0207 	add.w	r2, sp, #7
    6cf4:	4641      	mov	r1, r8
    6cf6:	f7ff fd3b 	bl	6770 <fal_find>
	if (i < ARRAY_SIZE(fal)) {
    6cfa:	2807      	cmp	r0, #7
    6cfc:	d929      	bls.n	6d52 <ll_fal_add+0x7e>
	} else if (j >= ARRAY_SIZE(fal)) {
    6cfe:	f89d 6007 	ldrb.w	r6, [sp, #7]
    6d02:	2e07      	cmp	r6, #7
    6d04:	d82c      	bhi.n	6d60 <ll_fal_add+0x8c>
	fal[i].id_addr_type = id_addr->type & 0x1;
    6d06:	4d19      	ldr	r5, [pc, #100]	; (6d6c <ll_fal_add+0x98>)
    6d08:	783a      	ldrb	r2, [r7, #0]
    6d0a:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
	bt_addr_copy(&fal[i].id_addr, &id_addr->a);
    6d0e:	eb05 00c6 	add.w	r0, r5, r6, lsl #3
	fal[i].id_addr_type = id_addr->type & 0x1;
    6d12:	f362 0341 	bfi	r3, r2, #1, #1
    6d16:	4641      	mov	r1, r8
    6d18:	2206      	movs	r2, #6
    6d1a:	3002      	adds	r0, #2
    6d1c:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
    6d20:	f006 fe71 	bl	da06 <memcpy>
	j = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    6d24:	7838      	ldrb	r0, [r7, #0]
    6d26:	4622      	mov	r2, r4
    6d28:	4641      	mov	r1, r8
    6d2a:	f7ff ff99 	bl	6c60 <ull_filter_rl_find>
	if (j < ARRAY_SIZE(rl)) {
    6d2e:	00f3      	lsls	r3, r6, #3
    6d30:	2807      	cmp	r0, #7
		fal[i].rl_idx = j;
    6d32:	442b      	add	r3, r5
	if (j < ARRAY_SIZE(rl)) {
    6d34:	d811      	bhi.n	6d5a <ll_fal_add+0x86>
		fal[i].rl_idx = j;
    6d36:	7058      	strb	r0, [r3, #1]
		rl[j].fal = 1U;
    6d38:	2328      	movs	r3, #40	; 0x28
    6d3a:	4a0d      	ldr	r2, [pc, #52]	; (6d70 <ll_fal_add+0x9c>)
    6d3c:	4358      	muls	r0, r3
    6d3e:	5c13      	ldrb	r3, [r2, r0]
    6d40:	f043 0320 	orr.w	r3, r3, #32
    6d44:	5413      	strb	r3, [r2, r0]
	fal[i].taken = 1U;
    6d46:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
    6d4a:	f043 0301 	orr.w	r3, r3, #1
    6d4e:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
	return fal_add(addr);
    6d52:	b2e0      	uxtb	r0, r4
}
    6d54:	b002      	add	sp, #8
    6d56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		fal[i].rl_idx = FILTER_IDX_NONE;
    6d5a:	22ff      	movs	r2, #255	; 0xff
    6d5c:	705a      	strb	r2, [r3, #1]
    6d5e:	e7f2      	b.n	6d46 <ll_fal_add+0x72>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    6d60:	2407      	movs	r4, #7
    6d62:	e7f6      	b.n	6d52 <ll_fal_add+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
    6d64:	200c      	movs	r0, #12
    6d66:	e7f5      	b.n	6d54 <ll_fal_add+0x80>
		return 0;
    6d68:	4620      	mov	r0, r4
    6d6a:	e7f3      	b.n	6d54 <ll_fal_add+0x80>
    6d6c:	20001cca 	.word	0x20001cca
    6d70:	20001764 	.word	0x20001764

00006d74 <ll_rl_add>:
{
    6d74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6d78:	4680      	mov	r8, r0
    6d7a:	b085      	sub	sp, #20
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
    6d7c:	2000      	movs	r0, #0
{
    6d7e:	468a      	mov	sl, r1
    6d80:	4693      	mov	fp, r2
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
    6d82:	f007 fbeb 	bl	e55c <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
    6d86:	2800      	cmp	r0, #0
    6d88:	f040 8083 	bne.w	6e92 <ll_rl_add+0x11e>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, &j);
    6d8c:	46c1      	mov	r9, r8
    6d8e:	f10d 020f 	add.w	r2, sp, #15
    6d92:	f819 0b01 	ldrb.w	r0, [r9], #1
    6d96:	4649      	mov	r1, r9
    6d98:	f7ff ff62 	bl	6c60 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    6d9c:	2807      	cmp	r0, #7
    6d9e:	d97a      	bls.n	6e96 <ll_rl_add+0x122>
	} else if (j >= ARRAY_SIZE(rl)) {
    6da0:	f89d 500f 	ldrb.w	r5, [sp, #15]
    6da4:	2d07      	cmp	r5, #7
    6da6:	d878      	bhi.n	6e9a <ll_rl_add+0x126>
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
    6da8:	eb05 0785 	add.w	r7, r5, r5, lsl #2
    6dac:	4c3c      	ldr	r4, [pc, #240]	; (6ea0 <ll_rl_add+0x12c>)
    6dae:	00ff      	lsls	r7, r7, #3
	rl[i].id_addr_type = id_addr->type & 0x1;
    6db0:	2628      	movs	r6, #40	; 0x28
    6db2:	436e      	muls	r6, r5
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
    6db4:	1c78      	adds	r0, r7, #1
    6db6:	2206      	movs	r2, #6
    6db8:	4649      	mov	r1, r9
    6dba:	4420      	add	r0, r4
    6dbc:	f006 fe23 	bl	da06 <memcpy>
	rl[i].id_addr_type = id_addr->type & 0x1;
    6dc0:	f898 1000 	ldrb.w	r1, [r8]
    6dc4:	5da3      	ldrb	r3, [r4, r6]
    6dc6:	19a2      	adds	r2, r4, r6
    6dc8:	f361 1386 	bfi	r3, r1, #6, #1
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    6dcc:	4650      	mov	r0, sl
    6dce:	2110      	movs	r1, #16
	rl[i].id_addr_type = id_addr->type & 0x1;
    6dd0:	9201      	str	r2, [sp, #4]
    6dd2:	55a3      	strb	r3, [r4, r6]
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    6dd4:	f007 f839 	bl	de4a <mem_nz>
    6dd8:	5da3      	ldrb	r3, [r4, r6]
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    6dda:	2110      	movs	r1, #16
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    6ddc:	f360 0382 	bfi	r3, r0, #2, #1
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    6de0:	4658      	mov	r0, fp
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    6de2:	55a3      	strb	r3, [r4, r6]
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    6de4:	f007 f831 	bl	de4a <mem_nz>
    6de8:	5da3      	ldrb	r3, [r4, r6]
	if (rl[i].pirk) {
    6dea:	9a01      	ldr	r2, [sp, #4]
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    6dec:	f000 0001 	and.w	r0, r0, #1
    6df0:	f360 03c3 	bfi	r3, r0, #3, #1
	if (rl[i].pirk) {
    6df4:	f013 0f04 	tst.w	r3, #4
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    6df8:	55a3      	strb	r3, [r4, r6]
	if (rl[i].pirk) {
    6dfa:	d136      	bne.n	6e6a <ll_rl_add+0xf6>
	if (rl[i].lirk) {
    6dfc:	b150      	cbz	r0, 6e14 <ll_rl_add+0xa0>
		(void)memcpy(rl[i].local_irk, lirk, IRK_SIZE);
    6dfe:	1df8      	adds	r0, r7, #7
    6e00:	2210      	movs	r2, #16
    6e02:	4659      	mov	r1, fp
    6e04:	4420      	add	r0, r4
    6e06:	f006 fdfe 	bl	da06 <memcpy>
		rl[i].local_rpa = NULL;
    6e0a:	2328      	movs	r3, #40	; 0x28
    6e0c:	fb03 4305 	mla	r3, r3, r5, r4
    6e10:	2200      	movs	r2, #0
    6e12:	625a      	str	r2, [r3, #36]	; 0x24
	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
    6e14:	2628      	movs	r6, #40	; 0x28
    6e16:	436e      	muls	r6, r5
    6e18:	f107 0018 	add.w	r0, r7, #24
    6e1c:	2206      	movs	r2, #6
    6e1e:	2100      	movs	r1, #0
    6e20:	4420      	add	r0, r4
    6e22:	f006 fdfb 	bl	da1c <memset>
	rl[i].rpas_ready = 0U;
    6e26:	5da3      	ldrb	r3, [r4, r6]
    6e28:	f023 0312 	bic.w	r3, r3, #18
    6e2c:	55a3      	strb	r3, [r4, r6]
	j = fal_find(id_addr->type, id_addr->a.val, NULL);
    6e2e:	2200      	movs	r2, #0
    6e30:	f898 0000 	ldrb.w	r0, [r8]
    6e34:	4649      	mov	r1, r9
    6e36:	f7ff fc9b 	bl	6770 <fal_find>
	if (j < ARRAY_SIZE(fal)) {
    6e3a:	2807      	cmp	r0, #7
    6e3c:	5da3      	ldrb	r3, [r4, r6]
		fal[j].rl_idx = i;
    6e3e:	bf9d      	ittte	ls
    6e40:	4a18      	ldrls	r2, [pc, #96]	; (6ea4 <ll_rl_add+0x130>)
		rl[i].fal = 1U;
    6e42:	f043 0320 	orrls.w	r3, r3, #32
		fal[j].rl_idx = i;
    6e46:	eb02 00c0 	addls.w	r0, r2, r0, lsl #3
		rl[i].fal = 0U;
    6e4a:	f36f 1345 	bfchi	r3, #5, #1
    6e4e:	55a3      	strb	r3, [r4, r6]
	rl[i].taken = 1U;
    6e50:	f04f 0328 	mov.w	r3, #40	; 0x28
		fal[j].rl_idx = i;
    6e54:	bf98      	it	ls
    6e56:	7045      	strbls	r5, [r0, #1]
	rl[i].taken = 1U;
    6e58:	435d      	muls	r5, r3
	return 0;
    6e5a:	2000      	movs	r0, #0
	rl[i].taken = 1U;
    6e5c:	5d63      	ldrb	r3, [r4, r5]
    6e5e:	f043 0301 	orr.w	r3, r3, #1
    6e62:	5563      	strb	r3, [r4, r5]
}
    6e64:	b005      	add	sp, #20
    6e66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rl[i].pirk_idx = peer_irk_count;
    6e6a:	4b0f      	ldr	r3, [pc, #60]	; (6ea8 <ll_rl_add+0x134>)
    6e6c:	7819      	ldrb	r1, [r3, #0]
    6e6e:	75d1      	strb	r1, [r2, #23]
		peer_irk_rl_ids[peer_irk_count] = i;
    6e70:	4a0e      	ldr	r2, [pc, #56]	; (6eac <ll_rl_add+0x138>)
    6e72:	5455      	strb	r5, [r2, r1]
		sys_memcpy_swap(peer_irks[peer_irk_count++], pirk, IRK_SIZE);
    6e74:	1c4a      	adds	r2, r1, #1
    6e76:	701a      	strb	r2, [r3, #0]
    6e78:	4b0d      	ldr	r3, [pc, #52]	; (6eb0 <ll_rl_add+0x13c>)
    6e7a:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    6e7e:	f10a 0210 	add.w	r2, sl, #16
    6e82:	3b01      	subs	r3, #1
		*pdst++ = *psrc--;
    6e84:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    6e88:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (; length > 0; length--) {
    6e8c:	4552      	cmp	r2, sl
    6e8e:	d1f9      	bne.n	6e84 <ll_rl_add+0x110>
    6e90:	e7b4      	b.n	6dfc <ll_rl_add+0x88>
		return BT_HCI_ERR_CMD_DISALLOWED;
    6e92:	200c      	movs	r0, #12
    6e94:	e7e6      	b.n	6e64 <ll_rl_add+0xf0>
		return BT_HCI_ERR_INVALID_PARAM;
    6e96:	2012      	movs	r0, #18
    6e98:	e7e4      	b.n	6e64 <ll_rl_add+0xf0>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    6e9a:	2007      	movs	r0, #7
    6e9c:	e7e2      	b.n	6e64 <ll_rl_add+0xf0>
    6e9e:	bf00      	nop
    6ea0:	20001764 	.word	0x20001764
    6ea4:	20001cca 	.word	0x20001cca
    6ea8:	20001d6c 	.word	0x20001d6c
    6eac:	20001d6d 	.word	0x20001d6d
    6eb0:	20001d75 	.word	0x20001d75

00006eb4 <ll_rl_remove>:
{
    6eb4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6eb8:	9001      	str	r0, [sp, #4]
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
    6eba:	2000      	movs	r0, #0
    6ebc:	f007 fb4e 	bl	e55c <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
    6ec0:	4607      	mov	r7, r0
    6ec2:	2800      	cmp	r0, #0
    6ec4:	d15d      	bne.n	6f82 <ll_rl_remove+0xce>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    6ec6:	f8dd 8004 	ldr.w	r8, [sp, #4]
    6eca:	f818 0b01 	ldrb.w	r0, [r8], #1
    6ece:	463a      	mov	r2, r7
    6ed0:	4641      	mov	r1, r8
    6ed2:	f7ff fec5 	bl	6c60 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    6ed6:	2807      	cmp	r0, #7
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    6ed8:	4604      	mov	r4, r0
	if (i < ARRAY_SIZE(rl)) {
    6eda:	d854      	bhi.n	6f86 <ll_rl_remove+0xd2>
		if (rl[i].pirk) {
    6edc:	f04f 0b28 	mov.w	fp, #40	; 0x28
    6ee0:	4e2a      	ldr	r6, [pc, #168]	; (6f8c <ll_rl_remove+0xd8>)
    6ee2:	fb0b f200 	mul.w	r2, fp, r0
    6ee6:	18b1      	adds	r1, r6, r2
    6ee8:	5cb2      	ldrb	r2, [r6, r2]
    6eea:	0753      	lsls	r3, r2, #29
    6eec:	d52c      	bpl.n	6f48 <ll_rl_remove+0x94>
			uint8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
    6eee:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 6f90 <ll_rl_remove+0xdc>
    6ef2:	f89a 5000 	ldrb.w	r5, [sl]
    6ef6:	3d01      	subs	r5, #1
			if (pj && pi != pj) {
    6ef8:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
    6efc:	d01f      	beq.n	6f3e <ll_rl_remove+0x8a>
			uint8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
    6efe:	f891 9017 	ldrb.w	r9, [r1, #23]
			if (pj && pi != pj) {
    6f02:	45a9      	cmp	r9, r5
    6f04:	d01b      	beq.n	6f3e <ll_rl_remove+0x8a>
				(void)memcpy(peer_irks[pi], peer_irks[pj],
    6f06:	4823      	ldr	r0, [pc, #140]	; (6f94 <ll_rl_remove+0xe0>)
    6f08:	2210      	movs	r2, #16
    6f0a:	eb00 1105 	add.w	r1, r0, r5, lsl #4
    6f0e:	eb00 1009 	add.w	r0, r0, r9, lsl #4
    6f12:	f006 fd78 	bl	da06 <memcpy>
				     k < CONFIG_BT_CTLR_RL_SIZE;
    6f16:	4631      	mov	r1, r6
				(void)memcpy(peer_irks[pi], peer_irks[pj],
    6f18:	463a      	mov	r2, r7
					if (rl[k].taken && rl[k].pirk &&
    6f1a:	fb0b f302 	mul.w	r3, fp, r2
    6f1e:	eb06 0c03 	add.w	ip, r6, r3
    6f22:	5cf3      	ldrb	r3, [r6, r3]
    6f24:	07df      	lsls	r7, r3, #31
    6f26:	b2d0      	uxtb	r0, r2
    6f28:	d525      	bpl.n	6f76 <ll_rl_remove+0xc2>
    6f2a:	075b      	lsls	r3, r3, #29
    6f2c:	d523      	bpl.n	6f76 <ll_rl_remove+0xc2>
    6f2e:	7dcb      	ldrb	r3, [r1, #23]
    6f30:	42ab      	cmp	r3, r5
    6f32:	d120      	bne.n	6f76 <ll_rl_remove+0xc2>
						peer_irk_rl_ids[pi] = k;
    6f34:	4b18      	ldr	r3, [pc, #96]	; (6f98 <ll_rl_remove+0xe4>)
						rl[k].pirk_idx = pi;
    6f36:	f88c 9017 	strb.w	r9, [ip, #23]
						peer_irk_rl_ids[pi] = k;
    6f3a:	f803 0009 	strb.w	r0, [r3, r9]
			peer_irk_count--;
    6f3e:	f89a 3000 	ldrb.w	r3, [sl]
    6f42:	3b01      	subs	r3, #1
    6f44:	f88a 3000 	strb.w	r3, [sl]
		j = fal_find(id_addr->type, id_addr->a.val, NULL);
    6f48:	9b01      	ldr	r3, [sp, #4]
    6f4a:	2200      	movs	r2, #0
    6f4c:	7818      	ldrb	r0, [r3, #0]
    6f4e:	4641      	mov	r1, r8
    6f50:	f7ff fc0e 	bl	6770 <fal_find>
		if (j < ARRAY_SIZE(fal)) {
    6f54:	2807      	cmp	r0, #7
			fal[j].rl_idx = FILTER_IDX_NONE;
    6f56:	bf9f      	itttt	ls
    6f58:	4b10      	ldrls	r3, [pc, #64]	; (6f9c <ll_rl_remove+0xe8>)
    6f5a:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
    6f5e:	23ff      	movls	r3, #255	; 0xff
    6f60:	7043      	strbls	r3, [r0, #1]
		rl[i].taken = 0U;
    6f62:	2028      	movs	r0, #40	; 0x28
    6f64:	4360      	muls	r0, r4
    6f66:	5c33      	ldrb	r3, [r6, r0]
    6f68:	f36f 0300 	bfc	r3, #0, #1
    6f6c:	5433      	strb	r3, [r6, r0]
		return 0;
    6f6e:	2000      	movs	r0, #0
}
    6f70:	b003      	add	sp, #12
    6f72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				for (k = 0U;
    6f76:	3201      	adds	r2, #1
    6f78:	2a08      	cmp	r2, #8
    6f7a:	f101 0128 	add.w	r1, r1, #40	; 0x28
    6f7e:	d1cc      	bne.n	6f1a <ll_rl_remove+0x66>
    6f80:	e7dd      	b.n	6f3e <ll_rl_remove+0x8a>
		return BT_HCI_ERR_CMD_DISALLOWED;
    6f82:	200c      	movs	r0, #12
    6f84:	e7f4      	b.n	6f70 <ll_rl_remove+0xbc>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    6f86:	2002      	movs	r0, #2
    6f88:	e7f2      	b.n	6f70 <ll_rl_remove+0xbc>
    6f8a:	bf00      	nop
    6f8c:	20001764 	.word	0x20001764
    6f90:	20001d6c 	.word	0x20001d6c
    6f94:	20001d75 	.word	0x20001d75
    6f98:	20001d6d 	.word	0x20001d6d
    6f9c:	20001cca 	.word	0x20001cca

00006fa0 <ll_rl_crpa_get>:
{
    6fa0:	b538      	push	{r3, r4, r5, lr}
    6fa2:	460d      	mov	r5, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    6fa4:	4601      	mov	r1, r0
    6fa6:	2200      	movs	r2, #0
    6fa8:	f811 0b01 	ldrb.w	r0, [r1], #1
    6fac:	f7ff fe58 	bl	6c60 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl) &&
    6fb0:	2807      	cmp	r0, #7
    6fb2:	d901      	bls.n	6fb8 <ll_rl_crpa_get+0x18>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    6fb4:	2002      	movs	r0, #2
}
    6fb6:	bd38      	pop	{r3, r4, r5, pc}
	    mem_nz(rl[i].curr_rpa.val, sizeof(rl[i].curr_rpa.val))) {
    6fb8:	2428      	movs	r4, #40	; 0x28
    6fba:	2318      	movs	r3, #24
    6fbc:	fb14 3000 	smlabb	r0, r4, r0, r3
    6fc0:	4c07      	ldr	r4, [pc, #28]	; (6fe0 <ll_rl_crpa_get+0x40>)
    6fc2:	4404      	add	r4, r0
    6fc4:	2106      	movs	r1, #6
    6fc6:	4620      	mov	r0, r4
    6fc8:	f006 ff3f 	bl	de4a <mem_nz>
	if (i < ARRAY_SIZE(rl) &&
    6fcc:	2800      	cmp	r0, #0
    6fce:	d0f1      	beq.n	6fb4 <ll_rl_crpa_get+0x14>
    6fd0:	2206      	movs	r2, #6
    6fd2:	4621      	mov	r1, r4
    6fd4:	4628      	mov	r0, r5
    6fd6:	f006 fd16 	bl	da06 <memcpy>
		return 0;
    6fda:	2000      	movs	r0, #0
}
    6fdc:	e7eb      	b.n	6fb6 <ll_rl_crpa_get+0x16>
    6fde:	bf00      	nop
    6fe0:	20001764 	.word	0x20001764

00006fe4 <ll_rl_lrpa_get>:
{
    6fe4:	b510      	push	{r4, lr}
    6fe6:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    6fe8:	4601      	mov	r1, r0
    6fea:	2200      	movs	r2, #0
    6fec:	f811 0b01 	ldrb.w	r0, [r1], #1
    6ff0:	f7ff fe36 	bl	6c60 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    6ff4:	2807      	cmp	r0, #7
    6ff6:	d80a      	bhi.n	700e <ll_rl_lrpa_get+0x2a>
		bt_addr_copy(lrpa, rl[i].local_rpa);
    6ff8:	4b06      	ldr	r3, [pc, #24]	; (7014 <ll_rl_lrpa_get+0x30>)
    6ffa:	2228      	movs	r2, #40	; 0x28
    6ffc:	fb02 3000 	mla	r0, r2, r0, r3
	memcpy(dst, src, sizeof(*dst));
    7000:	2206      	movs	r2, #6
    7002:	6a41      	ldr	r1, [r0, #36]	; 0x24
    7004:	4620      	mov	r0, r4
    7006:	f006 fcfe 	bl	da06 <memcpy>
		return 0;
    700a:	2000      	movs	r0, #0
}
    700c:	bd10      	pop	{r4, pc}
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    700e:	2002      	movs	r0, #2
    7010:	e7fc      	b.n	700c <ll_rl_lrpa_get+0x28>
    7012:	bf00      	nop
    7014:	20001764 	.word	0x20001764

00007018 <ll_priv_mode_set>:
{
    7018:	b570      	push	{r4, r5, r6, lr}
    701a:	4605      	mov	r5, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
    701c:	2000      	movs	r0, #0
{
    701e:	460c      	mov	r4, r1
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
    7020:	f007 fa9c 	bl	e55c <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
    7024:	4606      	mov	r6, r0
    7026:	b9f0      	cbnz	r0, 7066 <ll_priv_mode_set+0x4e>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    7028:	4629      	mov	r1, r5
    702a:	4632      	mov	r2, r6
    702c:	f811 0b01 	ldrb.w	r0, [r1], #1
    7030:	f7ff fe16 	bl	6c60 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    7034:	2807      	cmp	r0, #7
    7036:	d818      	bhi.n	706a <ll_priv_mode_set+0x52>
		switch (mode) {
    7038:	b124      	cbz	r4, 7044 <ll_priv_mode_set+0x2c>
    703a:	2c01      	cmp	r4, #1
    703c:	d00a      	beq.n	7054 <ll_priv_mode_set+0x3c>
    703e:	2412      	movs	r4, #18
}
    7040:	4620      	mov	r0, r4
    7042:	bd70      	pop	{r4, r5, r6, pc}
			rl[i].dev = 0U;
    7044:	2228      	movs	r2, #40	; 0x28
    7046:	4b0a      	ldr	r3, [pc, #40]	; (7070 <ll_priv_mode_set+0x58>)
    7048:	4350      	muls	r0, r2
    704a:	5c1a      	ldrb	r2, [r3, r0]
    704c:	f364 1204 	bfi	r2, r4, #4, #1
    7050:	541a      	strb	r2, [r3, r0]
			break;
    7052:	e7f5      	b.n	7040 <ll_priv_mode_set+0x28>
			rl[i].dev = 1U;
    7054:	2328      	movs	r3, #40	; 0x28
    7056:	4906      	ldr	r1, [pc, #24]	; (7070 <ll_priv_mode_set+0x58>)
    7058:	4343      	muls	r3, r0
	return 0;
    705a:	4634      	mov	r4, r6
			rl[i].dev = 1U;
    705c:	5cca      	ldrb	r2, [r1, r3]
    705e:	f042 0210 	orr.w	r2, r2, #16
    7062:	54ca      	strb	r2, [r1, r3]
			break;
    7064:	e7ec      	b.n	7040 <ll_priv_mode_set+0x28>
		return BT_HCI_ERR_CMD_DISALLOWED;
    7066:	240c      	movs	r4, #12
    7068:	e7ea      	b.n	7040 <ll_priv_mode_set+0x28>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
    706a:	2402      	movs	r4, #2
    706c:	e7e8      	b.n	7040 <ll_priv_mode_set+0x28>
    706e:	bf00      	nop
    7070:	20001764 	.word	0x20001764

00007074 <ull_filter_lll_irks_get>:
	*count = peer_irk_count;
    7074:	4b02      	ldr	r3, [pc, #8]	; (7080 <ull_filter_lll_irks_get+0xc>)
    7076:	781b      	ldrb	r3, [r3, #0]
    7078:	7003      	strb	r3, [r0, #0]
}
    707a:	4802      	ldr	r0, [pc, #8]	; (7084 <ull_filter_lll_irks_get+0x10>)
    707c:	4770      	bx	lr
    707e:	bf00      	nop
    7080:	20001d6c 	.word	0x20001d6c
    7084:	20001d75 	.word	0x20001d75

00007088 <ull_filter_lll_rl_irk_idx>:
{
    7088:	b510      	push	{r4, lr}
	LL_ASSERT(irkmatch_id < peer_irk_count);
    708a:	4b1c      	ldr	r3, [pc, #112]	; (70fc <ull_filter_lll_rl_irk_idx+0x74>)
    708c:	781b      	ldrb	r3, [r3, #0]
    708e:	4283      	cmp	r3, r0
{
    7090:	4604      	mov	r4, r0
	LL_ASSERT(irkmatch_id < peer_irk_count);
    7092:	d80c      	bhi.n	70ae <ull_filter_lll_rl_irk_idx+0x26>
    7094:	4a1a      	ldr	r2, [pc, #104]	; (7100 <ull_filter_lll_rl_irk_idx+0x78>)
    7096:	491b      	ldr	r1, [pc, #108]	; (7104 <ull_filter_lll_rl_irk_idx+0x7c>)
    7098:	481b      	ldr	r0, [pc, #108]	; (7108 <ull_filter_lll_rl_irk_idx+0x80>)
    709a:	f240 336d 	movw	r3, #877	; 0x36d
    709e:	f005 feae 	bl	cdfe <printk>
    70a2:	4040      	eors	r0, r0
    70a4:	f380 8811 	msr	BASEPRI, r0
    70a8:	f04f 0003 	mov.w	r0, #3
    70ac:	df02      	svc	2
	i = peer_irk_rl_ids[irkmatch_id];
    70ae:	4b17      	ldr	r3, [pc, #92]	; (710c <ull_filter_lll_rl_irk_idx+0x84>)
    70b0:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
    70b2:	2c07      	cmp	r4, #7
    70b4:	d90c      	bls.n	70d0 <ull_filter_lll_rl_irk_idx+0x48>
    70b6:	4a12      	ldr	r2, [pc, #72]	; (7100 <ull_filter_lll_rl_irk_idx+0x78>)
    70b8:	4915      	ldr	r1, [pc, #84]	; (7110 <ull_filter_lll_rl_irk_idx+0x88>)
    70ba:	4813      	ldr	r0, [pc, #76]	; (7108 <ull_filter_lll_rl_irk_idx+0x80>)
    70bc:	f240 336f 	movw	r3, #879	; 0x36f
    70c0:	f005 fe9d 	bl	cdfe <printk>
    70c4:	4040      	eors	r0, r0
    70c6:	f380 8811 	msr	BASEPRI, r0
    70ca:	f04f 0003 	mov.w	r0, #3
    70ce:	df02      	svc	2
	LL_ASSERT(rl[i].taken);
    70d0:	2328      	movs	r3, #40	; 0x28
    70d2:	4a10      	ldr	r2, [pc, #64]	; (7114 <ull_filter_lll_rl_irk_idx+0x8c>)
    70d4:	4363      	muls	r3, r4
    70d6:	5cd3      	ldrb	r3, [r2, r3]
    70d8:	07db      	lsls	r3, r3, #31
    70da:	d40c      	bmi.n	70f6 <ull_filter_lll_rl_irk_idx+0x6e>
    70dc:	4a08      	ldr	r2, [pc, #32]	; (7100 <ull_filter_lll_rl_irk_idx+0x78>)
    70de:	490e      	ldr	r1, [pc, #56]	; (7118 <ull_filter_lll_rl_irk_idx+0x90>)
    70e0:	4809      	ldr	r0, [pc, #36]	; (7108 <ull_filter_lll_rl_irk_idx+0x80>)
    70e2:	f44f 735c 	mov.w	r3, #880	; 0x370
    70e6:	f005 fe8a 	bl	cdfe <printk>
    70ea:	4040      	eors	r0, r0
    70ec:	f380 8811 	msr	BASEPRI, r0
    70f0:	f04f 0003 	mov.w	r0, #3
    70f4:	df02      	svc	2
}
    70f6:	4620      	mov	r0, r4
    70f8:	bd10      	pop	{r4, pc}
    70fa:	bf00      	nop
    70fc:	20001d6c 	.word	0x20001d6c
    7100:	000117b3 	.word	0x000117b3
    7104:	00011994 	.word	0x00011994
    7108:	00010f78 	.word	0x00010f78
    710c:	20001d6d 	.word	0x20001d6d
    7110:	000119b1 	.word	0x000119b1
    7114:	20001764 	.word	0x20001764
    7118:	00011988 	.word	0x00011988

0000711c <ull_filter_lll_irk_in_fal>:
	if (rl_idx >= ARRAY_SIZE(rl)) {
    711c:	2807      	cmp	r0, #7
{
    711e:	b538      	push	{r3, r4, r5, lr}
    7120:	4604      	mov	r4, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
    7122:	d818      	bhi.n	7156 <ull_filter_lll_irk_in_fal+0x3a>
	LL_ASSERT(rl[rl_idx].taken);
    7124:	2328      	movs	r3, #40	; 0x28
    7126:	4d0d      	ldr	r5, [pc, #52]	; (715c <ull_filter_lll_irk_in_fal+0x40>)
    7128:	4343      	muls	r3, r0
    712a:	5ceb      	ldrb	r3, [r5, r3]
    712c:	07db      	lsls	r3, r3, #31
    712e:	d40c      	bmi.n	714a <ull_filter_lll_irk_in_fal+0x2e>
    7130:	4a0b      	ldr	r2, [pc, #44]	; (7160 <ull_filter_lll_irk_in_fal+0x44>)
    7132:	490c      	ldr	r1, [pc, #48]	; (7164 <ull_filter_lll_irk_in_fal+0x48>)
    7134:	480c      	ldr	r0, [pc, #48]	; (7168 <ull_filter_lll_irk_in_fal+0x4c>)
    7136:	f240 337b 	movw	r3, #891	; 0x37b
    713a:	f005 fe60 	bl	cdfe <printk>
    713e:	4040      	eors	r0, r0
    7140:	f380 8811 	msr	BASEPRI, r0
    7144:	f04f 0003 	mov.w	r0, #3
    7148:	df02      	svc	2
	return rl[rl_idx].fal;
    714a:	2028      	movs	r0, #40	; 0x28
    714c:	4344      	muls	r4, r0
    714e:	5d28      	ldrb	r0, [r5, r4]
    7150:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
    7154:	bd38      	pop	{r3, r4, r5, pc}
		return false;
    7156:	2000      	movs	r0, #0
    7158:	e7fc      	b.n	7154 <ull_filter_lll_irk_in_fal+0x38>
    715a:	bf00      	nop
    715c:	20001764 	.word	0x20001764
    7160:	000117b3 	.word	0x000117b3
    7164:	00011800 	.word	0x00011800
    7168:	00010f78 	.word	0x00010f78

0000716c <ull_filter_lll_rl_addr_allowed>:
{
    716c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (*rl_idx != FILTER_IDX_NONE) {
    7170:	7813      	ldrb	r3, [r2, #0]
    7172:	2bff      	cmp	r3, #255	; 0xff
    7174:	d12b      	bne.n	71ce <ull_filter_lll_rl_addr_allowed+0x62>
    7176:	4c17      	ldr	r4, [pc, #92]	; (71d4 <ull_filter_lll_rl_addr_allowed+0x68>)
    7178:	2300      	movs	r3, #0
    717a:	4626      	mov	r6, r4
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
    717c:	f04f 0e28 	mov.w	lr, #40	; 0x28
    7180:	fb0e f503 	mul.w	r5, lr, r3
    7184:	fa5f fc83 	uxtb.w	ip, r3
    7188:	5d75      	ldrb	r5, [r6, r5]
    718a:	07ef      	lsls	r7, r5, #31
    718c:	d51a      	bpl.n	71c4 <ull_filter_lll_rl_addr_allowed+0x58>
    718e:	f3c5 1580 	ubfx	r5, r5, #6, #1
    7192:	4285      	cmp	r5, r0
    7194:	d116      	bne.n	71c4 <ull_filter_lll_rl_addr_allowed+0x58>
			for (j = 0U; j < BDADDR_SIZE; j++) {
    7196:	1e4f      	subs	r7, r1, #1
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
    7198:	4625      	mov	r5, r4
			for (j = 0U; j < BDADDR_SIZE; j++) {
    719a:	f104 0806 	add.w	r8, r4, #6
				if (addr[j] != id_addr[j]) {
    719e:	f815 af01 	ldrb.w	sl, [r5, #1]!
    71a2:	f817 9f01 	ldrb.w	r9, [r7, #1]!
    71a6:	45ca      	cmp	sl, r9
    71a8:	d10c      	bne.n	71c4 <ull_filter_lll_rl_addr_allowed+0x58>
			for (j = 0U; j < BDADDR_SIZE; j++) {
    71aa:	4545      	cmp	r5, r8
    71ac:	d1f7      	bne.n	719e <ull_filter_lll_rl_addr_allowed+0x32>
				*rl_idx = i;
    71ae:	f882 c000 	strb.w	ip, [r2]
				return !rl[i].pirk || rl[i].dev;
    71b2:	2228      	movs	r2, #40	; 0x28
    71b4:	4353      	muls	r3, r2
    71b6:	5cf0      	ldrb	r0, [r6, r3]
    71b8:	0743      	lsls	r3, r0, #29
    71ba:	d508      	bpl.n	71ce <ull_filter_lll_rl_addr_allowed+0x62>
    71bc:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
    71c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    71c4:	3301      	adds	r3, #1
    71c6:	2b08      	cmp	r3, #8
    71c8:	f104 0428 	add.w	r4, r4, #40	; 0x28
    71cc:	d1d8      	bne.n	7180 <ull_filter_lll_rl_addr_allowed+0x14>
				return !rl[i].pirk || rl[i].dev;
    71ce:	2001      	movs	r0, #1
    71d0:	e7f6      	b.n	71c0 <ull_filter_lll_rl_addr_allowed+0x54>
    71d2:	bf00      	nop
    71d4:	20001764 	.word	0x20001764

000071d8 <ull_filter_lll_rl_enabled>:
	return rl_enable;
    71d8:	4b02      	ldr	r3, [pc, #8]	; (71e4 <ull_filter_lll_rl_enabled+0xc>)
    71da:	7818      	ldrb	r0, [r3, #0]
}
    71dc:	3800      	subs	r0, #0
    71de:	bf18      	it	ne
    71e0:	2001      	movne	r0, #1
    71e2:	4770      	bx	lr
    71e4:	20001df5 	.word	0x20001df5

000071e8 <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(const void *arg)
{
    71e8:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	lll_prof_enter_ull_high();

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
    71ea:	4b08      	ldr	r3, [pc, #32]	; (720c <rtc0_nrf5_isr+0x24>)
    71ec:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
    71f0:	b122      	cbz	r2, 71fc <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
    71f2:	2000      	movs	r0, #0
    71f4:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
    71f8:	f7fd fe82 	bl	4f00 <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
    71fc:	2001      	movs	r0, #1
    71fe:	f7fd f9c3 	bl	4588 <mayfly_run>

	lll_prof_exit_ull_low();
#endif

	DEBUG_TICKER_ISR(0);
}
    7202:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
    7206:	2002      	movs	r0, #2
    7208:	f7fd b9be 	b.w	4588 <mayfly_run>
    720c:	4000b000 	.word	0x4000b000

00007210 <ticker_stop_op_cb>:
static uint8_t preempt_stop_ack;
static uint8_t preempt_req;
static uint8_t volatile preempt_ack;

static void ticker_stop_op_cb(uint32_t status, void *param)
{
    7210:	b510      	push	{r4, lr}
	ARG_UNUSED(param);
	ARG_UNUSED(status);

	LL_ASSERT(preempt_stop_req != preempt_stop_ack);
    7212:	4b0d      	ldr	r3, [pc, #52]	; (7248 <ticker_stop_op_cb+0x38>)
    7214:	4c0d      	ldr	r4, [pc, #52]	; (724c <ticker_stop_op_cb+0x3c>)
    7216:	781b      	ldrb	r3, [r3, #0]
    7218:	7822      	ldrb	r2, [r4, #0]
    721a:	429a      	cmp	r2, r3
    721c:	d10c      	bne.n	7238 <ticker_stop_op_cb+0x28>
    721e:	4a0c      	ldr	r2, [pc, #48]	; (7250 <ticker_stop_op_cb+0x40>)
    7220:	490c      	ldr	r1, [pc, #48]	; (7254 <ticker_stop_op_cb+0x44>)
    7222:	480d      	ldr	r0, [pc, #52]	; (7258 <ticker_stop_op_cb+0x48>)
    7224:	f44f 733e 	mov.w	r3, #760	; 0x2f8
    7228:	f005 fde9 	bl	cdfe <printk>
    722c:	4040      	eors	r0, r0
    722e:	f380 8811 	msr	BASEPRI, r0
    7232:	f04f 0003 	mov.w	r0, #3
    7236:	df02      	svc	2
	preempt_stop_ack++;
    7238:	7823      	ldrb	r3, [r4, #0]
    723a:	3301      	adds	r3, #1
    723c:	7023      	strb	r3, [r4, #0]

	preempt_req = preempt_ack;
    723e:	4b07      	ldr	r3, [pc, #28]	; (725c <ticker_stop_op_cb+0x4c>)
    7240:	781a      	ldrb	r2, [r3, #0]
    7242:	4b07      	ldr	r3, [pc, #28]	; (7260 <ticker_stop_op_cb+0x50>)
    7244:	701a      	strb	r2, [r3, #0]
}
    7246:	bd10      	pop	{r4, pc}
    7248:	20001e2d 	.word	0x20001e2d
    724c:	20001e2c 	.word	0x20001e2c
    7250:	000119ca 	.word	0x000119ca
    7254:	00011a10 	.word	0x00011a10
    7258:	00010f78 	.word	0x00010f78
    725c:	20001e28 	.word	0x20001e28
    7260:	20001e29 	.word	0x20001e29

00007264 <ticker_start_op_cb>:

static void ticker_start_op_cb(uint32_t status, void *param)
{
    7264:	b510      	push	{r4, lr}
	ARG_UNUSED(param);
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
    7266:	b160      	cbz	r0, 7282 <ticker_start_op_cb+0x1e>
    7268:	4a1c      	ldr	r2, [pc, #112]	; (72dc <ticker_start_op_cb+0x78>)
    726a:	491d      	ldr	r1, [pc, #116]	; (72e0 <ticker_start_op_cb+0x7c>)
    726c:	481d      	ldr	r0, [pc, #116]	; (72e4 <ticker_start_op_cb+0x80>)
    726e:	f240 3301 	movw	r3, #769	; 0x301
    7272:	f005 fdc4 	bl	cdfe <printk>
    7276:	4040      	eors	r0, r0
    7278:	f380 8811 	msr	BASEPRI, r0
    727c:	f04f 0003 	mov.w	r0, #3
    7280:	df02      	svc	2

	LL_ASSERT(preempt_start_req != preempt_start_ack);
    7282:	4b19      	ldr	r3, [pc, #100]	; (72e8 <ticker_start_op_cb+0x84>)
    7284:	4c19      	ldr	r4, [pc, #100]	; (72ec <ticker_start_op_cb+0x88>)
    7286:	781b      	ldrb	r3, [r3, #0]
    7288:	7822      	ldrb	r2, [r4, #0]
    728a:	429a      	cmp	r2, r3
    728c:	d10c      	bne.n	72a8 <ticker_start_op_cb+0x44>
    728e:	4a13      	ldr	r2, [pc, #76]	; (72dc <ticker_start_op_cb+0x78>)
    7290:	4917      	ldr	r1, [pc, #92]	; (72f0 <ticker_start_op_cb+0x8c>)
    7292:	4814      	ldr	r0, [pc, #80]	; (72e4 <ticker_start_op_cb+0x80>)
    7294:	f240 3303 	movw	r3, #771	; 0x303
    7298:	f005 fdb1 	bl	cdfe <printk>
    729c:	4040      	eors	r0, r0
    729e:	f380 8811 	msr	BASEPRI, r0
    72a2:	f04f 0003 	mov.w	r0, #3
    72a6:	df02      	svc	2
	preempt_start_ack++;
    72a8:	7823      	ldrb	r3, [r4, #0]
    72aa:	3301      	adds	r3, #1
    72ac:	7023      	strb	r3, [r4, #0]

	LL_ASSERT(preempt_req == preempt_ack);
    72ae:	4b11      	ldr	r3, [pc, #68]	; (72f4 <ticker_start_op_cb+0x90>)
    72b0:	4c11      	ldr	r4, [pc, #68]	; (72f8 <ticker_start_op_cb+0x94>)
    72b2:	781b      	ldrb	r3, [r3, #0]
    72b4:	7822      	ldrb	r2, [r4, #0]
    72b6:	429a      	cmp	r2, r3
    72b8:	d00c      	beq.n	72d4 <ticker_start_op_cb+0x70>
    72ba:	4a08      	ldr	r2, [pc, #32]	; (72dc <ticker_start_op_cb+0x78>)
    72bc:	490f      	ldr	r1, [pc, #60]	; (72fc <ticker_start_op_cb+0x98>)
    72be:	4809      	ldr	r0, [pc, #36]	; (72e4 <ticker_start_op_cb+0x80>)
    72c0:	f240 3306 	movw	r3, #774	; 0x306
    72c4:	f005 fd9b 	bl	cdfe <printk>
    72c8:	4040      	eors	r0, r0
    72ca:	f380 8811 	msr	BASEPRI, r0
    72ce:	f04f 0003 	mov.w	r0, #3
    72d2:	df02      	svc	2
	preempt_req++;
    72d4:	7823      	ldrb	r3, [r4, #0]
    72d6:	3301      	adds	r3, #1
    72d8:	7023      	strb	r3, [r4, #0]
}
    72da:	bd10      	pop	{r4, pc}
    72dc:	000119ca 	.word	0x000119ca
    72e0:	00011a35 	.word	0x00011a35
    72e4:	00010f78 	.word	0x00010f78
    72e8:	20001e2b 	.word	0x20001e2b
    72ec:	20001e2a 	.word	0x20001e2a
    72f0:	00011a41 	.word	0x00011a41
    72f4:	20001e28 	.word	0x20001e28
    72f8:	20001e29 	.word	0x20001e29
    72fc:	00011a68 	.word	0x00011a68

00007300 <preempt_ticker_cb>:
}

static void preempt_ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
			      uint32_t remainder, uint16_t lazy, uint8_t force,
			      void *param)
{
    7300:	b510      	push	{r4, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, preempt};
	uint32_t ret;

	LL_ASSERT(preempt_ack != preempt_req);
    7302:	4a17      	ldr	r2, [pc, #92]	; (7360 <preempt_ticker_cb+0x60>)
    7304:	4c17      	ldr	r4, [pc, #92]	; (7364 <preempt_ticker_cb+0x64>)
    7306:	7812      	ldrb	r2, [r2, #0]
    7308:	7823      	ldrb	r3, [r4, #0]
    730a:	429a      	cmp	r2, r3
    730c:	d10c      	bne.n	7328 <preempt_ticker_cb+0x28>
    730e:	4a16      	ldr	r2, [pc, #88]	; (7368 <preempt_ticker_cb+0x68>)
    7310:	4916      	ldr	r1, [pc, #88]	; (736c <preempt_ticker_cb+0x6c>)
    7312:	4817      	ldr	r0, [pc, #92]	; (7370 <preempt_ticker_cb+0x70>)
    7314:	f240 3367 	movw	r3, #871	; 0x367
    7318:	f005 fd71 	bl	cdfe <printk>
    731c:	4040      	eors	r0, r0
    731e:	f380 8811 	msr	BASEPRI, r0
    7322:	f04f 0003 	mov.w	r0, #3
    7326:	df02      	svc	2
	preempt_ack++;
    7328:	7823      	ldrb	r3, [r4, #0]

	mfy.param = param;
    732a:	9a03      	ldr	r2, [sp, #12]
	preempt_ack++;
    732c:	3301      	adds	r3, #1
    732e:	b2db      	uxtb	r3, r3
    7330:	7023      	strb	r3, [r4, #0]
	mfy.param = param;
    7332:	4b10      	ldr	r3, [pc, #64]	; (7374 <preempt_ticker_cb+0x74>)
    7334:	609a      	str	r2, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    7336:	2200      	movs	r2, #0
    7338:	4611      	mov	r1, r2
    733a:	2001      	movs	r0, #1
    733c:	f7fd f8d4 	bl	44e8 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    7340:	b160      	cbz	r0, 735c <preempt_ticker_cb+0x5c>
    7342:	4a09      	ldr	r2, [pc, #36]	; (7368 <preempt_ticker_cb+0x68>)
    7344:	490c      	ldr	r1, [pc, #48]	; (7378 <preempt_ticker_cb+0x78>)
    7346:	480a      	ldr	r0, [pc, #40]	; (7370 <preempt_ticker_cb+0x70>)
    7348:	f240 336d 	movw	r3, #877	; 0x36d
    734c:	f005 fd57 	bl	cdfe <printk>
    7350:	4040      	eors	r0, r0
    7352:	f380 8811 	msr	BASEPRI, r0
    7356:	f04f 0003 	mov.w	r0, #3
    735a:	df02      	svc	2
}
    735c:	bd10      	pop	{r4, pc}
    735e:	bf00      	nop
    7360:	20001e29 	.word	0x20001e29
    7364:	20001e28 	.word	0x20001e28
    7368:	000119ca 	.word	0x000119ca
    736c:	00011a83 	.word	0x00011a83
    7370:	00010f78 	.word	0x00010f78
    7374:	20000364 	.word	0x20000364
    7378:	00011648 	.word	0x00011648

0000737c <preempt_ticker_stop>:
{
    737c:	b513      	push	{r0, r1, r4, lr}
	if ((preempt_stop_req != preempt_stop_ack) ||
    737e:	4a17      	ldr	r2, [pc, #92]	; (73dc <preempt_ticker_stop+0x60>)
    7380:	4917      	ldr	r1, [pc, #92]	; (73e0 <preempt_ticker_stop+0x64>)
    7382:	7813      	ldrb	r3, [r2, #0]
    7384:	7809      	ldrb	r1, [r1, #0]
    7386:	4299      	cmp	r1, r3
    7388:	d003      	beq.n	7392 <preempt_ticker_stop+0x16>
		return TICKER_STATUS_SUCCESS;
    738a:	2400      	movs	r4, #0
}
    738c:	4620      	mov	r0, r4
    738e:	b002      	add	sp, #8
    7390:	bd10      	pop	{r4, pc}
	    (preempt_req == preempt_ack)) {
    7392:	4b14      	ldr	r3, [pc, #80]	; (73e4 <preempt_ticker_stop+0x68>)
    7394:	4914      	ldr	r1, [pc, #80]	; (73e8 <preempt_ticker_stop+0x6c>)
    7396:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_stop_req != preempt_stop_ack) ||
    7398:	7809      	ldrb	r1, [r1, #0]
    739a:	4299      	cmp	r1, r3
    739c:	d0f5      	beq.n	738a <preempt_ticker_stop+0xe>
	preempt_stop_req++;
    739e:	7813      	ldrb	r3, [r2, #0]
    73a0:	3301      	adds	r3, #1
    73a2:	b2db      	uxtb	r3, r3
    73a4:	7013      	strb	r3, [r2, #0]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    73a6:	2200      	movs	r2, #0
    73a8:	4b10      	ldr	r3, [pc, #64]	; (73ec <preempt_ticker_stop+0x70>)
    73aa:	9200      	str	r2, [sp, #0]
    73ac:	4611      	mov	r1, r2
    73ae:	4610      	mov	r0, r2
    73b0:	f7fd fe52 	bl	5058 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    73b4:	4604      	mov	r4, r0
    73b6:	2800      	cmp	r0, #0
    73b8:	d0e7      	beq.n	738a <preempt_ticker_stop+0xe>
    73ba:	2802      	cmp	r0, #2
    73bc:	d0e6      	beq.n	738c <preempt_ticker_stop+0x10>
    73be:	4a0c      	ldr	r2, [pc, #48]	; (73f0 <preempt_ticker_stop+0x74>)
    73c0:	490c      	ldr	r1, [pc, #48]	; (73f4 <preempt_ticker_stop+0x78>)
    73c2:	480d      	ldr	r0, [pc, #52]	; (73f8 <preempt_ticker_stop+0x7c>)
    73c4:	f240 3359 	movw	r3, #857	; 0x359
    73c8:	f005 fd19 	bl	cdfe <printk>
    73cc:	4040      	eors	r0, r0
    73ce:	f380 8811 	msr	BASEPRI, r0
    73d2:	f04f 0003 	mov.w	r0, #3
    73d6:	df02      	svc	2
    73d8:	e7d8      	b.n	738c <preempt_ticker_stop+0x10>
    73da:	bf00      	nop
    73dc:	20001e2d 	.word	0x20001e2d
    73e0:	20001e2c 	.word	0x20001e2c
    73e4:	20001e28 	.word	0x20001e28
    73e8:	20001e29 	.word	0x20001e29
    73ec:	00007211 	.word	0x00007211
    73f0:	000119ca 	.word	0x000119ca
    73f4:	0001177e 	.word	0x0001177e
    73f8:	00010f78 	.word	0x00010f78

000073fc <preempt_ticker_start>:
	ull = HDR_LLL2ULL(p->param);
    73fc:	68cb      	ldr	r3, [r1, #12]
    73fe:	681b      	ldr	r3, [r3, #0]
{
    7400:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	preempt_anchor = p->ticks_at_expire;
    7404:	f8d1 8000 	ldr.w	r8, [r1]
	preempt_to = MAX(ull->ticks_active_to_start,
    7408:	68de      	ldr	r6, [r3, #12]
	if ((preempt_start_req != preempt_start_ack) ||
    740a:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 74b0 <preempt_ticker_start+0xb4>
{
    740e:	460d      	mov	r5, r1
	preempt_to = MAX(ull->ticks_active_to_start,
    7410:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    7414:	4291      	cmp	r1, r2
    7416:	bf2c      	ite	cs
    7418:	ebc6 0601 	rsbcs	r6, r6, r1
    741c:	ebc6 0602 	rsbcc	r6, r6, r2
	if ((preempt_start_req != preempt_start_ack) ||
    7420:	4a24      	ldr	r2, [pc, #144]	; (74b4 <preempt_ticker_start+0xb8>)
    7422:	f899 3000 	ldrb.w	r3, [r9]
    7426:	7812      	ldrb	r2, [r2, #0]
    7428:	429a      	cmp	r2, r3
{
    742a:	b08a      	sub	sp, #40	; 0x28
    742c:	4604      	mov	r4, r0
	ticks_at_preempt_new = preempt_anchor + preempt_to;
    742e:	eb08 0706 	add.w	r7, r8, r6
	if ((preempt_start_req != preempt_start_ack) ||
    7432:	d105      	bne.n	7440 <preempt_ticker_start+0x44>
	    (preempt_req != preempt_ack)) {
    7434:	4b20      	ldr	r3, [pc, #128]	; (74b8 <preempt_ticker_start+0xbc>)
    7436:	4a21      	ldr	r2, [pc, #132]	; (74bc <preempt_ticker_start+0xc0>)
    7438:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_start_req != preempt_start_ack) ||
    743a:	7812      	ldrb	r2, [r2, #0]
    743c:	429a      	cmp	r2, r3
    743e:	d018      	beq.n	7472 <preempt_ticker_start+0x76>
		if (!prev || prev->is_aborted ||
    7440:	2c00      	cmp	r4, #0
    7442:	d032      	beq.n	74aa <preempt_ticker_start+0xae>
    7444:	7f23      	ldrb	r3, [r4, #28]
    7446:	079b      	lsls	r3, r3, #30
    7448:	d42f      	bmi.n	74aa <preempt_ticker_start+0xae>
		diff = ticks_at_preempt_new - ticks_at_preempt;
    744a:	f8df a074 	ldr.w	sl, [pc, #116]	; 74c0 <preempt_ticker_start+0xc4>
    744e:	f8da 2000 	ldr.w	r2, [sl]
    7452:	1aba      	subs	r2, r7, r2
		if (!prev || prev->is_aborted ||
    7454:	f412 0000 	ands.w	r0, r2, #8388608	; 0x800000
    7458:	d024      	beq.n	74a4 <preempt_ticker_start+0xa8>
		preempt_ticker_stop();
    745a:	f7ff ff8f 	bl	737c <preempt_ticker_stop>
		prev->is_aborted = 1U;
    745e:	7f23      	ldrb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
    7460:	68e1      	ldr	r1, [r4, #12]
		ticks_at_preempt = ticks_at_preempt_new;
    7462:	f8ca 7000 	str.w	r7, [sl]
		prev->is_aborted = 1U;
    7466:	f043 0302 	orr.w	r3, r3, #2
    746a:	7723      	strb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
    746c:	4620      	mov	r0, r4
    746e:	69a3      	ldr	r3, [r4, #24]
    7470:	4798      	blx	r3
	preempt_start_req++;
    7472:	f899 2000 	ldrb.w	r2, [r9]
	ticks_at_preempt = ticks_at_preempt_new;
    7476:	4b12      	ldr	r3, [pc, #72]	; (74c0 <preempt_ticker_start+0xc4>)
	preempt_start_req++;
    7478:	3201      	adds	r2, #1
	ticks_at_preempt = ticks_at_preempt_new;
    747a:	601f      	str	r7, [r3, #0]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    747c:	4b11      	ldr	r3, [pc, #68]	; (74c4 <preempt_ticker_start+0xc8>)
    747e:	9508      	str	r5, [sp, #32]
	preempt_start_req++;
    7480:	b2d2      	uxtb	r2, r2
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    7482:	e9cd 5306 	strd	r5, r3, [sp, #24]
	preempt_start_req++;
    7486:	f889 2000 	strb.w	r2, [r9]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    748a:	4b0f      	ldr	r3, [pc, #60]	; (74c8 <preempt_ticker_start+0xcc>)
    748c:	9305      	str	r3, [sp, #20]
    748e:	2200      	movs	r2, #0
    7490:	e9cd 2203 	strd	r2, r2, [sp, #12]
    7494:	e9cd 2201 	strd	r2, r2, [sp, #4]
    7498:	9600      	str	r6, [sp, #0]
    749a:	4643      	mov	r3, r8
    749c:	4611      	mov	r1, r2
    749e:	4610      	mov	r0, r2
    74a0:	f006 ff74 	bl	e38c <ticker_start>
}
    74a4:	b00a      	add	sp, #40	; 0x28
    74a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return TICKER_STATUS_SUCCESS;
    74aa:	2000      	movs	r0, #0
    74ac:	e7fa      	b.n	74a4 <preempt_ticker_start+0xa8>
    74ae:	bf00      	nop
    74b0:	20001e2b 	.word	0x20001e2b
    74b4:	20001e2a 	.word	0x20001e2a
    74b8:	20001e28 	.word	0x20001e28
    74bc:	20001e29 	.word	0x20001e29
    74c0:	200018c0 	.word	0x200018c0
    74c4:	00007265 	.word	0x00007265
    74c8:	00007301 	.word	0x00007301

000074cc <preempt>:

static void preempt(void *param)
{
    74cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_event *next;
	uint8_t idx;
	int err;

	/* No event to abort */
	if (!event.curr.abort_cb || !event.curr.param) {
    74ce:	4c3a      	ldr	r4, [pc, #232]	; (75b8 <preempt+0xec>)
    74d0:	68a3      	ldr	r3, [r4, #8]
{
    74d2:	b089      	sub	sp, #36	; 0x24
    74d4:	4605      	mov	r5, r0
	if (!event.curr.abort_cb || !event.curr.param) {
    74d6:	2b00      	cmp	r3, #0
    74d8:	d034      	beq.n	7544 <preempt+0x78>
    74da:	6823      	ldr	r3, [r4, #0]
    74dc:	2b00      	cmp	r3, #0
    74de:	d031      	beq.n	7544 <preempt+0x78>
		return;
	}

	/* Check if any prepare in pipeline */
	idx = UINT8_MAX;
    74e0:	23ff      	movs	r3, #255	; 0xff
    74e2:	f88d 300a 	strb.w	r3, [sp, #10]
		return;
	}

	/* Find a prepare that is ready and not a resume */
	while (next && (next->is_aborted || next->is_resume)) {
		next = ull_prepare_dequeue_iter(&idx);
    74e6:	f10d 000a 	add.w	r0, sp, #10
    74ea:	f7fe fc6b 	bl	5dc4 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
    74ee:	4601      	mov	r1, r0
    74f0:	b340      	cbz	r0, 7544 <preempt+0x78>
    74f2:	7f06      	ldrb	r6, [r0, #28]
    74f4:	f016 0603 	ands.w	r6, r6, #3
    74f8:	d1f5      	bne.n	74e6 <preempt+0x1a>
	if (!next) {
		return;
	}

	/* Preemptor not in pipeline */
	if (next != param) {
    74fa:	4285      	cmp	r5, r0
    74fc:	d013      	beq.n	7526 <preempt+0x5a>
		uint32_t ret;

		/* Start the preempt timeout */
		ret = preempt_ticker_start(NULL, next);
    74fe:	4630      	mov	r0, r6
    7500:	f7ff ff7c 	bl	73fc <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    7504:	f030 0302 	bics.w	r3, r0, #2
    7508:	d01c      	beq.n	7544 <preempt+0x78>
    750a:	4a2c      	ldr	r2, [pc, #176]	; (75bc <preempt+0xf0>)
    750c:	492c      	ldr	r1, [pc, #176]	; (75c0 <preempt+0xf4>)
    750e:	f240 3393 	movw	r3, #915	; 0x393

		/* Enqueue as resume event */
		iter = resume_enqueue(resume_cb);
		LL_ASSERT(iter);
	} else {
		LL_ASSERT(err == -ECANCELED);
    7512:	482c      	ldr	r0, [pc, #176]	; (75c4 <preempt+0xf8>)
    7514:	f005 fc73 	bl	cdfe <printk>
    7518:	4040      	eors	r0, r0
    751a:	f380 8811 	msr	BASEPRI, r0
    751e:	f04f 0003 	mov.w	r0, #3
    7522:	df02      	svc	2
    7524:	e00e      	b.n	7544 <preempt+0x78>
	err = event.curr.is_abort_cb(next->prepare_param.param,
    7526:	6863      	ldr	r3, [r4, #4]
    7528:	6821      	ldr	r1, [r4, #0]
    752a:	68e8      	ldr	r0, [r5, #12]
    752c:	aa03      	add	r2, sp, #12
    752e:	4798      	blx	r3
	if (!err) {
    7530:	4607      	mov	r7, r0
    7532:	b948      	cbnz	r0, 7548 <preempt+0x7c>
		next->is_aborted = 1;
    7534:	7f2b      	ldrb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
    7536:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
    7538:	f043 0302 	orr.w	r3, r3, #2
    753c:	772b      	strb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
    753e:	4628      	mov	r0, r5
    7540:	69ab      	ldr	r3, [r5, #24]
    7542:	4798      	blx	r3
	}
}
    7544:	b009      	add	sp, #36	; 0x24
    7546:	bdf0      	pop	{r4, r5, r6, r7, pc}
	event.curr.abort_cb(NULL, event.curr.param);
    7548:	68a3      	ldr	r3, [r4, #8]
    754a:	6821      	ldr	r1, [r4, #0]
    754c:	4630      	mov	r0, r6
    754e:	4798      	blx	r3
	if (err == -EAGAIN) {
    7550:	f117 0f0b 	cmn.w	r7, #11
    7554:	d129      	bne.n	75aa <preempt+0xde>
		iter_idx = UINT8_MAX;
    7556:	25ff      	movs	r5, #255	; 0xff
				iter_idx = UINT8_MAX;
    7558:	f88d 500b 	strb.w	r5, [sp, #11]
			iter = ull_prepare_dequeue_iter(&iter_idx);
    755c:	f10d 000b 	add.w	r0, sp, #11
    7560:	f7fe fc30 	bl	5dc4 <ull_prepare_dequeue_iter>
		while (iter) {
    7564:	b9a0      	cbnz	r0, 7590 <preempt+0xc4>
	prepare_param.param = event.curr.param;
    7566:	6823      	ldr	r3, [r4, #0]
    7568:	9307      	str	r3, [sp, #28]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
    756a:	2301      	movs	r3, #1
	struct lll_prepare_param prepare_param = {0};
    756c:	e9cd 0004 	strd	r0, r0, [sp, #16]
    7570:	9006      	str	r0, [sp, #24]
	event.curr.param = NULL;
    7572:	6020      	str	r0, [r4, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
    7574:	9300      	str	r3, [sp, #0]
    7576:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
    757a:	9b03      	ldr	r3, [sp, #12]
    757c:	aa04      	add	r2, sp, #16
    757e:	f7fe fbe5 	bl	5d4c <ull_prepare_enqueue>
		LL_ASSERT(iter);
    7582:	2800      	cmp	r0, #0
    7584:	d1de      	bne.n	7544 <preempt+0x78>
    7586:	4a0d      	ldr	r2, [pc, #52]	; (75bc <preempt+0xf0>)
    7588:	490f      	ldr	r1, [pc, #60]	; (75c8 <preempt+0xfc>)
    758a:	f240 33c5 	movw	r3, #965	; 0x3c5
    758e:	e7c0      	b.n	7512 <preempt+0x46>
			if (!iter->is_aborted &&
    7590:	7f03      	ldrb	r3, [r0, #28]
    7592:	079a      	lsls	r2, r3, #30
    7594:	d4e2      	bmi.n	755c <preempt+0x90>
			    event.curr.param == iter->prepare_param.param) {
    7596:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
    7598:	6821      	ldr	r1, [r4, #0]
    759a:	4291      	cmp	r1, r2
    759c:	d1de      	bne.n	755c <preempt+0x90>
				iter->is_aborted = 1;
    759e:	f043 0302 	orr.w	r3, r3, #2
    75a2:	7703      	strb	r3, [r0, #28]
				iter->abort_cb(&iter->prepare_param,
    75a4:	6983      	ldr	r3, [r0, #24]
    75a6:	4798      	blx	r3
    75a8:	e7d6      	b.n	7558 <preempt+0x8c>
		LL_ASSERT(err == -ECANCELED);
    75aa:	378c      	adds	r7, #140	; 0x8c
    75ac:	d0ca      	beq.n	7544 <preempt+0x78>
    75ae:	4a03      	ldr	r2, [pc, #12]	; (75bc <preempt+0xf0>)
    75b0:	4906      	ldr	r1, [pc, #24]	; (75cc <preempt+0x100>)
    75b2:	f240 33c7 	movw	r3, #967	; 0x3c7
    75b6:	e7ac      	b.n	7512 <preempt+0x46>
    75b8:	200018ac 	.word	0x200018ac
    75bc:	000119ca 	.word	0x000119ca
    75c0:	0001177e 	.word	0x0001177e
    75c4:	00010f78 	.word	0x00010f78
    75c8:	00011a9e 	.word	0x00011a9e
    75cc:	00011aa3 	.word	0x00011aa3

000075d0 <lll_init>:
{
    75d0:	b510      	push	{r4, lr}
    75d2:	4816      	ldr	r0, [pc, #88]	; (762c <lll_init+0x5c>)
    75d4:	f004 f84c 	bl	b670 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(DT_LABEL(DT_NODELABEL(rng)));
    75d8:	4b15      	ldr	r3, [pc, #84]	; (7630 <lll_init+0x60>)
    75da:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
    75dc:	b310      	cbz	r0, 7624 <lll_init+0x54>
	event.curr.abort_cb = NULL;
    75de:	4b15      	ldr	r3, [pc, #84]	; (7634 <lll_init+0x64>)
    75e0:	2400      	movs	r4, #0
    75e2:	609c      	str	r4, [r3, #8]
	err = lll_clock_init();
    75e4:	f000 f9d4 	bl	7990 <lll_clock_init>
	if (err < 0) {
    75e8:	2800      	cmp	r0, #0
    75ea:	db1a      	blt.n	7622 <lll_init+0x52>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
    75ec:	4622      	mov	r2, r4
    75ee:	4621      	mov	r1, r4
    75f0:	2001      	movs	r0, #1
    75f2:	f7fa fe09 	bl	2208 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
    75f6:	4622      	mov	r2, r4
    75f8:	2101      	movs	r1, #1
    75fa:	200b      	movs	r0, #11
    75fc:	f7fa fe04 	bl	2208 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
    7600:	4622      	mov	r2, r4
    7602:	4621      	mov	r1, r4
    7604:	2018      	movs	r0, #24
    7606:	f7fa fdff 	bl	2208 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
    760a:	2001      	movs	r0, #1
    760c:	f7fa fdca 	bl	21a4 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
    7610:	200b      	movs	r0, #11
    7612:	f7fa fdc7 	bl	21a4 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
    7616:	2018      	movs	r0, #24
    7618:	f7fa fdc4 	bl	21a4 <arch_irq_enable>
	radio_setup();
    761c:	f007 f972 	bl	e904 <radio_setup>
	return 0;
    7620:	4620      	mov	r0, r4
}
    7622:	bd10      	pop	{r4, pc}
		return -ENODEV;
    7624:	f06f 0012 	mvn.w	r0, #18
    7628:	e7fb      	b.n	7622 <lll_init+0x52>
    762a:	bf00      	nop
    762c:	00011aaf 	.word	0x00011aaf
    7630:	200018a8 	.word	0x200018a8
    7634:	200018ac 	.word	0x200018ac

00007638 <lll_csrand_get>:
	return entropy_get_entropy(dev_entropy, buf, len);
    7638:	4a05      	ldr	r2, [pc, #20]	; (7650 <lll_csrand_get+0x18>)
{
    763a:	b410      	push	{r4}
    763c:	4603      	mov	r3, r0
	return entropy_get_entropy(dev_entropy, buf, len);
    763e:	6810      	ldr	r0, [r2, #0]
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
    7640:	6882      	ldr	r2, [r0, #8]
    7642:	6814      	ldr	r4, [r2, #0]
    7644:	b28a      	uxth	r2, r1
    7646:	4619      	mov	r1, r3
    7648:	4623      	mov	r3, r4
}
    764a:	bc10      	pop	{r4}
    764c:	4718      	bx	r3
    764e:	bf00      	nop
    7650:	200018a8 	.word	0x200018a8

00007654 <lll_csrand_isr_get>:
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
    7654:	4b08      	ldr	r3, [pc, #32]	; (7678 <lll_csrand_isr_get+0x24>)
{
    7656:	b430      	push	{r4, r5}
    7658:	4604      	mov	r4, r0
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
    765a:	6818      	ldr	r0, [r3, #0]
					  uint32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	if (unlikely(!api->get_entropy_isr)) {
    765c:	6883      	ldr	r3, [r0, #8]
    765e:	685d      	ldr	r5, [r3, #4]
    7660:	b28a      	uxth	r2, r1
    7662:	b125      	cbz	r5, 766e <lll_csrand_isr_get+0x1a>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
    7664:	4621      	mov	r1, r4
    7666:	46ac      	mov	ip, r5
    7668:	2300      	movs	r3, #0
}
    766a:	bc30      	pop	{r4, r5}
    766c:	4760      	bx	ip
    766e:	f06f 0085 	mvn.w	r0, #133	; 0x85
    7672:	bc30      	pop	{r4, r5}
    7674:	4770      	bx	lr
    7676:	bf00      	nop
    7678:	200018a8 	.word	0x200018a8

0000767c <lll_disable>:
{
    767c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    767e:	4b19      	ldr	r3, [pc, #100]	; (76e4 <lll_disable+0x68>)
	if (!param || (param == event.curr.param)) {
    7680:	4604      	mov	r4, r0
    7682:	b110      	cbz	r0, 768a <lll_disable+0xe>
    7684:	681a      	ldr	r2, [r3, #0]
    7686:	4282      	cmp	r2, r0
    7688:	d105      	bne.n	7696 <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
    768a:	689a      	ldr	r2, [r3, #8]
    768c:	b16a      	cbz	r2, 76aa <lll_disable+0x2e>
    768e:	6819      	ldr	r1, [r3, #0]
    7690:	b159      	cbz	r1, 76aa <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
    7692:	2000      	movs	r0, #0
    7694:	4790      	blx	r2
		idx = UINT8_MAX;
    7696:	25ff      	movs	r5, #255	; 0xff
				idx = UINT8_MAX;
    7698:	f88d 5007 	strb.w	r5, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
    769c:	f10d 0007 	add.w	r0, sp, #7
    76a0:	f7fe fb90 	bl	5dc4 <ull_prepare_dequeue_iter>
		while (next) {
    76a4:	b980      	cbnz	r0, 76c8 <lll_disable+0x4c>
}
    76a6:	b003      	add	sp, #12
    76a8:	bd30      	pop	{r4, r5, pc}
			LL_ASSERT(!param);
    76aa:	2c00      	cmp	r4, #0
    76ac:	d0f3      	beq.n	7696 <lll_disable+0x1a>
    76ae:	4a0e      	ldr	r2, [pc, #56]	; (76e8 <lll_disable+0x6c>)
    76b0:	490e      	ldr	r1, [pc, #56]	; (76ec <lll_disable+0x70>)
    76b2:	480f      	ldr	r0, [pc, #60]	; (76f0 <lll_disable+0x74>)
    76b4:	23fd      	movs	r3, #253	; 0xfd
    76b6:	f005 fba2 	bl	cdfe <printk>
    76ba:	4040      	eors	r0, r0
    76bc:	f380 8811 	msr	BASEPRI, r0
    76c0:	f04f 0003 	mov.w	r0, #3
    76c4:	df02      	svc	2
    76c6:	e7e6      	b.n	7696 <lll_disable+0x1a>
			if (!next->is_aborted &&
    76c8:	7f03      	ldrb	r3, [r0, #28]
    76ca:	079b      	lsls	r3, r3, #30
    76cc:	d4e6      	bmi.n	769c <lll_disable+0x20>
			    (!param || (param == next->prepare_param.param))) {
    76ce:	68c1      	ldr	r1, [r0, #12]
			if (!next->is_aborted &&
    76d0:	b10c      	cbz	r4, 76d6 <lll_disable+0x5a>
			    (!param || (param == next->prepare_param.param))) {
    76d2:	428c      	cmp	r4, r1
    76d4:	d1e2      	bne.n	769c <lll_disable+0x20>
				next->is_aborted = 1;
    76d6:	7f03      	ldrb	r3, [r0, #28]
    76d8:	f043 0302 	orr.w	r3, r3, #2
    76dc:	7703      	strb	r3, [r0, #28]
				next->abort_cb(&next->prepare_param,
    76de:	6983      	ldr	r3, [r0, #24]
    76e0:	4798      	blx	r3
    76e2:	e7d9      	b.n	7698 <lll_disable+0x1c>
    76e4:	200018ac 	.word	0x200018ac
    76e8:	000119ca 	.word	0x000119ca
    76ec:	00011ab3 	.word	0x00011ab3
    76f0:	00010f78 	.word	0x00010f78

000076f4 <lll_done>:
{
    76f4:	b538      	push	{r3, r4, r5, lr}
    76f6:	4604      	mov	r4, r0
	next = ull_prepare_dequeue_get();
    76f8:	f7fe fb56 	bl	5da8 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
    76fc:	b17c      	cbz	r4, 771e <lll_done+0x2a>
    76fe:	b960      	cbnz	r0, 771a <lll_done+0x26>
    7700:	4a1d      	ldr	r2, [pc, #116]	; (7778 <lll_done+0x84>)
    7702:	491e      	ldr	r1, [pc, #120]	; (777c <lll_done+0x88>)
    7704:	481e      	ldr	r0, [pc, #120]	; (7780 <lll_done+0x8c>)
    7706:	f240 1337 	movw	r3, #311	; 0x137
    770a:	f005 fb78 	bl	cdfe <printk>
    770e:	4040      	eors	r0, r0
    7710:	f380 8811 	msr	BASEPRI, r0
    7714:	f04f 0003 	mov.w	r0, #3
    7718:	df02      	svc	2
			ull = HDR_LLL2ULL(param);
    771a:	6824      	ldr	r4, [r4, #0]
    771c:	e015      	b.n	774a <lll_done+0x56>
		LL_ASSERT(event.curr.abort_cb);
    771e:	4d19      	ldr	r5, [pc, #100]	; (7784 <lll_done+0x90>)
    7720:	68ab      	ldr	r3, [r5, #8]
    7722:	b963      	cbnz	r3, 773e <lll_done+0x4a>
    7724:	4a14      	ldr	r2, [pc, #80]	; (7778 <lll_done+0x84>)
    7726:	4918      	ldr	r1, [pc, #96]	; (7788 <lll_done+0x94>)
    7728:	4815      	ldr	r0, [pc, #84]	; (7780 <lll_done+0x8c>)
    772a:	f240 133d 	movw	r3, #317	; 0x13d
    772e:	f005 fb66 	bl	cdfe <printk>
    7732:	4040      	eors	r0, r0
    7734:	f380 8811 	msr	BASEPRI, r0
    7738:	f04f 0003 	mov.w	r0, #3
    773c:	df02      	svc	2
		param = event.curr.param;
    773e:	682c      	ldr	r4, [r5, #0]
		event.curr.abort_cb = NULL;
    7740:	2300      	movs	r3, #0
    7742:	60ab      	str	r3, [r5, #8]
		event.curr.param = NULL;
    7744:	602b      	str	r3, [r5, #0]
		if (param) {
    7746:	2c00      	cmp	r4, #0
    7748:	d1e7      	bne.n	771a <lll_done+0x26>
	ull_prepare_dequeue(TICKER_USER_ID_LLL);
    774a:	2000      	movs	r0, #0
    774c:	f7fe fb58 	bl	5e00 <ull_prepare_dequeue>
	evdone = ull_event_done(ull);
    7750:	4620      	mov	r0, r4
    7752:	f7fe fb9d 	bl	5e90 <ull_event_done>
	LL_ASSERT(evdone);
    7756:	b960      	cbnz	r0, 7772 <lll_done+0x7e>
    7758:	4a07      	ldr	r2, [pc, #28]	; (7778 <lll_done+0x84>)
    775a:	490c      	ldr	r1, [pc, #48]	; (778c <lll_done+0x98>)
    775c:	4808      	ldr	r0, [pc, #32]	; (7780 <lll_done+0x8c>)
    775e:	f240 136d 	movw	r3, #365	; 0x16d
    7762:	f005 fb4c 	bl	cdfe <printk>
    7766:	4040      	eors	r0, r0
    7768:	f380 8811 	msr	BASEPRI, r0
    776c:	f04f 0003 	mov.w	r0, #3
    7770:	df02      	svc	2
}
    7772:	2000      	movs	r0, #0
    7774:	bd38      	pop	{r3, r4, r5, pc}
    7776:	bf00      	nop
    7778:	000119ca 	.word	0x000119ca
    777c:	00011aba 	.word	0x00011aba
    7780:	00010f78 	.word	0x00010f78
    7784:	200018ac 	.word	0x200018ac
    7788:	00011ac9 	.word	0x00011ac9
    778c:	00011add 	.word	0x00011add

00007790 <lll_chan_set>:
	switch (chan) {
    7790:	2826      	cmp	r0, #38	; 0x26
{
    7792:	b510      	push	{r4, lr}
    7794:	4604      	mov	r4, r0
	switch (chan) {
    7796:	d00b      	beq.n	77b0 <lll_chan_set+0x20>
    7798:	2827      	cmp	r0, #39	; 0x27
    779a:	d00b      	beq.n	77b4 <lll_chan_set+0x24>
    779c:	2825      	cmp	r0, #37	; 0x25
    779e:	d10b      	bne.n	77b8 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
    77a0:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
    77a2:	f000 fd59 	bl	8258 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
    77a6:	4620      	mov	r0, r4
}
    77a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
    77ac:	f000 bd5a 	b.w	8264 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
    77b0:	201a      	movs	r0, #26
    77b2:	e7f6      	b.n	77a2 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
    77b4:	2050      	movs	r0, #80	; 0x50
    77b6:	e7f4      	b.n	77a2 <lll_chan_set+0x12>
		if (chan < 11) {
    77b8:	280a      	cmp	r0, #10
    77ba:	d802      	bhi.n	77c2 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
    77bc:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
    77be:	0040      	lsls	r0, r0, #1
    77c0:	e7ef      	b.n	77a2 <lll_chan_set+0x12>
		} else if (chan < 40) {
    77c2:	2827      	cmp	r0, #39	; 0x27
    77c4:	d801      	bhi.n	77ca <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
    77c6:	3003      	adds	r0, #3
    77c8:	e7f9      	b.n	77be <lll_chan_set+0x2e>
			LL_ASSERT(0);
    77ca:	4a07      	ldr	r2, [pc, #28]	; (77e8 <lll_chan_set+0x58>)
    77cc:	4907      	ldr	r1, [pc, #28]	; (77ec <lll_chan_set+0x5c>)
    77ce:	4808      	ldr	r0, [pc, #32]	; (77f0 <lll_chan_set+0x60>)
    77d0:	f44f 73ed 	mov.w	r3, #474	; 0x1da
    77d4:	f005 fb13 	bl	cdfe <printk>
    77d8:	4040      	eors	r0, r0
    77da:	f380 8811 	msr	BASEPRI, r0
    77de:	f04f 0003 	mov.w	r0, #3
    77e2:	df02      	svc	2
    77e4:	e7df      	b.n	77a6 <lll_chan_set+0x16>
    77e6:	bf00      	nop
    77e8:	000119ca 	.word	0x000119ca
    77ec:	00011d2c 	.word	0x00011d2c
    77f0:	00010f78 	.word	0x00010f78

000077f4 <lll_isr_cleanup>:
{
    77f4:	b508      	push	{r3, lr}
    77f6:	4601      	mov	r1, r0
	radio_isr_set(isr_race, param);
    77f8:	480f      	ldr	r0, [pc, #60]	; (7838 <lll_isr_cleanup+0x44>)
    77fa:	f000 fcd3 	bl	81a4 <radio_isr_set>
	if (!radio_is_idle()) {
    77fe:	f000 fdc5 	bl	838c <radio_is_idle>
    7802:	b908      	cbnz	r0, 7808 <lll_isr_cleanup+0x14>
		radio_disable();
    7804:	f000 fd90 	bl	8328 <radio_disable>
	radio_tmr_stop();
    7808:	f000 ff6c 	bl	86e4 <radio_tmr_stop>
	err = lll_hfclock_off();
    780c:	f000 f8e6 	bl	79dc <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    7810:	2800      	cmp	r0, #0
    7812:	da0c      	bge.n	782e <lll_isr_cleanup+0x3a>
    7814:	4a09      	ldr	r2, [pc, #36]	; (783c <lll_isr_cleanup+0x48>)
    7816:	490a      	ldr	r1, [pc, #40]	; (7840 <lll_isr_cleanup+0x4c>)
    7818:	480a      	ldr	r0, [pc, #40]	; (7844 <lll_isr_cleanup+0x50>)
    781a:	f240 233d 	movw	r3, #573	; 0x23d
    781e:	f005 faee 	bl	cdfe <printk>
    7822:	4040      	eors	r0, r0
    7824:	f380 8811 	msr	BASEPRI, r0
    7828:	f04f 0003 	mov.w	r0, #3
    782c:	df02      	svc	2
}
    782e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
    7832:	2000      	movs	r0, #0
    7834:	f7ff bf5e 	b.w	76f4 <lll_done>
    7838:	0000e73d 	.word	0x0000e73d
    783c:	000119ca 	.word	0x000119ca
    7840:	00011ae4 	.word	0x00011ae4
    7844:	00010f78 	.word	0x00010f78

00007848 <lll_prepare_resolve>:
{
    7848:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    784c:	461d      	mov	r5, r3
    784e:	f89d a030 	ldrb.w	sl, [sp, #48]	; 0x30
	idx = UINT8_MAX;
    7852:	23ff      	movs	r3, #255	; 0xff
{
    7854:	4681      	mov	r9, r0
    7856:	4688      	mov	r8, r1
    7858:	4616      	mov	r6, r2
	idx = UINT8_MAX;
    785a:	f88d 300f 	strb.w	r3, [sp, #15]
		p = ull_prepare_dequeue_iter(&idx);
    785e:	f10d 000f 	add.w	r0, sp, #15
    7862:	f7fe faaf 	bl	5dc4 <ull_prepare_dequeue_iter>
    7866:	4604      	mov	r4, r0
	while (p && (p->is_aborted || p->is_resume)) {
    7868:	b110      	cbz	r0, 7870 <lll_prepare_resolve+0x28>
    786a:	7f03      	ldrb	r3, [r0, #28]
    786c:	079b      	lsls	r3, r3, #30
    786e:	d1f6      	bne.n	785e <lll_prepare_resolve+0x16>
	    event.curr.abort_cb ||
    7870:	4f41      	ldr	r7, [pc, #260]	; (7978 <lll_prepare_resolve+0x130>)
	if ((!is_dequeue && !is_done_sync()) ||
    7872:	68bb      	ldr	r3, [r7, #8]
    7874:	b923      	cbnz	r3, 7880 <lll_prepare_resolve+0x38>
	    event.curr.abort_cb ||
    7876:	2c00      	cmp	r4, #0
    7878:	d046      	beq.n	7908 <lll_prepare_resolve+0xc0>
	    (p && is_resume)) {
    787a:	f1ba 0f00 	cmp.w	sl, #0
    787e:	d034      	beq.n	78ea <lll_prepare_resolve+0xa2>
		next = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
    7880:	462a      	mov	r2, r5
    7882:	f8cd a000 	str.w	sl, [sp]
    7886:	4633      	mov	r3, r6
    7888:	4641      	mov	r1, r8
    788a:	4648      	mov	r0, r9
    788c:	f7fe fa5e 	bl	5d4c <ull_prepare_enqueue>
		LL_ASSERT(next);
    7890:	4605      	mov	r5, r0
    7892:	b960      	cbnz	r0, 78ae <lll_prepare_resolve+0x66>
    7894:	4a39      	ldr	r2, [pc, #228]	; (797c <lll_prepare_resolve+0x134>)
    7896:	493a      	ldr	r1, [pc, #232]	; (7980 <lll_prepare_resolve+0x138>)
    7898:	483a      	ldr	r0, [pc, #232]	; (7984 <lll_prepare_resolve+0x13c>)
    789a:	f44f 7322 	mov.w	r3, #648	; 0x288
    789e:	f005 faae 	bl	cdfe <printk>
    78a2:	4040      	eors	r0, r0
    78a4:	f380 8811 	msr	BASEPRI, r0
    78a8:	f04f 0003 	mov.w	r0, #3
    78ac:	df02      	svc	2
		if (is_resume) {
    78ae:	f1ba 0f00 	cmp.w	sl, #0
    78b2:	d005      	beq.n	78c0 <lll_prepare_resolve+0x78>
		return -EINPROGRESS;
    78b4:	f06f 0476 	mvn.w	r4, #118	; 0x76
}
    78b8:	4620      	mov	r0, r4
    78ba:	b004      	add	sp, #16
    78bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ret  = preempt_ticker_start(p, next);
    78c0:	4629      	mov	r1, r5
    78c2:	4620      	mov	r0, r4
    78c4:	f7ff fd9a 	bl	73fc <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    78c8:	f030 0302 	bics.w	r3, r0, #2
    78cc:	d0f2      	beq.n	78b4 <lll_prepare_resolve+0x6c>
    78ce:	4a2b      	ldr	r2, [pc, #172]	; (797c <lll_prepare_resolve+0x134>)
    78d0:	492d      	ldr	r1, [pc, #180]	; (7988 <lll_prepare_resolve+0x140>)
    78d2:	482c      	ldr	r0, [pc, #176]	; (7984 <lll_prepare_resolve+0x13c>)
    78d4:	f240 2393 	movw	r3, #659	; 0x293
    78d8:	f005 fa91 	bl	cdfe <printk>
    78dc:	4040      	eors	r0, r0
    78de:	f380 8811 	msr	BASEPRI, r0
    78e2:	f04f 0003 	mov.w	r0, #3
    78e6:	df02      	svc	2
    78e8:	e7e4      	b.n	78b4 <lll_prepare_resolve+0x6c>
	LL_ASSERT(!p || &p->prepare_param == prepare_param);
    78ea:	42ac      	cmp	r4, r5
    78ec:	d00c      	beq.n	7908 <lll_prepare_resolve+0xc0>
    78ee:	4a23      	ldr	r2, [pc, #140]	; (797c <lll_prepare_resolve+0x134>)
    78f0:	4926      	ldr	r1, [pc, #152]	; (798c <lll_prepare_resolve+0x144>)
    78f2:	4824      	ldr	r0, [pc, #144]	; (7984 <lll_prepare_resolve+0x13c>)
    78f4:	f240 23b9 	movw	r3, #697	; 0x2b9
    78f8:	f005 fa81 	bl	cdfe <printk>
    78fc:	4040      	eors	r0, r0
    78fe:	f380 8811 	msr	BASEPRI, r0
    7902:	f04f 0003 	mov.w	r0, #3
    7906:	df02      	svc	2
	event.curr.param = prepare_param->param;
    7908:	68eb      	ldr	r3, [r5, #12]
	event.curr.abort_cb = abort_cb;
    790a:	f8c7 8008 	str.w	r8, [r7, #8]
	event.curr.is_abort_cb = is_abort_cb;
    790e:	e9c7 3900 	strd	r3, r9, [r7]
	err = prepare_cb(prepare_param);
    7912:	4628      	mov	r0, r5
    7914:	47b0      	blx	r6
    7916:	4604      	mov	r4, r0
	ret = preempt_ticker_stop();
    7918:	f7ff fd30 	bl	737c <preempt_ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    791c:	f030 0302 	bics.w	r3, r0, #2
    7920:	d00c      	beq.n	793c <lll_prepare_resolve+0xf4>
    7922:	4a16      	ldr	r2, [pc, #88]	; (797c <lll_prepare_resolve+0x134>)
    7924:	4918      	ldr	r1, [pc, #96]	; (7988 <lll_prepare_resolve+0x140>)
    7926:	4817      	ldr	r0, [pc, #92]	; (7984 <lll_prepare_resolve+0x13c>)
    7928:	f240 23c6 	movw	r3, #710	; 0x2c6
    792c:	f005 fa67 	bl	cdfe <printk>
    7930:	4040      	eors	r0, r0
    7932:	f380 8811 	msr	BASEPRI, r0
    7936:	f04f 0003 	mov.w	r0, #3
    793a:	df02      	svc	2
		p = ull_prepare_dequeue_iter(&idx);
    793c:	f10d 000f 	add.w	r0, sp, #15
    7940:	f7fe fa40 	bl	5dc4 <ull_prepare_dequeue_iter>
		if (!p) {
    7944:	4601      	mov	r1, r0
    7946:	2800      	cmp	r0, #0
    7948:	d0b6      	beq.n	78b8 <lll_prepare_resolve+0x70>
	} while (p->is_aborted || p->is_resume);
    794a:	7f00      	ldrb	r0, [r0, #28]
    794c:	f010 0003 	ands.w	r0, r0, #3
    7950:	d1f4      	bne.n	793c <lll_prepare_resolve+0xf4>
	ret = preempt_ticker_start(NULL, p);
    7952:	f7ff fd53 	bl	73fc <preempt_ticker_start>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    7956:	f030 0302 	bics.w	r3, r0, #2
    795a:	d0ad      	beq.n	78b8 <lll_prepare_resolve+0x70>
    795c:	4a07      	ldr	r2, [pc, #28]	; (797c <lll_prepare_resolve+0x134>)
    795e:	490a      	ldr	r1, [pc, #40]	; (7988 <lll_prepare_resolve+0x140>)
    7960:	4808      	ldr	r0, [pc, #32]	; (7984 <lll_prepare_resolve+0x13c>)
    7962:	f240 23d3 	movw	r3, #723	; 0x2d3
    7966:	f005 fa4a 	bl	cdfe <printk>
    796a:	4040      	eors	r0, r0
    796c:	f380 8811 	msr	BASEPRI, r0
    7970:	f04f 0003 	mov.w	r0, #3
    7974:	df02      	svc	2
    7976:	e79f      	b.n	78b8 <lll_prepare_resolve+0x70>
    7978:	200018ac 	.word	0x200018ac
    797c:	000119ca 	.word	0x000119ca
    7980:	00011ac4 	.word	0x00011ac4
    7984:	00010f78 	.word	0x00010f78
    7988:	0001177e 	.word	0x0001177e
    798c:	00011aed 	.word	0x00011aed

00007990 <lll_clock_init>:

	return k_sem_take(&state.sem, K_MSEC(timeout));
}

int lll_clock_init(void)
{
    7990:	b508      	push	{r3, lr}
	struct onoff_manager *mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
    7992:	2001      	movs	r0, #1
    7994:	f001 fa16 	bl	8dc4 <z_nrf_clock_control_get_onoff>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    7998:	4904      	ldr	r1, [pc, #16]	; (79ac <lll_clock_init+0x1c>)
    799a:	2300      	movs	r3, #0
    799c:	604b      	str	r3, [r1, #4]
    799e:	60cb      	str	r3, [r1, #12]
    79a0:	2301      	movs	r3, #1
    79a2:	608b      	str	r3, [r1, #8]

	sys_notify_init_spinwait(&lf_cli.notify);

	return onoff_request(mgr, &lf_cli);
}
    79a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return onoff_request(mgr, &lf_cli);
    79a8:	f005 baa5 	b.w	cef6 <onoff_request>
    79ac:	200018c8 	.word	0x200018c8

000079b0 <lll_hfclock_on>:

	return 0;
}

int lll_hfclock_on(void)
{
    79b0:	b508      	push	{r3, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    79b2:	4b09      	ldr	r3, [pc, #36]	; (79d8 <lll_hfclock_on+0x28>)
    79b4:	f3bf 8f5b 	dmb	ish
    79b8:	e853 2f00 	ldrex	r2, [r3]
    79bc:	1c51      	adds	r1, r2, #1
    79be:	e843 1000 	strex	r0, r1, [r3]
    79c2:	2800      	cmp	r0, #0
    79c4:	d1f8      	bne.n	79b8 <lll_hfclock_on+0x8>
    79c6:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&hf_refcnt) > 0) {
    79ca:	2a00      	cmp	r2, #0
    79cc:	dc01      	bgt.n	79d2 <lll_hfclock_on+0x22>
		return 0;
	}

	z_nrf_clock_bt_ctlr_hf_request();
    79ce:	f001 fa01 	bl	8dd4 <z_nrf_clock_bt_ctlr_hf_request>
	DEBUG_RADIO_XTAL(1);

	return 0;
}
    79d2:	2000      	movs	r0, #0
    79d4:	bd08      	pop	{r3, pc}
    79d6:	bf00      	nop
    79d8:	200018c4 	.word	0x200018c4

000079dc <lll_hfclock_off>:

	return err;
}

int lll_hfclock_off(void)
{
    79dc:	b508      	push	{r3, lr}
	if (hf_refcnt < 1) {
    79de:	4b0c      	ldr	r3, [pc, #48]	; (7a10 <lll_hfclock_off+0x34>)
    79e0:	681a      	ldr	r2, [r3, #0]
    79e2:	2a00      	cmp	r2, #0
    79e4:	dd10      	ble.n	7a08 <lll_hfclock_off+0x2c>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    79e6:	f3bf 8f5b 	dmb	ish
    79ea:	e853 2f00 	ldrex	r2, [r3]
    79ee:	1e51      	subs	r1, r2, #1
    79f0:	e843 1000 	strex	r0, r1, [r3]
    79f4:	2800      	cmp	r0, #0
    79f6:	d1f8      	bne.n	79ea <lll_hfclock_off+0xe>
    79f8:	f3bf 8f5b 	dmb	ish
		return -EALREADY;
	}

	if (atomic_dec(&hf_refcnt) > 1) {
    79fc:	2a01      	cmp	r2, #1
    79fe:	dc01      	bgt.n	7a04 <lll_hfclock_off+0x28>
		return 0;
	}

	z_nrf_clock_bt_ctlr_hf_release();
    7a00:	f001 f9fe 	bl	8e00 <z_nrf_clock_bt_ctlr_hf_release>
		return 0;
    7a04:	2000      	movs	r0, #0
    7a06:	e001      	b.n	7a0c <lll_hfclock_off+0x30>
		return -EALREADY;
    7a08:	f06f 0077 	mvn.w	r0, #119	; 0x77
	DEBUG_RADIO_XTAL(0);

	return 0;
}
    7a0c:	bd08      	pop	{r3, pc}
    7a0e:	bf00      	nop
    7a10:	200018c4 	.word	0x200018c4

00007a14 <isr_tx>:

	lll_done(param);
}

static void isr_tx(void *param)
{
    7a14:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7a16:	4605      	mov	r5, r0
		lll_prof_latency_capture();
		node_rx_prof = lll_prof_reserve();
	}

	/* Clear radio tx status and events */
	lll_isr_tx_status_reset();
    7a18:	f006 fec4 	bl	e7a4 <lll_isr_tx_status_reset>

	/* setup tIFS switching */
	radio_tmr_tifs_set(EVENT_IFS_US);
    7a1c:	2096      	movs	r0, #150	; 0x96
    7a1e:	f000 fde7 	bl	85f0 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(phy_p, 0, phy_p, phy_flags);
    7a22:	2300      	movs	r3, #0
    7a24:	4618      	mov	r0, r3
    7a26:	461a      	mov	r2, r3
    7a28:	4619      	mov	r1, r3
    7a2a:	f000 fd53 	bl	84d4 <radio_switch_complete_and_tx>

	/* setup Rx buffer */
	node_rx = ull_pdu_rx_alloc_peek(1);
    7a2e:	2001      	movs	r0, #1
    7a30:	f7fe f966 	bl	5d00 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    7a34:	4604      	mov	r4, r0
    7a36:	b960      	cbnz	r0, 7a52 <isr_tx+0x3e>
    7a38:	4a23      	ldr	r2, [pc, #140]	; (7ac8 <isr_tx+0xb4>)
    7a3a:	4924      	ldr	r1, [pc, #144]	; (7acc <isr_tx+0xb8>)
    7a3c:	4824      	ldr	r0, [pc, #144]	; (7ad0 <isr_tx+0xbc>)
    7a3e:	f240 433f 	movw	r3, #1087	; 0x43f
    7a42:	f005 f9dc 	bl	cdfe <printk>
    7a46:	4040      	eors	r0, r0
    7a48:	f380 8811 	msr	BASEPRI, r0
    7a4c:	f04f 0003 	mov.w	r0, #3
    7a50:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    7a52:	f104 001c 	add.w	r0, r4, #28
    7a56:	f000 fc55 	bl	8304 <radio_pkt_rx_set>

	/* assert if radio packet ptr is not set and radio started rx */
	LL_ASSERT(!radio_is_ready());
    7a5a:	f000 fc83 	bl	8364 <radio_is_ready>
    7a5e:	b160      	cbz	r0, 7a7a <isr_tx+0x66>
    7a60:	4a19      	ldr	r2, [pc, #100]	; (7ac8 <isr_tx+0xb4>)
    7a62:	491c      	ldr	r1, [pc, #112]	; (7ad4 <isr_tx+0xc0>)
    7a64:	481a      	ldr	r0, [pc, #104]	; (7ad0 <isr_tx+0xbc>)
    7a66:	f240 4343 	movw	r3, #1091	; 0x443
    7a6a:	f005 f9c8 	bl	cdfe <printk>
    7a6e:	4040      	eors	r0, r0
    7a70:	f380 8811 	msr	BASEPRI, r0
    7a74:	f04f 0003 	mov.w	r0, #3
    7a78:	df02      	svc	2

	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_cputime_capture();
	}

	radio_isr_set(isr_rx, param);
    7a7a:	4817      	ldr	r0, [pc, #92]	; (7ad8 <isr_tx+0xc4>)
    7a7c:	4629      	mov	r1, r5
    7a7e:	f000 fb91 	bl	81a4 <radio_isr_set>

#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (ull_filter_lll_rl_enabled()) {
    7a82:	f7ff fba9 	bl	71d8 <ull_filter_lll_rl_enabled>
    7a86:	b148      	cbz	r0, 7a9c <isr_tx+0x88>
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    7a88:	f10d 0007 	add.w	r0, sp, #7
    7a8c:	f7ff faf2 	bl	7074 <ull_filter_lll_irks_get>

		radio_ar_configure(count, irks, 0);
    7a90:	2200      	movs	r2, #0
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    7a92:	4601      	mov	r1, r0
		radio_ar_configure(count, irks, 0);
    7a94:	f89d 0007 	ldrb.w	r0, [sp, #7]
    7a98:	f000 fe4a 	bl	8730 <radio_ar_configure>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	/* +/- 2us active clock jitter, +1 us hcto compensation */
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    7a9c:	f000 fe42 	bl	8724 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(phy_p, 0);
    7aa0:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    7aa2:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
    7aa4:	4608      	mov	r0, r1
    7aa6:	f006 ff51 	bl	e94c <radio_rx_chain_delay_get>
	hcto += addr_us_get(phy_p);
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
    7aaa:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
    7aac:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
    7aae:	4608      	mov	r0, r1
    7ab0:	f006 ff4a 	bl	e948 <radio_tx_chain_delay_get>
    7ab4:	442c      	add	r4, r5
    7ab6:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
    7ab8:	1a20      	subs	r0, r4, r0
    7aba:	f000 fe1f 	bl	86fc <radio_tmr_hcto_configure>
		/* NOTE: as scratch packet is used to receive, it is safe to
		 * generate profile event using rx nodes.
		 */
		lll_prof_reserve_send(node_rx_prof);
	}
}
    7abe:	b003      	add	sp, #12
    7ac0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	radio_tmr_end_capture();
    7ac4:	f000 be26 	b.w	8714 <radio_tmr_end_capture>
    7ac8:	00011b34 	.word	0x00011b34
    7acc:	00011b7e 	.word	0x00011b7e
    7ad0:	00010f78 	.word	0x00010f78
    7ad4:	00011b86 	.word	0x00011b86
    7ad8:	00007f45 	.word	0x00007f45

00007adc <abort_cb>:
{
    7adc:	b510      	push	{r4, lr}
    7ade:	460c      	mov	r4, r1
	if (!prepare_param) {
    7ae0:	b930      	cbnz	r0, 7af0 <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
    7ae2:	480e      	ldr	r0, [pc, #56]	; (7b1c <abort_cb+0x40>)
    7ae4:	f000 fb5e 	bl	81a4 <radio_isr_set>
}
    7ae8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
    7aec:	f000 bc1c 	b.w	8328 <radio_disable>
	err = lll_hfclock_off();
    7af0:	f7ff ff74 	bl	79dc <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    7af4:	2800      	cmp	r0, #0
    7af6:	da0c      	bge.n	7b12 <abort_cb+0x36>
    7af8:	4a09      	ldr	r2, [pc, #36]	; (7b20 <abort_cb+0x44>)
    7afa:	490a      	ldr	r1, [pc, #40]	; (7b24 <abort_cb+0x48>)
    7afc:	480a      	ldr	r0, [pc, #40]	; (7b28 <abort_cb+0x4c>)
    7afe:	f240 431e 	movw	r3, #1054	; 0x41e
    7b02:	f005 f97c 	bl	cdfe <printk>
    7b06:	4040      	eors	r0, r0
    7b08:	f380 8811 	msr	BASEPRI, r0
    7b0c:	f04f 0003 	mov.w	r0, #3
    7b10:	df02      	svc	2
	lll_done(param);
    7b12:	4620      	mov	r0, r4
}
    7b14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
    7b18:	f7ff bdec 	b.w	76f4 <lll_done>
    7b1c:	0000e7d3 	.word	0x0000e7d3
    7b20:	00011b34 	.word	0x00011b34
    7b24:	00011ae4 	.word	0x00011ae4
    7b28:	00010f78 	.word	0x00010f78

00007b2c <lll_adv_init>:
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
    7b2c:	4b08      	ldr	r3, [pc, #32]	; (7b50 <lll_adv_init+0x24>)
    7b2e:	2204      	movs	r2, #4
{
    7b30:	b510      	push	{r4, lr}
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
    7b32:	1898      	adds	r0, r3, r2
    7b34:	2128      	movs	r1, #40	; 0x28
    7b36:	f006 f923 	bl	dd80 <mem_init>
	MFIFO_INIT(pdu_free);
    7b3a:	4b06      	ldr	r3, [pc, #24]	; (7b54 <lll_adv_init+0x28>)
    7b3c:	2400      	movs	r4, #0
    7b3e:	805c      	strh	r4, [r3, #2]
	return z_impl_k_sem_init(sem, initial_count, limit);
    7b40:	2202      	movs	r2, #2
    7b42:	4621      	mov	r1, r4
    7b44:	4804      	ldr	r0, [pc, #16]	; (7b58 <lll_adv_init+0x2c>)
    7b46:	f007 fe14 	bl	f772 <z_impl_k_sem_init>
}
    7b4a:	4620      	mov	r0, r4
    7b4c:	bd10      	pop	{r4, pc}
    7b4e:	bf00      	nop
    7b50:	200018d8 	.word	0x200018d8
    7b54:	20000374 	.word	0x20000374
    7b58:	2000197c 	.word	0x2000197c

00007b5c <lll_adv_data_init>:
{
    7b5c:	b510      	push	{r4, lr}
    7b5e:	4604      	mov	r4, r0
	p = mem_acquire(&mem_pdu.free);
    7b60:	4805      	ldr	r0, [pc, #20]	; (7b78 <lll_adv_data_init+0x1c>)
    7b62:	f006 f935 	bl	ddd0 <mem_acquire>
	if (!p) {
    7b66:	4603      	mov	r3, r0
    7b68:	b118      	cbz	r0, 7b72 <lll_adv_data_init+0x16>
	p->len = 0U;
    7b6a:	2000      	movs	r0, #0
    7b6c:	7058      	strb	r0, [r3, #1]
	pdu->pdu[0] = (void *)p;
    7b6e:	6063      	str	r3, [r4, #4]
}
    7b70:	bd10      	pop	{r4, pc}
		return -ENOMEM;
    7b72:	f06f 000b 	mvn.w	r0, #11
    7b76:	e7fb      	b.n	7b70 <lll_adv_data_init+0x14>
    7b78:	200018d8 	.word	0x200018d8

00007b7c <lll_adv_pdu_alloc_pdu_adv>:
{
    7b7c:	b538      	push	{r3, r4, r5, lr}
	p = MFIFO_DEQUEUE_PEEK(pdu_free);
    7b7e:	4c33      	ldr	r4, [pc, #204]	; (7c4c <lll_adv_pdu_alloc_pdu_adv+0xd0>)
    7b80:	78a2      	ldrb	r2, [r4, #2]
	if (first == last) {
    7b82:	78e1      	ldrb	r1, [r4, #3]
    7b84:	7823      	ldrb	r3, [r4, #0]
    7b86:	4291      	cmp	r1, r2
    7b88:	d023      	beq.n	7bd2 <lll_adv_pdu_alloc_pdu_adv+0x56>
	return *((void **)(fifo + first * size));
    7b8a:	fb02 4303 	mla	r3, r2, r3, r4
    7b8e:	685d      	ldr	r5, [r3, #4]
	if (p) {
    7b90:	b1fd      	cbz	r5, 7bd2 <lll_adv_pdu_alloc_pdu_adv+0x56>
	return z_impl_k_sem_take(sem, timeout);
    7b92:	482f      	ldr	r0, [pc, #188]	; (7c50 <lll_adv_pdu_alloc_pdu_adv+0xd4>)
    7b94:	2200      	movs	r2, #0
    7b96:	2300      	movs	r3, #0
    7b98:	f004 f8f4 	bl	bd84 <z_impl_k_sem_take>
		LL_ASSERT(!err);
    7b9c:	b160      	cbz	r0, 7bb8 <lll_adv_pdu_alloc_pdu_adv+0x3c>
    7b9e:	4a2d      	ldr	r2, [pc, #180]	; (7c54 <lll_adv_pdu_alloc_pdu_adv+0xd8>)
    7ba0:	492d      	ldr	r1, [pc, #180]	; (7c58 <lll_adv_pdu_alloc_pdu_adv+0xdc>)
    7ba2:	482e      	ldr	r0, [pc, #184]	; (7c5c <lll_adv_pdu_alloc_pdu_adv+0xe0>)
    7ba4:	f240 1397 	movw	r3, #407	; 0x197
    7ba8:	f005 f929 	bl	cdfe <printk>
    7bac:	4040      	eors	r0, r0
    7bae:	f380 8811 	msr	BASEPRI, r0
    7bb2:	f04f 0003 	mov.w	r0, #3
    7bb6:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
    7bb8:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
    7bba:	78e1      	ldrb	r1, [r4, #3]
		MFIFO_DEQUEUE(pdu_free);
    7bbc:	7862      	ldrb	r2, [r4, #1]
    7bbe:	4299      	cmp	r1, r3
    7bc0:	d005      	beq.n	7bce <lll_adv_pdu_alloc_pdu_adv+0x52>
	_first += 1U;
    7bc2:	3301      	adds	r3, #1
    7bc4:	b2db      	uxtb	r3, r3
		_first = 0U;
    7bc6:	429a      	cmp	r2, r3
    7bc8:	bf08      	it	eq
    7bca:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    7bcc:	70a3      	strb	r3, [r4, #2]
}
    7bce:	4628      	mov	r0, r5
    7bd0:	bd38      	pop	{r3, r4, r5, pc}
	p = mem_acquire(&mem_pdu.free);
    7bd2:	4823      	ldr	r0, [pc, #140]	; (7c60 <lll_adv_pdu_alloc_pdu_adv+0xe4>)
    7bd4:	f006 f8fc 	bl	ddd0 <mem_acquire>
	if (p) {
    7bd8:	4605      	mov	r5, r0
    7bda:	2800      	cmp	r0, #0
    7bdc:	d1f7      	bne.n	7bce <lll_adv_pdu_alloc_pdu_adv+0x52>
    7bde:	481c      	ldr	r0, [pc, #112]	; (7c50 <lll_adv_pdu_alloc_pdu_adv+0xd4>)
    7be0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    7be4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7be8:	f004 f8cc 	bl	bd84 <z_impl_k_sem_take>
	LL_ASSERT(!err);
    7bec:	b160      	cbz	r0, 7c08 <lll_adv_pdu_alloc_pdu_adv+0x8c>
    7bee:	4a19      	ldr	r2, [pc, #100]	; (7c54 <lll_adv_pdu_alloc_pdu_adv+0xd8>)
    7bf0:	4919      	ldr	r1, [pc, #100]	; (7c58 <lll_adv_pdu_alloc_pdu_adv+0xdc>)
    7bf2:	481a      	ldr	r0, [pc, #104]	; (7c5c <lll_adv_pdu_alloc_pdu_adv+0xe0>)
    7bf4:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
    7bf8:	f005 f901 	bl	cdfe <printk>
    7bfc:	4040      	eors	r0, r0
    7bfe:	f380 8811 	msr	BASEPRI, r0
    7c02:	f04f 0003 	mov.w	r0, #3
    7c06:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
    7c08:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
    7c0a:	78e0      	ldrb	r0, [r4, #3]
	p = MFIFO_DEQUEUE(pdu_free);
    7c0c:	7822      	ldrb	r2, [r4, #0]
    7c0e:	7861      	ldrb	r1, [r4, #1]
    7c10:	4298      	cmp	r0, r3
    7c12:	d10d      	bne.n	7c30 <lll_adv_pdu_alloc_pdu_adv+0xb4>
	LL_ASSERT(p);
    7c14:	4a0f      	ldr	r2, [pc, #60]	; (7c54 <lll_adv_pdu_alloc_pdu_adv+0xd8>)
    7c16:	4913      	ldr	r1, [pc, #76]	; (7c64 <lll_adv_pdu_alloc_pdu_adv+0xe8>)
    7c18:	4810      	ldr	r0, [pc, #64]	; (7c5c <lll_adv_pdu_alloc_pdu_adv+0xe0>)
    7c1a:	f240 13ad 	movw	r3, #429	; 0x1ad
    7c1e:	f005 f8ee 	bl	cdfe <printk>
    7c22:	4040      	eors	r0, r0
    7c24:	f380 8811 	msr	BASEPRI, r0
    7c28:	f04f 0003 	mov.w	r0, #3
    7c2c:	df02      	svc	2
    7c2e:	e7ce      	b.n	7bce <lll_adv_pdu_alloc_pdu_adv+0x52>
	mem = *((void **)(fifo + _first * size));
    7c30:	fb03 4202 	mla	r2, r3, r2, r4
	_first += 1U;
    7c34:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
    7c36:	6852      	ldr	r2, [r2, #4]
	_first += 1U;
    7c38:	b2db      	uxtb	r3, r3
		_first = 0U;
    7c3a:	4299      	cmp	r1, r3
    7c3c:	bf08      	it	eq
    7c3e:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    7c40:	70a3      	strb	r3, [r4, #2]
    7c42:	2a00      	cmp	r2, #0
    7c44:	d0e6      	beq.n	7c14 <lll_adv_pdu_alloc_pdu_adv+0x98>
    7c46:	4615      	mov	r5, r2
    7c48:	e7c1      	b.n	7bce <lll_adv_pdu_alloc_pdu_adv+0x52>
    7c4a:	bf00      	nop
    7c4c:	20000374 	.word	0x20000374
    7c50:	2000197c 	.word	0x2000197c
    7c54:	00011b34 	.word	0x00011b34
    7c58:	000115c5 	.word	0x000115c5
    7c5c:	00010f78 	.word	0x00010f78
    7c60:	200018d8 	.word	0x200018d8
    7c64:	00010f06 	.word	0x00010f06

00007c68 <lll_adv_pdu_latest_get>:
{
    7c68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
    7c6a:	7803      	ldrb	r3, [r0, #0]
	if (first != pdu->last) {
    7c6c:	7842      	ldrb	r2, [r0, #1]
    7c6e:	429a      	cmp	r2, r3
{
    7c70:	4605      	mov	r5, r0
    7c72:	460e      	mov	r6, r1
	first = pdu->first;
    7c74:	b2dc      	uxtb	r4, r3
	if (first != pdu->last) {
    7c76:	d021      	beq.n	7cbc <lll_adv_pdu_latest_get+0x54>
			if (!MFIFO_ENQUEUE_IDX_GET(pdu_free, &free_idx)) {
    7c78:	4a13      	ldr	r2, [pc, #76]	; (7cc8 <lll_adv_pdu_latest_get+0x60>)
    7c7a:	78d0      	ldrb	r0, [r2, #3]
	if (last == count) {
    7c7c:	7857      	ldrb	r7, [r2, #1]
    7c7e:	7891      	ldrb	r1, [r2, #2]
	last = last + 1;
    7c80:	1c43      	adds	r3, r0, #1
    7c82:	b2db      	uxtb	r3, r3
		last = 0U;
    7c84:	429f      	cmp	r7, r3
    7c86:	bf08      	it	eq
    7c88:	2300      	moveq	r3, #0
	if (last == first) {
    7c8a:	4299      	cmp	r1, r3
    7c8c:	d01a      	beq.n	7cc4 <lll_adv_pdu_latest_get+0x5c>
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    7c8e:	f892 c000 	ldrb.w	ip, [r2]
    7c92:	eb05 0784 	add.w	r7, r5, r4, lsl #2
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    7c96:	fb0c 2000 	mla	r0, ip, r0, r2
		p = pdu->pdu[pdu_idx];
    7c9a:	6879      	ldr	r1, [r7, #4]
    7c9c:	6041      	str	r1, [r0, #4]
	*last = idx; /* Commit: Update write index */
    7c9e:	70d3      	strb	r3, [r2, #3]
		first += 1U;
    7ca0:	3401      	adds	r4, #1
    7ca2:	b2e4      	uxtb	r4, r4
	z_impl_k_sem_give(sem);
    7ca4:	4809      	ldr	r0, [pc, #36]	; (7ccc <lll_adv_pdu_latest_get+0x64>)
    7ca6:	f004 f847 	bl	bd38 <z_impl_k_sem_give>
			first = 0U;
    7caa:	2c02      	cmp	r4, #2
		*is_modified = 1U;
    7cac:	f04f 0301 	mov.w	r3, #1
			first = 0U;
    7cb0:	bf08      	it	eq
    7cb2:	2400      	moveq	r4, #0
		pdu->first = first;
    7cb4:	702c      	strb	r4, [r5, #0]
		*is_modified = 1U;
    7cb6:	7033      	strb	r3, [r6, #0]
		pdu->pdu[pdu_idx] = NULL;
    7cb8:	2300      	movs	r3, #0
    7cba:	607b      	str	r3, [r7, #4]
	return (void *)pdu->pdu[first];
    7cbc:	eb05 0484 	add.w	r4, r5, r4, lsl #2
    7cc0:	6860      	ldr	r0, [r4, #4]
}
    7cc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return NULL;
    7cc4:	2000      	movs	r0, #0
    7cc6:	e7fc      	b.n	7cc2 <lll_adv_pdu_latest_get+0x5a>
    7cc8:	20000374 	.word	0x20000374
    7ccc:	2000197c 	.word	0x2000197c

00007cd0 <chan_prepare.isra.0>:
{
	struct pdu_adv *pdu;
	uint8_t chan;
	uint8_t upd;

	chan = find_lsb_set(lll->chan_map_curr);
    7cd0:	7903      	ldrb	r3, [r0, #4]
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    7cd2:	f3c3 03c2 	ubfx	r3, r3, #3, #3
static struct pdu_adv *chan_prepare(struct lll_adv *lll)
    7cd6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7cd8:	2b00      	cmp	r3, #0
    7cda:	4604      	mov	r4, r0
    7cdc:	fa93 f0a3 	rbit	r0, r3
    7ce0:	fab0 f080 	clz	r0, r0
    7ce4:	bf08      	it	eq
    7ce6:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
    7cea:	1c45      	adds	r5, r0, #1
    7cec:	d10c      	bne.n	7d08 <chan_prepare.isra.0+0x38>
    7cee:	4a34      	ldr	r2, [pc, #208]	; (7dc0 <chan_prepare.isra.0+0xf0>)
    7cf0:	4934      	ldr	r1, [pc, #208]	; (7dc4 <chan_prepare.isra.0+0xf4>)
    7cf2:	4835      	ldr	r0, [pc, #212]	; (7dc8 <chan_prepare.isra.0+0xf8>)
    7cf4:	f240 5335 	movw	r3, #1333	; 0x535
    7cf8:	f005 f881 	bl	cdfe <printk>
    7cfc:	4040      	eors	r0, r0
    7cfe:	f380 8811 	msr	BASEPRI, r0
    7d02:	f04f 0003 	mov.w	r0, #3
    7d06:	df02      	svc	2

	lll->chan_map_curr &= (lll->chan_map_curr - 1);
    7d08:	7923      	ldrb	r3, [r4, #4]
    7d0a:	f3c3 01c2 	ubfx	r1, r3, #3, #3
    7d0e:	1e4a      	subs	r2, r1, #1
    7d10:	400a      	ands	r2, r1
    7d12:	f362 03c5 	bfi	r3, r2, #3, #3

	lll_chan_set(36 + chan);
    7d16:	f105 0024 	add.w	r0, r5, #36	; 0x24
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
    7d1a:	7123      	strb	r3, [r4, #4]
	lll_chan_set(36 + chan);
    7d1c:	f7ff fd38 	bl	7790 <lll_chan_set>

	/* FIXME: get latest only when primary PDU without Aux PDUs */
	upd = 0U;
    7d20:	2300      	movs	r3, #0
#endif /* CONFIG_BT_CTLR_ADV_EXT_PDU_EXTRA_DATA_MEMORY */

static inline struct pdu_adv *lll_adv_data_latest_get(struct lll_adv *lll,
						      uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->adv_data, is_modified);
    7d22:	f10d 0107 	add.w	r1, sp, #7
    7d26:	f104 0008 	add.w	r0, r4, #8
    7d2a:	f88d 3007 	strb.w	r3, [sp, #7]
    7d2e:	f7ff ff9b 	bl	7c68 <lll_adv_pdu_latest_get>
	pdu = lll_adv_data_latest_get(lll, &upd);
	LL_ASSERT(pdu);
    7d32:	4605      	mov	r5, r0
    7d34:	b960      	cbnz	r0, 7d50 <chan_prepare.isra.0+0x80>
    7d36:	4a22      	ldr	r2, [pc, #136]	; (7dc0 <chan_prepare.isra.0+0xf0>)
    7d38:	4924      	ldr	r1, [pc, #144]	; (7dcc <chan_prepare.isra.0+0xfc>)
    7d3a:	4823      	ldr	r0, [pc, #140]	; (7dc8 <chan_prepare.isra.0+0xf8>)
    7d3c:	f240 533e 	movw	r3, #1342	; 0x53e
    7d40:	f005 f85d 	bl	cdfe <printk>
    7d44:	4040      	eors	r0, r0
    7d46:	f380 8811 	msr	BASEPRI, r0
    7d4a:	f04f 0003 	mov.w	r0, #3
    7d4e:	df02      	svc	2

	radio_pkt_tx_set(pdu);
    7d50:	4628      	mov	r0, r5
    7d52:	f000 fadd 	bl	8310 <radio_pkt_tx_set>

	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
    7d56:	782b      	ldrb	r3, [r5, #0]
    7d58:	f003 030f 	and.w	r3, r3, #15
    7d5c:	2b02      	cmp	r3, #2
    7d5e:	d028      	beq.n	7db2 <chan_prepare.isra.0+0xe2>
}

static inline struct pdu_adv *lll_adv_scan_rsp_latest_get(struct lll_adv *lll,
							  uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
    7d60:	f10d 0107 	add.w	r1, sp, #7
    7d64:	f104 0014 	add.w	r0, r4, #20
    7d68:	f7ff ff7e 	bl	7c68 <lll_adv_pdu_latest_get>
	    (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
	     (pdu->type != PDU_ADV_TYPE_EXT_IND))) {
		struct pdu_adv *scan_pdu;

		scan_pdu = lll_adv_scan_rsp_latest_get(lll, &upd);
		LL_ASSERT(scan_pdu);
    7d6c:	4606      	mov	r6, r0
    7d6e:	b960      	cbnz	r0, 7d8a <chan_prepare.isra.0+0xba>
    7d70:	4a13      	ldr	r2, [pc, #76]	; (7dc0 <chan_prepare.isra.0+0xf0>)
    7d72:	4917      	ldr	r1, [pc, #92]	; (7dd0 <chan_prepare.isra.0+0x100>)
    7d74:	4814      	ldr	r0, [pc, #80]	; (7dc8 <chan_prepare.isra.0+0xf8>)
    7d76:	f44f 63a9 	mov.w	r3, #1352	; 0x548
    7d7a:	f005 f840 	bl	cdfe <printk>
    7d7e:	4040      	eors	r0, r0
    7d80:	f380 8811 	msr	BASEPRI, r0
    7d84:	f04f 0003 	mov.w	r0, #3
    7d88:	df02      	svc	2

#if defined(CONFIG_BT_CTLR_PRIVACY)
		if (upd) {
    7d8a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7d8e:	b123      	cbz	r3, 7d9a <chan_prepare.isra.0+0xca>
			/* Copy the address from the adv packet we will send
			 * into the scan response.
			 */
			memcpy(&scan_pdu->scan_rsp.addr[0],
    7d90:	2206      	movs	r2, #6
    7d92:	1ca9      	adds	r1, r5, #2
    7d94:	1cb0      	adds	r0, r6, #2
    7d96:	f005 fe36 	bl	da06 <memcpy>
#else
		ARG_UNUSED(scan_pdu);
		ARG_UNUSED(upd);
#endif /* !CONFIG_BT_CTLR_PRIVACY */

		radio_isr_set(isr_tx, lll);
    7d9a:	480e      	ldr	r0, [pc, #56]	; (7dd4 <chan_prepare.isra.0+0x104>)
    7d9c:	4621      	mov	r1, r4
    7d9e:	f000 fa01 	bl	81a4 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
    7da2:	2096      	movs	r0, #150	; 0x96
    7da4:	f000 fc24 	bl	85f0 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
    7da8:	2000      	movs	r0, #0
    7daa:	f000 fb7f 	bl	84ac <radio_switch_complete_and_rx>
		radio_isr_set(isr_done, lll);
		radio_switch_complete_and_disable();
	}

	return pdu;
}
    7dae:	b002      	add	sp, #8
    7db0:	bd70      	pop	{r4, r5, r6, pc}
		radio_isr_set(isr_done, lll);
    7db2:	4809      	ldr	r0, [pc, #36]	; (7dd8 <chan_prepare.isra.0+0x108>)
    7db4:	4621      	mov	r1, r4
    7db6:	f000 f9f5 	bl	81a4 <radio_isr_set>
		radio_switch_complete_and_disable();
    7dba:	f000 fb9f 	bl	84fc <radio_switch_complete_and_disable>
	return pdu;
    7dbe:	e7f6      	b.n	7dae <chan_prepare.isra.0+0xde>
    7dc0:	00011b34 	.word	0x00011b34
    7dc4:	00011b98 	.word	0x00011b98
    7dc8:	00010f78 	.word	0x00010f78
    7dcc:	00011ba2 	.word	0x00011ba2
    7dd0:	00011b9d 	.word	0x00011b9d
    7dd4:	00007a15 	.word	0x00007a15
    7dd8:	0000e82d 	.word	0x0000e82d

00007ddc <prepare_cb>:
{
    7ddc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	lll = p->param;
    7dde:	68c4      	ldr	r4, [r0, #12]
{
    7de0:	4605      	mov	r5, r0
	radio_reset();
    7de2:	f000 f9ff 	bl	81e4 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    7de6:	2000      	movs	r0, #0
    7de8:	f000 fa30 	bl	824c <radio_tx_power_set>
	radio_phy_set(0, 0);
    7dec:	2100      	movs	r1, #0
    7dee:	4608      	mov	r0, r1
    7df0:	f000 fa1c 	bl	822c <radio_phy_set>
	radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, PDU_AC_LEG_PAYLOAD_SIZE_MAX,
    7df4:	2200      	movs	r2, #0
    7df6:	2125      	movs	r1, #37	; 0x25
    7df8:	2008      	movs	r0, #8
    7dfa:	f000 fa5d 	bl	82b8 <radio_pkt_configure>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    7dfe:	4b2e      	ldr	r3, [pc, #184]	; (7eb8 <prepare_cb+0xdc>)
    7e00:	9301      	str	r3, [sp, #4]
	radio_aa_set((uint8_t *)&aa);
    7e02:	a801      	add	r0, sp, #4
    7e04:	f000 fa40 	bl	8288 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
    7e08:	492c      	ldr	r1, [pc, #176]	; (7ebc <prepare_cb+0xe0>)
    7e0a:	f240 605b 	movw	r0, #1627	; 0x65b
    7e0e:	f000 fac7 	bl	83a0 <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
    7e12:	7923      	ldrb	r3, [r4, #4]
    7e14:	f3c3 0202 	ubfx	r2, r3, #0, #3
    7e18:	f362 03c5 	bfi	r3, r2, #3, #3
    7e1c:	7123      	strb	r3, [r4, #4]
	pdu = chan_prepare(lll);
    7e1e:	4620      	mov	r0, r4
    7e20:	f7ff ff56 	bl	7cd0 <chan_prepare.isra.0>
	if (ull_filter_lll_rl_enabled()) {
    7e24:	f7ff f9d8 	bl	71d8 <ull_filter_lll_rl_enabled>
    7e28:	7923      	ldrb	r3, [r4, #4]
    7e2a:	b360      	cbz	r0, 7e86 <prepare_cb+0xaa>
			ull_filter_lll_get(!!(lll->filter_policy));
    7e2c:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    7e30:	bf14      	ite	ne
    7e32:	2001      	movne	r0, #1
    7e34:	2000      	moveq	r0, #0
		struct lll_filter *fal = ull_filter_lll_get(true);
    7e36:	f7fe fdbb 	bl	69b0 <ull_filter_lll_get>
		radio_filter_configure(fal->enable_bitmask,
    7e3a:	7841      	ldrb	r1, [r0, #1]
    7e3c:	1c82      	adds	r2, r0, #2
    7e3e:	7800      	ldrb	r0, [r0, #0]
    7e40:	f000 fb7c 	bl	853c <radio_filter_configure>
	ull = HDR_LLL2ULL(lll);
    7e44:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
    7e46:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
    7e48:	4638      	mov	r0, r7
    7e4a:	f006 fc8e 	bl	e76a <lll_event_offset_get>
    7e4e:	4406      	add	r6, r0
	start_us = radio_tmr_start(1, ticks_at_start, remainder);
    7e50:	686a      	ldr	r2, [r5, #4]
    7e52:	f106 0109 	add.w	r1, r6, #9
    7e56:	2001      	movs	r0, #1
    7e58:	f000 fbd6 	bl	8608 <radio_tmr_start>
	radio_tmr_end_capture();
    7e5c:	f000 fc5a 	bl	8714 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
    7e60:	4620      	mov	r0, r4
    7e62:	f7fe fb95 	bl	6590 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_ADV_BASE +
    7e66:	1c81      	adds	r1, r0, #2
    7e68:	4632      	mov	r2, r6
    7e6a:	b2c9      	uxtb	r1, r1
    7e6c:	4638      	mov	r0, r7
    7e6e:	f006 fc8a 	bl	e786 <lll_preempt_calc>
    7e72:	b168      	cbz	r0, 7e90 <prepare_cb+0xb4>
		radio_isr_set(isr_abort, lll);
    7e74:	4812      	ldr	r0, [pc, #72]	; (7ec0 <prepare_cb+0xe4>)
    7e76:	4621      	mov	r1, r4
    7e78:	f000 f994 	bl	81a4 <radio_isr_set>
		radio_disable();
    7e7c:	f000 fa54 	bl	8328 <radio_disable>
}
    7e80:	2000      	movs	r0, #0
    7e82:	b003      	add	sp, #12
    7e84:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) && lll->filter_policy) {
    7e86:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    7e8a:	d0db      	beq.n	7e44 <prepare_cb+0x68>
		struct lll_filter *fal = ull_filter_lll_get(true);
    7e8c:	2001      	movs	r0, #1
    7e8e:	e7d2      	b.n	7e36 <prepare_cb+0x5a>
		ret = lll_prepare_done(lll);
    7e90:	4620      	mov	r0, r4
    7e92:	f006 fc68 	bl	e766 <lll_prepare_done>
		LL_ASSERT(!ret);
    7e96:	2800      	cmp	r0, #0
    7e98:	d0f2      	beq.n	7e80 <prepare_cb+0xa4>
    7e9a:	4a0a      	ldr	r2, [pc, #40]	; (7ec4 <prepare_cb+0xe8>)
    7e9c:	490a      	ldr	r1, [pc, #40]	; (7ec8 <prepare_cb+0xec>)
    7e9e:	480b      	ldr	r0, [pc, #44]	; (7ecc <prepare_cb+0xf0>)
    7ea0:	f240 33cf 	movw	r3, #975	; 0x3cf
    7ea4:	f004 ffab 	bl	cdfe <printk>
    7ea8:	4040      	eors	r0, r0
    7eaa:	f380 8811 	msr	BASEPRI, r0
    7eae:	f04f 0003 	mov.w	r0, #3
    7eb2:	df02      	svc	2
    7eb4:	e7e4      	b.n	7e80 <prepare_cb+0xa4>
    7eb6:	bf00      	nop
    7eb8:	8e89bed6 	.word	0x8e89bed6
    7ebc:	00555555 	.word	0x00555555
    7ec0:	0000e7d3 	.word	0x0000e7d3
    7ec4:	00011b34 	.word	0x00011b34
    7ec8:	00011648 	.word	0x00011648
    7ecc:	00010f78 	.word	0x00010f78

00007ed0 <lll_adv_prepare>:
{
    7ed0:	b513      	push	{r0, r1, r4, lr}
    7ed2:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    7ed4:	f7ff fd6c 	bl	79b0 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
    7ed8:	2800      	cmp	r0, #0
    7eda:	da0c      	bge.n	7ef6 <lll_adv_prepare+0x26>
    7edc:	4a12      	ldr	r2, [pc, #72]	; (7f28 <lll_adv_prepare+0x58>)
    7ede:	4913      	ldr	r1, [pc, #76]	; (7f2c <lll_adv_prepare+0x5c>)
    7ee0:	4813      	ldr	r0, [pc, #76]	; (7f30 <lll_adv_prepare+0x60>)
    7ee2:	f44f 7326 	mov.w	r3, #664	; 0x298
    7ee6:	f004 ff8a 	bl	cdfe <printk>
    7eea:	4040      	eors	r0, r0
    7eec:	f380 8811 	msr	BASEPRI, r0
    7ef0:	f04f 0003 	mov.w	r0, #3
    7ef4:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
    7ef6:	4a0f      	ldr	r2, [pc, #60]	; (7f34 <lll_adv_prepare+0x64>)
    7ef8:	490f      	ldr	r1, [pc, #60]	; (7f38 <lll_adv_prepare+0x68>)
    7efa:	4810      	ldr	r0, [pc, #64]	; (7f3c <lll_adv_prepare+0x6c>)
    7efc:	9400      	str	r4, [sp, #0]
    7efe:	2300      	movs	r3, #0
    7f00:	f006 fae8 	bl	e4d4 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    7f04:	b170      	cbz	r0, 7f24 <lll_adv_prepare+0x54>
    7f06:	3077      	adds	r0, #119	; 0x77
    7f08:	d00c      	beq.n	7f24 <lll_adv_prepare+0x54>
    7f0a:	4a07      	ldr	r2, [pc, #28]	; (7f28 <lll_adv_prepare+0x58>)
    7f0c:	490c      	ldr	r1, [pc, #48]	; (7f40 <lll_adv_prepare+0x70>)
    7f0e:	4808      	ldr	r0, [pc, #32]	; (7f30 <lll_adv_prepare+0x60>)
    7f10:	f240 239b 	movw	r3, #667	; 0x29b
    7f14:	f004 ff73 	bl	cdfe <printk>
    7f18:	4040      	eors	r0, r0
    7f1a:	f380 8811 	msr	BASEPRI, r0
    7f1e:	f04f 0003 	mov.w	r0, #3
    7f22:	df02      	svc	2
}
    7f24:	b002      	add	sp, #8
    7f26:	bd10      	pop	{r4, pc}
    7f28:	00011b34 	.word	0x00011b34
    7f2c:	00011ae4 	.word	0x00011ae4
    7f30:	00010f78 	.word	0x00010f78
    7f34:	00007ddd 	.word	0x00007ddd
    7f38:	00007add 	.word	0x00007add
    7f3c:	0000e7cd 	.word	0x0000e7cd
    7f40:	00011ba6 	.word	0x00011ba6

00007f44 <isr_rx>:
{
    7f44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7f48:	b085      	sub	sp, #20
    7f4a:	4604      	mov	r4, r0
	trx_done = radio_is_done();
    7f4c:	f000 fa14 	bl	8378 <radio_is_done>
	if (trx_done) {
    7f50:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
    7f54:	d073      	beq.n	803e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3e>
		crc_ok = radio_crc_is_valid();
    7f56:	f000 fa2f 	bl	83b8 <radio_crc_is_valid>
    7f5a:	fa5f f980 	uxtb.w	r9, r0
		devmatch_ok = radio_filter_has_match();
    7f5e:	f000 fb1b 	bl	8598 <radio_filter_has_match>
    7f62:	b2c7      	uxtb	r7, r0
		devmatch_id = radio_filter_match_get();
    7f64:	f000 fb22 	bl	85ac <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
    7f68:	f000 fc26 	bl	87b8 <radio_ar_has_match>
    7f6c:	fa5f f880 	uxtb.w	r8, r0
		irkmatch_id = radio_ar_match_get();
    7f70:	f000 fc0a 	bl	8788 <radio_ar_match_get>
    7f74:	b2c6      	uxtb	r6, r0
		rssi_ready = radio_rssi_is_ready();
    7f76:	f000 fad7 	bl	8528 <radio_rssi_is_ready>
	lll_isr_status_reset();
    7f7a:	f006 fc1a 	bl	e7b2 <lll_isr_status_reset>
	if (!trx_done) {
    7f7e:	2d00      	cmp	r5, #0
    7f80:	d064      	beq.n	804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>
	if (crc_ok) {
    7f82:	f1b9 0f00 	cmp.w	r9, #0
    7f86:	d061      	beq.n	804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>
	uint8_t rx_addr;
	uint8_t *tgt_addr;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	uint8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    7f88:	f1b8 0f00 	cmp.w	r8, #0
    7f8c:	d05c      	beq.n	8048 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x48>
    7f8e:	4630      	mov	r0, r6
    7f90:	f7ff f87a 	bl	7088 <ull_filter_lll_rl_irk_idx>
    7f94:	f88d 000f 	strb.w	r0, [sp, #15]
				    FILTER_IDX_NONE;
#else
	uint8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	node_rx = ull_pdu_rx_alloc_peek(1);
    7f98:	2001      	movs	r0, #1
    7f9a:	f7fd feb1 	bl	5d00 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    7f9e:	4605      	mov	r5, r0
    7fa0:	b960      	cbnz	r0, 7fbc <isr_rx+0x78>
    7fa2:	4a2f      	ldr	r2, [pc, #188]	; (8060 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x60>)
    7fa4:	492f      	ldr	r1, [pc, #188]	; (8064 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x64>)
    7fa6:	4830      	ldr	r0, [pc, #192]	; (8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>)
    7fa8:	f44f 63af 	mov.w	r3, #1400	; 0x578
    7fac:	f004 ff27 	bl	cdfe <printk>
    7fb0:	4040      	eors	r0, r0
    7fb2:	f380 8811 	msr	BASEPRI, r0
    7fb6:	f04f 0003 	mov.w	r0, #3
    7fba:	df02      	svc	2
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
    7fbc:	7a23      	ldrb	r3, [r4, #8]
    7fbe:	eb04 0383 	add.w	r3, r4, r3, lsl #2

	pdu_rx = (void *)node_rx->pdu;
    7fc2:	f105 011c 	add.w	r1, r5, #28
    7fc6:	68de      	ldr	r6, [r3, #12]
	pdu_adv = lll_adv_data_curr_get(lll);

	addr = pdu_adv->adv_ind.addr;
    7fc8:	4633      	mov	r3, r6
	tx_addr = pdu_adv->tx_addr;
    7fca:	f813 0b02 	ldrb.w	r0, [r3], #2
    7fce:	f3c0 1280 	ubfx	r2, r0, #6, #1

	if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
    7fd2:	f000 000f 	and.w	r0, r0, #15
    7fd6:	2801      	cmp	r0, #1
	} else {
		tgt_addr = NULL;
	}
	rx_addr = pdu_adv->rx_addr;

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
    7fd8:	7f28      	ldrb	r0, [r5, #28]
    7fda:	f000 000f 	and.w	r0, r0, #15
		tgt_addr = pdu_adv->direct_ind.tgt_addr;
    7fde:	bf0c      	ite	eq
    7fe0:	3608      	addeq	r6, #8
		tgt_addr = NULL;
    7fe2:	2600      	movne	r6, #0
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
    7fe4:	2803      	cmp	r0, #3
    7fe6:	d131      	bne.n	804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>
    7fe8:	7f68      	ldrb	r0, [r5, #29]
    7fea:	280c      	cmp	r0, #12
    7fec:	d12e      	bne.n	804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
    7fee:	bb6e      	cbnz	r6, 804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>
	    (tgt_addr == NULL) &&
	    lll_adv_scan_req_check(lll, pdu_rx, tx_addr, addr, devmatch_ok,
    7ff0:	f10d 000f 	add.w	r0, sp, #15
    7ff4:	e9cd 7000 	strd	r7, r0, [sp]
    7ff8:	4620      	mov	r0, r4
    7ffa:	f006 fc2f 	bl	e85c <lll_adv_scan_req_check>
	    (tgt_addr == NULL) &&
    7ffe:	b328      	cbz	r0, 804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>
				    &rl_idx)) {
		radio_isr_set(isr_done, lll);
    8000:	4621      	mov	r1, r4
    8002:	481a      	ldr	r0, [pc, #104]	; (806c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x6c>)
    8004:	f000 f8ce 	bl	81a4 <radio_isr_set>
		radio_switch_complete_and_disable();
    8008:	f000 fa78 	bl	84fc <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
    800c:	7d20      	ldrb	r0, [r4, #20]
    800e:	eb04 0480 	add.w	r4, r4, r0, lsl #2
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
    8012:	69a0      	ldr	r0, [r4, #24]
    8014:	f000 f97c 	bl	8310 <radio_pkt_tx_set>

		/* assert if radio packet ptr is not set and radio started tx */
		LL_ASSERT(!radio_is_ready());
    8018:	f000 f9a4 	bl	8364 <radio_is_ready>
    801c:	b160      	cbz	r0, 8038 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x38>
    801e:	4a10      	ldr	r2, [pc, #64]	; (8060 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x60>)
    8020:	4913      	ldr	r1, [pc, #76]	; (8070 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x70>)
    8022:	4811      	ldr	r0, [pc, #68]	; (8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>)
    8024:	f240 5391 	movw	r3, #1425	; 0x591
    8028:	f004 fee9 	bl	cdfe <printk>
    802c:	4040      	eors	r0, r0
    802e:	f380 8811 	msr	BASEPRI, r0
    8032:	f04f 0003 	mov.w	r0, #3
    8036:	df02      	svc	2
}
    8038:	b005      	add	sp, #20
    803a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
    803e:	46a9      	mov	r9, r5
    8040:	46a8      	mov	r8, r5
    8042:	462f      	mov	r7, r5
		devmatch_id = irkmatch_id = 0xFF;
    8044:	26ff      	movs	r6, #255	; 0xff
    8046:	e798      	b.n	7f7a <isr_rx+0x36>
	uint8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    8048:	20ff      	movs	r0, #255	; 0xff
    804a:	e7a3      	b.n	7f94 <isr_rx+0x50>
	radio_isr_set(isr_done, param);
    804c:	4807      	ldr	r0, [pc, #28]	; (806c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x6c>)
    804e:	4621      	mov	r1, r4
    8050:	f000 f8a8 	bl	81a4 <radio_isr_set>
}
    8054:	b005      	add	sp, #20
    8056:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	radio_disable();
    805a:	f000 b965 	b.w	8328 <radio_disable>
    805e:	bf00      	nop
    8060:	00011b34 	.word	0x00011b34
    8064:	00011b7e 	.word	0x00011b7e
    8068:	00010f78 	.word	0x00010f78
    806c:	0000e82d 	.word	0x0000e82d
    8070:	00011b86 	.word	0x00011b86

00008074 <cntr_init>:

static uint8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
    8074:	4b05      	ldr	r3, [pc, #20]	; (808c <cntr_init+0x18>)
    8076:	2200      	movs	r2, #0
    8078:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    807c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    8080:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
    8084:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
    8088:	4770      	bx	lr
    808a:	bf00      	nop
    808c:	4000b000 	.word	0x4000b000

00008090 <cntr_start>:

uint32_t cntr_start(void)
{
	if (_refcount++) {
    8090:	4a04      	ldr	r2, [pc, #16]	; (80a4 <cntr_start+0x14>)
    8092:	7813      	ldrb	r3, [r2, #0]
    8094:	1c59      	adds	r1, r3, #1
    8096:	7011      	strb	r1, [r2, #0]
    8098:	2001      	movs	r0, #1
    809a:	b913      	cbnz	r3, 80a2 <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    809c:	4a02      	ldr	r2, [pc, #8]	; (80a8 <cntr_start+0x18>)
    809e:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
    80a0:	4618      	mov	r0, r3
}
    80a2:	4770      	bx	lr
    80a4:	20001e2e 	.word	0x20001e2e
    80a8:	4000b000 	.word	0x4000b000

000080ac <cntr_stop>:

uint32_t cntr_stop(void)
{
    80ac:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
    80ae:	4c0d      	ldr	r4, [pc, #52]	; (80e4 <cntr_stop+0x38>)
    80b0:	7823      	ldrb	r3, [r4, #0]
    80b2:	b95b      	cbnz	r3, 80cc <cntr_stop+0x20>
    80b4:	4a0c      	ldr	r2, [pc, #48]	; (80e8 <cntr_stop+0x3c>)
    80b6:	490d      	ldr	r1, [pc, #52]	; (80ec <cntr_stop+0x40>)
    80b8:	480d      	ldr	r0, [pc, #52]	; (80f0 <cntr_stop+0x44>)
    80ba:	232d      	movs	r3, #45	; 0x2d
    80bc:	f004 fe9f 	bl	cdfe <printk>
    80c0:	4040      	eors	r0, r0
    80c2:	f380 8811 	msr	BASEPRI, r0
    80c6:	f04f 0003 	mov.w	r0, #3
    80ca:	df02      	svc	2

	if (--_refcount) {
    80cc:	7820      	ldrb	r0, [r4, #0]
    80ce:	3801      	subs	r0, #1
    80d0:	b2c0      	uxtb	r0, r0
    80d2:	7020      	strb	r0, [r4, #0]
    80d4:	2301      	movs	r3, #1
    80d6:	b910      	cbnz	r0, 80de <cntr_stop+0x32>
    80d8:	4a06      	ldr	r2, [pc, #24]	; (80f4 <cntr_stop+0x48>)
    80da:	6053      	str	r3, [r2, #4]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
    80dc:	bd10      	pop	{r4, pc}
		return 1;
    80de:	4618      	mov	r0, r3
    80e0:	e7fc      	b.n	80dc <cntr_stop+0x30>
    80e2:	bf00      	nop
    80e4:	20001e2e 	.word	0x20001e2e
    80e8:	00011bca 	.word	0x00011bca
    80ec:	00011c16 	.word	0x00011c16
    80f0:	00010f78 	.word	0x00010f78
    80f4:	4000b000 	.word	0x4000b000

000080f8 <cntr_cnt_get>:
     return p_reg->COUNTER;
    80f8:	4b01      	ldr	r3, [pc, #4]	; (8100 <cntr_cnt_get+0x8>)
    80fa:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

uint32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
    80fe:	4770      	bx	lr
    8100:	4000b000 	.word	0x4000b000

00008104 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
    8104:	4b02      	ldr	r3, [pc, #8]	; (8110 <cntr_cmp_set+0xc>)
    8106:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    810a:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(uint8_t cmp, uint32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
    810e:	4770      	bx	lr
    8110:	4000b000 	.word	0x4000b000

00008114 <do_ecb>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8114:	4b10      	ldr	r3, [pc, #64]	; (8158 <do_ecb+0x44>)
	uint8_t clear_text[16];
	uint8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
    8116:	b530      	push	{r4, r5, lr}
    8118:	2201      	movs	r2, #1
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
		NRF_ECB->EVENTS_ENDECB = 0;
    811a:	2400      	movs	r4, #0
    811c:	605a      	str	r2, [r3, #4]
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
    811e:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
    8122:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
    8126:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
    812a:	601a      	str	r2, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    812c:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    8130:	b931      	cbnz	r1, 8140 <do_ecb+0x2c>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    8132:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    8136:	b919      	cbnz	r1, 8140 <do_ecb+0x2c>
		       (NRF_ECB->ECBDATAPTR != 0)) {
    8138:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    813c:	2900      	cmp	r1, #0
    813e:	d1f5      	bne.n	812c <do_ecb+0x18>
    8140:	605a      	str	r2, [r3, #4]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
    8142:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
    8146:	2900      	cmp	r1, #0
    8148:	d1e8      	bne.n	811c <do_ecb+0x8>
    814a:	f8d3 5504 	ldr.w	r5, [r3, #1284]	; 0x504
    814e:	2d00      	cmp	r5, #0
    8150:	d0e4      	beq.n	811c <do_ecb+0x8>

	NRF_ECB->ECBDATAPTR = 0;
    8152:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
}
    8156:	bd30      	pop	{r4, r5, pc}
    8158:	4000e000 	.word	0x4000e000

0000815c <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(uint8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
    815c:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
    815e:	4b08      	ldr	r3, [pc, #32]	; (8180 <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
    8160:	bf14      	ite	ne
    8162:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
    8166:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
    816a:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
    816e:	bf14      	ite	ne
    8170:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
    8174:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
    8178:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
    817c:	4770      	bx	lr
    817e:	bf00      	nop
    8180:	4001f000 	.word	0x4001f000

00008184 <isr_radio>:
}
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

uint32_t radio_has_disabled(void)
{
	return (NRF_RADIO->EVENTS_DISABLED != 0);
    8184:	4b04      	ldr	r3, [pc, #16]	; (8198 <isr_radio+0x14>)
    8186:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
    818a:	b123      	cbz	r3, 8196 <isr_radio+0x12>
		isr_cb(isr_cb_param);
    818c:	4b03      	ldr	r3, [pc, #12]	; (819c <isr_radio+0x18>)
    818e:	4a04      	ldr	r2, [pc, #16]	; (81a0 <isr_radio+0x1c>)
    8190:	681b      	ldr	r3, [r3, #0]
    8192:	6810      	ldr	r0, [r2, #0]
    8194:	4718      	bx	r3
}
    8196:	4770      	bx	lr
    8198:	40001000 	.word	0x40001000
    819c:	20001998 	.word	0x20001998
    81a0:	2000199c 	.word	0x2000199c

000081a4 <radio_isr_set>:
{
    81a4:	b538      	push	{r3, r4, r5, lr}
    81a6:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
    81a8:	2001      	movs	r0, #1
{
    81aa:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
    81ac:	f7fa f80a 	bl	21c4 <arch_irq_disable>
	isr_cb_param = param;
    81b0:	4b08      	ldr	r3, [pc, #32]	; (81d4 <radio_isr_set+0x30>)
    81b2:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
    81b4:	4b08      	ldr	r3, [pc, #32]	; (81d8 <radio_isr_set+0x34>)
    81b6:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    81b8:	4b08      	ldr	r3, [pc, #32]	; (81dc <radio_isr_set+0x38>)
    81ba:	2210      	movs	r2, #16
    81bc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    81c0:	4b07      	ldr	r3, [pc, #28]	; (81e0 <radio_isr_set+0x3c>)
    81c2:	2202      	movs	r2, #2
    81c4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
    81c8:	2001      	movs	r0, #1
}
    81ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
    81ce:	f7f9 bfe9 	b.w	21a4 <arch_irq_enable>
    81d2:	bf00      	nop
    81d4:	2000199c 	.word	0x2000199c
    81d8:	20001998 	.word	0x20001998
    81dc:	40001000 	.word	0x40001000
    81e0:	e000e100 	.word	0xe000e100

000081e4 <radio_reset>:
{
    81e4:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
    81e6:	2001      	movs	r0, #1
    81e8:	f7f9 ffec 	bl	21c4 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (radio_power ? RADIO_POWER_POWER_Enabled : RADIO_POWER_POWER_Disabled)
    81ec:	4a0d      	ldr	r2, [pc, #52]	; (8224 <radio_reset+0x40>)
    81ee:	2300      	movs	r3, #0
    81f0:	f8c2 3ffc 	str.w	r3, [r2, #4092]	; 0xffc
    81f4:	2301      	movs	r3, #1
    81f6:	f8c2 3ffc 	str.w	r3, [r2, #4092]	; 0xffc
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

static inline void hal_radio_reset(void)
{
	/* Anomalies 102, 106 and 107 */
	*(volatile uint32_t *)0x40001774 = ((*(volatile uint32_t *)0x40001774) &
    81fa:	f8d2 3774 	ldr.w	r3, [r2, #1908]	; 0x774
					 0xfffffffe) | 0x01000000;
    81fe:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    8202:	f023 0301 	bic.w	r3, r3, #1
    8206:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile uint32_t *)0x40001774 = ((*(volatile uint32_t *)0x40001774) &
    820a:	f8c2 3774 	str.w	r3, [r2, #1908]	; 0x774
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
    820e:	4b06      	ldr	r3, [pc, #24]	; (8228 <radio_reset+0x44>)
    8210:	f44f 5290 	mov.w	r2, #4608	; 0x1200
    8214:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		BIT(HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(0)) |
#if defined(CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE)
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PHYEND_DELAY_COMPENSATION_PPI(0)) |
#endif /* CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE */
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PPI(0));
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
    8218:	f44f 5210 	mov.w	r2, #9216	; 0x2400
    821c:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
    8220:	bd08      	pop	{r3, pc}
    8222:	bf00      	nop
    8224:	40001000 	.word	0x40001000
    8228:	4001f000 	.word	0x4001f000

0000822c <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
    822c:	4b06      	ldr	r3, [pc, #24]	; (8248 <radio_phy_set+0x1c>)
	default:
		mode = RADIO_MODE_MODE_Ble_1Mbit;
		break;

	case BIT(1):
		mode = RADIO_MODE_MODE_Ble_2Mbit;
    822e:	2802      	cmp	r0, #2
    8230:	bf14      	ite	ne
    8232:	2203      	movne	r2, #3
    8234:	2204      	moveq	r2, #4
    8236:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
    823a:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
    823e:	f042 0201 	orr.w	r2, r2, #1
    8242:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
    8246:	4770      	bx	lr
    8248:	40001000 	.word	0x40001000

0000824c <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (uint32_t)power;
    824c:	4b01      	ldr	r3, [pc, #4]	; (8254 <radio_tx_power_set+0x8>)
    824e:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
    8252:	4770      	bx	lr
    8254:	40001000 	.word	0x40001000

00008258 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
    8258:	4b01      	ldr	r3, [pc, #4]	; (8260 <radio_freq_chan_set+0x8>)
    825a:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
    825e:	4770      	bx	lr
    8260:	40001000 	.word	0x40001000

00008264 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
    8264:	4b07      	ldr	r3, [pc, #28]	; (8284 <radio_whiten_iv_set+0x20>)
    8266:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
    826a:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    826e:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
    8272:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
    8276:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    827a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    827e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    8282:	4770      	bx	lr
    8284:	40001000 	.word	0x40001000

00008288 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
    8288:	4a0a      	ldr	r2, [pc, #40]	; (82b4 <radio_aa_set+0x2c>)
    828a:	2300      	movs	r3, #0
    828c:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
    8290:	2301      	movs	r3, #1
    8292:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
    8296:	78c3      	ldrb	r3, [r0, #3]
    8298:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
    829c:	7843      	ldrb	r3, [r0, #1]
    829e:	7881      	ldrb	r1, [r0, #2]
    82a0:	041b      	lsls	r3, r3, #16
    82a2:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    82a6:	7801      	ldrb	r1, [r0, #0]
    82a8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    82ac:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
    82b0:	4770      	bx	lr
    82b2:	bf00      	nop
    82b4:	40001000 	.word	0x40001000

000082b8 <radio_pkt_configure>:
	switch (phy) {
    82b8:	f3c2 0342 	ubfx	r3, r2, #1, #3
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
    82bc:	2b02      	cmp	r3, #2
    82be:	bf14      	ite	ne
    82c0:	2300      	movne	r3, #0
    82c2:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
	if (pdu_type == RADIO_PKT_CONF_PDU_TYPE_DC) {
    82c6:	07d2      	lsls	r2, r2, #31
		extra |= (RADIO_PCNF0_S1INCL_Include <<
    82c8:	bf48      	it	mi
    82ca:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
		((((uint32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) & RADIO_PCNF0_LFLEN_Msk) |
    82ce:	f000 000f 	and.w	r0, r0, #15
		((((uint32_t)bits_s1) << RADIO_PCNF0_S1LEN_Pos) & RADIO_PCNF0_S1LEN_Msk) | extra;
    82d2:	4318      	orrs	r0, r3
	NRF_RADIO->PCNF0 =
    82d4:	4b09      	ldr	r3, [pc, #36]	; (82fc <radio_pkt_configure+0x44>)
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
    82d6:	4a0a      	ldr	r2, [pc, #40]	; (8300 <radio_pkt_configure+0x48>)
		((((uint32_t)bits_s1) << RADIO_PCNF0_S1LEN_Pos) & RADIO_PCNF0_S1LEN_Msk) | extra;
    82d8:	f440 7080 	orr.w	r0, r0, #256	; 0x100
	NRF_RADIO->PCNF0 =
    82dc:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
    82e0:	f8d3 0518 	ldr.w	r0, [r3, #1304]	; 0x518
    82e4:	4002      	ands	r2, r0
    82e6:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |=
    82ea:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    82ee:	4311      	orrs	r1, r2
    82f0:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
    82f4:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
}
    82f8:	4770      	bx	lr
    82fa:	bf00      	nop
    82fc:	40001000 	.word	0x40001000
    8300:	fef80000 	.word	0xfef80000

00008304 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (uint32_t)rx_packet;
    8304:	4b01      	ldr	r3, [pc, #4]	; (830c <radio_pkt_rx_set+0x8>)
    8306:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
    830a:	4770      	bx	lr
    830c:	40001000 	.word	0x40001000

00008310 <radio_pkt_tx_set>:
    8310:	4b01      	ldr	r3, [pc, #4]	; (8318 <radio_pkt_tx_set+0x8>)
    8312:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
    8316:	4770      	bx	lr
    8318:	40001000 	.word	0x40001000

0000831c <radio_tx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    831c:	4b01      	ldr	r3, [pc, #4]	; (8324 <radio_tx_enable+0x8>)
    831e:	2201      	movs	r2, #1
    8320:	601a      	str	r2, [r3, #0]
}
    8322:	4770      	bx	lr
    8324:	40001000 	.word	0x40001000

00008328 <radio_disable>:
    p_reg->CHENCLR = mask;
    8328:	4a07      	ldr	r2, [pc, #28]	; (8348 <radio_disable+0x20>)
    832a:	f44f 6310 	mov.w	r3, #2304	; 0x900
    832e:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
    8332:	2301      	movs	r3, #1
    8334:	6053      	str	r3, [r2, #4]
    8336:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
    8338:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
    833c:	2100      	movs	r1, #0
    833e:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    8342:	6113      	str	r3, [r2, #16]
}
    8344:	4770      	bx	lr
    8346:	bf00      	nop
    8348:	4001f000 	.word	0x4001f000

0000834c <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
    834c:	4b04      	ldr	r3, [pc, #16]	; (8360 <radio_status_reset+0x14>)
    834e:	2200      	movs	r2, #0
    8350:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
    8354:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
    8358:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
    835c:	4770      	bx	lr
    835e:	bf00      	nop
    8360:	40001000 	.word	0x40001000

00008364 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
    8364:	4b03      	ldr	r3, [pc, #12]	; (8374 <radio_is_ready+0x10>)
    8366:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
    836a:	3800      	subs	r0, #0
    836c:	bf18      	it	ne
    836e:	2001      	movne	r0, #1
    8370:	4770      	bx	lr
    8372:	bf00      	nop
    8374:	40001000 	.word	0x40001000

00008378 <radio_is_done>:
	return (NRF_RADIO->NRF_RADIO_TXRX_END_EVENT != 0);
    8378:	4b03      	ldr	r3, [pc, #12]	; (8388 <radio_is_done+0x10>)
    837a:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
    837e:	3800      	subs	r0, #0
    8380:	bf18      	it	ne
    8382:	2001      	movne	r0, #1
    8384:	4770      	bx	lr
    8386:	bf00      	nop
    8388:	40001000 	.word	0x40001000

0000838c <radio_is_idle>:
}

uint32_t radio_is_idle(void)
{
	return (NRF_RADIO->STATE == 0);
    838c:	4b03      	ldr	r3, [pc, #12]	; (839c <radio_is_idle+0x10>)
    838e:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
    8392:	fab0 f080 	clz	r0, r0
    8396:	0940      	lsrs	r0, r0, #5
    8398:	4770      	bx	lr
    839a:	bf00      	nop
    839c:	40001000 	.word	0x40001000

000083a0 <radio_crc_configure>:

void radio_crc_configure(uint32_t polynomial, uint32_t iv)
{
	NRF_RADIO->CRCCNF =
    83a0:	4b04      	ldr	r3, [pc, #16]	; (83b4 <radio_crc_configure+0x14>)
    83a2:	f240 1203 	movw	r2, #259	; 0x103
    83a6:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	    (((RADIO_CRCCNF_SKIPADDR_Skip) << RADIO_CRCCNF_SKIPADDR_Pos) &
	     RADIO_CRCCNF_SKIPADDR_Msk) |
	    (((RADIO_CRCCNF_LEN_Three) << RADIO_CRCCNF_LEN_Pos) &
	       RADIO_CRCCNF_LEN_Msk);
	NRF_RADIO->CRCPOLY = polynomial;
    83aa:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
    83ae:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
    83b2:	4770      	bx	lr
    83b4:	40001000 	.word	0x40001000

000083b8 <radio_crc_is_valid>:

uint32_t radio_crc_is_valid(void)
{
	return (NRF_RADIO->CRCSTATUS != 0);
    83b8:	4b03      	ldr	r3, [pc, #12]	; (83c8 <radio_crc_is_valid+0x10>)
    83ba:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    83be:	3800      	subs	r0, #0
    83c0:	bf18      	it	ne
    83c2:	2001      	movne	r0, #1
    83c4:	4770      	bx	lr
    83c6:	bf00      	nop
    83c8:	40001000 	.word	0x40001000

000083cc <sw_switch>:
 *                         direction to next direction.
 */
void sw_switch(uint8_t dir_curr, uint8_t dir_next, uint8_t phy_curr, uint8_t flags_curr,
	       uint8_t phy_next, uint8_t flags_next,
	       enum radio_end_evt_delay_state end_evt_delay_en)
{
    83cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
    83ce:	4d31      	ldr	r5, [pc, #196]	; (8494 <sw_switch+0xc8>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
    83d0:	4f31      	ldr	r7, [pc, #196]	; (8498 <sw_switch+0xcc>)
    83d2:	782e      	ldrb	r6, [r5, #0]
    83d4:	f8df e0c4 	ldr.w	lr, [pc, #196]	; 849c <sw_switch+0xd0>
{
    83d8:	f89d c014 	ldrb.w	ip, [sp, #20]
    83dc:	f8c7 e568 	str.w	lr, [r7, #1384]	; 0x568
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
    83e0:	00f3      	lsls	r3, r6, #3
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
    83e2:	f106 040c 	add.w	r4, r6, #12
    83e6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    83ea:	b2e4      	uxtb	r4, r4
    83ec:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
    83f0:	00e4      	lsls	r4, r4, #3
    83f2:	f8c7 356c 	str.w	r3, [r7, #1388]	; 0x56c
	nrf_ppi_event_endpoint_setup(
    83f6:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
    83fa:	4b29      	ldr	r3, [pc, #164]	; (84a0 <sw_switch+0xd4>)
    83fc:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
    8400:	eb03 0386 	add.w	r3, r3, r6, lsl #2

	/* NOTE: As constants are passed to dir_curr and dir_next, the
	 *       compiler should optimize out the redundant code path
	 *       during the optimization.
	 */
	if (dir_next == SW_SWITCH_TX) {
    8404:	2901      	cmp	r1, #1
    8406:	ea4f 0786 	mov.w	r7, r6, lsl #2
    p_reg->CH[(uint32_t) channel].EEP = eep;
    840a:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
    840e:	d13b      	bne.n	8488 <sw_switch+0xbc>
		/* TX */

		/* Calculate delay with respect to current and next PHY.
		 */
		if (dir_curr == SW_SWITCH_TX) {
    8410:	2801      	cmp	r0, #1
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_2M_NS;
    8412:	f24a 035a 	movw	r3, #41050	; 0xa05a
    8416:	d126      	bne.n	8466 <sw_switch+0x9a>
    8418:	f649 4240 	movw	r2, #40000	; 0x9c40
    841c:	f1bc 0f02 	cmp.w	ip, #2
    8420:	bf08      	it	eq
    8422:	4613      	moveq	r3, r2
			delay = HAL_RADIO_NS2US_ROUND(
    8424:	f203 13f5 	addw	r3, r3, #501	; 0x1f5
			hal_radio_b2b_txen_on_sw_switch(ppi);
		} else {
			/* If RX PHY is LE Coded, calculate for S8 coding.
			 * Assumption being, S8 has higher delay.
			 */
			delay = HAL_RADIO_NS2US_ROUND(
    8428:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    842c:	fbb3 f3f2 	udiv	r3, r3, r2
    p_reg->CH[(uint32_t) channel].TEP = tep;
    8430:	4a1c      	ldr	r2, [pc, #112]	; (84a4 <sw_switch+0xd8>)
    8432:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay < SW_SWITCH_TIMER->CC[cc]) {
    8436:	f107 4280 	add.w	r2, r7, #1073741824	; 0x40000000
    843a:	f502 4210 	add.w	r2, r2, #36864	; 0x9000
    843e:	f8d2 1540 	ldr.w	r1, [r2, #1344]	; 0x540
    8442:	4299      	cmp	r1, r3
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 (SW_SWITCH_TIMER->CC[cc] - delay));
    8444:	bf8a      	itet	hi
    8446:	f8d2 1540 	ldrhi.w	r1, [r2, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
    844a:	2301      	movls	r3, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
    844c:	1acb      	subhi	r3, r1, r3
    844e:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    p_reg->CHENSET = mask;
    8452:	4b11      	ldr	r3, [pc, #68]	; (8498 <sw_switch+0xcc>)
    8454:	f44f 6210 	mov.w	r2, #2304	; 0x900
    8458:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 */
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* !CONFIG_SOC_SERIES_NRF53X */
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
    845c:	1c73      	adds	r3, r6, #1
	sw_tifs_toggle &= 1U;
    845e:	f003 0301 	and.w	r3, r3, #1
    8462:	702b      	strb	r3, [r5, #0]
}
    8464:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8466:	f649 4140 	movw	r1, #40000	; 0x9c40
    846a:	f1bc 0f02 	cmp.w	ip, #2
    846e:	bf08      	it	eq
    8470:	460b      	moveq	r3, r1
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_2M_NS;
    8472:	f241 504a 	movw	r0, #5450	; 0x154a
    8476:	f242 41b8 	movw	r1, #9400	; 0x24b8
    847a:	2a02      	cmp	r2, #2
    847c:	bf08      	it	eq
    847e:	4601      	moveq	r1, r0
			delay = HAL_RADIO_NS2US_ROUND(
    8480:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
    8484:	440b      	add	r3, r1
    8486:	e7cf      	b.n	8428 <sw_switch+0x5c>
    p_reg->CH[(uint32_t) channel].TEP = tep;
    8488:	4b07      	ldr	r3, [pc, #28]	; (84a8 <sw_switch+0xdc>)
    848a:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
		delay = HAL_RADIO_NS2US_CEIL(
    848e:	232d      	movs	r3, #45	; 0x2d
}
    8490:	e7d1      	b.n	8436 <sw_switch+0x6a>
    8492:	bf00      	nop
    8494:	20001e2f 	.word	0x20001e2f
    8498:	4001f000 	.word	0x4001f000
    849c:	4000110c 	.word	0x4000110c
    84a0:	40009140 	.word	0x40009140
    84a4:	40001000 	.word	0x40001000
    84a8:	40001004 	.word	0x40001004

000084ac <radio_switch_complete_and_rx>:
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(uint8_t phy_rx)
{
    84ac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
    84ae:	4b08      	ldr	r3, [pc, #32]	; (84d0 <radio_switch_complete_and_rx+0x24>)
    84b0:	2203      	movs	r2, #3
    84b2:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

	/* NOTE: As Tx chain delays are negligible constant values (~1 us)
	 *	 across nRF5x radios, sw_switch assumes the 1M chain delay for
	 *       calculations.
	 */
	sw_switch(SW_SWITCH_TX, SW_SWITCH_RX, SW_SWITCH_PHY_1M, SW_SWITCH_FLAGS_DONTCARE, phy_rx,
    84b6:	2300      	movs	r3, #0
    84b8:	9000      	str	r0, [sp, #0]
    84ba:	e9cd 3301 	strd	r3, r3, [sp, #4]
    84be:	461a      	mov	r2, r3
    84c0:	4619      	mov	r1, r3
    84c2:	2001      	movs	r0, #1
    84c4:	f7ff ff82 	bl	83cc <sw_switch>
		  SW_SWITCH_FLAGS_DONTCARE, END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    84c8:	b005      	add	sp, #20
    84ca:	f85d fb04 	ldr.w	pc, [sp], #4
    84ce:	bf00      	nop
    84d0:	40001000 	.word	0x40001000

000084d4 <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(uint8_t phy_rx, uint8_t flags_rx,
				  uint8_t phy_tx, uint8_t flags_tx)
{
    84d4:	b530      	push	{r4, r5, lr}
    84d6:	4604      	mov	r4, r0
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
    84d8:	4807      	ldr	r0, [pc, #28]	; (84f8 <radio_switch_complete_and_tx+0x24>)
{
    84da:	b085      	sub	sp, #20
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
    84dc:	2503      	movs	r5, #3
    84de:	f8c0 5200 	str.w	r5, [r0, #512]	; 0x200

	sw_switch(SW_SWITCH_RX, SW_SWITCH_TX, phy_rx, flags_rx, phy_tx, flags_tx,
    84e2:	2000      	movs	r0, #0
    84e4:	e9cd 3001 	strd	r3, r0, [sp, #4]
    84e8:	9200      	str	r2, [sp, #0]
    84ea:	460b      	mov	r3, r1
    84ec:	4622      	mov	r2, r4
    84ee:	2101      	movs	r1, #1
    84f0:	f7ff ff6c 	bl	83cc <sw_switch>
		  END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    84f4:	b005      	add	sp, #20
    84f6:	bd30      	pop	{r4, r5, pc}
    84f8:	40001000 	.word	0x40001000

000084fc <radio_switch_complete_and_disable>:
void radio_switch_complete_and_disable(void)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);
#else /* CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE);
    84fc:	4b05      	ldr	r3, [pc, #20]	; (8514 <radio_switch_complete_and_disable+0x18>)
    84fe:	2203      	movs	r2, #3
    8500:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
    8504:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
    8508:	f44f 6210 	mov.w	r2, #2304	; 0x900
    850c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    8510:	4770      	bx	lr
    8512:	bf00      	nop
    8514:	40001000 	.word	0x40001000

00008518 <radio_rssi_status_reset>:
	return NRF_RADIO->RSSISAMPLE;
}

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
    8518:	4b02      	ldr	r3, [pc, #8]	; (8524 <radio_rssi_status_reset+0xc>)
    851a:	2200      	movs	r2, #0
    851c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
    8520:	4770      	bx	lr
    8522:	bf00      	nop
    8524:	40001000 	.word	0x40001000

00008528 <radio_rssi_is_ready>:

uint32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
    8528:	4b03      	ldr	r3, [pc, #12]	; (8538 <radio_rssi_is_ready+0x10>)
    852a:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
    852e:	3800      	subs	r0, #0
    8530:	bf18      	it	ne
    8532:	2001      	movne	r0, #1
    8534:	4770      	bx	lr
    8536:	bf00      	nop
    8538:	40001000 	.word	0x40001000

0000853c <radio_filter_configure>:

void radio_filter_configure(uint8_t bitmask_enable, uint8_t bitmask_addr_type,
			    uint8_t *bdaddr)
{
    853c:	b5f0      	push	{r4, r5, r6, r7, lr}
    853e:	2400      	movs	r4, #0
    8540:	2706      	movs	r7, #6
    8542:	fb07 f304 	mul.w	r3, r7, r4
    8546:	18d5      	adds	r5, r2, r3
	uint8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((uint32_t)bdaddr[3] << 24) |
			((uint32_t)bdaddr[2] << 16) |
			((uint32_t)bdaddr[1] << 8) |
    8548:	58d6      	ldr	r6, [r2, r3]
    854a:	00a3      	lsls	r3, r4, #2
    854c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8550:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
	for (index = 0U; index < 8; index++) {
    8554:	3401      	adds	r4, #1
		NRF_RADIO->DAB[index] = ((uint32_t)bdaddr[3] << 24) |
    8556:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((uint32_t)bdaddr[5] << 8) | bdaddr[4];
    855a:	88ad      	ldrh	r5, [r5, #4]
    855c:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
	for (index = 0U; index < 8; index++) {
    8560:	2c08      	cmp	r4, #8
    8562:	d1ee      	bne.n	8542 <radio_filter_configure+0x6>
		bdaddr += 6;
	}

	NRF_RADIO->DACNF = ((uint32_t)bitmask_addr_type << 8) | bitmask_enable;
    8564:	4b02      	ldr	r3, [pc, #8]	; (8570 <radio_filter_configure+0x34>)
    8566:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    856a:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
    856e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8570:	40001000 	.word	0x40001000

00008574 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
    8574:	4a03      	ldr	r2, [pc, #12]	; (8584 <radio_filter_disable+0x10>)
    8576:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
    857a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    857e:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
    8582:	4770      	bx	lr
    8584:	40001000 	.word	0x40001000

00008588 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
    8588:	4b02      	ldr	r3, [pc, #8]	; (8594 <radio_filter_status_reset+0xc>)
    858a:	2200      	movs	r2, #0
    858c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    8590:	4770      	bx	lr
    8592:	bf00      	nop
    8594:	40001000 	.word	0x40001000

00008598 <radio_filter_has_match>:

uint32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
    8598:	4b03      	ldr	r3, [pc, #12]	; (85a8 <radio_filter_has_match+0x10>)
    859a:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
    859e:	3800      	subs	r0, #0
    85a0:	bf18      	it	ne
    85a2:	2001      	movne	r0, #1
    85a4:	4770      	bx	lr
    85a6:	bf00      	nop
    85a8:	40001000 	.word	0x40001000

000085ac <radio_filter_match_get>:

uint32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
    85ac:	4b01      	ldr	r3, [pc, #4]	; (85b4 <radio_filter_match_get+0x8>)
    85ae:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
    85b2:	4770      	bx	lr
    85b4:	40001000 	.word	0x40001000

000085b8 <radio_bc_configure>:
    p_reg->BCC = radio_bcc;
    85b8:	4b04      	ldr	r3, [pc, #16]	; (85cc <radio_bc_configure+0x14>)
    85ba:	f8c3 0560 	str.w	r0, [r3, #1376]	; 0x560

void radio_bc_configure(uint32_t n)
{
	nrf_radio_bcc_set(NRF_RADIO, n);
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
    85be:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    85c2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    85c6:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
    85ca:	4770      	bx	lr
    85cc:	40001000 	.word	0x40001000

000085d0 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    85d0:	4b05      	ldr	r3, [pc, #20]	; (85e8 <radio_tmr_status_reset+0x18>)
    85d2:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    85d6:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
    85da:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
    85de:	4a03      	ldr	r2, [pc, #12]	; (85ec <radio_tmr_status_reset+0x1c>)
    85e0:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
#endif /* CONFIG_BT_CTLR_PHY_CODED */
#if defined(CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE)
			BIT(HAL_SW_SWITCH_TIMER_PHYEND_DELAY_COMPENSATION_DISABLE_PPI) |
#endif /* CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
    85e4:	4770      	bx	lr
    85e6:	bf00      	nop
    85e8:	4000b000 	.word	0x4000b000
    85ec:	0e7000c0 	.word	0x0e7000c0

000085f0 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(uint32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
    85f0:	4b03      	ldr	r3, [pc, #12]	; (8600 <radio_tmr_tifs_set+0x10>)
    85f2:	4a04      	ldr	r2, [pc, #16]	; (8604 <radio_tmr_tifs_set+0x14>)
    85f4:	781b      	ldrb	r3, [r3, #0]
    85f6:	f503 73a8 	add.w	r3, r3, #336	; 0x150
    85fa:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    85fe:	4770      	bx	lr
    8600:	20001e2f 	.word	0x20001e2f
    8604:	40009000 	.word	0x40009000

00008608 <radio_tmr_start>:

uint32_t radio_tmr_start(uint8_t trx, uint32_t ticks_start, uint32_t remainder)
{
    8608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
    860a:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
    860e:	4c2f      	ldr	r4, [pc, #188]	; (86cc <radio_tmr_start+0xc4>)
    8610:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
    8614:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
    8616:	bf88      	it	hi
    8618:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    861c:	4b2c      	ldr	r3, [pc, #176]	; (86d0 <radio_tmr_start+0xc8>)
	}
	remainder /= 1000000UL;
    861e:	4c2d      	ldr	r4, [pc, #180]	; (86d4 <radio_tmr_start+0xcc>)
		remainder += 30517578UL;
    8620:	bf84      	itt	hi
    8622:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
    8626:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
    862a:	f04f 0501 	mov.w	r5, #1

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
    862e:	f04f 0600 	mov.w	r6, #0
	remainder /= 1000000UL;
    8632:	fbb2 f4f4 	udiv	r4, r2, r4
	EVENT_TIMER->PRESCALER = 4;
    8636:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
    863a:	f04f 0202 	mov.w	r2, #2
    863e:	60dd      	str	r5, [r3, #12]
	EVENT_TIMER->MODE = 0;
    8640:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	EVENT_TIMER->PRESCALER = 4;
    8644:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
    8648:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    864c:	4a22      	ldr	r2, [pc, #136]	; (86d8 <radio_tmr_start+0xd0>)
    p_reg->CC[cc_channel] = cc_value;
    864e:	f8c3 4540 	str.w	r4, [r3, #1344]	; 0x540
		ticks_start--;
    8652:	bf88      	it	hi
    8654:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
    8658:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
    865c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    8660:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
    8664:	491d      	ldr	r1, [pc, #116]	; (86dc <radio_tmr_start+0xd4>)
    8666:	f502 72a4 	add.w	r2, r2, #328	; 0x148
    866a:	f8c1 2540 	str.w	r2, [r1, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
    866e:	f8c1 3544 	str.w	r3, [r1, #1348]	; 0x544
    p_reg->CHENSET = mask;
    8672:	2340      	movs	r3, #64	; 0x40
    8674:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
    8678:	f7ff fd70 	bl	815c <hal_radio_enable_on_tick_ppi_config_and_enable>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    867c:	4b18      	ldr	r3, [pc, #96]	; (86e0 <radio_tmr_start+0xd8>)
    867e:	60dd      	str	r5, [r3, #12]
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
    8680:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
    8684:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
    8688:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
    868c:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
    868e:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
    8692:	3b74      	subs	r3, #116	; 0x74
    8694:	f8c1 3550 	str.w	r3, [r1, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
    8698:	f503 43fe 	add.w	r3, r3, #32512	; 0x7f00
    869c:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
    86a0:	f503 739a 	add.w	r3, r3, #308	; 0x134
    86a4:	f8c1 3558 	str.w	r3, [r1, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
    86a8:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
    86ac:	33c4      	adds	r3, #196	; 0xc4
    86ae:	f8c1 355c 	str.w	r3, [r1, #1372]	; 0x55c
    p_reg->CH[(uint32_t) channel].EEP = eep;
    86b2:	f5a3 33af 	sub.w	r3, r3, #89600	; 0x15e00
    86b6:	3bc0      	subs	r3, #192	; 0xc0
    86b8:	f8c1 3560 	str.w	r3, [r1, #1376]	; 0x560
    p_reg->CH[(uint32_t) channel].TEP = tep;
    86bc:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
    86c0:	33c8      	adds	r3, #200	; 0xc8
    86c2:	f8c1 3564 	str.w	r3, [r1, #1380]	; 0x564
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
    86c6:	4620      	mov	r0, r4
    86c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    86ca:	bf00      	nop
    86cc:	7ff0bdbf 	.word	0x7ff0bdbf
    86d0:	40008000 	.word	0x40008000
    86d4:	000f4240 	.word	0x000f4240
    86d8:	4000b000 	.word	0x4000b000
    86dc:	4001f000 	.word	0x4001f000
    86e0:	40009000 	.word	0x40009000

000086e4 <radio_tmr_stop>:
    86e4:	4a04      	ldr	r2, [pc, #16]	; (86f8 <radio_tmr_stop+0x14>)
    86e6:	2301      	movs	r3, #1
    86e8:	6053      	str	r3, [r2, #4]
    86ea:	6113      	str	r3, [r2, #16]
    86ec:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    86f0:	6053      	str	r3, [r2, #4]
    86f2:	6113      	str	r3, [r2, #16]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    86f4:	4770      	bx	lr
    86f6:	bf00      	nop
    86f8:	40008000 	.word	0x40008000

000086fc <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
    86fc:	4b04      	ldr	r3, [pc, #16]	; (8710 <radio_tmr_hcto_configure+0x14>)
    86fe:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
    8702:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
    8706:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
    870a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
    870e:	4770      	bx	lr
    8710:	40008000 	.word	0x40008000

00008714 <radio_tmr_end_capture>:
    8714:	4b02      	ldr	r3, [pc, #8]	; (8720 <radio_tmr_end_capture+0xc>)
    8716:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    871a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* !CONFIG_SOC_SERIES_NRF53X ||
	* (CONFIG_SOC_SERIES_NRF53X && !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	*/
}
    871e:	4770      	bx	lr
    8720:	4001f000 	.word	0x4001f000

00008724 <radio_tmr_tifs_base_get>:
    8724:	4b01      	ldr	r3, [pc, #4]	; (872c <radio_tmr_tifs_base_get+0x8>)
    8726:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
    872a:	4770      	bx	lr
    872c:	40008000 	.word	0x40008000

00008730 <radio_ar_configure>:
}

static uint8_t MALIGN(4) _aar_scratch[3];

void radio_ar_configure(uint32_t nirk, void *irk, uint8_t flags)
{
    8730:	b538      	push	{r3, r4, r5, lr}
	if (IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) &&
	    ((flags & BIT(1)) || (!(flags & BIT(0)) && (phy > PHY_1M)))) {
		addrptr = NRF_RADIO->PACKETPTR + 1;
		bcc = 80;
	} else {
		addrptr = NRF_RADIO->PACKETPTR - 1;
    8732:	4c11      	ldr	r4, [pc, #68]	; (8778 <radio_ar_configure+0x48>)
	/* For Coded PHY adjust for CI and TERM1 */
	if (IS_ENABLED(CONFIG_BT_CTLR_PHY_CODED) && (phy == PHY_CODED)) {
		bcc += 5;
	}

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
    8734:	4b11      	ldr	r3, [pc, #68]	; (877c <radio_ar_configure+0x4c>)
		addrptr = NRF_RADIO->PACKETPTR - 1;
    8736:	f8d4 2504 	ldr.w	r2, [r4, #1284]	; 0x504
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
    873a:	2503      	movs	r5, #3
		addrptr = NRF_RADIO->PACKETPTR - 1;
    873c:	3a01      	subs	r2, #1
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
    873e:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
	NRF_AAR->NIRK = nirk;
    8742:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_AAR->IRKPTR = (uint32_t)irk;
    8746:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	NRF_AAR->ADDRPTR = addrptr;
    874a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_AAR->SCRATCHPTR = (uint32_t)&_aar_scratch[0];

	NRF_AAR->EVENTS_END = 0;
    874e:	2100      	movs	r1, #0
	NRF_AAR->SCRATCHPTR = (uint32_t)&_aar_scratch[0];
    8750:	4a0b      	ldr	r2, [pc, #44]	; (8780 <radio_ar_configure+0x50>)
    8752:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	NRF_AAR->EVENTS_RESOLVED = 0;
	NRF_AAR->EVENTS_NOTRESOLVED = 0;

	radio_bc_configure(bcc);
    8756:	2040      	movs	r0, #64	; 0x40
	NRF_AAR->EVENTS_END = 0;
    8758:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
    875c:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
    8760:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
	radio_bc_configure(bcc);
    8764:	f7ff ff28 	bl	85b8 <radio_bc_configure>
    8768:	4b06      	ldr	r3, [pc, #24]	; (8784 <radio_ar_configure+0x54>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
    876a:	f8c4 1128 	str.w	r1, [r4, #296]	; 0x128
    876e:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    8772:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	radio_bc_status_reset();

	hal_trigger_aar_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}
    8776:	bd38      	pop	{r3, r4, r5, pc}
    8778:	40001000 	.word	0x40001000
    877c:	4000f000 	.word	0x4000f000
    8780:	20001994 	.word	0x20001994
    8784:	4001f000 	.word	0x4001f000

00008788 <radio_ar_match_get>:

uint32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
    8788:	4b01      	ldr	r3, [pc, #4]	; (8790 <radio_ar_match_get+0x8>)
    878a:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    878e:	4770      	bx	lr
    8790:	4000f000 	.word	0x4000f000

00008794 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
    8794:	4a06      	ldr	r2, [pc, #24]	; (87b0 <radio_ar_status_reset+0x1c>)
    8796:	2300      	movs	r3, #0
    8798:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
    879c:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    87a0:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
    p_reg->CHENCLR = mask;
    87a4:	4b03      	ldr	r3, [pc, #12]	; (87b4 <radio_ar_status_reset+0x20>)
    87a6:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    87aa:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			  AAR_ENABLE_ENABLE_Msk;

	hal_radio_nrf_ppi_channels_disable(BIT(HAL_TRIGGER_AAR_PPI));
}
    87ae:	4770      	bx	lr
    87b0:	40001000 	.word	0x40001000
    87b4:	4001f000 	.word	0x4001f000

000087b8 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
    87b8:	4b08      	ldr	r3, [pc, #32]	; (87dc <radio_ar_has_match+0x24>)
    87ba:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

uint32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
    87be:	b160      	cbz	r0, 87da <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
    87c0:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    87c4:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
    87c8:	b138      	cbz	r0, 87da <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
    87ca:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
    87ce:	b120      	cbz	r0, 87da <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
    87d0:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
    87d4:	fab0 f080 	clz	r0, r0
    87d8:	0940      	lsrs	r0, r0, #5
}
    87da:	4770      	bx	lr
    87dc:	40001000 	.word	0x40001000

000087e0 <mayfly_enable_cb>:

void mayfly_enable_cb(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    87e0:	2902      	cmp	r1, #2
{
    87e2:	b510      	push	{r4, lr}
    87e4:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    87e6:	d00b      	beq.n	8800 <mayfly_enable_cb+0x20>
    87e8:	4a0a      	ldr	r2, [pc, #40]	; (8814 <mayfly_enable_cb+0x34>)
    87ea:	490b      	ldr	r1, [pc, #44]	; (8818 <mayfly_enable_cb+0x38>)
    87ec:	480b      	ldr	r0, [pc, #44]	; (881c <mayfly_enable_cb+0x3c>)
    87ee:	231e      	movs	r3, #30
    87f0:	f004 fb05 	bl	cdfe <printk>
    87f4:	4040      	eors	r0, r0
    87f6:	f380 8811 	msr	BASEPRI, r0
    87fa:	f04f 0003 	mov.w	r0, #3
    87fe:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
    8800:	200b      	movs	r0, #11
	if (enable) {
    8802:	b11c      	cbz	r4, 880c <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
    8804:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
    8808:	f7f9 bccc 	b.w	21a4 <arch_irq_enable>
}
    880c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
    8810:	f7f9 bcd8 	b.w	21c4 <arch_irq_disable>
    8814:	00011c41 	.word	0x00011c41
    8818:	00011c8f 	.word	0x00011c8f
    881c:	00010f78 	.word	0x00010f78

00008820 <mayfly_is_enabled>:

uint32_t mayfly_is_enabled(uint8_t caller_id, uint8_t callee_id)
{
    8820:	b508      	push	{r3, lr}
	(void)caller_id;

	switch (callee_id) {
    8822:	b181      	cbz	r1, 8846 <mayfly_is_enabled+0x26>
    8824:	3901      	subs	r1, #1
    8826:	2901      	cmp	r1, #1
    8828:	d912      	bls.n	8850 <mayfly_is_enabled+0x30>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
    882a:	4a0a      	ldr	r2, [pc, #40]	; (8854 <mayfly_is_enabled+0x34>)
    882c:	490a      	ldr	r1, [pc, #40]	; (8858 <mayfly_is_enabled+0x38>)
    882e:	480b      	ldr	r0, [pc, #44]	; (885c <mayfly_is_enabled+0x3c>)
    8830:	2336      	movs	r3, #54	; 0x36
    8832:	f004 fae4 	bl	cdfe <printk>
    8836:	4040      	eors	r0, r0
    8838:	f380 8811 	msr	BASEPRI, r0
    883c:	f04f 0003 	mov.w	r0, #3
    8840:	df02      	svc	2
		break;
	}

	return 0;
}
    8842:	2000      	movs	r0, #0
    8844:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
    8846:	2018      	movs	r0, #24
}
    8848:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
    884c:	f7f9 bcce 	b.w	21ec <arch_irq_is_enabled>
    8850:	200b      	movs	r0, #11
    8852:	e7f9      	b.n	8848 <mayfly_is_enabled+0x28>
    8854:	00011c41 	.word	0x00011c41
    8858:	00011d2c 	.word	0x00011d2c
    885c:	00010f78 	.word	0x00010f78

00008860 <mayfly_pend>:

void mayfly_pend(uint8_t caller_id, uint8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
    8860:	2901      	cmp	r1, #1
{
    8862:	b508      	push	{r3, lr}
	switch (callee_id) {
    8864:	d008      	beq.n	8878 <mayfly_pend+0x18>
    8866:	2902      	cmp	r1, #2
    8868:	d006      	beq.n	8878 <mayfly_pend+0x18>
    886a:	b949      	cbnz	r1, 8880 <mayfly_pend+0x20>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    886c:	4b0b      	ldr	r3, [pc, #44]	; (889c <mayfly_pend+0x3c>)
    886e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    8872:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

	default:
		LL_ASSERT(0);
		break;
	}
}
    8876:	bd08      	pop	{r3, pc}
    8878:	4b08      	ldr	r3, [pc, #32]	; (889c <mayfly_pend+0x3c>)
    887a:	f44f 6200 	mov.w	r2, #2048	; 0x800
    887e:	e7f8      	b.n	8872 <mayfly_pend+0x12>
		LL_ASSERT(0);
    8880:	4a07      	ldr	r2, [pc, #28]	; (88a0 <mayfly_pend+0x40>)
    8882:	4908      	ldr	r1, [pc, #32]	; (88a4 <mayfly_pend+0x44>)
    8884:	4808      	ldr	r0, [pc, #32]	; (88a8 <mayfly_pend+0x48>)
    8886:	2367      	movs	r3, #103	; 0x67
    8888:	f004 fab9 	bl	cdfe <printk>
    888c:	4040      	eors	r0, r0
    888e:	f380 8811 	msr	BASEPRI, r0
    8892:	f04f 0003 	mov.w	r0, #3
    8896:	df02      	svc	2
}
    8898:	e7ed      	b.n	8876 <mayfly_pend+0x16>
    889a:	bf00      	nop
    889c:	e000e100 	.word	0xe000e100
    88a0:	00011c41 	.word	0x00011c41
    88a4:	00011d2c 	.word	0x00011d2c
    88a8:	00010f78 	.word	0x00010f78

000088ac <hal_ticker_instance0_caller_id_get>:

uint8_t hal_ticker_instance0_caller_id_get(uint8_t user_id)
{
	uint8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
    88ac:	2803      	cmp	r0, #3
{
    88ae:	b510      	push	{r4, lr}
    88b0:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
    88b2:	d90b      	bls.n	88cc <hal_ticker_instance0_caller_id_get+0x20>
    88b4:	4a0e      	ldr	r2, [pc, #56]	; (88f0 <hal_ticker_instance0_caller_id_get+0x44>)
    88b6:	490f      	ldr	r1, [pc, #60]	; (88f4 <hal_ticker_instance0_caller_id_get+0x48>)
    88b8:	480f      	ldr	r0, [pc, #60]	; (88f8 <hal_ticker_instance0_caller_id_get+0x4c>)
    88ba:	232b      	movs	r3, #43	; 0x2b
    88bc:	f004 fa9f 	bl	cdfe <printk>
    88c0:	4040      	eors	r0, r0
    88c2:	f380 8811 	msr	BASEPRI, r0
    88c6:	f04f 0003 	mov.w	r0, #3
    88ca:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
    88cc:	4b0b      	ldr	r3, [pc, #44]	; (88fc <hal_ticker_instance0_caller_id_get+0x50>)
    88ce:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
    88d0:	b95c      	cbnz	r4, 88ea <hal_ticker_instance0_caller_id_get+0x3e>
    88d2:	4a07      	ldr	r2, [pc, #28]	; (88f0 <hal_ticker_instance0_caller_id_get+0x44>)
    88d4:	490a      	ldr	r1, [pc, #40]	; (8900 <hal_ticker_instance0_caller_id_get+0x54>)
    88d6:	4808      	ldr	r0, [pc, #32]	; (88f8 <hal_ticker_instance0_caller_id_get+0x4c>)
    88d8:	232e      	movs	r3, #46	; 0x2e
    88da:	f004 fa90 	bl	cdfe <printk>
    88de:	4040      	eors	r0, r0
    88e0:	f380 8811 	msr	BASEPRI, r0
    88e4:	f04f 0003 	mov.w	r0, #3
    88e8:	df02      	svc	2

	return caller_id;
}
    88ea:	4620      	mov	r0, r4
    88ec:	bd10      	pop	{r4, pc}
    88ee:	bf00      	nop
    88f0:	00011cb1 	.word	0x00011cb1
    88f4:	00011cff 	.word	0x00011cff
    88f8:	00010f78 	.word	0x00010f78
    88fc:	00011d41 	.word	0x00011d41
    8900:	00011d1f 	.word	0x00011d1f

00008904 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
    8904:	3801      	subs	r0, #1
{
    8906:	b510      	push	{r4, lr}
    8908:	461c      	mov	r4, r3
	switch (caller_id) {
    890a:	2804      	cmp	r0, #4
    890c:	d845      	bhi.n	899a <hal_ticker_instance0_sched+0x96>
    890e:	e8df f000 	tbb	[pc, r0]
    8912:	1a03      	.short	0x1a03
    8914:	2c23      	.short	0x2c23
    8916:	3b          	.byte	0x3b
    8917:	00          	.byte	0x00
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
    8918:	2904      	cmp	r1, #4
    891a:	d107      	bne.n	892c <hal_ticker_instance0_sched+0x28>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
    891c:	4b20      	ldr	r3, [pc, #128]	; (89a0 <hal_ticker_instance0_sched+0x9c>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
    891e:	2102      	movs	r1, #2
			m.param = instance;
    8920:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
    8922:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
    8924:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    8928:	f7fb bdde 	b.w	44e8 <mayfly_enqueue>
			LL_ASSERT(0);
    892c:	234e      	movs	r3, #78	; 0x4e
		LL_ASSERT(0);
    892e:	4a1d      	ldr	r2, [pc, #116]	; (89a4 <hal_ticker_instance0_sched+0xa0>)
    8930:	491d      	ldr	r1, [pc, #116]	; (89a8 <hal_ticker_instance0_sched+0xa4>)
    8932:	481e      	ldr	r0, [pc, #120]	; (89ac <hal_ticker_instance0_sched+0xa8>)
    8934:	f004 fa63 	bl	cdfe <printk>
    8938:	4040      	eors	r0, r0
    893a:	f380 8811 	msr	BASEPRI, r0
    893e:	f04f 0003 	mov.w	r0, #3
    8942:	df02      	svc	2
}
    8944:	bd10      	pop	{r4, pc}
		switch (callee_id) {
    8946:	2903      	cmp	r1, #3
    8948:	d104      	bne.n	8954 <hal_ticker_instance0_sched+0x50>
			m.param = instance;
    894a:	4b19      	ldr	r3, [pc, #100]	; (89b0 <hal_ticker_instance0_sched+0xac>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
    894c:	2101      	movs	r1, #1
			m.param = instance;
    894e:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    8950:	4608      	mov	r0, r1
    8952:	e7e7      	b.n	8924 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    8954:	2365      	movs	r3, #101	; 0x65
    8956:	e7ea      	b.n	892e <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
    8958:	2904      	cmp	r1, #4
    895a:	d104      	bne.n	8966 <hal_ticker_instance0_sched+0x62>
			m.param = instance;
    895c:	4b15      	ldr	r3, [pc, #84]	; (89b4 <hal_ticker_instance0_sched+0xb0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
    895e:	2102      	movs	r1, #2
			m.param = instance;
    8960:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
    8962:	2001      	movs	r0, #1
    8964:	e7de      	b.n	8924 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    8966:	237c      	movs	r3, #124	; 0x7c
    8968:	e7e1      	b.n	892e <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
    896a:	2903      	cmp	r1, #3
    896c:	d003      	beq.n	8976 <hal_ticker_instance0_sched+0x72>
    896e:	2904      	cmp	r1, #4
    8970:	d006      	beq.n	8980 <hal_ticker_instance0_sched+0x7c>
			LL_ASSERT(0);
    8972:	23a2      	movs	r3, #162	; 0xa2
    8974:	e7db      	b.n	892e <hal_ticker_instance0_sched+0x2a>
			m.param = instance;
    8976:	4b10      	ldr	r3, [pc, #64]	; (89b8 <hal_ticker_instance0_sched+0xb4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    8978:	2101      	movs	r1, #1
			m.param = instance;
    897a:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    897c:	2002      	movs	r0, #2
    897e:	e7d1      	b.n	8924 <hal_ticker_instance0_sched+0x20>
			m.param = instance;
    8980:	4b0e      	ldr	r3, [pc, #56]	; (89bc <hal_ticker_instance0_sched+0xb8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    8982:	2102      	movs	r1, #2
			m.param = instance;
    8984:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    8986:	e7e3      	b.n	8950 <hal_ticker_instance0_sched+0x4c>
		switch (callee_id) {
    8988:	2904      	cmp	r1, #4
    898a:	d104      	bne.n	8996 <hal_ticker_instance0_sched+0x92>
			m.param = instance;
    898c:	4b0c      	ldr	r3, [pc, #48]	; (89c0 <hal_ticker_instance0_sched+0xbc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    898e:	2102      	movs	r1, #2
			m.param = instance;
    8990:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    8992:	2003      	movs	r0, #3
    8994:	e7c6      	b.n	8924 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    8996:	23ba      	movs	r3, #186	; 0xba
    8998:	e7c9      	b.n	892e <hal_ticker_instance0_sched+0x2a>
		LL_ASSERT(0);
    899a:	23c0      	movs	r3, #192	; 0xc0
    899c:	e7c7      	b.n	892e <hal_ticker_instance0_sched+0x2a>
    899e:	bf00      	nop
    89a0:	20000394 	.word	0x20000394
    89a4:	00011cb1 	.word	0x00011cb1
    89a8:	00011d2c 	.word	0x00011d2c
    89ac:	00010f78 	.word	0x00010f78
    89b0:	20000384 	.word	0x20000384
    89b4:	200003d4 	.word	0x200003d4
    89b8:	200003c4 	.word	0x200003c4
    89bc:	200003b4 	.word	0x200003b4
    89c0:	200003a4 	.word	0x200003a4

000089c4 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
    89c4:	4b02      	ldr	r3, [pc, #8]	; (89d0 <net_buf_pool_get+0xc>)
    89c6:	222c      	movs	r2, #44	; 0x2c
    89c8:	fb02 3000 	mla	r0, r2, r0, r3
    89cc:	4770      	bx	lr
    89ce:	bf00      	nop
    89d0:	200005c4 	.word	0x200005c4

000089d4 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    89d4:	7982      	ldrb	r2, [r0, #6]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
				__alignof__(struct net_buf));
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
    89d6:	4b06      	ldr	r3, [pc, #24]	; (89f0 <net_buf_id+0x1c>)
    89d8:	212c      	movs	r1, #44	; 0x2c
    89da:	fb01 3302 	mla	r3, r1, r2, r3
    89de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
    89e0:	7f1b      	ldrb	r3, [r3, #28]
    89e2:	3317      	adds	r3, #23
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
    89e4:	1a80      	subs	r0, r0, r2
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
    89e6:	f023 0303 	bic.w	r3, r3, #3

	return offset / struct_size;
}
    89ea:	fbb0 f0f3 	udiv	r0, r0, r3
    89ee:	4770      	bx	lr
    89f0:	200005c4 	.word	0x200005c4

000089f4 <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static uint8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
    89f4:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    89f6:	4b0a      	ldr	r3, [pc, #40]	; (8a20 <fixed_data_alloc+0x2c>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    89f8:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    89fa:	242c      	movs	r4, #44	; 0x2c
    89fc:	fb04 3302 	mla	r3, r4, r2, r3

	*size = MIN(fixed->data_size, *size);
    8a00:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    8a02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8a04:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
    8a06:	6823      	ldr	r3, [r4, #0]
    8a08:	429a      	cmp	r2, r3
    8a0a:	bf94      	ite	ls
    8a0c:	600a      	strls	r2, [r1, #0]
    8a0e:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    8a10:	f7ff ffe0 	bl	89d4 <net_buf_id>
    8a14:	e9d4 2300 	ldrd	r2, r3, [r4]
}
    8a18:	fb02 3000 	mla	r0, r2, r0, r3
    8a1c:	bd10      	pop	{r4, pc}
    8a1e:	bf00      	nop
    8a20:	200005c4 	.word	0x200005c4

00008a24 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
    8a24:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8a28:	4605      	mov	r5, r0
    8a2a:	9101      	str	r1, [sp, #4]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    8a2c:	4610      	mov	r0, r2
    8a2e:	4619      	mov	r1, r3
{
    8a30:	4691      	mov	r9, r2
    8a32:	4698      	mov	r8, r3
    8a34:	4617      	mov	r7, r2
    8a36:	461e      	mov	r6, r3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    8a38:	f007 f8b3 	bl	fba2 <sys_clock_timeout_end_calc>
    8a3c:	4682      	mov	sl, r0
    8a3e:	468b      	mov	fp, r1
	__asm__ volatile(
    8a40:	f04f 0320 	mov.w	r3, #32
    8a44:	f3ef 8111 	mrs	r1, BASEPRI
    8a48:	f383 8812 	msr	BASEPRI_MAX, r3
    8a4c:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    8a50:	8b6b      	ldrh	r3, [r5, #26]
    8a52:	2b00      	cmp	r3, #0
    8a54:	d05a      	beq.n	8b0c <net_buf_alloc_len+0xe8>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    8a56:	8b2a      	ldrh	r2, [r5, #24]
    8a58:	429a      	cmp	r2, r3
    8a5a:	d93e      	bls.n	8ada <net_buf_alloc_len+0xb6>
    8a5c:	9100      	str	r1, [sp, #0]
	return z_impl_k_queue_get(queue, timeout);
    8a5e:	2200      	movs	r2, #0
    8a60:	2300      	movs	r3, #0
    8a62:	4628      	mov	r0, r5
    8a64:	f003 f934 	bl	bcd0 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
    8a68:	9900      	ldr	r1, [sp, #0]
    8a6a:	4604      	mov	r4, r0
    8a6c:	2800      	cmp	r0, #0
    8a6e:	d034      	beq.n	8ada <net_buf_alloc_len+0xb6>
	__asm__ volatile(
    8a70:	f381 8811 	msr	BASEPRI, r1
    8a74:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    8a78:	9b01      	ldr	r3, [sp, #4]
    8a7a:	2b00      	cmp	r3, #0
    8a7c:	d056      	beq.n	8b2c <net_buf_alloc_len+0x108>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    8a7e:	ea58 0309 	orrs.w	r3, r8, r9
    8a82:	d00f      	beq.n	8aa4 <net_buf_alloc_len+0x80>
    8a84:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    8a88:	bf08      	it	eq
    8a8a:	f1b9 3fff 	cmpeq.w	r9, #4294967295	; 0xffffffff
    8a8e:	d009      	beq.n	8aa4 <net_buf_alloc_len+0x80>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
    8a90:	f003 ffce 	bl	ca30 <sys_clock_tick_get>
    8a94:	ebba 0700 	subs.w	r7, sl, r0
    8a98:	eb6b 0601 	sbc.w	r6, fp, r1
    8a9c:	2e00      	cmp	r6, #0
    8a9e:	bfbc      	itt	lt
    8aa0:	2700      	movlt	r7, #0
    8aa2:	463e      	movlt	r6, r7
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    8aa4:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
    8aa6:	f8df 809c 	ldr.w	r8, [pc, #156]	; 8b44 <net_buf_alloc_len+0x120>
    8aaa:	f04f 092c 	mov.w	r9, #44	; 0x2c
    8aae:	fb09 8303 	mla	r3, r9, r3, r8
    8ab2:	463a      	mov	r2, r7
    8ab4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8ab6:	681b      	ldr	r3, [r3, #0]
    8ab8:	a901      	add	r1, sp, #4
    8aba:	681d      	ldr	r5, [r3, #0]
    8abc:	4620      	mov	r0, r4
    8abe:	4633      	mov	r3, r6
    8ac0:	47a8      	blx	r5
    8ac2:	4605      	mov	r5, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    8ac4:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
    8ac6:	2800      	cmp	r0, #0
    8ac8:	d131      	bne.n	8b2e <net_buf_alloc_len+0x10a>
	k_lifo_put(&pool->free, buf);
    8aca:	79a0      	ldrb	r0, [r4, #6]
    8acc:	4621      	mov	r1, r4
    8ace:	fb00 8009 	mla	r0, r0, r9, r8
    8ad2:	f006 fe08 	bl	f6e6 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    8ad6:	462c      	mov	r4, r5
}
    8ad8:	e024      	b.n	8b24 <net_buf_alloc_len+0x100>
		uninit_count = pool->uninit_count--;
    8ada:	8b68      	ldrh	r0, [r5, #26]
    8adc:	1e43      	subs	r3, r0, #1
    8ade:	836b      	strh	r3, [r5, #26]
    8ae0:	f381 8811 	msr	BASEPRI, r1
    8ae4:	f3bf 8f6f 	isb	sy
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
    8ae8:	7f2a      	ldrb	r2, [r5, #28]
    8aea:	f102 0417 	add.w	r4, r2, #23
    8aee:	f024 0303 	bic.w	r3, r4, #3
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
    8af2:	8b2c      	ldrh	r4, [r5, #24]
    8af4:	1a20      	subs	r0, r4, r0
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
    8af6:	6aac      	ldr	r4, [r5, #40]	; 0x28
    8af8:	fb00 4403 	mla	r4, r0, r3, r4
	return pool - _net_buf_pool_list;
    8afc:	4811      	ldr	r0, [pc, #68]	; (8b44 <net_buf_alloc_len+0x120>)
    8afe:	4b12      	ldr	r3, [pc, #72]	; (8b48 <net_buf_alloc_len+0x124>)
	buf->user_data_size = pool->user_data_size;
    8b00:	71e2      	strb	r2, [r4, #7]
	return pool - _net_buf_pool_list;
    8b02:	1a2d      	subs	r5, r5, r0
    8b04:	10ad      	asrs	r5, r5, #2
    8b06:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
    8b08:	71a5      	strb	r5, [r4, #6]
		goto success;
    8b0a:	e7b5      	b.n	8a78 <net_buf_alloc_len+0x54>
    8b0c:	f381 8811 	msr	BASEPRI, r1
    8b10:	f3bf 8f6f 	isb	sy
    8b14:	464a      	mov	r2, r9
    8b16:	4643      	mov	r3, r8
    8b18:	4628      	mov	r0, r5
    8b1a:	f003 f8d9 	bl	bcd0 <z_impl_k_queue_get>
	if (!buf) {
    8b1e:	4604      	mov	r4, r0
    8b20:	2800      	cmp	r0, #0
    8b22:	d1a9      	bne.n	8a78 <net_buf_alloc_len+0x54>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
    8b24:	4620      	mov	r0, r4
    8b26:	b003      	add	sp, #12
    8b28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buf->__buf = NULL;
    8b2c:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
    8b2e:	2300      	movs	r3, #0
	buf->ref   = 1U;
    8b30:	2201      	movs	r2, #1
	buf->frags = NULL;
    8b32:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
    8b34:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
    8b36:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
    8b38:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
    8b3a:	6923      	ldr	r3, [r4, #16]
    8b3c:	81e2      	strh	r2, [r4, #14]
    8b3e:	60a3      	str	r3, [r4, #8]
	return buf;
    8b40:	e7f0      	b.n	8b24 <net_buf_alloc_len+0x100>
    8b42:	bf00      	nop
    8b44:	200005c4 	.word	0x200005c4
    8b48:	ba2e8ba3 	.word	0xba2e8ba3

00008b4c <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    8b4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8b50:	4d16      	ldr	r5, [pc, #88]	; (8bac <net_buf_unref+0x60>)
    8b52:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
    8b54:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
    8b56:	272c      	movs	r7, #44	; 0x2c
	while (buf) {
    8b58:	b90c      	cbnz	r4, 8b5e <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    8b5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
    8b5e:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
    8b60:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
    8b64:	3b01      	subs	r3, #1
    8b66:	b2db      	uxtb	r3, r3
    8b68:	7123      	strb	r3, [r4, #4]
    8b6a:	2b00      	cmp	r3, #0
    8b6c:	d1f5      	bne.n	8b5a <net_buf_unref+0xe>
		if (buf->__buf) {
    8b6e:	6921      	ldr	r1, [r4, #16]
    8b70:	b159      	cbz	r1, 8b8a <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    8b72:	7963      	ldrb	r3, [r4, #5]
    8b74:	079b      	lsls	r3, r3, #30
    8b76:	d407      	bmi.n	8b88 <net_buf_unref+0x3c>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    8b78:	79a3      	ldrb	r3, [r4, #6]
	pool->alloc->cb->unref(buf, data);
    8b7a:	fb07 5303 	mla	r3, r7, r3, r5
    8b7e:	4620      	mov	r0, r4
    8b80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8b82:	681b      	ldr	r3, [r3, #0]
    8b84:	689b      	ldr	r3, [r3, #8]
    8b86:	4798      	blx	r3
			buf->__buf = NULL;
    8b88:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
    8b8a:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
    8b8c:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
    8b8e:	fb07 5300 	mla	r3, r7, r0, r5
		buf->frags = NULL;
    8b92:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
    8b94:	6a1b      	ldr	r3, [r3, #32]
    8b96:	b11b      	cbz	r3, 8ba0 <net_buf_unref+0x54>
			pool->destroy(buf);
    8b98:	4620      	mov	r0, r4
    8b9a:	4798      	blx	r3
{
    8b9c:	4644      	mov	r4, r8
    8b9e:	e7db      	b.n	8b58 <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
    8ba0:	4621      	mov	r1, r4
    8ba2:	fb00 5007 	mla	r0, r0, r7, r5
    8ba6:	f006 fd9e 	bl	f6e6 <k_queue_prepend>
}
    8baa:	e7f7      	b.n	8b9c <net_buf_unref+0x50>
    8bac:	200005c4 	.word	0x200005c4

00008bb0 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    8bb0:	4b08      	ldr	r3, [pc, #32]	; (8bd4 <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    8bb2:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    8bb4:	1ac3      	subs	r3, r0, r3
{
    8bb6:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    8bb8:	4907      	ldr	r1, [pc, #28]	; (8bd8 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
    8bba:	109b      	asrs	r3, r3, #2
{
    8bbc:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    8bbe:	4359      	muls	r1, r3
    8bc0:	4806      	ldr	r0, [pc, #24]	; (8bdc <onoff_stop+0x2c>)
    8bc2:	2240      	movs	r2, #64	; 0x40
    8bc4:	f005 fff2 	bl	ebac <stop>
	notify(mgr, res);
    8bc8:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    8bca:	4601      	mov	r1, r0
	notify(mgr, res);
    8bcc:	4620      	mov	r0, r4
}
    8bce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
    8bd2:	4718      	bx	r3
    8bd4:	200019e0 	.word	0x200019e0
    8bd8:	b6db6db7 	.word	0xb6db6db7
    8bdc:	0000ff90 	.word	0x0000ff90

00008be0 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    8be0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    8be2:	4c0c      	ldr	r4, [pc, #48]	; (8c14 <onoff_start+0x34>)
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    8be4:	4a0c      	ldr	r2, [pc, #48]	; (8c18 <onoff_start+0x38>)
    8be6:	2340      	movs	r3, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
    8be8:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    8bea:	9300      	str	r3, [sp, #0]
{
    8bec:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    8bee:	460b      	mov	r3, r1
    8bf0:	490a      	ldr	r1, [pc, #40]	; (8c1c <onoff_start+0x3c>)
	size_t offset = (size_t)(mgr - data->mgr);
    8bf2:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    8bf4:	4361      	muls	r1, r4
{
    8bf6:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    8bf8:	4809      	ldr	r0, [pc, #36]	; (8c20 <onoff_start+0x40>)
    8bfa:	f006 f804 	bl	ec06 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    8bfe:	1e01      	subs	r1, r0, #0
    8c00:	da05      	bge.n	8c0e <onoff_start+0x2e>
		notify(mgr, err);
    8c02:	4630      	mov	r0, r6
    8c04:	462b      	mov	r3, r5
	}
}
    8c06:	b002      	add	sp, #8
    8c08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
    8c0c:	4718      	bx	r3
}
    8c0e:	b002      	add	sp, #8
    8c10:	bd70      	pop	{r4, r5, r6, pc}
    8c12:	bf00      	nop
    8c14:	200019e0 	.word	0x200019e0
    8c18:	0000ec75 	.word	0x0000ec75
    8c1c:	b6db6db7 	.word	0xb6db6db7
    8c20:	0000ff90 	.word	0x0000ff90

00008c24 <clk_init>:
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    8c24:	2200      	movs	r2, #0
{
    8c26:	b570      	push	{r4, r5, r6, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    8c28:	2101      	movs	r1, #1
{
    8c2a:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    8c2c:	4610      	mov	r0, r2
    8c2e:	f7f9 faeb 	bl	2208 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    8c32:	2000      	movs	r0, #0
    8c34:	f7f9 fab6 	bl	21a4 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    8c38:	480f      	ldr	r0, [pc, #60]	; (8c78 <clk_init+0x54>)
    8c3a:	f001 fd43 	bl	a6c4 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    8c3e:	4b0f      	ldr	r3, [pc, #60]	; (8c7c <clk_init+0x58>)
    8c40:	4298      	cmp	r0, r3
    8c42:	d115      	bne.n	8c70 <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    8c44:	f006 fb92 	bl	f36c <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
    8c48:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
    8c4a:	490d      	ldr	r1, [pc, #52]	; (8c80 <clk_init+0x5c>)
    8c4c:	4630      	mov	r0, r6
    8c4e:	f004 f93f 	bl	ced0 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
    8c52:	2800      	cmp	r0, #0
    8c54:	db0b      	blt.n	8c6e <clk_init+0x4a>
	struct nrf_clock_control_data *data = dev->data;
    8c56:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
    8c58:	4909      	ldr	r1, [pc, #36]	; (8c80 <clk_init+0x5c>)
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    8c5a:	2501      	movs	r5, #1
    8c5c:	6435      	str	r5, [r6, #64]	; 0x40
		err = onoff_manager_init(get_onoff_manager(dev, i),
    8c5e:	f104 001c 	add.w	r0, r4, #28
    8c62:	f004 f935 	bl	ced0 <onoff_manager_init>
		if (err < 0) {
    8c66:	2800      	cmp	r0, #0
    8c68:	db01      	blt.n	8c6e <clk_init+0x4a>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    8c6a:	64e5      	str	r5, [r4, #76]	; 0x4c
	}

	return 0;
    8c6c:	2000      	movs	r0, #0
}
    8c6e:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    8c70:	f06f 0004 	mvn.w	r0, #4
    8c74:	e7fb      	b.n	8c6e <clk_init+0x4a>
    8c76:	bf00      	nop
    8c78:	00008cb9 	.word	0x00008cb9
    8c7c:	0bad0000 	.word	0x0bad0000
    8c80:	0001057c 	.word	0x0001057c

00008c84 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
    8c84:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
    8c86:	230c      	movs	r3, #12
    8c88:	4809      	ldr	r0, [pc, #36]	; (8cb0 <clkstarted_handle.constprop.0+0x2c>)
    8c8a:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
    8c8c:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
    8c8e:	18c4      	adds	r4, r0, r3
	void *user_data = sub_data->user_data;
    8c90:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	sub_data->cb = NULL;
    8c94:	2200      	movs	r2, #0
	set_on_state(&sub_data->flags);
    8c96:	3340      	adds	r3, #64	; 0x40
	sub_data->cb = NULL;
    8c98:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
    8c9a:	4418      	add	r0, r3
    8c9c:	f005 ff73 	bl	eb86 <set_on_state>
	if (callback) {
    8ca0:	b12d      	cbz	r5, 8cae <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
    8ca2:	4632      	mov	r2, r6
    8ca4:	462b      	mov	r3, r5
    8ca6:	4803      	ldr	r0, [pc, #12]	; (8cb4 <clkstarted_handle.constprop.0+0x30>)
}
    8ca8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
    8cac:	4718      	bx	r3
}
    8cae:	bd70      	pop	{r4, r5, r6, pc}
    8cb0:	200019e0 	.word	0x200019e0
    8cb4:	0000ff90 	.word	0x0000ff90

00008cb8 <clock_event_handler>:
	switch (event) {
    8cb8:	b110      	cbz	r0, 8cc0 <clock_event_handler+0x8>
    8cba:	2801      	cmp	r0, #1
    8cbc:	d004      	beq.n	8cc8 <clock_event_handler+0x10>
    8cbe:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    8cc0:	4b03      	ldr	r3, [pc, #12]	; (8cd0 <clock_event_handler+0x18>)
    8cc2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    8cc4:	075b      	lsls	r3, r3, #29
    8cc6:	d101      	bne.n	8ccc <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    8cc8:	f7ff bfdc 	b.w	8c84 <clkstarted_handle.constprop.0>
}
    8ccc:	4770      	bx	lr
    8cce:	bf00      	nop
    8cd0:	200019e0 	.word	0x200019e0

00008cd4 <generic_hfclk_start>:
{
    8cd4:	b508      	push	{r3, lr}
	__asm__ volatile(
    8cd6:	f04f 0320 	mov.w	r3, #32
    8cda:	f3ef 8111 	mrs	r1, BASEPRI
    8cde:	f383 8812 	msr	BASEPRI_MAX, r3
    8ce2:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    8ce6:	4a12      	ldr	r2, [pc, #72]	; (8d30 <generic_hfclk_start+0x5c>)
    8ce8:	6813      	ldr	r3, [r2, #0]
    8cea:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
    8cee:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
    8cf2:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    8cf4:	d00c      	beq.n	8d10 <generic_hfclk_start+0x3c>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    8cf6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    8cfa:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    8cfe:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    8d02:	f013 0301 	ands.w	r3, r3, #1
    8d06:	d003      	beq.n	8d10 <generic_hfclk_start+0x3c>
			set_on_state(get_hf_flags());
    8d08:	480a      	ldr	r0, [pc, #40]	; (8d34 <generic_hfclk_start+0x60>)
    8d0a:	f005 ff3c 	bl	eb86 <set_on_state>
			already_started = true;
    8d0e:	2301      	movs	r3, #1
	__asm__ volatile(
    8d10:	f381 8811 	msr	BASEPRI, r1
    8d14:	f3bf 8f6f 	isb	sy
	if (already_started) {
    8d18:	b123      	cbz	r3, 8d24 <generic_hfclk_start+0x50>
}
    8d1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
    8d1e:	2000      	movs	r0, #0
    8d20:	f7ff bfb0 	b.w	8c84 <clkstarted_handle.constprop.0>
}
    8d24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    8d28:	2001      	movs	r0, #1
    8d2a:	f001 bcdb 	b.w	a6e4 <nrfx_clock_start>
    8d2e:	bf00      	nop
    8d30:	20001a30 	.word	0x20001a30
    8d34:	20001a20 	.word	0x20001a20

00008d38 <api_blocking_start>:
{
    8d38:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    8d3a:	2200      	movs	r2, #0
    8d3c:	2301      	movs	r3, #1
    8d3e:	e9cd 2302 	strd	r2, r3, [sp, #8]
    8d42:	ab04      	add	r3, sp, #16
    8d44:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    8d48:	4a09      	ldr	r2, [pc, #36]	; (8d70 <api_blocking_start+0x38>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    8d4a:	f8cd d000 	str.w	sp, [sp]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    8d4e:	466b      	mov	r3, sp
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    8d50:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    8d54:	f005 ff87 	bl	ec66 <api_start>
	if (err < 0) {
    8d58:	2800      	cmp	r0, #0
    8d5a:	db05      	blt.n	8d68 <api_blocking_start+0x30>
	return z_impl_k_sem_take(sem, timeout);
    8d5c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    8d60:	2300      	movs	r3, #0
    8d62:	4668      	mov	r0, sp
    8d64:	f003 f80e 	bl	bd84 <z_impl_k_sem_take>
}
    8d68:	b007      	add	sp, #28
    8d6a:	f85d fb04 	ldr.w	pc, [sp], #4
    8d6e:	bf00      	nop
    8d70:	0000ec8d 	.word	0x0000ec8d

00008d74 <lfclk_start>:
{
    8d74:	b510      	push	{r4, lr}
	if (!once) {
    8d76:	4c07      	ldr	r4, [pc, #28]	; (8d94 <lfclk_start+0x20>)
    8d78:	7823      	ldrb	r3, [r4, #0]
    8d7a:	b92b      	cbnz	r3, 8d88 <lfclk_start+0x14>
	z_impl_k_busy_wait(usec_to_wait);
    8d7c:	f44f 70a5 	mov.w	r0, #330	; 0x14a
    8d80:	f006 ff0b 	bl	fb9a <z_impl_k_busy_wait>
		once = true;
    8d84:	2301      	movs	r3, #1
    8d86:	7023      	strb	r3, [r4, #0]
}
    8d88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    8d8c:	2000      	movs	r0, #0
    8d8e:	f001 bca9 	b.w	a6e4 <nrfx_clock_start>
    8d92:	bf00      	nop
    8d94:	20001e30 	.word	0x20001e30

00008d98 <generic_hfclk_stop>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8d98:	4b09      	ldr	r3, [pc, #36]	; (8dc0 <generic_hfclk_stop+0x28>)
    8d9a:	f3bf 8f5b 	dmb	ish
    8d9e:	e853 2f00 	ldrex	r2, [r3]
    8da2:	f022 0102 	bic.w	r1, r2, #2
    8da6:	e843 1000 	strex	r0, r1, [r3]
    8daa:	2800      	cmp	r0, #0
    8dac:	d1f7      	bne.n	8d9e <generic_hfclk_stop+0x6>
    8dae:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    8db2:	07d3      	lsls	r3, r2, #31
    8db4:	d402      	bmi.n	8dbc <generic_hfclk_stop+0x24>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    8db6:	2001      	movs	r0, #1
    8db8:	f001 bcdc 	b.w	a774 <nrfx_clock_stop>
}
    8dbc:	4770      	bx	lr
    8dbe:	bf00      	nop
    8dc0:	20001a30 	.word	0x20001a30

00008dc4 <z_nrf_clock_control_get_onoff>:
}
    8dc4:	4a02      	ldr	r2, [pc, #8]	; (8dd0 <z_nrf_clock_control_get_onoff+0xc>)
	return &data->mgr[type];
    8dc6:	b2c3      	uxtb	r3, r0
}
    8dc8:	201c      	movs	r0, #28
    8dca:	fb03 2000 	mla	r0, r3, r0, r2
    8dce:	4770      	bx	lr
    8dd0:	200019e0 	.word	0x200019e0

00008dd4 <z_nrf_clock_bt_ctlr_hf_request>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8dd4:	4b09      	ldr	r3, [pc, #36]	; (8dfc <z_nrf_clock_bt_ctlr_hf_request+0x28>)
    8dd6:	f3bf 8f5b 	dmb	ish
    8dda:	e853 2f00 	ldrex	r2, [r3]
    8dde:	f042 0101 	orr.w	r1, r2, #1
    8de2:	e843 1000 	strex	r0, r1, [r3]
    8de6:	2800      	cmp	r0, #0
    8de8:	d1f7      	bne.n	8dda <z_nrf_clock_bt_ctlr_hf_request+0x6>
    8dea:	f3bf 8f5b 	dmb	ish
	if (atomic_or(&hfclk_users, HF_USER_BT) & HF_USER_GENERIC) {
    8dee:	0793      	lsls	r3, r2, #30
    8df0:	d402      	bmi.n	8df8 <z_nrf_clock_bt_ctlr_hf_request+0x24>
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    8df2:	2001      	movs	r0, #1
    8df4:	f001 bc76 	b.w	a6e4 <nrfx_clock_start>
}
    8df8:	4770      	bx	lr
    8dfa:	bf00      	nop
    8dfc:	20001a30 	.word	0x20001a30

00008e00 <z_nrf_clock_bt_ctlr_hf_release>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8e00:	4b09      	ldr	r3, [pc, #36]	; (8e28 <z_nrf_clock_bt_ctlr_hf_release+0x28>)
    8e02:	f3bf 8f5b 	dmb	ish
    8e06:	e853 2f00 	ldrex	r2, [r3]
    8e0a:	f022 0101 	bic.w	r1, r2, #1
    8e0e:	e843 1000 	strex	r0, r1, [r3]
    8e12:	2800      	cmp	r0, #0
    8e14:	d1f7      	bne.n	8e06 <z_nrf_clock_bt_ctlr_hf_release+0x6>
    8e16:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_BT) & HF_USER_GENERIC) {
    8e1a:	0793      	lsls	r3, r2, #30
    8e1c:	d402      	bmi.n	8e24 <z_nrf_clock_bt_ctlr_hf_release+0x24>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    8e1e:	2001      	movs	r0, #1
    8e20:	f001 bca8 	b.w	a774 <nrfx_clock_stop>
}
    8e24:	4770      	bx	lr
    8e26:	bf00      	nop
    8e28:	20001a30 	.word	0x20001a30

00008e2c <z_nrf_clock_control_lf_on>:
{
    8e2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    8e30:	4939      	ldr	r1, [pc, #228]	; (8f18 <z_nrf_clock_control_lf_on+0xec>)
    8e32:	f3bf 8f5b 	dmb	ish
    8e36:	4607      	mov	r7, r0
    8e38:	2201      	movs	r2, #1
    8e3a:	e851 3f00 	ldrex	r3, [r1]
    8e3e:	e841 2000 	strex	r0, r2, [r1]
    8e42:	2800      	cmp	r0, #0
    8e44:	d1f9      	bne.n	8e3a <z_nrf_clock_control_lf_on+0xe>
    8e46:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
    8e4a:	b933      	cbnz	r3, 8e5a <z_nrf_clock_control_lf_on+0x2e>
    8e4c:	4933      	ldr	r1, [pc, #204]	; (8f1c <z_nrf_clock_control_lf_on+0xf0>)
		err = onoff_request(mgr, &cli);
    8e4e:	4834      	ldr	r0, [pc, #208]	; (8f20 <z_nrf_clock_control_lf_on+0xf4>)
    8e50:	604b      	str	r3, [r1, #4]
    8e52:	60cb      	str	r3, [r1, #12]
    8e54:	608a      	str	r2, [r1, #8]
    8e56:	f004 f84e 	bl	cef6 <onoff_request>
	switch (start_mode) {
    8e5a:	1e7b      	subs	r3, r7, #1
    8e5c:	2b01      	cmp	r3, #1
    8e5e:	d82f      	bhi.n	8ec0 <z_nrf_clock_control_lf_on+0x94>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    8e60:	2f01      	cmp	r7, #1
    8e62:	d107      	bne.n	8e74 <z_nrf_clock_control_lf_on+0x48>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    8e64:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8e68:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    8e6c:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    8e70:	2b01      	cmp	r3, #1
    8e72:	d025      	beq.n	8ec0 <z_nrf_clock_control_lf_on+0x94>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    8e74:	f006 fba0 	bl	f5b8 <k_is_in_isr>
    8e78:	4604      	mov	r4, r0
    8e7a:	b918      	cbnz	r0, 8e84 <z_nrf_clock_control_lf_on+0x58>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    8e7c:	4b29      	ldr	r3, [pc, #164]	; (8f24 <z_nrf_clock_control_lf_on+0xf8>)
	int key = isr_mode ? irq_lock() : 0;
    8e7e:	781b      	ldrb	r3, [r3, #0]
    8e80:	2b00      	cmp	r3, #0
    8e82:	d141      	bne.n	8f08 <z_nrf_clock_control_lf_on+0xdc>
	__asm__ volatile(
    8e84:	f04f 0320 	mov.w	r3, #32
    8e88:	f3ef 8611 	mrs	r6, BASEPRI
    8e8c:	f383 8812 	msr	BASEPRI_MAX, r3
    8e90:	f3bf 8f6f 	isb	sy
    8e94:	2401      	movs	r4, #1
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    8e96:	f8df 8090 	ldr.w	r8, [pc, #144]	; 8f28 <z_nrf_clock_control_lf_on+0xfc>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    8e9a:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    8e9e:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    8ea2:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
    8ea6:	03d2      	lsls	r2, r2, #15
    8ea8:	d50c      	bpl.n	8ec4 <z_nrf_clock_control_lf_on+0x98>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    8eaa:	f003 0303 	and.w	r3, r3, #3
	while (!(nrfx_clock_is_running(d, (void *)&type)
    8eae:	2b01      	cmp	r3, #1
    8eb0:	d001      	beq.n	8eb6 <z_nrf_clock_control_lf_on+0x8a>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    8eb2:	2f01      	cmp	r7, #1
    8eb4:	d106      	bne.n	8ec4 <z_nrf_clock_control_lf_on+0x98>
	if (isr_mode) {
    8eb6:	b30c      	cbz	r4, 8efc <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
    8eb8:	f386 8811 	msr	BASEPRI, r6
    8ebc:	f3bf 8f6f 	isb	sy
}
    8ec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    8ec4:	b1ac      	cbz	r4, 8ef2 <z_nrf_clock_control_lf_on+0xc6>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    8ec6:	4630      	mov	r0, r6
    8ec8:	f7f9 f8fc 	bl	20c4 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    8ecc:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    8ed0:	2b00      	cmp	r3, #0
    8ed2:	d1e4      	bne.n	8e9e <z_nrf_clock_control_lf_on+0x72>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    8ed4:	f8d5 2104 	ldr.w	r2, [r5, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
    8ed8:	2a00      	cmp	r2, #0
    8eda:	d0e0      	beq.n	8e9e <z_nrf_clock_control_lf_on+0x72>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8edc:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    8ee0:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
    8ee4:	2301      	movs	r3, #1
    8ee6:	f8c5 3518 	str.w	r3, [r5, #1304]	; 0x518
    8eea:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8eee:	60ab      	str	r3, [r5, #8]
}
    8ef0:	e7d5      	b.n	8e9e <z_nrf_clock_control_lf_on+0x72>
	return z_impl_k_sleep(timeout);
    8ef2:	2100      	movs	r1, #0
    8ef4:	2021      	movs	r0, #33	; 0x21
    8ef6:	f003 fbcb 	bl	c690 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    8efa:	e7e7      	b.n	8ecc <z_nrf_clock_control_lf_on+0xa0>
    p_reg->INTENSET = mask;
    8efc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8f00:	2202      	movs	r2, #2
    8f02:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    8f06:	e7db      	b.n	8ec0 <z_nrf_clock_control_lf_on+0x94>
    p_reg->INTENCLR = mask;
    8f08:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8f0c:	2202      	movs	r2, #2
    8f0e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	int key = isr_mode ? irq_lock() : 0;
    8f12:	4606      	mov	r6, r0
}
    8f14:	e7bf      	b.n	8e96 <z_nrf_clock_control_lf_on+0x6a>
    8f16:	bf00      	nop
    8f18:	20001a34 	.word	0x20001a34
    8f1c:	200019d0 	.word	0x200019d0
    8f20:	200019fc 	.word	0x200019fc
    8f24:	20002262 	.word	0x20002262
    8f28:	e000e100 	.word	0xe000e100

00008f2c <rtt_console_init>:

	return character;
}

static int rtt_console_init(const struct device *d)
{
    8f2c:	b510      	push	{r4, lr}
	ARG_UNUSED(d);

	__printk_hook_install(rtt_console_out);
    8f2e:	4c04      	ldr	r4, [pc, #16]	; (8f40 <rtt_console_init+0x14>)
    8f30:	4620      	mov	r0, r4
    8f32:	f7f7 fdef 	bl	b14 <__printk_hook_install>
	__stdout_hook_install(rtt_console_out);
    8f36:	4620      	mov	r0, r4
    8f38:	f7f9 fe6c 	bl	2c14 <__stdout_hook_install>

	return 0;
}
    8f3c:	2000      	movs	r0, #0
    8f3e:	bd10      	pop	{r4, pc}
    8f40:	00008f45 	.word	0x00008f45

00008f44 <rtt_console_out>:
{
    8f44:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return z_impl_k_mutex_lock(mutex, timeout);
    8f48:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8fa8 <rtt_console_out+0x64>
    8f4c:	4e17      	ldr	r6, [pc, #92]	; (8fac <rtt_console_out+0x68>)
	char c = (char)character;
    8f4e:	f88d 0007 	strb.w	r0, [sp, #7]
{
    8f52:	4604      	mov	r4, r0
	char c = (char)character;
    8f54:	2503      	movs	r5, #3
    8f56:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    8f5a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    8f5e:	4640      	mov	r0, r8
    8f60:	f002 fdfc 	bl	bb5c <z_impl_k_mutex_lock>
		cnt = SEGGER_RTT_WriteNoLock(0, &c, 1);
    8f64:	2201      	movs	r2, #1
    8f66:	f10d 0107 	add.w	r1, sp, #7
    8f6a:	2000      	movs	r0, #0
    8f6c:	f002 fb26 	bl	b5bc <SEGGER_RTT_WriteNoLock>
    8f70:	4607      	mov	r7, r0
	return z_impl_k_mutex_unlock(mutex);
    8f72:	4640      	mov	r0, r8
    8f74:	f002 fe6a 	bl	bc4c <z_impl_k_mutex_unlock>
		if (cnt) {
    8f78:	b12f      	cbz	r7, 8f86 <rtt_console_out+0x42>
			host_present = true;
    8f7a:	2301      	movs	r3, #1
    8f7c:	7033      	strb	r3, [r6, #0]
}
    8f7e:	4620      	mov	r0, r4
    8f80:	b002      	add	sp, #8
    8f82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (host_present) {
    8f86:	7833      	ldrb	r3, [r6, #0]
    8f88:	2b00      	cmp	r3, #0
    8f8a:	d0f8      	beq.n	8f7e <rtt_console_out+0x3a>
			if (max_cnt) {
    8f8c:	3d01      	subs	r5, #1
    8f8e:	d008      	beq.n	8fa2 <rtt_console_out+0x5e>
	if (!IS_ENABLED(CONFIG_MULTITHREADING) || k_is_in_isr()) {
    8f90:	f006 fb12 	bl	f5b8 <k_is_in_isr>
    8f94:	2800      	cmp	r0, #0
    8f96:	d1de      	bne.n	8f56 <rtt_console_out+0x12>
	return z_impl_k_sleep(timeout);
    8f98:	2100      	movs	r1, #0
    8f9a:	2042      	movs	r0, #66	; 0x42
    8f9c:	f003 fb78 	bl	c690 <z_impl_k_sleep>
    8fa0:	e7d9      	b.n	8f56 <rtt_console_out+0x12>
				host_present = false;
    8fa2:	7035      	strb	r5, [r6, #0]
    8fa4:	e7eb      	b.n	8f7e <rtt_console_out+0x3a>
    8fa6:	bf00      	nop
    8fa8:	20000568 	.word	0x20000568
    8fac:	20001e31 	.word	0x20001e31

00008fb0 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
    8fb0:	b530      	push	{r4, r5, lr}
	return port->config;
    8fb2:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    8fb4:	7b04      	ldrb	r4, [r0, #12]
    8fb6:	f001 051f 	and.w	r5, r1, #31
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
    8fba:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    8fbe:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
    8fc2:	b085      	sub	sp, #20
    8fc4:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
    8fc8:	d104      	bne.n	8fd4 <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
    8fca:	4628      	mov	r0, r5
    8fcc:	f001 fe70 	bl	acb0 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
    8fd0:	2000      	movs	r0, #0
    8fd2:	e02e      	b.n	9032 <gpio_nrfx_pin_interrupt_configure+0x82>
	if (mode == GPIO_INT_MODE_LEVEL) {
    8fd4:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
    8fd8:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
    8fdc:	d12b      	bne.n	9036 <gpio_nrfx_pin_interrupt_configure+0x86>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
    8fde:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    8fe2:	bf0c      	ite	eq
    8fe4:	2304      	moveq	r3, #4
    8fe6:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
    8fe8:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
    8fec:	6883      	ldr	r3, [r0, #8]
    8fee:	fa23 f101 	lsr.w	r1, r3, r1
    8ff2:	07c9      	lsls	r1, r1, #31
    8ff4:	d42b      	bmi.n	904e <gpio_nrfx_pin_interrupt_configure+0x9e>
    8ff6:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    8ffa:	d128      	bne.n	904e <gpio_nrfx_pin_interrupt_configure+0x9e>
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    8ffc:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    9000:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    9004:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    9008:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
    900c:	07db      	lsls	r3, r3, #31
    900e:	d41e      	bmi.n	904e <gpio_nrfx_pin_interrupt_configure+0x9e>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
    9010:	f10d 0407 	add.w	r4, sp, #7
    9014:	4621      	mov	r1, r4
    9016:	4628      	mov	r0, r5
    9018:	f001 fdb2 	bl	ab80 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
    901c:	4b14      	ldr	r3, [pc, #80]	; (9070 <gpio_nrfx_pin_interrupt_configure+0xc0>)
    901e:	4298      	cmp	r0, r3
    9020:	d114      	bne.n	904c <gpio_nrfx_pin_interrupt_configure+0x9c>
			err = nrfx_gpiote_channel_alloc(&ch);
    9022:	4620      	mov	r0, r4
    9024:	f001 fdfa 	bl	ac1c <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
    9028:	4b12      	ldr	r3, [pc, #72]	; (9074 <gpio_nrfx_pin_interrupt_configure+0xc4>)
    902a:	4298      	cmp	r0, r3
    902c:	d00e      	beq.n	904c <gpio_nrfx_pin_interrupt_configure+0x9c>
				return -ENOMEM;
    902e:	f06f 000b 	mvn.w	r0, #11
}
    9032:	b005      	add	sp, #20
    9034:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    9036:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    903a:	d005      	beq.n	9048 <gpio_nrfx_pin_interrupt_configure+0x98>
    903c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    9040:	bf0c      	ite	eq
    9042:	2302      	moveq	r3, #2
    9044:	2301      	movne	r3, #1
    9046:	e7cf      	b.n	8fe8 <gpio_nrfx_pin_interrupt_configure+0x38>
    9048:	2303      	movs	r3, #3
    904a:	e7cd      	b.n	8fe8 <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
    904c:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    904e:	2300      	movs	r3, #0
    9050:	4619      	mov	r1, r3
    9052:	aa02      	add	r2, sp, #8
    9054:	4628      	mov	r0, r5
    9056:	f001 fc6b 	bl	a930 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    905a:	4b06      	ldr	r3, [pc, #24]	; (9074 <gpio_nrfx_pin_interrupt_configure+0xc4>)
    905c:	4298      	cmp	r0, r3
    905e:	d104      	bne.n	906a <gpio_nrfx_pin_interrupt_configure+0xba>
	nrfx_gpiote_trigger_enable(abs_pin, true);
    9060:	2101      	movs	r1, #1
    9062:	4628      	mov	r0, r5
    9064:	f001 fde0 	bl	ac28 <nrfx_gpiote_trigger_enable>
    9068:	e7b2      	b.n	8fd0 <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
    906a:	f06f 0004 	mvn.w	r0, #4
    906e:	e7e0      	b.n	9032 <gpio_nrfx_pin_interrupt_configure+0x82>
    9070:	0bad0004 	.word	0x0bad0004
    9074:	0bad0000 	.word	0x0bad0000

00009078 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    9078:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
    907a:	f001 fdbf 	bl	abfc <nrfx_gpiote_is_init>
    907e:	4604      	mov	r4, r0
    9080:	b968      	cbnz	r0, 909e <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
    9082:	f001 fd93 	bl	abac <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
    9086:	4b08      	ldr	r3, [pc, #32]	; (90a8 <gpio_nrfx_init+0x30>)
    9088:	4298      	cmp	r0, r3
    908a:	d10a      	bne.n	90a2 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
    908c:	4807      	ldr	r0, [pc, #28]	; (90ac <gpio_nrfx_init+0x34>)
    908e:	4621      	mov	r1, r4
    9090:	f001 fd70 	bl	ab74 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    9094:	4622      	mov	r2, r4
    9096:	2105      	movs	r1, #5
    9098:	2006      	movs	r0, #6
    909a:	f7f9 f8b5 	bl	2208 <z_arm_irq_priority_set>
		return 0;
    909e:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
    90a0:	bd10      	pop	{r4, pc}
		return -EIO;
    90a2:	f06f 0004 	mvn.w	r0, #4
    90a6:	e7fb      	b.n	90a0 <gpio_nrfx_init+0x28>
    90a8:	0bad0000 	.word	0x0bad0000
    90ac:	000090b1 	.word	0x000090b1

000090b0 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    90b0:	0943      	lsrs	r3, r0, #5
{
    90b2:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    90b4:	d110      	bne.n	90d8 <nrfx_gpio_handler+0x28>
	return list->head;
    90b6:	4b09      	ldr	r3, [pc, #36]	; (90dc <nrfx_gpio_handler+0x2c>)
    90b8:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    90ba:	b169      	cbz	r1, 90d8 <nrfx_gpio_handler+0x28>
	gpio_fire_callbacks(list, port, BIT(pin));
    90bc:	2501      	movs	r5, #1
	return node->next;
    90be:	680c      	ldr	r4, [r1, #0]
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
    90c0:	4e07      	ldr	r6, [pc, #28]	; (90e0 <nrfx_gpio_handler+0x30>)
    90c2:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
    90c4:	688a      	ldr	r2, [r1, #8]
    90c6:	402a      	ands	r2, r5
    90c8:	d002      	beq.n	90d0 <nrfx_gpio_handler+0x20>
			cb->handler(port, cb, cb->pin_mask & pins);
    90ca:	684b      	ldr	r3, [r1, #4]
    90cc:	4630      	mov	r0, r6
    90ce:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    90d0:	b114      	cbz	r4, 90d8 <nrfx_gpio_handler+0x28>
    90d2:	4621      	mov	r1, r4
    90d4:	6824      	ldr	r4, [r4, #0]
    90d6:	e7f5      	b.n	90c4 <nrfx_gpio_handler+0x14>
}
    90d8:	bd70      	pop	{r4, r5, r6, pc}
    90da:	bf00      	nop
    90dc:	20001a38 	.word	0x20001a38
    90e0:	0000ffa8 	.word	0x0000ffa8

000090e4 <gpio_nrfx_pin_configure>:
{
    90e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return port->config;
    90e8:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    90ea:	7b3b      	ldrb	r3, [r7, #12]
    90ec:	f001 051f 	and.w	r5, r1, #31
{
    90f0:	b085      	sub	sp, #20
    90f2:	460e      	mov	r6, r1
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    90f4:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
    90f8:	4614      	mov	r4, r2
    90fa:	b9ca      	cbnz	r2, 9130 <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
    90fc:	a902      	add	r1, sp, #8
    90fe:	4628      	mov	r0, r5
    9100:	f001 fd3e 	bl	ab80 <nrfx_gpiote_channel_get>
    9104:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
    9106:	4628      	mov	r0, r5
    9108:	f001 fdfa 	bl	ad00 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
    910c:	4b48      	ldr	r3, [pc, #288]	; (9230 <gpio_nrfx_pin_configure+0x14c>)
    910e:	4298      	cmp	r0, r3
    9110:	d004      	beq.n	911c <gpio_nrfx_pin_configure+0x38>
		return -EIO;
    9112:	f06f 0004 	mvn.w	r0, #4
}
    9116:	b005      	add	sp, #20
    9118:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
    911c:	4284      	cmp	r4, r0
    911e:	d105      	bne.n	912c <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
    9120:	f89d 0008 	ldrb.w	r0, [sp, #8]
    9124:	f001 fd74 	bl	ac10 <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
    9128:	42a0      	cmp	r0, r4
    912a:	d1f2      	bne.n	9112 <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    912c:	2000      	movs	r0, #0
    912e:	e7f2      	b.n	9116 <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
    9130:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
    9134:	f10d 0103 	add.w	r1, sp, #3
    9138:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
    913a:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
    913e:	f001 fd1f 	bl	ab80 <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    9142:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
    9144:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    9146:	aa02      	add	r2, sp, #8
    9148:	4649      	mov	r1, r9
    914a:	4628      	mov	r0, r5
    914c:	f001 fbf0 	bl	a930 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    9150:	4b37      	ldr	r3, [pc, #220]	; (9230 <gpio_nrfx_pin_configure+0x14c>)
    9152:	4298      	cmp	r0, r3
    9154:	d002      	beq.n	915c <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    9156:	f06f 0015 	mvn.w	r0, #21
    915a:	e7dc      	b.n	9116 <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
    915c:	4580      	cmp	r8, r0
    915e:	d103      	bne.n	9168 <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
    9160:	f89d 0003 	ldrb.w	r0, [sp, #3]
    9164:	f001 fd54 	bl	ac10 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
    9168:	05a3      	lsls	r3, r4, #22
    916a:	d54e      	bpl.n	920a <gpio_nrfx_pin_configure+0x126>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    916c:	4b31      	ldr	r3, [pc, #196]	; (9234 <gpio_nrfx_pin_configure+0x150>)
    916e:	4a32      	ldr	r2, [pc, #200]	; (9238 <gpio_nrfx_pin_configure+0x154>)
    9170:	4023      	ands	r3, r4
    9172:	4293      	cmp	r3, r2
    9174:	d03a      	beq.n	91ec <gpio_nrfx_pin_configure+0x108>
    9176:	d80c      	bhi.n	9192 <gpio_nrfx_pin_configure+0xae>
    9178:	2b06      	cmp	r3, #6
    917a:	d014      	beq.n	91a6 <gpio_nrfx_pin_configure+0xc2>
    917c:	d804      	bhi.n	9188 <gpio_nrfx_pin_configure+0xa4>
    917e:	b193      	cbz	r3, 91a6 <gpio_nrfx_pin_configure+0xc2>
    9180:	2b02      	cmp	r3, #2
    9182:	d1e8      	bne.n	9156 <gpio_nrfx_pin_configure+0x72>
    9184:	2304      	movs	r3, #4
    9186:	e00e      	b.n	91a6 <gpio_nrfx_pin_configure+0xc2>
    9188:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    918c:	d1e3      	bne.n	9156 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
    918e:	2301      	movs	r3, #1
    9190:	e009      	b.n	91a6 <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    9192:	4a2a      	ldr	r2, [pc, #168]	; (923c <gpio_nrfx_pin_configure+0x158>)
    9194:	4293      	cmp	r3, r2
    9196:	d02b      	beq.n	91f0 <gpio_nrfx_pin_configure+0x10c>
    9198:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    919c:	d02a      	beq.n	91f4 <gpio_nrfx_pin_configure+0x110>
    919e:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    91a2:	d1d8      	bne.n	9156 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
    91a4:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
    91a6:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
    91aa:	f484 7380 	eor.w	r3, r4, #256	; 0x100
    91ae:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
    91b2:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
    91b4:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLDOWN;
    91b8:	bf54      	ite	pl
    91ba:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		return NRF_GPIO_PIN_PULLUP;
    91be:	2303      	movmi	r3, #3
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    91c0:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
    91c2:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    91c6:	d517      	bpl.n	91f8 <gpio_nrfx_pin_configure+0x114>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
    91c8:	687b      	ldr	r3, [r7, #4]
    91ca:	2101      	movs	r1, #1
    91cc:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
    91d0:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
    91d4:	2200      	movs	r2, #0
    91d6:	a901      	add	r1, sp, #4
    91d8:	4628      	mov	r0, r5
    91da:	f001 fc53 	bl	aa84 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    91de:	4b14      	ldr	r3, [pc, #80]	; (9230 <gpio_nrfx_pin_configure+0x14c>)
    91e0:	4298      	cmp	r0, r3
    91e2:	bf14      	ite	ne
    91e4:	f06f 0015 	mvnne.w	r0, #21
    91e8:	2000      	moveq	r0, #0
    91ea:	e794      	b.n	9116 <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
    91ec:	2307      	movs	r3, #7
    91ee:	e7da      	b.n	91a6 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
    91f0:	2305      	movs	r3, #5
    91f2:	e7d8      	b.n	91a6 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
    91f4:	2303      	movs	r3, #3
    91f6:	e7d6      	b.n	91a6 <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
    91f8:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
    91fa:	bf41      	itttt	mi
    91fc:	687b      	ldrmi	r3, [r7, #4]
    91fe:	2101      	movmi	r1, #1
    9200:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
    9204:	f8c3 650c 	strmi.w	r6, [r3, #1292]	; 0x50c
}
    9208:	e7e4      	b.n	91d4 <gpio_nrfx_pin_configure+0xf0>
	if (flags & GPIO_PULL_UP) {
    920a:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    920c:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
    9210:	bf54      	ite	pl
    9212:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
    9216:	2403      	movmi	r4, #3
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    9218:	461a      	mov	r2, r3
    921a:	a901      	add	r1, sp, #4
    921c:	4628      	mov	r0, r5
	nrfx_gpiote_input_config_t input_config = {
    921e:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    9222:	f001 fb85 	bl	a930 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    9226:	4b02      	ldr	r3, [pc, #8]	; (9230 <gpio_nrfx_pin_configure+0x14c>)
    9228:	4298      	cmp	r0, r3
    922a:	f43f af7f 	beq.w	912c <gpio_nrfx_pin_configure+0x48>
    922e:	e792      	b.n	9156 <gpio_nrfx_pin_configure+0x72>
    9230:	0bad0000 	.word	0x0bad0000
    9234:	00f00006 	.word	0x00f00006
    9238:	00100006 	.word	0x00100006
    923c:	00400002 	.word	0x00400002

00009240 <sx1509b_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
static int sx1509b_init(const struct device *dev)
{
    9240:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct sx1509b_config *cfg = dev->config;
    9244:	6847      	ldr	r7, [r0, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
    9246:	6905      	ldr	r5, [r0, #16]
{
    9248:	4606      	mov	r6, r0
    924a:	b087      	sub	sp, #28
	int rc;

	drv_data->i2c_master = device_get_binding(cfg->i2c_master_dev_name);
    924c:	6878      	ldr	r0, [r7, #4]
    924e:	f002 fa0f 	bl	b670 <z_impl_device_get_binding>
    9252:	4603      	mov	r3, r0
    9254:	6068      	str	r0, [r5, #4]
	if (!drv_data->i2c_master) {
    9256:	bb00      	cbnz	r0, 929a <sx1509b_init+0x5a>
		LOG_ERR("%s: no bus %s", dev->name,
    9258:	687a      	ldr	r2, [r7, #4]
    925a:	9203      	str	r2, [sp, #12]
    925c:	6832      	ldr	r2, [r6, #0]
    925e:	9202      	str	r2, [sp, #8]
    9260:	4a4a      	ldr	r2, [pc, #296]	; (938c <sx1509b_init+0x14c>)
    9262:	494b      	ldr	r1, [pc, #300]	; (9390 <sx1509b_init+0x150>)
    9264:	e9cd 0200 	strd	r0, r2, [sp]
    9268:	2201      	movs	r2, #1
    926a:	f005 fd6a 	bl	ed42 <z_log_msg2_runtime_create.constprop.0>
			cfg->i2c_master_dev_name);
		rc = -EINVAL;
    926e:	f06f 0415 	mvn.w	r4, #21
				SX1509B_REG_MISC_FREQ);
	}

out:
	if (rc != 0) {
		LOG_ERR("%s init failed: %d", dev->name, rc);
    9272:	6833      	ldr	r3, [r6, #0]
    9274:	9302      	str	r3, [sp, #8]
    9276:	4b47      	ldr	r3, [pc, #284]	; (9394 <sx1509b_init+0x154>)
    9278:	9301      	str	r3, [sp, #4]
    927a:	2300      	movs	r3, #0
    927c:	4944      	ldr	r1, [pc, #272]	; (9390 <sx1509b_init+0x150>)
    927e:	9403      	str	r4, [sp, #12]
    9280:	9300      	str	r3, [sp, #0]
    9282:	2201      	movs	r2, #1
    9284:	4618      	mov	r0, r3
    9286:	f005 fd5c 	bl	ed42 <z_log_msg2_runtime_create.constprop.0>
	z_impl_k_sem_give(sem);
    928a:	f105 0020 	add.w	r0, r5, #32
    928e:	f002 fd53 	bl	bd38 <z_impl_k_sem_give>
	} else {
		LOG_INF("%s init ok", dev->name);
	}
	k_sem_give(&drv_data->lock);
	return rc;
}
    9292:	4620      	mov	r0, r4
    9294:	b007      	add	sp, #28
    9296:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	rc = i2c_reg_write_byte(drv_data->i2c_master, cfg->i2c_slave_addr,
    929a:	893b      	ldrh	r3, [r7, #8]
 */
static inline int i2c_reg_write_byte(const struct device *dev,
				     uint16_t dev_addr,
				     uint8_t reg_addr, uint8_t value)
{
	uint8_t tx_buf[2] = {reg_addr, value};
    929c:	f04f 097d 	mov.w	r9, #125	; 0x7d
    92a0:	f04f 0812 	mov.w	r8, #18

	return i2c_write(dev, tx_buf, 2, dev_addr);
    92a4:	2202      	movs	r2, #2
    92a6:	a905      	add	r1, sp, #20
	uint8_t tx_buf[2] = {reg_addr, value};
    92a8:	f88d 9014 	strb.w	r9, [sp, #20]
    92ac:	f88d 8015 	strb.w	r8, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
    92b0:	f005 fd57 	bl	ed62 <i2c_write>
	if (rc != 0) {
    92b4:	4604      	mov	r4, r0
    92b6:	b160      	cbz	r0, 92d2 <sx1509b_init+0x92>
		LOG_ERR("%s: reset m0 failed: %d\n", dev->name, rc);
    92b8:	6833      	ldr	r3, [r6, #0]
    92ba:	9302      	str	r3, [sp, #8]
    92bc:	4b36      	ldr	r3, [pc, #216]	; (9398 <sx1509b_init+0x158>)
    92be:	9301      	str	r3, [sp, #4]
    92c0:	2300      	movs	r3, #0
    92c2:	9003      	str	r0, [sp, #12]
    92c4:	4932      	ldr	r1, [pc, #200]	; (9390 <sx1509b_init+0x150>)
    92c6:	9300      	str	r3, [sp, #0]
    92c8:	2201      	movs	r2, #1
    92ca:	4618      	mov	r0, r3
    92cc:	f005 fd39 	bl	ed42 <z_log_msg2_runtime_create.constprop.0>
		goto out;
    92d0:	e7cf      	b.n	9272 <sx1509b_init+0x32>
	uint8_t tx_buf[2] = {reg_addr, value};
    92d2:	2234      	movs	r2, #52	; 0x34
	rc = i2c_reg_write_byte(drv_data->i2c_master, cfg->i2c_slave_addr,
    92d4:	6868      	ldr	r0, [r5, #4]
    92d6:	893b      	ldrh	r3, [r7, #8]
    92d8:	f88d 2015 	strb.w	r2, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
    92dc:	a905      	add	r1, sp, #20
    92de:	2202      	movs	r2, #2
	uint8_t tx_buf[2] = {reg_addr, value};
    92e0:	f88d 9014 	strb.w	r9, [sp, #20]
	return i2c_write(dev, tx_buf, 2, dev_addr);
    92e4:	f005 fd3d 	bl	ed62 <i2c_write>
	if (rc != 0) {
    92e8:	4604      	mov	r4, r0
    92ea:	2800      	cmp	r0, #0
    92ec:	d1c1      	bne.n	9272 <sx1509b_init+0x32>
	return z_impl_k_sleep(timeout);
    92ee:	2100      	movs	r1, #0
    92f0:	2063      	movs	r0, #99	; 0x63
    92f2:	f003 f9cd 	bl	c690 <z_impl_k_sleep>
	drv_data->pin_state = (struct sx1509b_pin_state) {
    92f6:	4642      	mov	r2, r8
    92f8:	4621      	mov	r1, r4
    92fa:	f105 0008 	add.w	r0, r5, #8
    92fe:	f004 fb8d 	bl	da1c <memset>
    9302:	f24e 03e0 	movw	r3, #57568	; 0xe0e0
	uint8_t tx_buf[2] = {reg_addr, value};
    9306:	221e      	movs	r2, #30
    9308:	832b      	strh	r3, [r5, #24]
	drv_data->debounce_state = (struct sx1509b_debounce_state) {
    930a:	83ac      	strh	r4, [r5, #28]
    930c:	77ac      	strb	r4, [r5, #30]
	rc = i2c_reg_write_byte(drv_data->i2c_master, cfg->i2c_slave_addr,
    930e:	6868      	ldr	r0, [r5, #4]
    9310:	893b      	ldrh	r3, [r7, #8]
    9312:	f88d 2014 	strb.w	r2, [sp, #20]
    9316:	2240      	movs	r2, #64	; 0x40
    9318:	f88d 2015 	strb.w	r2, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
    931c:	a905      	add	r1, sp, #20
    931e:	2202      	movs	r2, #2
    9320:	f005 fd1f 	bl	ed62 <i2c_write>
	drv_data->debounce_state = (struct sx1509b_debounce_state) {
    9324:	46a0      	mov	r8, r4
	if (rc == 0) {
    9326:	4604      	mov	r4, r0
    9328:	2800      	cmp	r0, #0
    932a:	d1a2      	bne.n	9272 <sx1509b_init+0x32>
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
    932c:	8b2b      	ldrh	r3, [r5, #24]
    932e:	8939      	ldrh	r1, [r7, #8]
    9330:	6868      	ldr	r0, [r5, #4]
    9332:	2210      	movs	r2, #16
    9334:	f005 fd22 	bl	ed7c <i2c_reg_write_word_be>
	if (rc == 0) {
    9338:	4604      	mov	r4, r0
    933a:	2800      	cmp	r0, #0
    933c:	d199      	bne.n	9272 <sx1509b_init+0x32>
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
    933e:	8aeb      	ldrh	r3, [r5, #22]
    9340:	8939      	ldrh	r1, [r7, #8]
    9342:	6868      	ldr	r0, [r5, #4]
    9344:	220e      	movs	r2, #14
    9346:	f005 fd19 	bl	ed7c <i2c_reg_write_word_be>
	if (rc == 0) {
    934a:	4604      	mov	r4, r0
    934c:	2800      	cmp	r0, #0
    934e:	d190      	bne.n	9272 <sx1509b_init+0x32>
	uint8_t tx_buf[3] = { reg_addr, value };
    9350:	221f      	movs	r2, #31
		rc = i2c_reg_write_byte_be(
    9352:	6868      	ldr	r0, [r5, #4]
    9354:	893b      	ldrh	r3, [r7, #8]
	uint8_t tx_buf[3] = { reg_addr, value };
    9356:	f88d 2014 	strb.w	r2, [sp, #20]
    935a:	2298      	movs	r2, #152	; 0x98
    935c:	f88d 2015 	strb.w	r2, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
    9360:	a905      	add	r1, sp, #20
    9362:	2202      	movs	r2, #2
	uint8_t tx_buf[3] = { reg_addr, value };
    9364:	f88d 8016 	strb.w	r8, [sp, #22]
	return i2c_write(dev, tx_buf, 2, dev_addr);
    9368:	f005 fcfb 	bl	ed62 <i2c_write>
	if (rc != 0) {
    936c:	4604      	mov	r4, r0
    936e:	2800      	cmp	r0, #0
    9370:	f47f af7f 	bne.w	9272 <sx1509b_init+0x32>
		LOG_INF("%s init ok", dev->name);
    9374:	6833      	ldr	r3, [r6, #0]
    9376:	9302      	str	r3, [sp, #8]
    9378:	4b08      	ldr	r3, [pc, #32]	; (939c <sx1509b_init+0x15c>)
    937a:	4905      	ldr	r1, [pc, #20]	; (9390 <sx1509b_init+0x150>)
    937c:	e9cd 0300 	strd	r0, r3, [sp]
    9380:	2203      	movs	r2, #3
    9382:	4603      	mov	r3, r0
    9384:	f005 fcdd 	bl	ed42 <z_log_msg2_runtime_create.constprop.0>
    9388:	e77f      	b.n	928a <sx1509b_init+0x4a>
    938a:	bf00      	nop
    938c:	00011d6d 	.word	0x00011d6d
    9390:	000102f8 	.word	0x000102f8
    9394:	00011d94 	.word	0x00011d94
    9398:	00011d7b 	.word	0x00011d7b
    939c:	00011da7 	.word	0x00011da7

000093a0 <i2c_nrfx_twim_recover_bus>:

	return 0;
}

static int i2c_nrfx_twim_recover_bus(const struct device *dev)
{
    93a0:	b508      	push	{r3, lr}
	const struct i2c_nrfx_twim_config *config = dev->config;
    93a2:	6843      	ldr	r3, [r0, #4]
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    return nrfx_twi_twim_bus_recover(scl_pin, sda_pin);
    93a4:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
    93a8:	f002 f844 	bl	b434 <nrfx_twi_twim_bus_recover>

	nrfx_err_t err = nrfx_twim_bus_recover(config->config.scl,
					       config->config.sda);

	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
    93ac:	4b03      	ldr	r3, [pc, #12]	; (93bc <i2c_nrfx_twim_recover_bus+0x1c>)
    93ae:	4298      	cmp	r0, r3
}
    93b0:	bf14      	ite	ne
    93b2:	f06f 000f 	mvnne.w	r0, #15
    93b6:	2000      	moveq	r0, #0
    93b8:	bd08      	pop	{r3, pc}
    93ba:	bf00      	nop
    93bc:	0bad0000 	.word	0x0bad0000

000093c0 <init_twim>:
	.transfer    = i2c_nrfx_twim_transfer,
	.recover_bus = i2c_nrfx_twim_recover_bus,
};

static int init_twim(const struct device *dev)
{
    93c0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    93c2:	4604      	mov	r4, r0
	const struct i2c_nrfx_twim_config *config = dev->config;
    93c4:	6840      	ldr	r0, [r0, #4]
	struct i2c_nrfx_twim_data *dev_data = dev->data;
	nrfx_err_t result = nrfx_twim_init(&config->twim, &config->config,
    93c6:	6923      	ldr	r3, [r4, #16]
    93c8:	4a0c      	ldr	r2, [pc, #48]	; (93fc <init_twim+0x3c>)
    93ca:	f100 0108 	add.w	r1, r0, #8
    93ce:	f001 fe25 	bl	b01c <nrfx_twim_init>
					   event_handler, dev_data);
	if (result != NRFX_SUCCESS) {
    93d2:	4b0b      	ldr	r3, [pc, #44]	; (9400 <init_twim+0x40>)
    93d4:	4298      	cmp	r0, r3
    93d6:	d00e      	beq.n	93f6 <init_twim+0x36>
		LOG_ERR("Failed to initialize device: %s",
    93d8:	6823      	ldr	r3, [r4, #0]
    93da:	9302      	str	r3, [sp, #8]
    93dc:	4b09      	ldr	r3, [pc, #36]	; (9404 <init_twim+0x44>)
    93de:	9301      	str	r3, [sp, #4]
    93e0:	2300      	movs	r3, #0
    93e2:	4618      	mov	r0, r3
    93e4:	4908      	ldr	r1, [pc, #32]	; (9408 <init_twim+0x48>)
    93e6:	9300      	str	r3, [sp, #0]
    93e8:	2201      	movs	r2, #1
    93ea:	f005 fe31 	bl	f050 <z_log_msg2_runtime_create.constprop.0>
    93ee:	f06f 000f 	mvn.w	r0, #15
			dev->name);
		return -EBUSY;
	}

	return 0;
}
    93f2:	b004      	add	sp, #16
    93f4:	bd10      	pop	{r4, pc}
	return 0;
    93f6:	2000      	movs	r0, #0
    93f8:	e7fb      	b.n	93f2 <init_twim+0x32>
    93fa:	bf00      	nop
    93fc:	0000940d 	.word	0x0000940d
    9400:	0bad0000 	.word	0x0bad0000
    9404:	00011dcc 	.word	0x00011dcc
    9408:	000102b8 	.word	0x000102b8

0000940c <event_handler>:
	switch (p_event->type) {
    940c:	7803      	ldrb	r3, [r0, #0]
    940e:	2b01      	cmp	r3, #1
    9410:	d008      	beq.n	9424 <event_handler+0x18>
    9412:	2b02      	cmp	r3, #2
    9414:	d008      	beq.n	9428 <event_handler+0x1c>
    9416:	b94b      	cbnz	r3, 942c <event_handler+0x20>
		dev_data->res = NRFX_SUCCESS;
    9418:	4b05      	ldr	r3, [pc, #20]	; (9430 <event_handler+0x24>)
		dev_data->res = NRFX_ERROR_INTERNAL;
    941a:	630b      	str	r3, [r1, #48]	; 0x30
	z_impl_k_sem_give(sem);
    941c:	f101 0018 	add.w	r0, r1, #24
    9420:	f002 bc8a 	b.w	bd38 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    9424:	4b03      	ldr	r3, [pc, #12]	; (9434 <event_handler+0x28>)
    9426:	e7f8      	b.n	941a <event_handler+0xe>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    9428:	4b03      	ldr	r3, [pc, #12]	; (9438 <event_handler+0x2c>)
    942a:	e7f6      	b.n	941a <event_handler+0xe>
		dev_data->res = NRFX_ERROR_INTERNAL;
    942c:	4b03      	ldr	r3, [pc, #12]	; (943c <event_handler+0x30>)
    942e:	e7f4      	b.n	941a <event_handler+0xe>
    9430:	0bad0000 	.word	0x0bad0000
    9434:	0bae0001 	.word	0x0bae0001
    9438:	0bae0002 	.word	0x0bae0002
    943c:	0bad0001 	.word	0x0bad0001

00009440 <i2c_nrfx_twim_configure>:
{
    9440:	b510      	push	{r4, lr}
	if (I2C_ADDR_10_BITS & dev_config) {
    9442:	f011 0301 	ands.w	r3, r1, #1
	const struct i2c_nrfx_twim_config *config = dev->config;
    9446:	6842      	ldr	r2, [r0, #4]
	struct i2c_nrfx_twim_data *data = dev->data;
    9448:	6904      	ldr	r4, [r0, #16]
{
    944a:	b088      	sub	sp, #32
	if (I2C_ADDR_10_BITS & dev_config) {
    944c:	d110      	bne.n	9470 <i2c_nrfx_twim_configure+0x30>
	switch (I2C_SPEED_GET(dev_config)) {
    944e:	f3c1 0042 	ubfx	r0, r1, #1, #3
    9452:	2801      	cmp	r0, #1
    9454:	d00f      	beq.n	9476 <i2c_nrfx_twim_configure+0x36>
    9456:	2802      	cmp	r0, #2
    9458:	d016      	beq.n	9488 <i2c_nrfx_twim_configure+0x48>
		LOG_ERR("unsupported speed");
    945a:	4a0d      	ldr	r2, [pc, #52]	; (9490 <i2c_nrfx_twim_configure+0x50>)
    945c:	9206      	str	r2, [sp, #24]
    945e:	2202      	movs	r2, #2
    9460:	9201      	str	r2, [sp, #4]
    9462:	9205      	str	r2, [sp, #20]
    9464:	480b      	ldr	r0, [pc, #44]	; (9494 <i2c_nrfx_twim_configure+0x54>)
    9466:	aa05      	add	r2, sp, #20
    9468:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    946c:	f004 fa62 	bl	d934 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
    9470:	f06f 0015 	mvn.w	r0, #21
    9474:	e006      	b.n	9484 <i2c_nrfx_twim_configure+0x44>
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_100K);
    9476:	6813      	ldr	r3, [r2, #0]
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
    9478:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
    947c:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	return 0;
    9480:	2000      	movs	r0, #0
	data->dev_config = dev_config;
    9482:	6361      	str	r1, [r4, #52]	; 0x34
}
    9484:	b008      	add	sp, #32
    9486:	bd10      	pop	{r4, pc}
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_400K);
    9488:	6813      	ldr	r3, [r2, #0]
    948a:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
    948e:	e7f5      	b.n	947c <i2c_nrfx_twim_configure+0x3c>
    9490:	00011dec 	.word	0x00011dec
    9494:	000102b8 	.word	0x000102b8

00009498 <i2c_nrfx_twim_transfer>:
{
    9498:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    949c:	b099      	sub	sp, #100	; 0x64
	struct i2c_nrfx_twim_data *dev_data = dev->data;
    949e:	f8d0 a010 	ldr.w	sl, [r0, #16]
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
    94a2:	6846      	ldr	r6, [r0, #4]
{
    94a4:	af06      	add	r7, sp, #24
    94a6:	461d      	mov	r5, r3
	nrfx_twim_xfer_desc_t cur_xfer = {
    94a8:	f107 0b1c 	add.w	fp, r7, #28
	uint8_t *msg_buf = dev_data->msg_buf;
    94ac:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
{
    94b0:	60fa      	str	r2, [r7, #12]
	uint8_t *msg_buf = dev_data->msg_buf;
    94b2:	617b      	str	r3, [r7, #20]
{
    94b4:	4681      	mov	r9, r0
	uint16_t concat_buf_size = dev_config->concat_buf_size;
    94b6:	8b33      	ldrh	r3, [r6, #24]
    94b8:	613b      	str	r3, [r7, #16]
{
    94ba:	460c      	mov	r4, r1
	nrfx_twim_xfer_desc_t cur_xfer = {
    94bc:	2214      	movs	r2, #20
    94be:	2100      	movs	r1, #0
    94c0:	4658      	mov	r0, fp
    94c2:	f004 faab 	bl	da1c <memset>
    94c6:	777d      	strb	r5, [r7, #29]
	return z_impl_k_sem_take(sem, timeout);
    94c8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    94cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    94d0:	4650      	mov	r0, sl
    94d2:	f002 fc57 	bl	bd84 <z_impl_k_sem_take>
	k_sem_take(&dev_data->completion_sync, K_NO_WAIT);
    94d6:	f10a 0318 	add.w	r3, sl, #24
    94da:	60bb      	str	r3, [r7, #8]
    94dc:	2200      	movs	r2, #0
    94de:	2300      	movs	r3, #0
    94e0:	f10a 0018 	add.w	r0, sl, #24
    94e4:	f002 fc4e 	bl	bd84 <z_impl_k_sem_take>
	for (size_t i = 0; i < num_msgs; i++) {
    94e8:	f04f 0800 	mov.w	r8, #0
	nrfx_twim_enable(&dev_config->twim);
    94ec:	4630      	mov	r0, r6
    94ee:	f001 fde5 	bl	b0bc <nrfx_twim_enable>
	uint16_t msg_buf_used = 0;
    94f2:	4645      	mov	r5, r8
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
    94f4:	f8c7 b004 	str.w	fp, [r7, #4]
	for (size_t i = 0; i < num_msgs; i++) {
    94f8:	68fb      	ldr	r3, [r7, #12]
    94fa:	4598      	cmp	r8, r3
    94fc:	d301      	bcc.n	9502 <i2c_nrfx_twim_transfer+0x6a>
    94fe:	2400      	movs	r4, #0
    9500:	e02e      	b.n	9560 <i2c_nrfx_twim_transfer+0xc8>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
    9502:	7a21      	ldrb	r1, [r4, #8]
    9504:	070b      	lsls	r3, r1, #28
    9506:	f100 80df 	bmi.w	96c8 <i2c_nrfx_twim_transfer+0x230>
				&& ((msgs[i].flags & I2C_MSG_READ)
    950a:	68fb      	ldr	r3, [r7, #12]
		bool concat_next = ((i + 1) < num_msgs)
    950c:	f108 0b01 	add.w	fp, r8, #1
				&& ((msgs[i].flags & I2C_MSG_READ)
    9510:	459b      	cmp	fp, r3
    9512:	d20a      	bcs.n	952a <i2c_nrfx_twim_transfer+0x92>
				&& !(msgs[i].flags & I2C_MSG_STOP)
    9514:	0788      	lsls	r0, r1, #30
    9516:	d408      	bmi.n	952a <i2c_nrfx_twim_transfer+0x92>
				&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
    9518:	7d23      	ldrb	r3, [r4, #20]
				    == (msgs[i + 1].flags & I2C_MSG_READ));
    951a:	ea81 0203 	eor.w	r2, r1, r3
				&& ((msgs[i].flags & I2C_MSG_READ)
    951e:	f002 0201 	and.w	r2, r2, #1
    9522:	f003 0304 	and.w	r3, r3, #4
    9526:	4313      	orrs	r3, r2
    9528:	d025      	beq.n	9576 <i2c_nrfx_twim_transfer+0xde>
		if (concat_next || (msg_buf_used != 0)) {
    952a:	2d00      	cmp	r5, #0
    952c:	d036      	beq.n	959c <i2c_nrfx_twim_transfer+0x104>
				&& ((msgs[i].flags & I2C_MSG_READ)
    952e:	2300      	movs	r3, #0
			if ((msg_buf_used + msgs[i].len) > concat_buf_size) {
    9530:	6862      	ldr	r2, [r4, #4]
    9532:	f8d7 c010 	ldr.w	ip, [r7, #16]
    9536:	18a8      	adds	r0, r5, r2
    9538:	4560      	cmp	r0, ip
    953a:	d91e      	bls.n	957a <i2c_nrfx_twim_transfer+0xe2>
				LOG_ERR("Need to use concatenation buffer and "
    953c:	f8d9 3000 	ldr.w	r3, [r9]
    9540:	9305      	str	r3, [sp, #20]
    9542:	693b      	ldr	r3, [r7, #16]
    9544:	4962      	ldr	r1, [pc, #392]	; (96d0 <i2c_nrfx_twim_transfer+0x238>)
    9546:	9502      	str	r5, [sp, #8]
    9548:	e9cd 2303 	strd	r2, r3, [sp, #12]
    954c:	4b61      	ldr	r3, [pc, #388]	; (96d4 <i2c_nrfx_twim_transfer+0x23c>)
    954e:	9301      	str	r3, [sp, #4]
    9550:	2300      	movs	r3, #0
    9552:	9300      	str	r3, [sp, #0]
    9554:	2201      	movs	r2, #1
    9556:	4618      	mov	r0, r3
    9558:	f005 fd7a 	bl	f050 <z_log_msg2_runtime_create.constprop.0>
				ret = -ENOSPC;
    955c:	f06f 041b 	mvn.w	r4, #27
	nrfx_twim_disable(&dev_config->twim);
    9560:	4630      	mov	r0, r6
    9562:	f001 fdbb 	bl	b0dc <nrfx_twim_disable>
	z_impl_k_sem_give(sem);
    9566:	4650      	mov	r0, sl
    9568:	f002 fbe6 	bl	bd38 <z_impl_k_sem_give>
}
    956c:	4620      	mov	r0, r4
    956e:	374c      	adds	r7, #76	; 0x4c
    9570:	46bd      	mov	sp, r7
    9572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				&& ((msgs[i].flags & I2C_MSG_READ)
    9576:	2301      	movs	r3, #1
    9578:	e7da      	b.n	9530 <i2c_nrfx_twim_transfer+0x98>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
    957a:	07c9      	lsls	r1, r1, #31
    957c:	d406      	bmi.n	958c <i2c_nrfx_twim_transfer+0xf4>
    957e:	603b      	str	r3, [r7, #0]
				memcpy(msg_buf + msg_buf_used,
    9580:	697b      	ldr	r3, [r7, #20]
    9582:	6821      	ldr	r1, [r4, #0]
    9584:	1958      	adds	r0, r3, r5
    9586:	f004 fa3e 	bl	da06 <memcpy>
    958a:	683b      	ldr	r3, [r7, #0]
			msg_buf_used += msgs[i].len;
    958c:	6862      	ldr	r2, [r4, #4]
    958e:	4415      	add	r5, r2
    9590:	b2ad      	uxth	r5, r5
		if (concat_next) {
    9592:	2b00      	cmp	r3, #0
    9594:	d03f      	beq.n	9616 <i2c_nrfx_twim_transfer+0x17e>
    9596:	340c      	adds	r4, #12
		bool concat_next = ((i + 1) < num_msgs)
    9598:	46d8      	mov	r8, fp
    959a:	e7ad      	b.n	94f8 <i2c_nrfx_twim_transfer+0x60>
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
    959c:	07ca      	lsls	r2, r1, #31
    959e:	d51c      	bpl.n	95da <i2c_nrfx_twim_transfer+0x142>
			cur_xfer.p_primary_buf = msgs[i].buf;
    95a0:	6823      	ldr	r3, [r4, #0]
    95a2:	62bb      	str	r3, [r7, #40]	; 0x28
			cur_xfer.primary_length = msgs[i].len;
    95a4:	6863      	ldr	r3, [r4, #4]
    95a6:	623b      	str	r3, [r7, #32]
    95a8:	2500      	movs	r5, #0
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
    95aa:	7a23      	ldrb	r3, [r4, #8]
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
    95ac:	6879      	ldr	r1, [r7, #4]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
    95ae:	f003 0201 	and.w	r2, r3, #1
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
    95b2:	f013 0f02 	tst.w	r3, #2
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
    95b6:	773a      	strb	r2, [r7, #28]
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
    95b8:	4630      	mov	r0, r6
    95ba:	bf0c      	ite	eq
    95bc:	2220      	moveq	r2, #32
    95be:	2200      	movne	r2, #0
    95c0:	f001 fdaa 	bl	b118 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
    95c4:	4b44      	ldr	r3, [pc, #272]	; (96d8 <i2c_nrfx_twim_transfer+0x240>)
    95c6:	4298      	cmp	r0, r3
    95c8:	d02b      	beq.n	9622 <i2c_nrfx_twim_transfer+0x18a>
			if (res == NRFX_ERROR_BUSY) {
    95ca:	330b      	adds	r3, #11
				ret = -EIO;
    95cc:	4298      	cmp	r0, r3
    95ce:	bf0c      	ite	eq
    95d0:	f06f 040f 	mvneq.w	r4, #15
    95d4:	f06f 0404 	mvnne.w	r4, #4
    95d8:	e7c2      	b.n	9560 <i2c_nrfx_twim_transfer+0xc8>
			   !nrfx_is_in_ram(msgs[i].buf)) {
    95da:	6821      	ldr	r1, [r4, #0]

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    95dc:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
    95e0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    95e4:	d0dc      	beq.n	95a0 <i2c_nrfx_twim_transfer+0x108>
			if (msgs[i].len > dev_config->flash_buf_max_size) {
    95e6:	6862      	ldr	r2, [r4, #4]
    95e8:	8b73      	ldrh	r3, [r6, #26]
    95ea:	4293      	cmp	r3, r2
    95ec:	d20f      	bcs.n	960e <i2c_nrfx_twim_transfer+0x176>
				LOG_ERR("Cannot copy flash buffer of size: %u. "
    95ee:	f8d9 3000 	ldr.w	r3, [r9]
    95f2:	4937      	ldr	r1, [pc, #220]	; (96d0 <i2c_nrfx_twim_transfer+0x238>)
    95f4:	e9cd 2302 	strd	r2, r3, [sp, #8]
    95f8:	4b38      	ldr	r3, [pc, #224]	; (96dc <i2c_nrfx_twim_transfer+0x244>)
    95fa:	2201      	movs	r2, #1
    95fc:	e9cd 5300 	strd	r5, r3, [sp]
    9600:	4628      	mov	r0, r5
    9602:	462b      	mov	r3, r5
    9604:	f005 fd24 	bl	f050 <z_log_msg2_runtime_create.constprop.0>
				ret = -EINVAL;
    9608:	f06f 0415 	mvn.w	r4, #21
				break;
    960c:	e7a8      	b.n	9560 <i2c_nrfx_twim_transfer+0xc8>
			memcpy(msg_buf, msgs[i].buf, msgs[i].len);
    960e:	6978      	ldr	r0, [r7, #20]
    9610:	f004 f9f9 	bl	da06 <memcpy>
			msg_buf_used = msgs[i].len;
    9614:	88a5      	ldrh	r5, [r4, #4]
		if (msg_buf_used == 0) {
    9616:	2d00      	cmp	r5, #0
    9618:	d0c2      	beq.n	95a0 <i2c_nrfx_twim_transfer+0x108>
			cur_xfer.p_primary_buf = msg_buf;
    961a:	697b      	ldr	r3, [r7, #20]
    961c:	62bb      	str	r3, [r7, #40]	; 0x28
			cur_xfer.primary_length = msg_buf_used;
    961e:	623d      	str	r5, [r7, #32]
    9620:	e7c3      	b.n	95aa <i2c_nrfx_twim_transfer+0x112>
	return z_impl_k_sem_take(sem, timeout);
    9622:	2300      	movs	r3, #0
    9624:	68b8      	ldr	r0, [r7, #8]
    9626:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    962a:	f002 fbab 	bl	bd84 <z_impl_k_sem_take>
		if (ret != 0) {
    962e:	4603      	mov	r3, r0
    9630:	b1b8      	cbz	r0, 9662 <i2c_nrfx_twim_transfer+0x1ca>
			LOG_ERR("Error on I2C line occurred for message %d", i);
    9632:	4b2b      	ldr	r3, [pc, #172]	; (96e0 <i2c_nrfx_twim_transfer+0x248>)
    9634:	e9c7 3810 	strd	r3, r8, [r7, #64]	; 0x40
    9638:	2303      	movs	r3, #3
    963a:	61bb      	str	r3, [r7, #24]
    963c:	63fb      	str	r3, [r7, #60]	; 0x3c
    963e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    9642:	4823      	ldr	r0, [pc, #140]	; (96d0 <i2c_nrfx_twim_transfer+0x238>)
    9644:	2300      	movs	r3, #0
    9646:	f107 023c 	add.w	r2, r7, #60	; 0x3c
    964a:	f004 f973 	bl	d934 <z_impl_z_log_msg2_static_create>
			nrfx_twim_disable(&dev_config->twim);
    964e:	4630      	mov	r0, r6
    9650:	f001 fd44 	bl	b0dc <nrfx_twim_disable>
    9654:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
    9658:	f001 feec 	bl	b434 <nrfx_twi_twim_bus_recover>
			ret = -EIO;
    965c:	f06f 0404 	mvn.w	r4, #4
			break;
    9660:	e77e      	b.n	9560 <i2c_nrfx_twim_transfer+0xc8>
		res = dev_data->res;
    9662:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
    9666:	4a1c      	ldr	r2, [pc, #112]	; (96d8 <i2c_nrfx_twim_transfer+0x240>)
    9668:	4291      	cmp	r1, r2
    966a:	d012      	beq.n	9692 <i2c_nrfx_twim_transfer+0x1fa>
			LOG_ERR("Error 0x%08X occurred for message %d", res, i);
    966c:	481d      	ldr	r0, [pc, #116]	; (96e4 <i2c_nrfx_twim_transfer+0x24c>)
    966e:	466c      	mov	r4, sp
    9670:	b088      	sub	sp, #32
    9672:	aa06      	add	r2, sp, #24
    9674:	e9c2 0104 	strd	r0, r1, [r2, #16]
    9678:	2104      	movs	r1, #4
    967a:	f8c2 8018 	str.w	r8, [r2, #24]
    967e:	6339      	str	r1, [r7, #48]	; 0x30
    9680:	f842 1f0c 	str.w	r1, [r2, #12]!
    9684:	4812      	ldr	r0, [pc, #72]	; (96d0 <i2c_nrfx_twim_transfer+0x238>)
    9686:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    968a:	f004 f953 	bl	d934 <z_impl_z_log_msg2_static_create>
    968e:	46a5      	mov	sp, r4
    9690:	e7e4      	b.n	965c <i2c_nrfx_twim_transfer+0x1c4>
		if ((msgs[i].flags & I2C_MSG_READ)
    9692:	7a23      	ldrb	r3, [r4, #8]
    9694:	07db      	lsls	r3, r3, #31
    9696:	d401      	bmi.n	969c <i2c_nrfx_twim_transfer+0x204>
		msg_buf_used = 0;
    9698:	2500      	movs	r5, #0
    969a:	e77c      	b.n	9596 <i2c_nrfx_twim_transfer+0xfe>
		    && cur_xfer.p_primary_buf == msg_buf) {
    969c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    969e:	697a      	ldr	r2, [r7, #20]
    96a0:	429a      	cmp	r2, r3
    96a2:	d1f9      	bne.n	9698 <i2c_nrfx_twim_transfer+0x200>
    96a4:	46a0      	mov	r8, r4
    96a6:	e008      	b.n	96ba <i2c_nrfx_twim_transfer+0x222>
				memcpy(msgs[j].buf,
    96a8:	697b      	ldr	r3, [r7, #20]
    96aa:	f8d8 000c 	ldr.w	r0, [r8, #12]
				msg_buf_used -= msgs[j].len;
    96ae:	1aa9      	subs	r1, r5, r2
    96b0:	b28d      	uxth	r5, r1
				memcpy(msgs[j].buf,
    96b2:	fa13 f181 	uxtah	r1, r3, r1
    96b6:	f004 f9a6 	bl	da06 <memcpy>
			while (msg_buf_used >= msgs[j].len) {
    96ba:	f8d8 2004 	ldr.w	r2, [r8, #4]
    96be:	4295      	cmp	r5, r2
    96c0:	f1a8 080c 	sub.w	r8, r8, #12
    96c4:	d2f0      	bcs.n	96a8 <i2c_nrfx_twim_transfer+0x210>
    96c6:	e7e7      	b.n	9698 <i2c_nrfx_twim_transfer+0x200>
			ret = -ENOTSUP;
    96c8:	f06f 0485 	mvn.w	r4, #133	; 0x85
    96cc:	e748      	b.n	9560 <i2c_nrfx_twim_transfer+0xc8>
    96ce:	bf00      	nop
    96d0:	000102b8 	.word	0x000102b8
    96d4:	00011dfe 	.word	0x00011dfe
    96d8:	0bad0000 	.word	0x0bad0000
    96dc:	00011e8e 	.word	0x00011e8e
    96e0:	00011ef4 	.word	0x00011ef4
    96e4:	00011f1e 	.word	0x00011f1e

000096e8 <common_init.isra.0>:
 *
 * @param gpiop where to store the GPIO device pointer
 *
 * @return negative on error, otherwise zero.
 */
static int common_init(const struct device *dev)
    96e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    96ea:	4604      	mov	r4, r0
    96ec:	b085      	sub	sp, #20
{
	const struct driver_config *cfg = dev->config;
	gpio_flags_t flags;

	if (!device_is_ready(cfg->enable.port)) {
    96ee:	68c0      	ldr	r0, [r0, #12]
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
    96f0:	f005 feda 	bl	f4a8 <z_device_is_ready>
    96f4:	4603      	mov	r3, r0
    96f6:	b970      	cbnz	r0, 9716 <common_init.isra.0+0x2e>
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
    96f8:	68e2      	ldr	r2, [r4, #12]
    96fa:	491c      	ldr	r1, [pc, #112]	; (976c <common_init.isra.0+0x84>)
    96fc:	6812      	ldr	r2, [r2, #0]
    96fe:	9202      	str	r2, [sp, #8]
    9700:	4a1b      	ldr	r2, [pc, #108]	; (9770 <common_init.isra.0+0x88>)
    9702:	e9cd 0200 	strd	r0, r2, [sp]
    9706:	2201      	movs	r2, #1
    9708:	f005 fd25 	bl	f156 <z_log_msg2_runtime_create.constprop.0>
		return -ENODEV;
    970c:	f06f 0412 	mvn.w	r4, #18
		 */
		k_busy_wait(delay_us);
	}

	return rc;
}
    9710:	4620      	mov	r0, r4
    9712:	b005      	add	sp, #20
    9714:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (on) {
    9716:	7d25      	ldrb	r5, [r4, #20]
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
{
	return gpio_pin_configure(spec->port,
				  spec->pin,
				  spec->dt_flags | extra_flags);
    9718:	7c63      	ldrb	r3, [r4, #17]
	return gpio_pin_configure(spec->port,
    971a:	68e0      	ldr	r0, [r4, #12]
    971c:	7c21      	ldrb	r1, [r4, #16]
    971e:	f015 0503 	ands.w	r5, r5, #3
		flags = GPIO_OUTPUT_ACTIVE;
    9722:	bf16      	itet	ne
    9724:	f44f 52d0 	movne.w	r2, #6656	; 0x1a00
		flags = GPIO_OUTPUT_INACTIVE;
    9728:	f44f 52b0 	moveq.w	r2, #5632	; 0x1600
		delay_us = cfg->startup_delay_us;
    972c:	6865      	ldrne	r5, [r4, #4]
    972e:	4313      	orrs	r3, r2
	struct gpio_driver_data *data =
    9730:	6907      	ldr	r7, [r0, #16]
	const struct gpio_driver_api *api =
    9732:	f8d0 c008 	ldr.w	ip, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
    9736:	683c      	ldr	r4, [r7, #0]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    9738:	07da      	lsls	r2, r3, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
    973a:	bf48      	it	mi
    973c:	f483 6340 	eormi.w	r3, r3, #3072	; 0xc00
		data->invert |= (gpio_port_pins_t)BIT(pin);
    9740:	2601      	movs	r6, #1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
    9742:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
		data->invert |= (gpio_port_pins_t)BIT(pin);
    9746:	408e      	lsls	r6, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    9748:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
    974a:	bf4c      	ite	mi
    974c:	4334      	orrmi	r4, r6
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    974e:	43b4      	bicpl	r4, r6
    9750:	603c      	str	r4, [r7, #0]
	return api->pin_configure(port, pin, flags);
    9752:	f8dc 3000 	ldr.w	r3, [ip]
    9756:	4798      	blx	r3
	if ((rc == 0) && (delay_us > 0)) {
    9758:	4604      	mov	r4, r0
    975a:	2800      	cmp	r0, #0
    975c:	d1d8      	bne.n	9710 <common_init.isra.0+0x28>
    975e:	2d00      	cmp	r5, #0
    9760:	d0d6      	beq.n	9710 <common_init.isra.0+0x28>
	z_impl_k_busy_wait(usec_to_wait);
    9762:	4628      	mov	r0, r5
    9764:	f006 fa19 	bl	fb9a <z_impl_k_busy_wait>
}
    9768:	e7d2      	b.n	9710 <common_init.isra.0+0x28>
    976a:	bf00      	nop
    976c:	000102e8 	.word	0x000102e8
    9770:	00011f57 	.word	0x00011f57

00009774 <regulator_fixed_init_onoff>:
	.enable = enable_onoff,
	.disable = disable_onoff,
};

static int regulator_fixed_init_onoff(const struct device *dev)
{
    9774:	b530      	push	{r4, r5, lr}
	struct driver_data_onoff *data = dev->data;
    9776:	6905      	ldr	r5, [r0, #16]
	int rc;

	data->dev = dev;
	rc = onoff_manager_init(&data->mgr, &transitions);
    9778:	4910      	ldr	r1, [pc, #64]	; (97bc <regulator_fixed_init_onoff+0x48>)
{
    977a:	4604      	mov	r4, r0
	data->dev = dev;
    977c:	4628      	mov	r0, r5
{
    977e:	b085      	sub	sp, #20
	data->dev = dev;
    9780:	f840 4b04 	str.w	r4, [r0], #4
	rc = onoff_manager_init(&data->mgr, &transitions);
    9784:	f003 fba4 	bl	ced0 <onoff_manager_init>
	__ASSERT_NO_MSG(rc == 0);

#ifdef CONFIG_MULTITHREADING
	k_work_init_delayable(&data->dwork, onoff_worker);
    9788:	490d      	ldr	r1, [pc, #52]	; (97c0 <regulator_fixed_init_onoff+0x4c>)
    978a:	f105 0020 	add.w	r0, r5, #32
    978e:	f006 f88d 	bl	f8ac <k_work_init_delayable>
#endif /* CONFIG_MULTITHREADING */

	rc = common_init(dev);
    9792:	6860      	ldr	r0, [r4, #4]
    9794:	f7ff ffa8 	bl	96e8 <common_init.isra.0>
	if (rc >= 0) {
		rc = 0;
	}

	LOG_INF("%s onoff: %d", dev->name, rc);
    9798:	6823      	ldr	r3, [r4, #0]
    979a:	9302      	str	r3, [sp, #8]
    979c:	4b09      	ldr	r3, [pc, #36]	; (97c4 <regulator_fixed_init_onoff+0x50>)
    979e:	9301      	str	r3, [sp, #4]
    97a0:	ea00 75e0 	and.w	r5, r0, r0, asr #31
    97a4:	2300      	movs	r3, #0
    97a6:	4618      	mov	r0, r3
    97a8:	4907      	ldr	r1, [pc, #28]	; (97c8 <regulator_fixed_init_onoff+0x54>)
    97aa:	9503      	str	r5, [sp, #12]
    97ac:	9300      	str	r3, [sp, #0]
    97ae:	2203      	movs	r2, #3
    97b0:	f005 fcd1 	bl	f156 <z_log_msg2_runtime_create.constprop.0>

	return rc;
}
    97b4:	4628      	mov	r0, r5
    97b6:	b005      	add	sp, #20
    97b8:	bd30      	pop	{r4, r5, pc}
    97ba:	bf00      	nop
    97bc:	000106c4 	.word	0x000106c4
    97c0:	0000f173 	.word	0x0000f173
    97c4:	00011f6f 	.word	0x00011f6f
    97c8:	000102e8 	.word	0x000102e8

000097cc <regulator_fixed_init_sync>:
	.enable = enable_sync,
	.disable = disable_sync,
};

static int regulator_fixed_init_sync(const struct device *dev)
{
    97cc:	b530      	push	{r4, r5, lr}
    97ce:	4605      	mov	r5, r0
    97d0:	b085      	sub	sp, #20
	const struct driver_config *cfg = dev->config;
	int rc = common_init(dev);
    97d2:	6840      	ldr	r0, [r0, #4]
    97d4:	f7ff ff88 	bl	96e8 <common_init.isra.0>
	__ASSERT(cfg->startup_delay_us == 0,
		 "sync not valid with startup delay");
	__ASSERT(cfg->off_on_delay_us == 0,
		 "sync not valid with shutdown delay");

	LOG_INF("%s sync: %d", dev->name, rc);
    97d8:	682b      	ldr	r3, [r5, #0]
    97da:	9302      	str	r3, [sp, #8]
    97dc:	4b06      	ldr	r3, [pc, #24]	; (97f8 <regulator_fixed_init_sync+0x2c>)
    97de:	9301      	str	r3, [sp, #4]
    97e0:	2300      	movs	r3, #0
	int rc = common_init(dev);
    97e2:	4604      	mov	r4, r0
	LOG_INF("%s sync: %d", dev->name, rc);
    97e4:	9003      	str	r0, [sp, #12]
    97e6:	4905      	ldr	r1, [pc, #20]	; (97fc <regulator_fixed_init_sync+0x30>)
    97e8:	9300      	str	r3, [sp, #0]
    97ea:	4618      	mov	r0, r3
    97ec:	2203      	movs	r2, #3
    97ee:	f005 fcb2 	bl	f156 <z_log_msg2_runtime_create.constprop.0>

	return rc;
}
    97f2:	4620      	mov	r0, r4
    97f4:	b005      	add	sp, #20
    97f6:	bd30      	pop	{r4, r5, pc}
    97f8:	00011f7c 	.word	0x00011f7c
    97fc:	000102e8 	.word	0x000102e8

00009800 <finalize_transition>:
{
    9800:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if ((rc >= 0) && (delay_us > 0)) {
    9804:	1e1c      	subs	r4, r3, #0
{
    9806:	4605      	mov	r5, r0
    9808:	460f      	mov	r7, r1
    980a:	4690      	mov	r8, r2
	if ((rc >= 0) && (delay_us > 0)) {
    980c:	db10      	blt.n	9830 <finalize_transition+0x30>
    980e:	b17a      	cbz	r2, 9830 <finalize_transition+0x30>
			return (uint32_t)((t * to_hz + off) / from_hz);
    9810:	ea4f 4952 	mov.w	r9, r2, lsr #17
    9814:	03d6      	lsls	r6, r2, #15
    9816:	2300      	movs	r3, #0
    9818:	4a14      	ldr	r2, [pc, #80]	; (986c <finalize_transition+0x6c>)
    981a:	4630      	mov	r0, r6
    981c:	4649      	mov	r1, r9
    981e:	f7f6 fc5f 	bl	e0 <__aeabi_uldivmod>
		    || k_is_pre_kernel()
    9822:	b110      	cbz	r0, 982a <finalize_transition+0x2a>
	return !z_sys_post_kernel;
    9824:	4b12      	ldr	r3, [pc, #72]	; (9870 <finalize_transition+0x70>)
    9826:	781b      	ldrb	r3, [r3, #0]
    9828:	b943      	cbnz	r3, 983c <finalize_transition+0x3c>
	z_impl_k_busy_wait(usec_to_wait);
    982a:	4640      	mov	r0, r8
    982c:	f006 f9b5 	bl	fb9a <z_impl_k_busy_wait>
	notify(&data->mgr, rc);
    9830:	4621      	mov	r1, r4
    9832:	1d28      	adds	r0, r5, #4
    9834:	463b      	mov	r3, r7
}
    9836:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	notify(&data->mgr, rc);
    983a:	4718      	bx	r3
			return ((t * to_hz + off) / from_hz);
    983c:	480d      	ldr	r0, [pc, #52]	; (9874 <finalize_transition+0x74>)
    983e:	4a0b      	ldr	r2, [pc, #44]	; (986c <finalize_transition+0x6c>)
			data->notify = notify;
    9840:	652f      	str	r7, [r5, #80]	; 0x50
    9842:	1830      	adds	r0, r6, r0
			data->task = WORK_TASK_DELAY;
    9844:	f04f 0303 	mov.w	r3, #3
    9848:	f149 0100 	adc.w	r1, r9, #0
    984c:	f885 3054 	strb.w	r3, [r5, #84]	; 0x54
    9850:	2300      	movs	r3, #0
    9852:	f7f6 fc45 	bl	e0 <__aeabi_uldivmod>
    9856:	4602      	mov	r2, r0
    9858:	460b      	mov	r3, r1
			rc = k_work_schedule(&data->dwork, K_USEC(delay_us));
    985a:	f105 0020 	add.w	r0, r5, #32
    985e:	f002 fc07 	bl	c070 <k_work_schedule>
			if (rc >= 0) {
    9862:	1e04      	subs	r4, r0, #0
    9864:	dbe4      	blt.n	9830 <finalize_transition+0x30>
}
    9866:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    986a:	bf00      	nop
    986c:	000f4240 	.word	0x000f4240
    9870:	20002262 	.word	0x20002262
    9874:	000f423f 	.word	0x000f423f

00009878 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
    9878:	b570      	push	{r4, r5, r6, lr}
		break;
	default:
		return -ENOTSUP;
	}
#else
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
    987a:	794b      	ldrb	r3, [r1, #5]
    987c:	2b01      	cmp	r3, #1
    987e:	d120      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    9880:	798b      	ldrb	r3, [r1, #6]
    9882:	2b03      	cmp	r3, #3
    9884:	d11d      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    9886:	79cc      	ldrb	r4, [r1, #7]
    9888:	b10c      	cbz	r4, 988e <uarte_nrfx_configure+0x16>
    988a:	2c01      	cmp	r4, #1
    988c:	d119      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    988e:	790a      	ldrb	r2, [r1, #4]
    9890:	b112      	cbz	r2, 9898 <uarte_nrfx_configure+0x20>
    9892:	2a02      	cmp	r2, #2
    9894:	d115      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
    9896:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    9898:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    989a:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
    989c:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
    98a0:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
    98a2:	d062      	beq.n	996a <uarte_nrfx_configure+0xf2>
    98a4:	d82b      	bhi.n	98fe <uarte_nrfx_configure+0x86>
    98a6:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    98aa:	d061      	beq.n	9970 <uarte_nrfx_configure+0xf8>
    98ac:	d814      	bhi.n	98d8 <uarte_nrfx_configure+0x60>
    98ae:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    98b2:	d05f      	beq.n	9974 <uarte_nrfx_configure+0xfc>
    98b4:	d808      	bhi.n	98c8 <uarte_nrfx_configure+0x50>
    98b6:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    98ba:	d05e      	beq.n	997a <uarte_nrfx_configure+0x102>
    98bc:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    98c0:	d05e      	beq.n	9980 <uarte_nrfx_configure+0x108>
    98c2:	f06f 0085 	mvn.w	r0, #133	; 0x85
    98c6:	e04f      	b.n	9968 <uarte_nrfx_configure+0xf0>
    98c8:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    98cc:	d05b      	beq.n	9986 <uarte_nrfx_configure+0x10e>
    98ce:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    98d2:	d1f6      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    98d4:	4b36      	ldr	r3, [pc, #216]	; (99b0 <uarte_nrfx_configure+0x138>)
    98d6:	e03c      	b.n	9952 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
    98d8:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    98dc:	d056      	beq.n	998c <uarte_nrfx_configure+0x114>
    98de:	d807      	bhi.n	98f0 <uarte_nrfx_configure+0x78>
    98e0:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    98e4:	d054      	beq.n	9990 <uarte_nrfx_configure+0x118>
    98e6:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    98ea:	d1ea      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    98ec:	4b31      	ldr	r3, [pc, #196]	; (99b4 <uarte_nrfx_configure+0x13c>)
    98ee:	e030      	b.n	9952 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
    98f0:	f647 2612 	movw	r6, #31250	; 0x7a12
    98f4:	42b3      	cmp	r3, r6
    98f6:	d1e4      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    98f8:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    98fc:	e029      	b.n	9952 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
    98fe:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    9902:	d047      	beq.n	9994 <uarte_nrfx_configure+0x11c>
    9904:	d813      	bhi.n	992e <uarte_nrfx_configure+0xb6>
    9906:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    990a:	d046      	beq.n	999a <uarte_nrfx_configure+0x122>
    990c:	d809      	bhi.n	9922 <uarte_nrfx_configure+0xaa>
    990e:	f64d 26c0 	movw	r6, #56000	; 0xdac0
    9912:	42b3      	cmp	r3, r6
    9914:	d043      	beq.n	999e <uarte_nrfx_configure+0x126>
    9916:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    991a:	d1d2      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    991c:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    9920:	e017      	b.n	9952 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
    9922:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    9926:	d1cc      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    9928:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    992c:	e011      	b.n	9952 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
    992e:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    9932:	d037      	beq.n	99a4 <uarte_nrfx_configure+0x12c>
    9934:	d808      	bhi.n	9948 <uarte_nrfx_configure+0xd0>
    9936:	4e20      	ldr	r6, [pc, #128]	; (99b8 <uarte_nrfx_configure+0x140>)
    9938:	42b3      	cmp	r3, r6
    993a:	d036      	beq.n	99aa <uarte_nrfx_configure+0x132>
    993c:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    9940:	d1bf      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    9942:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    9946:	e004      	b.n	9952 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
    9948:	4e1c      	ldr	r6, [pc, #112]	; (99bc <uarte_nrfx_configure+0x144>)
    994a:	42b3      	cmp	r3, r6
    994c:	d1b9      	bne.n	98c2 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    994e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
	struct uarte_nrfx_data *data = dev->data;
    9952:	6900      	ldr	r0, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    9954:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	data->uart_config = *cfg;
    9958:	1d03      	adds	r3, r0, #4
    995a:	c903      	ldmia	r1, {r0, r1}
                    | (uint32_t)p_cfg->hwfc;
    995c:	4322      	orrs	r2, r4
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    995e:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
    9962:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    9966:	2000      	movs	r0, #0
}
    9968:	bd70      	pop	{r4, r5, r6, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    996a:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    996e:	e7f0      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    9970:	4b13      	ldr	r3, [pc, #76]	; (99c0 <uarte_nrfx_configure+0x148>)
    9972:	e7ee      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    9974:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    9978:	e7eb      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = 0x00014000;
    997a:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    997e:	e7e8      	b.n	9952 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
    9980:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    9984:	e7e5      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    9986:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    998a:	e7e2      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    998c:	4b0d      	ldr	r3, [pc, #52]	; (99c4 <uarte_nrfx_configure+0x14c>)
    998e:	e7e0      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    9990:	4b0d      	ldr	r3, [pc, #52]	; (99c8 <uarte_nrfx_configure+0x150>)
    9992:	e7de      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    9994:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    9998:	e7db      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    999a:	4b0c      	ldr	r3, [pc, #48]	; (99cc <uarte_nrfx_configure+0x154>)
    999c:	e7d9      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    999e:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    99a2:	e7d6      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    99a4:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    99a8:	e7d3      	b.n	9952 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    99aa:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    99ae:	e7d0      	b.n	9952 <uarte_nrfx_configure+0xda>
    99b0:	0013b000 	.word	0x0013b000
    99b4:	004ea000 	.word	0x004ea000
    99b8:	0003d090 	.word	0x0003d090
    99bc:	000f4240 	.word	0x000f4240
    99c0:	00275000 	.word	0x00275000
    99c4:	0075c000 	.word	0x0075c000
    99c8:	003af000 	.word	0x003af000
    99cc:	013a9000 	.word	0x013a9000

000099d0 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
    99d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct uarte_nrfx_data *data = dev->data;
    99d2:	6906      	ldr	r6, [r0, #16]
{
    99d4:	4605      	mov	r5, r0
    99d6:	460f      	mov	r7, r1
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    99d8:	f005 fdee 	bl	f5b8 <k_is_in_isr>
    99dc:	b910      	cbnz	r0, 99e4 <uarte_nrfx_poll_out+0x14>
    99de:	4b2c      	ldr	r3, [pc, #176]	; (9a90 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
    99e0:	781b      	ldrb	r3, [r3, #0]
    99e2:	b983      	cbnz	r3, 9a06 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
    99e4:	f04f 0320 	mov.w	r3, #32
    99e8:	f3ef 8411 	mrs	r4, BASEPRI
    99ec:	f383 8812 	msr	BASEPRI_MAX, r3
    99f0:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
    99f4:	6868      	ldr	r0, [r5, #4]
    99f6:	f005 fc5a 	bl	f2ae <is_tx_ready.isra.0>
    99fa:	bb28      	cbnz	r0, 9a48 <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
    99fc:	f384 8811 	msr	BASEPRI, r4
    9a00:	f3bf 8f6f 	isb	sy
}
    9a04:	e7ee      	b.n	99e4 <uarte_nrfx_poll_out+0x14>
{
    9a06:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
    9a08:	6868      	ldr	r0, [r5, #4]
    9a0a:	f005 fc50 	bl	f2ae <is_tx_ready.isra.0>
    9a0e:	b970      	cbnz	r0, 9a2e <uarte_nrfx_poll_out+0x5e>
    9a10:	2001      	movs	r0, #1
    9a12:	f005 fca9 	bl	f368 <nrfx_busy_wait>
    9a16:	3c01      	subs	r4, #1
    9a18:	d1f6      	bne.n	9a08 <uarte_nrfx_poll_out+0x38>
	return z_impl_k_sleep(timeout);
    9a1a:	2100      	movs	r1, #0
    9a1c:	2021      	movs	r0, #33	; 0x21
    9a1e:	f002 fe37 	bl	c690 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    9a22:	e7f0      	b.n	9a06 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
    9a24:	f384 8811 	msr	BASEPRI, r4
    9a28:	f3bf 8f6f 	isb	sy
}
    9a2c:	e7f5      	b.n	9a1a <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
    9a2e:	f04f 0320 	mov.w	r3, #32
    9a32:	f3ef 8411 	mrs	r4, BASEPRI
    9a36:	f383 8812 	msr	BASEPRI_MAX, r3
    9a3a:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
    9a3e:	6868      	ldr	r0, [r5, #4]
    9a40:	f005 fc35 	bl	f2ae <is_tx_ready.isra.0>
    9a44:	2800      	cmp	r0, #0
    9a46:	d0ed      	beq.n	9a24 <uarte_nrfx_poll_out+0x54>
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
    9a48:	f806 7f10 	strb.w	r7, [r6, #16]!
	tx_start(dev, &data->char_out, 1);
    9a4c:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
    9a4e:	680b      	ldr	r3, [r1, #0]
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
    9a50:	2201      	movs	r2, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    9a52:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    9a56:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    9a5a:	2200      	movs	r2, #0
    9a5c:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    9a60:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
    9a64:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
    9a68:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
    9a6c:	684a      	ldr	r2, [r1, #4]
    9a6e:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    9a70:	bf41      	itttt	mi
    9a72:	2208      	movmi	r2, #8
    9a74:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
    9a78:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
    9a7c:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9a80:	2201      	movs	r2, #1
    9a82:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
    9a84:	f384 8811 	msr	BASEPRI, r4
    9a88:	f3bf 8f6f 	isb	sy

	irq_unlock(key);
}
    9a8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9a8e:	bf00      	nop
    9a90:	20002262 	.word	0x20002262

00009a94 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
    9a94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    9a98:	2101      	movs	r1, #1
    9a9a:	4606      	mov	r6, r0
    9a9c:	b089      	sub	sp, #36	; 0x24
    9a9e:	2200      	movs	r2, #0
    9aa0:	2002      	movs	r0, #2
    9aa2:	f7f8 fbb1 	bl	2208 <z_arm_irq_priority_set>
    9aa6:	2002      	movs	r0, #2
    9aa8:	f7f8 fb7c 	bl	21a4 <arch_irq_enable>
	const struct uarte_nrfx_config *config = dev->config;
    9aac:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = dev->data;
    9aae:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
    9ab0:	683c      	ldr	r4, [r7, #0]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    9ab2:	2300      	movs	r3, #0
    9ab4:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
    9ab8:	602e      	str	r6, [r5, #0]
	uarte_nrfx_pins_configure(dev, false);
    9aba:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    9abc:	68d8      	ldr	r0, [r3, #12]
    9abe:	1c41      	adds	r1, r0, #1
    9ac0:	d00c      	beq.n	9adc <uarte_0_init+0x48>
    *p_pin = pin_number & 0x1F;
    9ac2:	f000 021f 	and.w	r2, r0, #31
    p_reg->OUTSET = set_mask;
    9ac6:	f04f 4ca0 	mov.w	ip, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    9aca:	2101      	movs	r1, #1
    9acc:	4091      	lsls	r1, r2
    reg->PIN_CNF[pin_number] = cnf;
    9ace:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    p_reg->OUTSET = set_mask;
    9ad2:	f8cc 1508 	str.w	r1, [ip, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = cnf;
    9ad6:	2103      	movs	r1, #3
    9ad8:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    9adc:	6919      	ldr	r1, [r3, #16]
    9ade:	1c4a      	adds	r2, r1, #1
    9ae0:	d010      	beq.n	9b04 <uarte_0_init+0x70>
			nrf_gpio_cfg_input(cfg->rx_pin,
    9ae2:	7f1a      	ldrb	r2, [r3, #28]
    9ae4:	2a00      	cmp	r2, #0
    *p_pin = pin_number & 0x1F;
    9ae6:	f001 021f 	and.w	r2, r1, #31
    9aea:	bf14      	ite	ne
    9aec:	f04f 0c03 	movne.w	ip, #3
    9af0:	f04f 0c00 	moveq.w	ip, #0
    reg->PIN_CNF[pin_number] = cnf;
    9af4:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    9af8:	f04f 4ea0 	mov.w	lr, #1342177280	; 0x50000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    9afc:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    reg->PIN_CNF[pin_number] = cnf;
    9b00:	f84e c022 	str.w	ip, [lr, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    9b04:	f8d3 c014 	ldr.w	ip, [r3, #20]
    9b08:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
    9b0c:	d00f      	beq.n	9b2e <uarte_0_init+0x9a>
    *p_pin = pin_number & 0x1F;
    9b0e:	f00c 021f 	and.w	r2, ip, #31
    p_reg->OUTSET = set_mask;
    9b12:	f04f 48a0 	mov.w	r8, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    9b16:	f04f 0e01 	mov.w	lr, #1
    9b1a:	fa0e fe02 	lsl.w	lr, lr, r2
    reg->PIN_CNF[pin_number] = cnf;
    9b1e:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    p_reg->OUTSET = set_mask;
    9b22:	f8c8 e508 	str.w	lr, [r8, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = cnf;
    9b26:	f04f 0e03 	mov.w	lr, #3
    9b2a:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    9b2e:	f8d3 e018 	ldr.w	lr, [r3, #24]
    9b32:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
    9b36:	d010      	beq.n	9b5a <uarte_0_init+0xc6>
			nrf_gpio_cfg_input(cfg->cts_pin,
    9b38:	7f5a      	ldrb	r2, [r3, #29]
    9b3a:	2a00      	cmp	r2, #0
    *p_pin = pin_number & 0x1F;
    9b3c:	f00e 021f 	and.w	r2, lr, #31
    9b40:	bf14      	ite	ne
    9b42:	f04f 0803 	movne.w	r8, #3
    9b46:	f04f 0800 	moveq.w	r8, #0
    reg->PIN_CNF[pin_number] = cnf;
    9b4a:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    9b4e:	f04f 49a0 	mov.w	r9, #1342177280	; 0x50000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    9b52:	ea4f 0888 	mov.w	r8, r8, lsl #2
    reg->PIN_CNF[pin_number] = cnf;
    9b56:	f849 8022 	str.w	r8, [r9, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
    9b5a:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
    9b5c:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    9b60:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &data->uart_config);
    9b64:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
    9b66:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
    9b6a:	1d29      	adds	r1, r5, #4
    p_reg->PSEL.CTS = pselcts;
    9b6c:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
    9b70:	f7ff fe82 	bl	9878 <uarte_nrfx_configure>
	if (err) {
    9b74:	4606      	mov	r6, r0
    9b76:	b9b8      	cbnz	r0, 9ba8 <uarte_0_init+0x114>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
    9b78:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
    9b7a:	0799      	lsls	r1, r3, #30
    9b7c:	d52b      	bpl.n	9bd6 <uarte_0_init+0x142>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    9b7e:	f105 0012 	add.w	r0, r5, #18
    9b82:	f001 f987 	bl	ae94 <nrfx_ppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
    9b86:	4b28      	ldr	r3, [pc, #160]	; (9c28 <uarte_0_init+0x194>)
    9b88:	4298      	cmp	r0, r3
    9b8a:	d011      	beq.n	9bb0 <uarte_0_init+0x11c>
		LOG_ERR("Failed to allocate PPI Channel");
    9b8c:	4b27      	ldr	r3, [pc, #156]	; (9c2c <uarte_0_init+0x198>)
    9b8e:	9306      	str	r3, [sp, #24]
    9b90:	2302      	movs	r3, #2
    9b92:	9301      	str	r3, [sp, #4]
    9b94:	9305      	str	r3, [sp, #20]
    9b96:	4826      	ldr	r0, [pc, #152]	; (9c30 <uarte_0_init+0x19c>)
    9b98:	4633      	mov	r3, r6
    9b9a:	aa05      	add	r2, sp, #20
    9b9c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -EIO;
    9ba0:	f06f 0604 	mvn.w	r6, #4
    9ba4:	f003 fec6 	bl	d934 <z_impl_z_log_msg2_static_create>
UART_NRF_UARTE_DEVICE(0);
    9ba8:	4630      	mov	r0, r6
    9baa:	b009      	add	sp, #36	; 0x24
    9bac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
    9bb0:	7ca8      	ldrb	r0, [r5, #18]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
    9bb2:	00c3      	lsls	r3, r0, #3
    9bb4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    9bb8:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    return (uint32_t)p_reg + (uint32_t)task;
    9bbc:	f104 020c 	add.w	r2, r4, #12
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
    9bc0:	f504 7190 	add.w	r1, r4, #288	; 0x120
    p_reg->CH[(uint32_t) channel].EEP = eep;
    9bc4:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    p_reg->CH[(uint32_t) channel].TEP = tep;
    9bc8:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
    p_reg->CHENSET = mask;
    9bcc:	4a19      	ldr	r2, [pc, #100]	; (9c34 <uarte_0_init+0x1a0>)
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    9bce:	2301      	movs	r3, #1
    9bd0:	4083      	lsls	r3, r0
    9bd2:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    9bd6:	2308      	movs	r3, #8
    9bd8:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
    9bdc:	7a3b      	ldrb	r3, [r7, #8]
    9bde:	b95b      	cbnz	r3, 9bf8 <uarte_0_init+0x164>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    9be0:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
    9be4:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    9be8:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    9bec:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    9bf0:	2301      	movs	r3, #1
    9bf2:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9bf6:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
    9bf8:	687b      	ldr	r3, [r7, #4]
    9bfa:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
    9bfc:	bf5c      	itt	pl
    9bfe:	f44f 7280 	movpl.w	r2, #256	; 0x100
    9c02:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
    9c06:	06db      	lsls	r3, r3, #27
    9c08:	bf44      	itt	mi
    9c0a:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
    9c0e:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
    9c12:	3510      	adds	r5, #16
    p_reg->TXD.MAXCNT = length;
    9c14:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    9c16:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    9c1a:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    9c1e:	2301      	movs	r3, #1
    9c20:	60a3      	str	r3, [r4, #8]
    9c22:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
    9c24:	e7c0      	b.n	9ba8 <uarte_0_init+0x114>
    9c26:	bf00      	nop
    9c28:	0bad0000 	.word	0x0bad0000
    9c2c:	00011fd9 	.word	0x00011fd9
    9c30:	00010300 	.word	0x00010300
    9c34:	4001f000 	.word	0x4001f000

00009c38 <random_byte_get>:
	__asm__ volatile(
    9c38:	f04f 0320 	mov.w	r3, #32
    9c3c:	f3ef 8211 	mrs	r2, BASEPRI
    9c40:	f383 8812 	msr	BASEPRI_MAX, r3
    9c44:	f3bf 8f6f 	isb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)rng_event);
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    9c48:	4b09      	ldr	r3, [pc, #36]	; (9c70 <random_byte_get+0x38>)
    9c4a:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
    9c4e:	b161      	cbz	r1, 9c6a <random_byte_get+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    9c50:	2100      	movs	r1, #0
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
    9c52:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    9c56:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    9c5a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
		retval = nrf_rng_random_value_get(NRF_RNG);
    9c5e:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
    9c60:	f382 8811 	msr	BASEPRI, r2
    9c64:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
    9c68:	4770      	bx	lr
	int retval = -EAGAIN;
    9c6a:	f06f 000a 	mvn.w	r0, #10
    9c6e:	e7f7      	b.n	9c60 <random_byte_get+0x28>
    9c70:	4000d000 	.word	0x4000d000

00009c74 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static uint16_t rng_pool_get(struct rng_pool *rngp, uint8_t *buf, uint16_t len)
{
    9c74:	b5f0      	push	{r4, r5, r6, r7, lr}
    9c76:	4603      	mov	r3, r0
	uint32_t last  = rngp->last;
    9c78:	7884      	ldrb	r4, [r0, #2]
	uint32_t mask  = rngp->mask;
    9c7a:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
    9c7c:	f04f 0020 	mov.w	r0, #32
    9c80:	f3ef 8e11 	mrs	lr, BASEPRI
    9c84:	f380 8812 	msr	BASEPRI_MAX, r0
    9c88:	f3bf 8f6f 	isb	sy
	uint32_t first, available;
	uint32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
    9c8c:	781e      	ldrb	r6, [r3, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
    9c8e:	f893 c001 	ldrb.w	ip, [r3, #1]

	available = (last - first) & mask;
    9c92:	1ba4      	subs	r4, r4, r6
    9c94:	403c      	ands	r4, r7
	if (available < len) {
    9c96:	42a2      	cmp	r2, r4
		len = available;
    9c98:	bf88      	it	hi
    9c9a:	b2a2      	uxthhi	r2, r4

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
    9c9c:	18b0      	adds	r0, r6, r2
    9c9e:	4038      	ands	r0, r7
	first = rngp->first_alloc;
    9ca0:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
    9ca2:	7018      	strb	r0, [r3, #0]
	__asm__ volatile(
    9ca4:	f38e 8811 	msr	BASEPRI, lr
    9ca8:	f3bf 8f6f 	isb	sy
    9cac:	1888      	adds	r0, r1, r2
	uint8_t *dst   = buf;
    9cae:	460a      	mov	r2, r1
	irq_unlock(key);

	while (likely(len--)) {
    9cb0:	4290      	cmp	r0, r2
    9cb2:	d119      	bne.n	9ce8 <rng_pool_get+0x74>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
    9cb4:	4566      	cmp	r6, ip
    9cb6:	d10d      	bne.n	9cd4 <rng_pool_get+0x60>
	__asm__ volatile(
    9cb8:	f04f 0520 	mov.w	r5, #32
    9cbc:	f3ef 8011 	mrs	r0, BASEPRI
    9cc0:	f385 8812 	msr	BASEPRI_MAX, r5
    9cc4:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
    9cc8:	781d      	ldrb	r5, [r3, #0]
    9cca:	705d      	strb	r5, [r3, #1]
	__asm__ volatile(
    9ccc:	f380 8811 	msr	BASEPRI, r0
    9cd0:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
    9cd4:	1a52      	subs	r2, r2, r1
	available = available - len;
	if (available <= rngp->threshold) {
    9cd6:	791b      	ldrb	r3, [r3, #4]
	len = dst - buf;
    9cd8:	b290      	uxth	r0, r2
	available = available - len;
    9cda:	1a22      	subs	r2, r4, r0
	if (available <= rngp->threshold) {
    9cdc:	4293      	cmp	r3, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    9cde:	bf22      	ittt	cs
    9ce0:	4b06      	ldrcs	r3, [pc, #24]	; (9cfc <rng_pool_get+0x88>)
    9ce2:	2201      	movcs	r2, #1
    9ce4:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
    9ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
    9ce8:	eb03 0e05 	add.w	lr, r3, r5
		first = (first + 1) & mask;
    9cec:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
    9cee:	f89e e005 	ldrb.w	lr, [lr, #5]
    9cf2:	f802 eb01 	strb.w	lr, [r2], #1
		first = (first + 1) & mask;
    9cf6:	403d      	ands	r5, r7
    9cf8:	e7da      	b.n	9cb0 <rng_pool_get+0x3c>
    9cfa:	bf00      	nop
    9cfc:	4000d000 	.word	0x4000d000

00009d00 <entropy_nrf5_get_entropy_isr>:
	uint16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    9d00:	43db      	mvns	r3, r3
{
    9d02:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    9d06:	f013 0501 	ands.w	r5, r3, #1
{
    9d0a:	460e      	mov	r6, r1
    9d0c:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    9d0e:	d004      	beq.n	9d1a <entropy_nrf5_get_entropy_isr+0x1a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
    9d10:	4821      	ldr	r0, [pc, #132]	; (9d98 <entropy_nrf5_get_entropy_isr+0x98>)
    9d12:	f7ff ffaf 	bl	9c74 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
    9d16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
    9d1a:	b3a2      	cbz	r2, 9d86 <entropy_nrf5_get_entropy_isr+0x86>
	__asm__ volatile(
    9d1c:	f04f 0320 	mov.w	r3, #32
    9d20:	f3ef 8811 	mrs	r8, BASEPRI
    9d24:	f383 8812 	msr	BASEPRI_MAX, r3
    9d28:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
    9d2c:	200d      	movs	r0, #13
    9d2e:	f7f8 fa5d 	bl	21ec <arch_irq_is_enabled>
    9d32:	4607      	mov	r7, r0
		irq_disable(IRQN);
    9d34:	200d      	movs	r0, #13
    9d36:	f7f8 fa45 	bl	21c4 <arch_irq_disable>
	__asm__ volatile(
    9d3a:	f388 8811 	msr	BASEPRI, r8
    9d3e:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    9d42:	f8df 8058 	ldr.w	r8, [pc, #88]	; 9d9c <entropy_nrf5_get_entropy_isr+0x9c>
    9d46:	f8df 9058 	ldr.w	r9, [pc, #88]	; 9da0 <entropy_nrf5_get_entropy_isr+0xa0>
    9d4a:	f8c8 5100 	str.w	r5, [r8, #256]	; 0x100
    9d4e:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
    9d52:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    9d56:	2301      	movs	r3, #1
    9d58:	f8c8 3000 	str.w	r3, [r8]
    9d5c:	4625      	mov	r5, r4
    9d5e:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    9d62:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
			while (!nrf_rng_event_check(NRF_RNG,
    9d66:	b183      	cbz	r3, 9d8a <entropy_nrf5_get_entropy_isr+0x8a>
			byte = random_byte_get();
    9d68:	f7ff ff66 	bl	9c38 <random_byte_get>
			if (byte < 0) {
    9d6c:	1e03      	subs	r3, r0, #0
    9d6e:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    9d72:	dbf6      	blt.n	9d62 <entropy_nrf5_get_entropy_isr+0x62>
			buf[--len] = byte;
    9d74:	3d01      	subs	r5, #1
    9d76:	b2ad      	uxth	r5, r5
    9d78:	5573      	strb	r3, [r6, r5]
		} while (len);
    9d7a:	2d00      	cmp	r5, #0
    9d7c:	d1f1      	bne.n	9d62 <entropy_nrf5_get_entropy_isr+0x62>
		if (irq_enabled) {
    9d7e:	b117      	cbz	r7, 9d86 <entropy_nrf5_get_entropy_isr+0x86>
			irq_enable(IRQN);
    9d80:	200d      	movs	r0, #13
    9d82:	f7f8 fa0f 	bl	21a4 <arch_irq_enable>
	return cnt;
    9d86:	4620      	mov	r0, r4
    9d88:	e7c5      	b.n	9d16 <entropy_nrf5_get_entropy_isr+0x16>
  __ASM volatile ("dsb 0xF":::"memory");
    9d8a:	f3bf 8f4f 	dsb	sy
				__WFE();
    9d8e:	bf20      	wfe
				__SEV();
    9d90:	bf40      	sev
				__WFE();
    9d92:	bf20      	wfe
    9d94:	e7e5      	b.n	9d62 <entropy_nrf5_get_entropy_isr+0x62>
    9d96:	bf00      	nop
    9d98:	20001a7c 	.word	0x20001a7c
    9d9c:	4000d000 	.word	0x4000d000
    9da0:	e000e100 	.word	0xe000e100

00009da4 <entropy_nrf5_get_entropy>:
{
    9da4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return z_impl_k_sem_take(sem, timeout);
    9da8:	4f13      	ldr	r7, [pc, #76]	; (9df8 <entropy_nrf5_get_entropy+0x54>)
    9daa:	460d      	mov	r5, r1
    9dac:	4614      	mov	r4, r2
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    9dae:	f107 0845 	add.w	r8, r7, #69	; 0x45
    9db2:	f107 0918 	add.w	r9, r7, #24
	while (len) {
    9db6:	b914      	cbnz	r4, 9dbe <entropy_nrf5_get_entropy+0x1a>
}
    9db8:	4620      	mov	r0, r4
    9dba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9dbe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9dc2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9dc6:	4638      	mov	r0, r7
    9dc8:	f001 ffdc 	bl	bd84 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    9dcc:	4622      	mov	r2, r4
    9dce:	4629      	mov	r1, r5
    9dd0:	4640      	mov	r0, r8
    9dd2:	f7ff ff4f 	bl	9c74 <rng_pool_get>
    9dd6:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
    9dd8:	4638      	mov	r0, r7
    9dda:	f001 ffad 	bl	bd38 <z_impl_k_sem_give>
		if (bytes == 0U) {
    9dde:	b93e      	cbnz	r6, 9df0 <entropy_nrf5_get_entropy+0x4c>
	return z_impl_k_sem_take(sem, timeout);
    9de0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9de4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9de8:	4648      	mov	r0, r9
    9dea:	f001 ffcb 	bl	bd84 <z_impl_k_sem_take>
			continue;
    9dee:	e7e2      	b.n	9db6 <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
    9df0:	1ba4      	subs	r4, r4, r6
    9df2:	b2a4      	uxth	r4, r4
		buf += bytes;
    9df4:	4435      	add	r5, r6
    9df6:	e7de      	b.n	9db6 <entropy_nrf5_get_entropy+0x12>
    9df8:	20001a4c 	.word	0x20001a4c

00009dfc <entropy_nrf5_init>:
		    &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_ENTROPY_INIT_PRIORITY,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(const struct device *dev)
{
    9dfc:	b538      	push	{r3, r4, r5, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
    9dfe:	4c19      	ldr	r4, [pc, #100]	; (9e64 <entropy_nrf5_init+0x68>)
    9e00:	2201      	movs	r2, #1
    9e02:	4611      	mov	r1, r2
    9e04:	4620      	mov	r0, r4
    9e06:	f005 fcb4 	bl	f772 <z_impl_k_sem_init>
    9e0a:	2201      	movs	r2, #1
    9e0c:	2100      	movs	r1, #0
    9e0e:	f104 0018 	add.w	r0, r4, #24
    9e12:	f005 fcae 	bl	f772 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
    9e16:	f240 4307 	movw	r3, #1031	; 0x407
    9e1a:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
    9e1e:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    9e22:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
    9e24:	230c      	movs	r3, #12
    9e26:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
    9e2a:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
    9e2c:	4b0e      	ldr	r3, [pc, #56]	; (9e68 <entropy_nrf5_init+0x6c>)
    9e2e:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
    9e32:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
    9e36:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
    9e3a:	f042 0201 	orr.w	r2, r2, #1
    9e3e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    p_reg->INTENSET = mask;
    9e42:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    9e44:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
    9e48:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
    9e4c:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
    9e50:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    9e52:	6019      	str	r1, [r3, #0]
    9e54:	200d      	movs	r0, #13
    9e56:	f7f8 f9d7 	bl	2208 <z_arm_irq_priority_set>
	irq_enable(IRQN);
    9e5a:	200d      	movs	r0, #13
    9e5c:	f7f8 f9a2 	bl	21a4 <arch_irq_enable>

	return 0;
}
    9e60:	4628      	mov	r0, r5
    9e62:	bd38      	pop	{r3, r4, r5, pc}
    9e64:	20001a4c 	.word	0x20001a4c
    9e68:	4000d000 	.word	0x4000d000

00009e6c <isr>:
{
    9e6c:	b510      	push	{r4, lr}
	byte = random_byte_get();
    9e6e:	f7ff fee3 	bl	9c38 <random_byte_get>
	if (byte < 0) {
    9e72:	2800      	cmp	r0, #0
    9e74:	db20      	blt.n	9eb8 <isr+0x4c>
	uint8_t last  = rngp->last;
    9e76:	4b17      	ldr	r3, [pc, #92]	; (9ed4 <isr+0x68>)
    9e78:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
    9e7c:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	uint8_t mask  = rngp->mask;
    9e80:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
    9e84:	1a51      	subs	r1, r2, r1
    9e86:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
    9e8a:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
    9e8c:	d10d      	bne.n	9eaa <isr+0x3e>
	uint8_t last  = rngp->last;
    9e8e:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
    9e92:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	uint8_t mask  = rngp->mask;
    9e96:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
    9e9a:	1a51      	subs	r1, r2, r1
    9e9c:	ea34 0101 	bics.w	r1, r4, r1
    9ea0:	d10b      	bne.n	9eba <isr+0x4e>
    9ea2:	4b0d      	ldr	r3, [pc, #52]	; (9ed8 <isr+0x6c>)
    9ea4:	2201      	movs	r2, #1
    9ea6:	605a      	str	r2, [r3, #4]
}
    9ea8:	e00e      	b.n	9ec8 <isr+0x5c>
	rngp->buffer[last] = byte;
    9eaa:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    9eac:	3201      	adds	r2, #1
    9eae:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    9eb0:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
    9eb4:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
    9eb8:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
    9eba:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    9ebc:	3201      	adds	r2, #1
    9ebe:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    9ec0:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
    9ec4:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
    9ec8:	4804      	ldr	r0, [pc, #16]	; (9edc <isr+0x70>)
}
    9eca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9ece:	f001 bf33 	b.w	bd38 <z_impl_k_sem_give>
    9ed2:	bf00      	nop
    9ed4:	20001a4c 	.word	0x20001a4c
    9ed8:	4000d000 	.word	0x4000d000
    9edc:	20001a64 	.word	0x20001a64

00009ee0 <compare_int_lock>:
	return 0;
#endif
}

static bool compare_int_lock(int32_t chan)
{
    9ee0:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
    9ee2:	2301      	movs	r3, #1
    9ee4:	4083      	lsls	r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    9ee6:	4a11      	ldr	r2, [pc, #68]	; (9f2c <compare_int_lock+0x4c>)
    9ee8:	f3bf 8f5b 	dmb	ish
    9eec:	43dc      	mvns	r4, r3
    9eee:	e852 1f00 	ldrex	r1, [r2]
    9ef2:	ea01 0c04 	and.w	ip, r1, r4
    9ef6:	e842 ce00 	strex	lr, ip, [r2]
    9efa:	f1be 0f00 	cmp.w	lr, #0
    9efe:	d1f6      	bne.n	9eee <compare_int_lock+0xe>
    9f00:	f3bf 8f5b 	dmb	ish

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    9f04:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    9f08:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
    9f0c:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    9f10:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    9f14:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
  __ASM volatile ("dmb 0xF":::"memory");
    9f18:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9f1c:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
    9f20:	420b      	tst	r3, r1
}
    9f22:	bf14      	ite	ne
    9f24:	2001      	movne	r0, #1
    9f26:	2000      	moveq	r0, #0
    9f28:	bd10      	pop	{r4, pc}
    9f2a:	bf00      	nop
    9f2c:	20001aa4 	.word	0x20001aa4

00009f30 <sys_clock_timeout_handler>:
static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
    9f30:	4919      	ldr	r1, [pc, #100]	; (9f98 <sys_clock_timeout_handler+0x68>)
{
    9f32:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9f34:	4604      	mov	r4, r0
	return absolute_time & COUNTER_MAX;
    9f36:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
    9f3a:	6808      	ldr	r0, [r1, #0]

	last_count += dticks * CYC_PER_TICK;
    9f3c:	e9c1 2300 	strd	r2, r3, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
    9f40:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
    9f44:	1a10      	subs	r0, r2, r0
	if (in_anchor_range(cc_value)) {
    9f46:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
    9f4a:	d222      	bcs.n	9f92 <sys_clock_timeout_handler+0x62>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
    9f4c:	4b13      	ldr	r3, [pc, #76]	; (9f9c <sys_clock_timeout_handler+0x6c>)
    9f4e:	681b      	ldr	r3, [r3, #0]
    9f50:	0a1a      	lsrs	r2, r3, #8
    9f52:	061b      	lsls	r3, r3, #24
    9f54:	195e      	adds	r6, r3, r5
    9f56:	4b12      	ldr	r3, [pc, #72]	; (9fa0 <sys_clock_timeout_handler+0x70>)
    9f58:	f142 0700 	adc.w	r7, r2, #0
    9f5c:	e9c3 6700 	strd	r6, r7, [r3]
		return true;
    9f60:	2601      	movs	r6, #1
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    9f62:	f002 fd09 	bl	c978 <sys_clock_announce>
    return p_reg->CC[ch];
    9f66:	00a3      	lsls	r3, r4, #2
    9f68:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    9f6c:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
    9f70:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
    9f74:	42aa      	cmp	r2, r5
    9f76:	d10b      	bne.n	9f90 <sys_clock_timeout_handler+0x60>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
    9f78:	b91e      	cbnz	r6, 9f82 <sys_clock_timeout_handler+0x52>
    p_reg->CC[ch] = cc_val;
    9f7a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    9f7e:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->EVTENSET = mask;
    9f82:	4b08      	ldr	r3, [pc, #32]	; (9fa4 <sys_clock_timeout_handler+0x74>)
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    9f84:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    9f88:	fa00 f404 	lsl.w	r4, r0, r4
    9f8c:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
    9f90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
    9f92:	2600      	movs	r6, #0
    9f94:	e7e5      	b.n	9f62 <sys_clock_timeout_handler+0x32>
    9f96:	bf00      	nop
    9f98:	20000dd8 	.word	0x20000dd8
    9f9c:	20001aa8 	.word	0x20001aa8
    9fa0:	20000dc0 	.word	0x20000dc0
    9fa4:	40011000 	.word	0x40011000

00009fa8 <compare_int_unlock>:
	if (key) {
    9fa8:	b319      	cbz	r1, 9ff2 <compare_int_unlock+0x4a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    9faa:	f3bf 8f5b 	dmb	ish
		atomic_or(&int_mask, BIT(chan));
    9fae:	2301      	movs	r3, #1
    9fb0:	4a10      	ldr	r2, [pc, #64]	; (9ff4 <compare_int_unlock+0x4c>)
    9fb2:	4083      	lsls	r3, r0
    9fb4:	e852 1f00 	ldrex	r1, [r2]
    9fb8:	4319      	orrs	r1, r3
    9fba:	e842 1c00 	strex	ip, r1, [r2]
    9fbe:	f1bc 0f00 	cmp.w	ip, #0
    9fc2:	d1f7      	bne.n	9fb4 <compare_int_unlock+0xc>
    9fc4:	f3bf 8f5b 	dmb	ish
    p_reg->INTENSET = mask;
    9fc8:	4a0b      	ldr	r2, [pc, #44]	; (9ff8 <compare_int_unlock+0x50>)
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    9fca:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    9fce:	4083      	lsls	r3, r0
    9fd0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    9fd4:	4b09      	ldr	r3, [pc, #36]	; (9ffc <compare_int_unlock+0x54>)
    9fd6:	f3bf 8f5b 	dmb	ish
    9fda:	681b      	ldr	r3, [r3, #0]
    9fdc:	f3bf 8f5b 	dmb	ish
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
    9fe0:	fa23 f000 	lsr.w	r0, r3, r0
    9fe4:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9fe6:	bf42      	ittt	mi
    9fe8:	4b05      	ldrmi	r3, [pc, #20]	; (a000 <compare_int_unlock+0x58>)
    9fea:	f44f 3200 	movmi.w	r2, #131072	; 0x20000
    9fee:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
    9ff2:	4770      	bx	lr
    9ff4:	20001aa4 	.word	0x20001aa4
    9ff8:	40011000 	.word	0x40011000
    9ffc:	20001aa0 	.word	0x20001aa0
    a000:	e000e100 	.word	0xe000e100

0000a004 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
    a004:	4b0d      	ldr	r3, [pc, #52]	; (a03c <z_nrf_rtc_timer_read+0x38>)
    a006:	6818      	ldr	r0, [r3, #0]
    a008:	0a01      	lsrs	r1, r0, #8
    a00a:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
    a00c:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
    a010:	4b0b      	ldr	r3, [pc, #44]	; (a040 <z_nrf_rtc_timer_read+0x3c>)
    a012:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
    a016:	1818      	adds	r0, r3, r0
    a018:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
    a01c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    a020:	d20a      	bcs.n	a038 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
    a022:	4b08      	ldr	r3, [pc, #32]	; (a044 <z_nrf_rtc_timer_read+0x40>)
    a024:	e9d3 2300 	ldrd	r2, r3, [r3]
    a028:	4290      	cmp	r0, r2
    a02a:	eb71 0303 	sbcs.w	r3, r1, r3
    a02e:	d203      	bcs.n	a038 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
    a030:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
    a034:	f141 0100 	adc.w	r1, r1, #0
}
    a038:	4770      	bx	lr
    a03a:	bf00      	nop
    a03c:	20001aa8 	.word	0x20001aa8
    a040:	40011000 	.word	0x40011000
    a044:	20000dc0 	.word	0x20000dc0

0000a048 <compare_set>:
{
    a048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a04c:	b085      	sub	sp, #20
    a04e:	4616      	mov	r6, r2
    a050:	4698      	mov	r8, r3
    a052:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
    a054:	f7ff ff44 	bl	9ee0 <compare_int_lock>
    a058:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
    a05a:	f7ff ffd3 	bl	a004 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
    a05e:	42b0      	cmp	r0, r6
    a060:	eb71 0308 	sbcs.w	r3, r1, r8
    a064:	d278      	bcs.n	a158 <compare_set+0x110>
		if (target_time - curr_time > COUNTER_SPAN) {
    a066:	4b46      	ldr	r3, [pc, #280]	; (a180 <compare_set+0x138>)
    a068:	1a30      	subs	r0, r6, r0
    a06a:	eb68 0101 	sbc.w	r1, r8, r1
    a06e:	4298      	cmp	r0, r3
    a070:	f171 0300 	sbcs.w	r3, r1, #0
    a074:	f080 8081 	bcs.w	a17a <compare_set+0x132>
		if (target_time != cc_data[chan].target_time) {
    a078:	4b42      	ldr	r3, [pc, #264]	; (a184 <compare_set+0x13c>)
    a07a:	eb03 1305 	add.w	r3, r3, r5, lsl #4
    a07e:	e9d3 ab02 	ldrd	sl, fp, [r3, #8]
    a082:	45d8      	cmp	r8, fp
    a084:	bf08      	it	eq
    a086:	4556      	cmpeq	r6, sl
    a088:	d051      	beq.n	a12e <compare_set+0xe6>
    a08a:	ea4f 0985 	mov.w	r9, r5, lsl #2
    a08e:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    a092:	f105 0750 	add.w	r7, r5, #80	; 0x50
    a096:	f509 3988 	add.w	r9, r9, #69632	; 0x11000
    a09a:	00bf      	lsls	r7, r7, #2
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    a09c:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    a0a0:	fa01 f305 	lsl.w	r3, r1, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    a0a4:	b2bf      	uxth	r7, r7
	return absolute_time & COUNTER_MAX;
    a0a6:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
    a0aa:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    a0ae:	9301      	str	r3, [sp, #4]
    return p_reg->CC[ch];
    a0b0:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
    a0b4:	4b34      	ldr	r3, [pc, #208]	; (a188 <compare_set+0x140>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    a0b6:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	uint32_t cc_val = abs_val & COUNTER_MAX;
    a0ba:	4614      	mov	r4, r2
     return p_reg->COUNTER;
    a0bc:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    a0c0:	1a40      	subs	r0, r0, r1
    a0c2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    a0c6:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
    a0ca:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
    a0cc:	f8c9 c540 	str.w	ip, [r9, #1344]	; 0x540
    a0d0:	d107      	bne.n	a0e2 <compare_set+0x9a>
    a0d2:	e9cd 2102 	strd	r2, r1, [sp, #8]
	z_impl_k_busy_wait(usec_to_wait);
    a0d6:	2013      	movs	r0, #19
    a0d8:	f005 fd5f 	bl	fb9a <z_impl_k_busy_wait>
    a0dc:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
    a0e0:	4b29      	ldr	r3, [pc, #164]	; (a188 <compare_set+0x140>)
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    a0e2:	f101 0c02 	add.w	ip, r1, #2
	return (a - b) & COUNTER_MAX;
    a0e6:	eba4 000c 	sub.w	r0, r4, ip
    a0ea:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			cc_val = now + 2;
    a0ee:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    a0f2:	bf88      	it	hi
    a0f4:	4664      	movhi	r4, ip
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    a0f6:	2000      	movs	r0, #0
    a0f8:	6038      	str	r0, [r7, #0]
    a0fa:	6838      	ldr	r0, [r7, #0]
    p_reg->EVTENSET = mask;
    a0fc:	9801      	ldr	r0, [sp, #4]
    a0fe:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    a102:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    a106:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
    a10a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    a10e:	4281      	cmp	r1, r0
    a110:	d006      	beq.n	a120 <compare_set+0xd8>
	return (a - b) & COUNTER_MAX;
    a112:	1a20      	subs	r0, r4, r0
    a114:	3802      	subs	r0, #2
    a116:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
    a11a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    a11e:	d819      	bhi.n	a154 <compare_set+0x10c>
	return (a - b) & COUNTER_MAX;
    a120:	1aa4      	subs	r4, r4, r2
    a122:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
    a126:	eb14 0a06 	adds.w	sl, r4, r6
    a12a:	f148 0b00 	adc.w	fp, r8, #0
	cc_data[chan].target_time = target_time;
    a12e:	4915      	ldr	r1, [pc, #84]	; (a184 <compare_set+0x13c>)
	cc_data[chan].callback = handler;
    a130:	980e      	ldr	r0, [sp, #56]	; 0x38
	cc_data[chan].target_time = target_time;
    a132:	012b      	lsls	r3, r5, #4
    a134:	eb01 1205 	add.w	r2, r1, r5, lsl #4
    a138:	e9c2 ab02 	strd	sl, fp, [r2, #8]
	cc_data[chan].callback = handler;
    a13c:	50c8      	str	r0, [r1, r3]
	cc_data[chan].user_context = user_data;
    a13e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    a140:	6053      	str	r3, [r2, #4]
	return ret;
    a142:	2400      	movs	r4, #0
	compare_int_unlock(chan, key);
    a144:	4628      	mov	r0, r5
    a146:	9900      	ldr	r1, [sp, #0]
    a148:	f7ff ff2e 	bl	9fa8 <compare_int_unlock>
}
    a14c:	4620      	mov	r0, r4
    a14e:	b005      	add	sp, #20
    a150:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a154:	4620      	mov	r0, r4
    a156:	e7b1      	b.n	a0bc <compare_set+0x74>
		atomic_or(&force_isr_mask, BIT(chan));
    a158:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    a15a:	4a0c      	ldr	r2, [pc, #48]	; (a18c <compare_set+0x144>)
    a15c:	f3bf 8f5b 	dmb	ish
    a160:	40ab      	lsls	r3, r5
    a162:	e852 1f00 	ldrex	r1, [r2]
    a166:	4319      	orrs	r1, r3
    a168:	e842 1000 	strex	r0, r1, [r2]
    a16c:	2800      	cmp	r0, #0
    a16e:	d1f8      	bne.n	a162 <compare_set+0x11a>
    a170:	f3bf 8f5b 	dmb	ish
    a174:	46b2      	mov	sl, r6
    a176:	46c3      	mov	fp, r8
    a178:	e7d9      	b.n	a12e <compare_set+0xe6>
			return -EINVAL;
    a17a:	f06f 0415 	mvn.w	r4, #21
    a17e:	e7e1      	b.n	a144 <compare_set+0xfc>
    a180:	01000001 	.word	0x01000001
    a184:	20000dc8 	.word	0x20000dc8
    a188:	40011000 	.word	0x40011000
    a18c:	20001aa0 	.word	0x20001aa0

0000a190 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
    a190:	b573      	push	{r0, r1, r4, r5, r6, lr}
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
    a192:	4b19      	ldr	r3, [pc, #100]	; (a1f8 <sys_clock_driver_init+0x68>)
    p_reg->PRESCALER = val;
    a194:	4d19      	ldr	r5, [pc, #100]	; (a1fc <sys_clock_driver_init+0x6c>)
    a196:	2400      	movs	r4, #0
    a198:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a19c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    a1a0:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    a1a4:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
    a1a8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    a1ac:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    a1b0:	4b13      	ldr	r3, [pc, #76]	; (a200 <sys_clock_driver_init+0x70>)
    a1b2:	2602      	movs	r6, #2
    a1b4:	f44f 3200 	mov.w	r2, #131072	; 0x20000

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    a1b8:	2101      	movs	r1, #1
    a1ba:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
    a1be:	2011      	movs	r0, #17
    a1c0:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    a1c4:	4622      	mov	r2, r4
    a1c6:	f7f8 f81f 	bl	2208 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    a1ca:	2011      	movs	r0, #17
    a1cc:	f7f7 ffea 	bl	21a4 <arch_irq_enable>

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    a1d0:	4a0c      	ldr	r2, [pc, #48]	; (a204 <sys_clock_driver_init+0x74>)
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    a1d2:	2301      	movs	r3, #1
    a1d4:	60ab      	str	r3, [r5, #8]
    a1d6:	602b      	str	r3, [r5, #0]
    a1d8:	6013      	str	r3, [r2, #0]

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
    a1da:	4b0b      	ldr	r3, [pc, #44]	; (a208 <sys_clock_driver_init+0x78>)
    a1dc:	4a0b      	ldr	r2, [pc, #44]	; (a20c <sys_clock_driver_init+0x7c>)
    a1de:	9300      	str	r3, [sp, #0]
    a1e0:	9401      	str	r4, [sp, #4]
    a1e2:	2300      	movs	r3, #0
    a1e4:	4620      	mov	r0, r4
    a1e6:	f7ff ff2f 	bl	a048 <compare_set>

	z_nrf_clock_control_lf_on(mode);
    a1ea:	4630      	mov	r0, r6
    a1ec:	f7fe fe1e 	bl	8e2c <z_nrf_clock_control_lf_on>

	return 0;
}
    a1f0:	4620      	mov	r0, r4
    a1f2:	b002      	add	sp, #8
    a1f4:	bd70      	pop	{r4, r5, r6, pc}
    a1f6:	bf00      	nop
    a1f8:	20000dc8 	.word	0x20000dc8
    a1fc:	40011000 	.word	0x40011000
    a200:	e000e100 	.word	0xe000e100
    a204:	20001aa4 	.word	0x20001aa4
    a208:	00009f31 	.word	0x00009f31
    a20c:	007fffff 	.word	0x007fffff

0000a210 <rtc_nrf_isr>:
{
    a210:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
    a214:	4c35      	ldr	r4, [pc, #212]	; (a2ec <rtc_nrf_isr+0xdc>)
    a216:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
    a21a:	079a      	lsls	r2, r3, #30
    a21c:	d50b      	bpl.n	a236 <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    a21e:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    a222:	b143      	cbz	r3, a236 <rtc_nrf_isr+0x26>
		overflow_cnt++;
    a224:	4a32      	ldr	r2, [pc, #200]	; (a2f0 <rtc_nrf_isr+0xe0>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    a226:	2300      	movs	r3, #0
    a228:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    a22c:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    a230:	6813      	ldr	r3, [r2, #0]
    a232:	3301      	adds	r3, #1
    a234:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    a236:	f04f 0320 	mov.w	r3, #32
    a23a:	f3ef 8211 	mrs	r2, BASEPRI
    a23e:	f383 8812 	msr	BASEPRI_MAX, r3
    a242:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
    a246:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
    a24a:	03db      	lsls	r3, r3, #15
    a24c:	d512      	bpl.n	a274 <rtc_nrf_isr+0x64>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    a24e:	f3bf 8f5b 	dmb	ish
    a252:	4b28      	ldr	r3, [pc, #160]	; (a2f4 <rtc_nrf_isr+0xe4>)
    a254:	e853 1f00 	ldrex	r1, [r3]
    a258:	f021 0001 	bic.w	r0, r1, #1
    a25c:	e843 0600 	strex	r6, r0, [r3]
    a260:	2e00      	cmp	r6, #0
    a262:	d1f7      	bne.n	a254 <rtc_nrf_isr+0x44>
    a264:	f3bf 8f5b 	dmb	ish
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    a268:	2900      	cmp	r1, #0
    a26a:	d136      	bne.n	a2da <rtc_nrf_isr+0xca>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    a26c:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		if (result) {
    a270:	2b00      	cmp	r3, #0
    a272:	d132      	bne.n	a2da <rtc_nrf_isr+0xca>
{
    a274:	2300      	movs	r3, #0
	__asm__ volatile(
    a276:	f382 8811 	msr	BASEPRI, r2
    a27a:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
    a27e:	b34b      	cbz	r3, a2d4 <rtc_nrf_isr+0xc4>
		curr_time = z_nrf_rtc_timer_read();
    a280:	f7ff fec0 	bl	a004 <z_nrf_rtc_timer_read>
	__asm__ volatile(
    a284:	f04f 0320 	mov.w	r3, #32
    a288:	f3ef 8c11 	mrs	ip, BASEPRI
    a28c:	f383 8812 	msr	BASEPRI_MAX, r3
    a290:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
    a294:	4b18      	ldr	r3, [pc, #96]	; (a2f8 <rtc_nrf_isr+0xe8>)
    a296:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
    a29a:	42b0      	cmp	r0, r6
    a29c:	eb71 0207 	sbcs.w	r2, r1, r7
    a2a0:	f04f 0200 	mov.w	r2, #0
    a2a4:	d320      	bcc.n	a2e8 <rtc_nrf_isr+0xd8>
			cc_data[chan].target_time = TARGET_TIME_INVALID;
    a2a6:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    a2aa:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
    a2ae:	e9d3 1500 	ldrd	r1, r5, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
    a2b2:	e9c3 8902 	strd	r8, r9, [r3, #8]
			cc_data[chan].callback = NULL;
    a2b6:	601a      	str	r2, [r3, #0]
    p_reg->EVTENCLR = mask;
    a2b8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    a2bc:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
	__asm__ volatile(
    a2c0:	f38c 8811 	msr	BASEPRI, ip
    a2c4:	f3bf 8f6f 	isb	sy
		if (handler) {
    a2c8:	b121      	cbz	r1, a2d4 <rtc_nrf_isr+0xc4>
			handler(chan, expire_time, user_context);
    a2ca:	9500      	str	r5, [sp, #0]
    a2cc:	4632      	mov	r2, r6
    a2ce:	463b      	mov	r3, r7
    a2d0:	2000      	movs	r0, #0
    a2d2:	4788      	blx	r1
}
    a2d4:	b003      	add	sp, #12
    a2d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    a2da:	2300      	movs	r3, #0
    a2dc:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
    a2e0:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    a2e4:	2301      	movs	r3, #1
}
    a2e6:	e7c6      	b.n	a276 <rtc_nrf_isr+0x66>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
    a2e8:	4611      	mov	r1, r2
    a2ea:	e7e9      	b.n	a2c0 <rtc_nrf_isr+0xb0>
    a2ec:	40011000 	.word	0x40011000
    a2f0:	20001aa8 	.word	0x20001aa8
    a2f4:	20001aa0 	.word	0x20001aa0
    a2f8:	20000dc8 	.word	0x20000dc8

0000a2fc <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    a2fc:	1c43      	adds	r3, r0, #1
{
    a2fe:	b513      	push	{r0, r1, r4, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    a300:	d021      	beq.n	a346 <sys_clock_set_timeout+0x4a>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    a302:	2801      	cmp	r0, #1
    a304:	dd21      	ble.n	a34a <sys_clock_set_timeout+0x4e>
    a306:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    a30a:	da20      	bge.n	a34e <sys_clock_set_timeout+0x52>
    a30c:	1e44      	subs	r4, r0, #1
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
    a30e:	f7ff fe79 	bl	a004 <z_nrf_rtc_timer_read>
    a312:	4b10      	ldr	r3, [pc, #64]	; (a354 <sys_clock_set_timeout+0x58>)
    a314:	e9d3 1300 	ldrd	r1, r3, [r3]
    a318:	1a40      	subs	r0, r0, r1
		ticks = 0;
    a31a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    a31e:	bf28      	it	cs
    a320:	2400      	movcs	r4, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    a322:	3001      	adds	r0, #1
    a324:	1902      	adds	r2, r0, r4
	uint64_t target_time = cyc + last_count;
    a326:	480c      	ldr	r0, [pc, #48]	; (a358 <sys_clock_set_timeout+0x5c>)
    a328:	4282      	cmp	r2, r0
    a32a:	bf28      	it	cs
    a32c:	4602      	movcs	r2, r0
    a32e:	1852      	adds	r2, r2, r1
    a330:	f04f 0000 	mov.w	r0, #0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
    a334:	4909      	ldr	r1, [pc, #36]	; (a35c <sys_clock_set_timeout+0x60>)
    a336:	9001      	str	r0, [sp, #4]
    a338:	9100      	str	r1, [sp, #0]
    a33a:	f143 0300 	adc.w	r3, r3, #0
    a33e:	f7ff fe83 	bl	a048 <compare_set>
}
    a342:	b002      	add	sp, #8
    a344:	bd10      	pop	{r4, pc}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    a346:	4804      	ldr	r0, [pc, #16]	; (a358 <sys_clock_set_timeout+0x5c>)
    a348:	e7e0      	b.n	a30c <sys_clock_set_timeout+0x10>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    a34a:	2400      	movs	r4, #0
    a34c:	e7df      	b.n	a30e <sys_clock_set_timeout+0x12>
    a34e:	4c02      	ldr	r4, [pc, #8]	; (a358 <sys_clock_set_timeout+0x5c>)
    a350:	e7dd      	b.n	a30e <sys_clock_set_timeout+0x12>
    a352:	bf00      	nop
    a354:	20000dd8 	.word	0x20000dd8
    a358:	007fffff 	.word	0x007fffff
    a35c:	00009f31 	.word	0x00009f31

0000a360 <sys_clock_elapsed>:
{
    a360:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
    a362:	f7ff fe4f 	bl	a004 <z_nrf_rtc_timer_read>
    a366:	4b02      	ldr	r3, [pc, #8]	; (a370 <sys_clock_elapsed+0x10>)
    a368:	681b      	ldr	r3, [r3, #0]
}
    a36a:	1ac0      	subs	r0, r0, r3
    a36c:	bd08      	pop	{r3, pc}
    a36e:	bf00      	nop
    a370:	20000dd8 	.word	0x20000dd8

0000a374 <nrf52_errata_16>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    a374:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
    a378:	f893 2fe0 	ldrb.w	r2, [r3, #4064]	; 0xfe0
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    a37c:	2a06      	cmp	r2, #6
    a37e:	d109      	bne.n	a394 <nrf52_errata_16+0x20>
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    a380:	f8d3 3fe8 	ldr.w	r3, [r3, #4072]	; 0xfe8
    a384:	f3c3 1303 	ubfx	r3, r3, #4, #4
    a388:	3b03      	subs	r3, #3
    a38a:	2b04      	cmp	r3, #4
    a38c:	d802      	bhi.n	a394 <nrf52_errata_16+0x20>
    a38e:	4a02      	ldr	r2, [pc, #8]	; (a398 <nrf52_errata_16+0x24>)
    a390:	5cd0      	ldrb	r0, [r2, r3]
    a392:	4770      	bx	lr
                    default:
                        return false;
                }
            }
        #endif
        return false;
    a394:	2000      	movs	r0, #0
    #endif
}
    a396:	4770      	bx	lr
    a398:	0001201e 	.word	0x0001201e

0000a39c <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    a39c:	4a02      	ldr	r2, [pc, #8]	; (a3a8 <nvmc_wait+0xc>)
    a39e:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    a3a2:	2b00      	cmp	r3, #0
    a3a4:	d0fb      	beq.n	a39e <nvmc_wait+0x2>
}
    a3a6:	4770      	bx	lr
    a3a8:	4001e000 	.word	0x4001e000

0000a3ac <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
    a3ac:	b510      	push	{r4, lr}
    #endif

    #if NRF52_ERRATA_12_ENABLE_WORKAROUND
        /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_12()){
    a3ae:	f004 ffcc 	bl	f34a <nrf52_errata_108>
    a3b2:	b140      	cbz	r0, a3c6 <SystemInit+0x1a>
            *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
    a3b4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    a3b8:	4a90      	ldr	r2, [pc, #576]	; (a5fc <SystemInit+0x250>)
    a3ba:	f8d3 3324 	ldr.w	r3, [r3, #804]	; 0x324
    a3be:	f3c3 2304 	ubfx	r3, r3, #8, #5
    a3c2:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    #endif

    #if NRF52_ERRATA_16_ENABLE_WORKAROUND
        /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_16()){
    a3c6:	f7ff ffd5 	bl	a374 <nrf52_errata_16>
    a3ca:	b110      	cbz	r0, a3d2 <SystemInit+0x26>
            *(volatile uint32_t *)0x4007C074 = 3131961357ul;
    a3cc:	4b8c      	ldr	r3, [pc, #560]	; (a600 <SystemInit+0x254>)
    a3ce:	4a8d      	ldr	r2, [pc, #564]	; (a604 <SystemInit+0x258>)
    a3d0:	675a      	str	r2, [r3, #116]	; 0x74
    #endif

    #if NRF52_ERRATA_31_ENABLE_WORKAROUND
        /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_31()){
    a3d2:	f004 ffba 	bl	f34a <nrf52_errata_108>
    a3d6:	b148      	cbz	r0, a3ec <SystemInit+0x40>
            *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
    a3d8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    a3dc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    a3e0:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
    a3e4:	f3c3 3342 	ubfx	r3, r3, #13, #3
    a3e8:	f8c2 353c 	str.w	r3, [r2, #1340]	; 0x53c
    #endif

    #if NRF52_ERRATA_32_ENABLE_WORKAROUND
        /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_32()){
    a3ec:	f7ff ffc2 	bl	a374 <nrf52_errata_16>
    a3f0:	b130      	cbz	r0, a400 <SystemInit+0x54>
            CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
    a3f2:	4a85      	ldr	r2, [pc, #532]	; (a608 <SystemInit+0x25c>)
    a3f4:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
    a3f8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    a3fc:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
    a400:	f004 ffa3 	bl	f34a <nrf52_errata_108>
    a404:	b140      	cbz	r0, a418 <SystemInit+0x6c>
            NRF_CLOCK->EVENTS_DONE = 0;
    a406:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a40a:	2200      	movs	r2, #0
    a40c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
    a410:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
    a414:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_37_ENABLE_WORKAROUND
        /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_37()){
    a418:	f7ff ffac 	bl	a374 <nrf52_errata_16>
    a41c:	b120      	cbz	r0, a428 <SystemInit+0x7c>
            *(volatile uint32_t *)0x400005A0 = 0x3;
    a41e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a422:	2203      	movs	r2, #3
    a424:	f8c3 25a0 	str.w	r2, [r3, #1440]	; 0x5a0
    #endif

    #if NRF52_ERRATA_57_ENABLE_WORKAROUND
        /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_57()){
    a428:	f7ff ffa4 	bl	a374 <nrf52_errata_16>
    a42c:	b160      	cbz	r0, a448 <SystemInit+0x9c>
            *(volatile uint32_t *)0x40005610 = 0x00000005;
    a42e:	4b77      	ldr	r3, [pc, #476]	; (a60c <SystemInit+0x260>)
    a430:	2205      	movs	r2, #5
    a432:	f8c3 2610 	str.w	r2, [r3, #1552]	; 0x610
            *(volatile uint32_t *)0x40005688 = 0x00000001;
    a436:	2201      	movs	r2, #1
    a438:	f8c3 2688 	str.w	r2, [r3, #1672]	; 0x688
            *(volatile uint32_t *)0x40005618 = 0x00000000;
    a43c:	2200      	movs	r2, #0
    a43e:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
            *(volatile uint32_t *)0x40005614 = 0x0000003F;
    a442:	223f      	movs	r2, #63	; 0x3f
    a444:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    a448:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    a44c:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    a450:	1c51      	adds	r1, r2, #1
            {
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    a452:	bf09      	itett	eq
    a454:	f04f 4370 	moveq.w	r3, #4026531840	; 0xf0000000
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
            }
            else
            {
                var1 = *(uint32_t *)0x10000130ul;
                var2 = *(uint32_t *)0x10000134ul;
    a458:	f8d3 3134 	ldrne.w	r3, [r3, #308]	; 0x134
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    a45c:	f893 2fe0 	ldrbeq.w	r2, [r3, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    a460:	f8d3 3fe8 	ldreq.w	r3, [r3, #4072]	; 0xfe8
    a464:	bf08      	it	eq
    a466:	f3c3 1303 	ubfxeq	r3, r3, #4, #4
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    a46a:	2a06      	cmp	r2, #6
    a46c:	d14d      	bne.n	a50a <SystemInit+0x15e>
            {
                switch(var2)
    a46e:	3b03      	subs	r3, #3
    a470:	2b04      	cmp	r3, #4
    a472:	d803      	bhi.n	a47c <SystemInit+0xd0>
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
    a474:	4a66      	ldr	r2, [pc, #408]	; (a610 <SystemInit+0x264>)
    a476:	5cd3      	ldrb	r3, [r2, r3]
    a478:	2b00      	cmp	r3, #0
    a47a:	d046      	beq.n	a50a <SystemInit+0x15e>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    a47c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    a480:	4b64      	ldr	r3, [pc, #400]	; (a614 <SystemInit+0x268>)
    a482:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    a486:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    a48a:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    a48e:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    a492:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    a496:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    a49a:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    a49e:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    a4a2:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    a4a6:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    a4aa:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    a4ae:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    a4b2:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    a4b6:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    a4ba:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    a4be:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    a4c2:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    a4c6:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    a4ca:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    a4ce:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    a4d2:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    a4d6:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    a4da:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    a4de:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    a4e2:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    a4e6:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    a4ea:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    a4ee:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    a4f2:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    a4f6:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    a4fa:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    a4fe:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    a502:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    a506:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_108_ENABLE_WORKAROUND
        /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_108()){
    a50a:	f004 ff1e 	bl	f34a <nrf52_errata_108>
    a50e:	b148      	cbz	r0, a524 <SystemInit+0x178>
            *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
    a510:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    a514:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    a518:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
    a51c:	f003 034f 	and.w	r3, r3, #79	; 0x4f
    a520:	f8c2 3ee4 	str.w	r3, [r2, #3812]	; 0xee4
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
    a524:	f004 ff11 	bl	f34a <nrf52_errata_108>
    a528:	b148      	cbz	r0, a53e <SystemInit+0x192>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    a52a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a52e:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    a532:	07d2      	lsls	r2, r2, #31
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    a534:	bf44      	itt	mi
    a536:	f06f 0201 	mvnmi.w	r2, #1
    a53a:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    a53e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    a542:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    a546:	2a06      	cmp	r2, #6
    a548:	d126      	bne.n	a598 <SystemInit+0x1ec>
            {
                switch(var2)
    a54a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
    a54e:	3b03      	subs	r3, #3
    a550:	2b04      	cmp	r3, #4
    a552:	d802      	bhi.n	a55a <SystemInit+0x1ae>
    #endif

    #if NRF52_ERRATA_182_ENABLE_WORKAROUND
        /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_182()){
    a554:	4a30      	ldr	r2, [pc, #192]	; (a618 <SystemInit+0x26c>)
    a556:	5cd3      	ldrb	r3, [r2, r3]
    a558:	b163      	cbz	r3, a574 <SystemInit+0x1c8>
            *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
    a55a:	4a30      	ldr	r2, [pc, #192]	; (a61c <SystemInit+0x270>)
    a55c:	f8d2 373c 	ldr.w	r3, [r2, #1852]	; 0x73c
    a560:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    a564:	f8c2 373c 	str.w	r3, [r2, #1852]	; 0x73c
         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    a568:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    a56c:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
    a570:	2b06      	cmp	r3, #6
    a572:	d111      	bne.n	a598 <SystemInit+0x1ec>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    a574:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    a578:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
    a57c:	3b03      	subs	r3, #3
    a57e:	2b04      	cmp	r3, #4
    a580:	d802      	bhi.n	a588 <SystemInit+0x1dc>
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
    a582:	4a27      	ldr	r2, [pc, #156]	; (a620 <SystemInit+0x274>)
    a584:	5cd3      	ldrb	r3, [r2, r3]
    a586:	b13b      	cbz	r3, a598 <SystemInit+0x1ec>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
    a588:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    a58c:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    a590:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a594:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    a598:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    a59c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    a5a0:	2a00      	cmp	r2, #0
    a5a2:	db03      	blt.n	a5ac <SystemInit+0x200>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    a5a4:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    a5a8:	2b00      	cmp	r3, #0
    a5aa:	da22      	bge.n	a5f2 <SystemInit+0x246>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    a5ac:	491d      	ldr	r1, [pc, #116]	; (a624 <SystemInit+0x278>)
    a5ae:	2301      	movs	r3, #1
            nvmc_config(NVMC_CONFIG_WEN_Wen);
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    a5b0:	f04f 2010 	mov.w	r0, #268439552	; 0x10001000
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    a5b4:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    a5b8:	2415      	movs	r4, #21
    nvmc_wait();
    a5ba:	f7ff feef 	bl	a39c <nvmc_wait>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    a5be:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
            nvmc_wait();
    a5c2:	f7ff feeb 	bl	a39c <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
    a5c6:	f8c0 4204 	str.w	r4, [r0, #516]	; 0x204
            nvmc_wait();
    a5ca:	f7ff fee7 	bl	a39c <nvmc_wait>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    a5ce:	2300      	movs	r3, #0
    a5d0:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
    nvmc_wait();
    a5d4:	f7ff fee2 	bl	a39c <nvmc_wait>
  __ASM volatile ("dsb 0xF":::"memory");
    a5d8:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    a5dc:	490a      	ldr	r1, [pc, #40]	; (a608 <SystemInit+0x25c>)
    a5de:	4b12      	ldr	r3, [pc, #72]	; (a628 <SystemInit+0x27c>)
    a5e0:	68ca      	ldr	r2, [r1, #12]
    a5e2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    a5e6:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    a5e8:	60cb      	str	r3, [r1, #12]
    a5ea:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    a5ee:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    a5f0:	e7fd      	b.n	a5ee <SystemInit+0x242>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    a5f2:	4b0e      	ldr	r3, [pc, #56]	; (a62c <SystemInit+0x280>)
    a5f4:	4a0e      	ldr	r2, [pc, #56]	; (a630 <SystemInit+0x284>)
    a5f6:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
    a5f8:	bd10      	pop	{r4, pc}
    a5fa:	bf00      	nop
    a5fc:	40013000 	.word	0x40013000
    a600:	4007c000 	.word	0x4007c000
    a604:	baadf00d 	.word	0xbaadf00d
    a608:	e000ed00 	.word	0xe000ed00
    a60c:	40005000 	.word	0x40005000
    a610:	0001200f 	.word	0x0001200f
    a614:	4000c000 	.word	0x4000c000
    a618:	00012014 	.word	0x00012014
    a61c:	40001000 	.word	0x40001000
    a620:	00012019 	.word	0x00012019
    a624:	4001e000 	.word	0x4001e000
    a628:	05fa0004 	.word	0x05fa0004
    a62c:	200004a8 	.word	0x200004a8
    a630:	03d09000 	.word	0x03d09000

0000a634 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
    a634:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
    a636:	2501      	movs	r5, #1
        prev_mask = *p_mask;
    a638:	6802      	ldr	r2, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
    a63a:	fab2 f382 	clz	r3, r2
    a63e:	f1c3 031f 	rsb	r3, r3, #31
        if (idx < 0) {
    a642:	1c5e      	adds	r6, r3, #1
        idx = 31 - NRF_CLZ(prev_mask);
    a644:	b2dc      	uxtb	r4, r3
        if (idx < 0) {
    a646:	d014      	beq.n	a672 <nrfx_flag32_alloc+0x3e>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    a648:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask & ~NRFX_BIT(idx);
    a64c:	fa05 f303 	lsl.w	r3, r5, r3
    a650:	ea22 0303 	bic.w	r3, r2, r3
    a654:	e850 6f00 	ldrex	r6, [r0]
    a658:	4296      	cmp	r6, r2
    a65a:	d104      	bne.n	a666 <nrfx_flag32_alloc+0x32>
    a65c:	e840 3c00 	strex	ip, r3, [r0]
    a660:	f1bc 0f00 	cmp.w	ip, #0
    a664:	d1f6      	bne.n	a654 <nrfx_flag32_alloc+0x20>
    a666:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    a66a:	d1e5      	bne.n	a638 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
    a66c:	4802      	ldr	r0, [pc, #8]	; (a678 <nrfx_flag32_alloc+0x44>)
    *p_flag = idx;
    a66e:	700c      	strb	r4, [r1, #0]
}
    a670:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
    a672:	4802      	ldr	r0, [pc, #8]	; (a67c <nrfx_flag32_alloc+0x48>)
    a674:	e7fc      	b.n	a670 <nrfx_flag32_alloc+0x3c>
    a676:	bf00      	nop
    a678:	0bad0000 	.word	0x0bad0000
    a67c:	0bad0002 	.word	0x0bad0002

0000a680 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
    a680:	6803      	ldr	r3, [r0, #0]
    a682:	40cb      	lsrs	r3, r1
    a684:	07db      	lsls	r3, r3, #31
{
    a686:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
    a688:	d415      	bmi.n	a6b6 <nrfx_flag32_free+0x36>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
    a68a:	2301      	movs	r3, #1
    a68c:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
    a690:	6803      	ldr	r3, [r0, #0]
    a692:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask | NRFX_BIT(flag);
    a696:	ea41 0203 	orr.w	r2, r1, r3
    a69a:	e850 4f00 	ldrex	r4, [r0]
    a69e:	429c      	cmp	r4, r3
    a6a0:	d104      	bne.n	a6ac <nrfx_flag32_free+0x2c>
    a6a2:	e840 2c00 	strex	ip, r2, [r0]
    a6a6:	f1bc 0f00 	cmp.w	ip, #0
    a6aa:	d1f6      	bne.n	a69a <nrfx_flag32_free+0x1a>
    a6ac:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    a6b0:	d1ee      	bne.n	a690 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
    a6b2:	4802      	ldr	r0, [pc, #8]	; (a6bc <nrfx_flag32_free+0x3c>)
}
    a6b4:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
    a6b6:	4802      	ldr	r0, [pc, #8]	; (a6c0 <nrfx_flag32_free+0x40>)
    a6b8:	e7fc      	b.n	a6b4 <nrfx_flag32_free+0x34>
    a6ba:	bf00      	nop
    a6bc:	0bad0000 	.word	0x0bad0000
    a6c0:	0bad0004 	.word	0x0bad0004

0000a6c4 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    a6c4:	4b04      	ldr	r3, [pc, #16]	; (a6d8 <nrfx_clock_init+0x14>)
    a6c6:	791a      	ldrb	r2, [r3, #4]
    a6c8:	b922      	cbnz	r2, a6d4 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
    a6ca:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
    a6cc:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    a6ce:	809a      	strh	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    a6d0:	4802      	ldr	r0, [pc, #8]	; (a6dc <nrfx_clock_init+0x18>)
    a6d2:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    a6d4:	4802      	ldr	r0, [pc, #8]	; (a6e0 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    a6d6:	4770      	bx	lr
    a6d8:	20001aac 	.word	0x20001aac
    a6dc:	0bad0000 	.word	0x0bad0000
    a6e0:	0bad000c 	.word	0x0bad000c

0000a6e4 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    a6e4:	b530      	push	{r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    a6e6:	b110      	cbz	r0, a6ee <nrfx_clock_start+0xa>
    a6e8:	2801      	cmp	r0, #1
    a6ea:	d034      	beq.n	a756 <nrfx_clock_start+0x72>
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
    a6ec:	bd30      	pop	{r4, r5, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    a6ee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a6f2:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    a6f6:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
    a6fa:	03c9      	lsls	r1, r1, #15
    a6fc:	d529      	bpl.n	a752 <nrfx_clock_start+0x6e>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    a6fe:	f002 0203 	and.w	r2, r2, #3
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    a702:	2a01      	cmp	r2, #1
    a704:	d125      	bne.n	a752 <nrfx_clock_start+0x6e>
    p_reg->LFCLKSRC = (uint32_t)(source);
    a706:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    a70a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a70e:	2200      	movs	r2, #0
    a710:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    a714:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->INTENSET = mask;
    a718:	2202      	movs	r2, #2
    a71a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    core_debug = CoreDebug->DEMCR;
    a71e:	4a13      	ldr	r2, [pc, #76]	; (a76c <nrfx_clock_start+0x88>)
    a720:	f8d2 00fc 	ldr.w	r0, [r2, #252]	; 0xfc
    CoreDebug->DEMCR = core_debug | CoreDebug_DEMCR_TRCENA_Msk;
    a724:	f040 7380 	orr.w	r3, r0, #16777216	; 0x1000000
    a728:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
    dwt_ctrl = DWT->CTRL;
    a72c:	4b10      	ldr	r3, [pc, #64]	; (a770 <nrfx_clock_start+0x8c>)
    a72e:	681c      	ldr	r4, [r3, #0]
    DWT->CTRL = dwt_ctrl | DWT_CTRL_CYCCNTENA_Msk;
    a730:	f044 0101 	orr.w	r1, r4, #1
    a734:	6019      	str	r1, [r3, #0]
    cyccnt_inital = DWT->CYCCNT;
    a736:	685d      	ldr	r5, [r3, #4]
    while ((DWT->CYCCNT - cyccnt_inital) < ANOMALY_132_DELAY_CYCLES)
    a738:	6859      	ldr	r1, [r3, #4]
    a73a:	1b49      	subs	r1, r1, r5
    a73c:	f5b1 5f0a 	cmp.w	r1, #8832	; 0x2280
    a740:	d3fa      	bcc.n	a738 <nrfx_clock_start+0x54>
    DWT->CTRL = dwt_ctrl;
    a742:	601c      	str	r4, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    a744:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    CoreDebug->DEMCR = core_debug;
    a748:	f8c2 00fc 	str.w	r0, [r2, #252]	; 0xfc
    a74c:	2201      	movs	r2, #1
    a74e:	609a      	str	r2, [r3, #8]
}
    a750:	e7cc      	b.n	a6ec <nrfx_clock_start+0x8>
    p_reg->LFCLKSRC = (uint32_t)(source);
    a752:	2200      	movs	r2, #0
    a754:	e7d7      	b.n	a706 <nrfx_clock_start+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    a756:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a75a:	2200      	movs	r2, #0
    a75c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    a760:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
    a764:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    a768:	6018      	str	r0, [r3, #0]
}
    a76a:	e7bf      	b.n	a6ec <nrfx_clock_start+0x8>
    a76c:	e000ed00 	.word	0xe000ed00
    a770:	e0001000 	.word	0xe0001000

0000a774 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    a774:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    a776:	b110      	cbz	r0, a77e <nrfx_clock_stop+0xa>
    a778:	2801      	cmp	r0, #1
    a77a:	d017      	beq.n	a7ac <nrfx_clock_stop+0x38>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    a77c:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
    a77e:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    a782:	2302      	movs	r3, #2
    a784:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    a788:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
    a78c:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    a790:	2301      	movs	r3, #1
    a792:	60e3      	str	r3, [r4, #12]
    a794:	f242 7510 	movw	r5, #10000	; 0x2710
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    a798:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
    a79c:	03db      	lsls	r3, r3, #15
    a79e:	d5ed      	bpl.n	a77c <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    a7a0:	2001      	movs	r0, #1
    a7a2:	f004 fde1 	bl	f368 <nrfx_busy_wait>
    a7a6:	3d01      	subs	r5, #1
    a7a8:	d1f6      	bne.n	a798 <nrfx_clock_stop+0x24>
    a7aa:	e7e7      	b.n	a77c <nrfx_clock_stop+0x8>
    p_reg->INTENCLR = mask;
    a7ac:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    a7b0:	2300      	movs	r3, #0
    p_reg->INTENCLR = mask;
    a7b2:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    a7b6:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
    a7ba:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    a7be:	6060      	str	r0, [r4, #4]
    a7c0:	f242 7510 	movw	r5, #10000	; 0x2710
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    a7c4:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    a7c8:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
    a7cc:	03d2      	lsls	r2, r2, #15
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    a7ce:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    a7d2:	d505      	bpl.n	a7e0 <nrfx_clock_stop+0x6c>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    a7d4:	b123      	cbz	r3, a7e0 <nrfx_clock_stop+0x6c>
    a7d6:	2001      	movs	r0, #1
    a7d8:	f004 fdc6 	bl	f368 <nrfx_busy_wait>
    a7dc:	3d01      	subs	r5, #1
    a7de:	d1f1      	bne.n	a7c4 <nrfx_clock_stop+0x50>
            m_clock_cb.hfclk_started = false;
    a7e0:	4b01      	ldr	r3, [pc, #4]	; (a7e8 <nrfx_clock_stop+0x74>)
    a7e2:	2200      	movs	r2, #0
    a7e4:	715a      	strb	r2, [r3, #5]
    a7e6:	e7c9      	b.n	a77c <nrfx_clock_stop+0x8>
    a7e8:	20001aac 	.word	0x20001aac

0000a7ec <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    a7ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    a7f0:	b510      	push	{r4, lr}
    a7f2:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    a7f6:	b16a      	cbz	r2, a814 <nrfx_power_clock_irq_handler+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    a7f8:	2200      	movs	r2, #0
    a7fa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    a7fe:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
    a802:	2201      	movs	r2, #1
    a804:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
    a808:	4b11      	ldr	r3, [pc, #68]	; (a850 <nrfx_power_clock_irq_handler+0x64>)
    a80a:	7958      	ldrb	r0, [r3, #5]
    a80c:	b910      	cbnz	r0, a814 <nrfx_power_clock_irq_handler+0x28>
        {
            m_clock_cb.hfclk_started = true;
    a80e:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    a810:	681b      	ldr	r3, [r3, #0]
    a812:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    a814:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    a818:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    a81c:	b172      	cbz	r2, a83c <nrfx_power_clock_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    a81e:	2200      	movs	r2, #0
    a820:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    a824:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    a828:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    a82c:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    a830:	0792      	lsls	r2, r2, #30
    a832:	d104      	bne.n	a83e <nrfx_power_clock_irq_handler+0x52>
    p_reg->LFCLKSRC = (uint32_t)(source);
    a834:	2201      	movs	r2, #1
    a836:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    a83a:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    a83c:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
    a83e:	2202      	movs	r2, #2
    a840:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    a844:	4b02      	ldr	r3, [pc, #8]	; (a850 <nrfx_power_clock_irq_handler+0x64>)
}
    a846:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    a84a:	681b      	ldr	r3, [r3, #0]
    a84c:	2001      	movs	r0, #1
    a84e:	4718      	bx	r3
    a850:	20001aac 	.word	0x20001aac

0000a854 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
    a854:	4b03      	ldr	r3, [pc, #12]	; (a864 <pin_in_use_by_te+0x10>)
    a856:	3008      	adds	r0, #8
    a858:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    a85c:	f3c0 1040 	ubfx	r0, r0, #5, #1
    a860:	4770      	bx	lr
    a862:	bf00      	nop
    a864:	200004ac 	.word	0x200004ac

0000a868 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
    a868:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    a86a:	f100 0308 	add.w	r3, r0, #8
    a86e:	4c0c      	ldr	r4, [pc, #48]	; (a8a0 <call_handler+0x38>)
    a870:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
    a874:	05da      	lsls	r2, r3, #23
{
    a876:	4605      	mov	r5, r0
    a878:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    a87a:	d507      	bpl.n	a88c <call_handler+0x24>
    a87c:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
    a880:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    a884:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
    a888:	6852      	ldr	r2, [r2, #4]
    a88a:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
    a88c:	68a3      	ldr	r3, [r4, #8]
    a88e:	b12b      	cbz	r3, a89c <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    a890:	68e2      	ldr	r2, [r4, #12]
    a892:	4631      	mov	r1, r6
    a894:	4628      	mov	r0, r5
    }
}
    a896:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    a89a:	4718      	bx	r3
}
    a89c:	bd70      	pop	{r4, r5, r6, pc}
    a89e:	bf00      	nop
    a8a0:	200004ac 	.word	0x200004ac

0000a8a4 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    a8a4:	4a12      	ldr	r2, [pc, #72]	; (a8f0 <release_handler+0x4c>)
    a8a6:	3008      	adds	r0, #8
{
    a8a8:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    a8aa:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
    a8ae:	05d9      	lsls	r1, r3, #23
    a8b0:	d51b      	bpl.n	a8ea <release_handler+0x46>
    a8b2:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
    a8b6:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    a8ba:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    a8be:	f102 0410 	add.w	r4, r2, #16
    a8c2:	2000      	movs	r0, #0
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    a8c4:	f834 3b02 	ldrh.w	r3, [r4], #2
    a8c8:	f413 7f80 	tst.w	r3, #256	; 0x100
    a8cc:	d003      	beq.n	a8d6 <release_handler+0x32>
    a8ce:	f3c3 2343 	ubfx	r3, r3, #9, #4
    a8d2:	4299      	cmp	r1, r3
    a8d4:	d009      	beq.n	a8ea <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    a8d6:	3001      	adds	r0, #1
    a8d8:	2820      	cmp	r0, #32
    a8da:	d1f3      	bne.n	a8c4 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
    a8dc:	2300      	movs	r3, #0
    a8de:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    a8e2:	4804      	ldr	r0, [pc, #16]	; (a8f4 <release_handler+0x50>)
}
    a8e4:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    a8e6:	f7ff becb 	b.w	a680 <nrfx_flag32_free>
}
    a8ea:	bc10      	pop	{r4}
    a8ec:	4770      	bx	lr
    a8ee:	bf00      	nop
    a8f0:	200004ac 	.word	0x200004ac
    a8f4:	20000500 	.word	0x20000500

0000a8f8 <pin_handler_trigger_uninit>:
{
    a8f8:	b538      	push	{r3, r4, r5, lr}
    a8fa:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
    a8fc:	f7ff ffaa 	bl	a854 <pin_in_use_by_te>
    a900:	4c09      	ldr	r4, [pc, #36]	; (a928 <pin_handler_trigger_uninit+0x30>)
    a902:	f102 0508 	add.w	r5, r2, #8
    a906:	b140      	cbz	r0, a91a <pin_handler_trigger_uninit+0x22>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    a908:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
    a90c:	4907      	ldr	r1, [pc, #28]	; (a92c <pin_handler_trigger_uninit+0x34>)
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
    a90e:	0b5b      	lsrs	r3, r3, #13
    a910:	f503 73a2 	add.w	r3, r3, #324	; 0x144
    a914:	2000      	movs	r0, #0
    a916:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    release_handler(pin);
    a91a:	4610      	mov	r0, r2
    a91c:	f7ff ffc2 	bl	a8a4 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
    a920:	2300      	movs	r3, #0
    a922:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
    a926:	bd38      	pop	{r3, r4, r5, pc}
    a928:	200004ac 	.word	0x200004ac
    a92c:	40006000 	.word	0x40006000

0000a930 <nrfx_gpiote_input_configure>:
{
    a930:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    a934:	4604      	mov	r4, r0
    a936:	461e      	mov	r6, r3
    if (p_input_config)
    a938:	b309      	cbz	r1, a97e <nrfx_gpiote_input_configure+0x4e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    a93a:	4f4d      	ldr	r7, [pc, #308]	; (aa70 <nrfx_gpiote_input_configure+0x140>)
    a93c:	f100 0808 	add.w	r8, r0, #8
    a940:	f837 5018 	ldrh.w	r5, [r7, r8, lsl #1]
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    a944:	07ab      	lsls	r3, r5, #30
    a946:	d506      	bpl.n	a956 <nrfx_gpiote_input_configure+0x26>
    a948:	f7ff ff84 	bl	a854 <pin_in_use_by_te>
        if (pin_is_task_output(pin))
    a94c:	b118      	cbz	r0, a956 <nrfx_gpiote_input_configure+0x26>
            return NRFX_ERROR_INVALID_PARAM;
    a94e:	4849      	ldr	r0, [pc, #292]	; (aa74 <nrfx_gpiote_input_configure+0x144>)
}
    a950:	b002      	add	sp, #8
    a952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *p_pin = pin_number & 0x1F;
    a956:	f004 001f 	and.w	r0, r4, #31
    a95a:	0080      	lsls	r0, r0, #2
    a95c:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    a960:	7809      	ldrb	r1, [r1, #0]
    uint32_t cnf = reg->PIN_CNF[pin_number];
    a962:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
    a966:	f025 0502 	bic.w	r5, r5, #2
    cnf &= ~to_update;
    a96a:	f023 030f 	bic.w	r3, r3, #15
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    a96e:	f045 0501 	orr.w	r5, r5, #1
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    a972:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
    a976:	f827 5018 	strh.w	r5, [r7, r8, lsl #1]
    reg->PIN_CNF[pin_number] = cnf;
    a97a:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
    if (p_trigger_config)
    a97e:	b192      	cbz	r2, a9a6 <nrfx_gpiote_input_configure+0x76>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    a980:	4b3b      	ldr	r3, [pc, #236]	; (aa70 <nrfx_gpiote_input_configure+0x140>)
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
    a982:	7815      	ldrb	r5, [r2, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
    a984:	6852      	ldr	r2, [r2, #4]
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    a986:	f104 0008 	add.w	r0, r4, #8
    a98a:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
        if (pin_is_output(pin))
    a98e:	078f      	lsls	r7, r1, #30
    a990:	d50c      	bpl.n	a9ac <nrfx_gpiote_input_configure+0x7c>
            if (use_evt)
    a992:	2a00      	cmp	r2, #0
    a994:	d1db      	bne.n	a94e <nrfx_gpiote_input_configure+0x1e>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    a996:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
    a99a:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    a99e:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
    a9a2:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    if (p_handler_config)
    a9a6:	bbce      	cbnz	r6, aa1c <nrfx_gpiote_input_configure+0xec>
    return NRFX_SUCCESS;
    a9a8:	4833      	ldr	r0, [pc, #204]	; (aa78 <nrfx_gpiote_input_configure+0x148>)
    a9aa:	e7d1      	b.n	a950 <nrfx_gpiote_input_configure+0x20>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
    a9ac:	f021 0120 	bic.w	r1, r1, #32
    a9b0:	04c9      	lsls	r1, r1, #19
    a9b2:	0cc9      	lsrs	r1, r1, #19
    a9b4:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
            if (use_evt)
    a9b8:	2a00      	cmp	r2, #0
    a9ba:	d0ec      	beq.n	a996 <nrfx_gpiote_input_configure+0x66>
                if (!edge)
    a9bc:	2d03      	cmp	r5, #3
    a9be:	d8c6      	bhi.n	a94e <nrfx_gpiote_input_configure+0x1e>
                uint8_t ch = *p_trigger_config->p_in_channel;
    a9c0:	7817      	ldrb	r7, [r2, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
    a9c2:	b92d      	cbnz	r5, a9d0 <nrfx_gpiote_input_configure+0xa0>
    a9c4:	4a2d      	ldr	r2, [pc, #180]	; (aa7c <nrfx_gpiote_input_configure+0x14c>)
    a9c6:	f507 71a2 	add.w	r1, r7, #324	; 0x144
    a9ca:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
#endif
}
    a9ce:	e7e2      	b.n	a996 <nrfx_gpiote_input_configure+0x66>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    a9d0:	00ba      	lsls	r2, r7, #2
    a9d2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    a9d6:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    a9da:	ea41 3147 	orr.w	r1, r1, r7, lsl #13
    a9de:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
    a9e2:	f02c 0c03 	bic.w	ip, ip, #3
    a9e6:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    a9ea:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
    a9ee:	f42c 3c47 	bic.w	ip, ip, #203776	; 0x31c00
    a9f2:	f42c 7c40 	bic.w	ip, ip, #768	; 0x300
    a9f6:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    a9fa:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
    a9fe:	ea4f 2c04 	mov.w	ip, r4, lsl #8
    aa02:	f40c 5cf8 	and.w	ip, ip, #7936	; 0x1f00
    aa06:	ea4e 4e05 	orr.w	lr, lr, r5, lsl #16
    aa0a:	ea4c 0c0e 	orr.w	ip, ip, lr
    aa0e:	f041 0120 	orr.w	r1, r1, #32
    aa12:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
    aa16:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
    aa1a:	e7bc      	b.n	a996 <nrfx_gpiote_input_configure+0x66>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
    aa1c:	e9d6 7600 	ldrd	r7, r6, [r6]
    release_handler(pin);
    aa20:	4620      	mov	r0, r4
    aa22:	f7ff ff3f 	bl	a8a4 <release_handler>
    if (!handler)
    aa26:	2f00      	cmp	r7, #0
    aa28:	d0be      	beq.n	a9a8 <nrfx_gpiote_input_configure+0x78>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    aa2a:	4d11      	ldr	r5, [pc, #68]	; (aa70 <nrfx_gpiote_input_configure+0x140>)
    aa2c:	682b      	ldr	r3, [r5, #0]
    aa2e:	429f      	cmp	r7, r3
    aa30:	d104      	bne.n	aa3c <nrfx_gpiote_input_configure+0x10c>
    aa32:	686b      	ldr	r3, [r5, #4]
    aa34:	429e      	cmp	r6, r3
    aa36:	d101      	bne.n	aa3c <nrfx_gpiote_input_configure+0x10c>
    aa38:	2200      	movs	r2, #0
    aa3a:	e009      	b.n	aa50 <nrfx_gpiote_input_configure+0x120>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
    aa3c:	4810      	ldr	r0, [pc, #64]	; (aa80 <nrfx_gpiote_input_configure+0x150>)
    aa3e:	f10d 0107 	add.w	r1, sp, #7
    aa42:	f7ff fdf7 	bl	a634 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
    aa46:	4b0c      	ldr	r3, [pc, #48]	; (aa78 <nrfx_gpiote_input_configure+0x148>)
    aa48:	4298      	cmp	r0, r3
    aa4a:	d181      	bne.n	a950 <nrfx_gpiote_input_configure+0x20>
        handler_id = (int32_t)id;
    aa4c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].handler = handler;
    aa50:	f845 7032 	str.w	r7, [r5, r2, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
    aa54:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    aa58:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
    aa5a:	605e      	str	r6, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    aa5c:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    aa60:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
    aa64:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    aa68:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
    aa6c:	e79c      	b.n	a9a8 <nrfx_gpiote_input_configure+0x78>
    aa6e:	bf00      	nop
    aa70:	200004ac 	.word	0x200004ac
    aa74:	0bad0004 	.word	0x0bad0004
    aa78:	0bad0000 	.word	0x0bad0000
    aa7c:	40006000 	.word	0x40006000
    aa80:	20000500 	.word	0x20000500

0000aa84 <nrfx_gpiote_output_configure>:
{
    aa84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aa86:	4604      	mov	r4, r0
    if (p_config)
    aa88:	b371      	cbz	r1, aae8 <nrfx_gpiote_output_configure+0x64>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    aa8a:	4e37      	ldr	r6, [pc, #220]	; (ab68 <nrfx_gpiote_output_configure+0xe4>)
    aa8c:	f100 0708 	add.w	r7, r0, #8
    aa90:	f836 5017 	ldrh.w	r5, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
    aa94:	07ab      	lsls	r3, r5, #30
    aa96:	d404      	bmi.n	aaa2 <nrfx_gpiote_output_configure+0x1e>
    aa98:	f7ff fedc 	bl	a854 <pin_in_use_by_te>
    aa9c:	b108      	cbz	r0, aaa2 <nrfx_gpiote_output_configure+0x1e>
    return NRFX_SUCCESS;
    aa9e:	4833      	ldr	r0, [pc, #204]	; (ab6c <nrfx_gpiote_output_configure+0xe8>)
}
    aaa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
    aaa2:	f015 0f1c 	tst.w	r5, #28
    aaa6:	784b      	ldrb	r3, [r1, #1]
    aaa8:	d001      	beq.n	aaae <nrfx_gpiote_output_configure+0x2a>
    aaaa:	2b01      	cmp	r3, #1
    aaac:	d0f7      	beq.n	aa9e <nrfx_gpiote_output_configure+0x1a>
    *p_pin = pin_number & 0x1F;
    aaae:	f004 001f 	and.w	r0, r4, #31
    aab2:	0080      	lsls	r0, r0, #2
    aab4:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
    aab8:	f891 e000 	ldrb.w	lr, [r1]
    uint32_t cnf = reg->PIN_CNF[pin_number];
    aabc:	f8d0 c700 	ldr.w	ip, [r0, #1792]	; 0x700
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    aac0:	7889      	ldrb	r1, [r1, #2]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    aac2:	005b      	lsls	r3, r3, #1
    cnf &= ~to_update;
    aac4:	f42c 6ce1 	bic.w	ip, ip, #1800	; 0x708
    aac8:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    aacc:	f02c 0c07 	bic.w	ip, ip, #7
    aad0:	ea43 030c 	orr.w	r3, r3, ip
    aad4:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
    aad8:	f045 0503 	orr.w	r5, r5, #3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    aadc:	f043 0301 	orr.w	r3, r3, #1
    aae0:	f826 5017 	strh.w	r5, [r6, r7, lsl #1]
    reg->PIN_CNF[pin_number] = cnf;
    aae4:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
    if (p_task_config)
    aae8:	b90a      	cbnz	r2, aaee <nrfx_gpiote_output_configure+0x6a>
    return NRFX_SUCCESS;
    aaea:	4821      	ldr	r0, [pc, #132]	; (ab70 <nrfx_gpiote_output_configure+0xec>)
    aaec:	e7d8      	b.n	aaa0 <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    aaee:	4e1e      	ldr	r6, [pc, #120]	; (ab68 <nrfx_gpiote_output_configure+0xe4>)
    aaf0:	f104 0708 	add.w	r7, r4, #8
    aaf4:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
    aaf8:	0783      	lsls	r3, r0, #30
    aafa:	d5d0      	bpl.n	aa9e <nrfx_gpiote_output_configure+0x1a>
        uint32_t ch = p_task_config->task_ch;
    aafc:	f892 c000 	ldrb.w	ip, [r2]
    p_reg->CONFIG[idx] = 0;
    ab00:	4661      	mov	r1, ip
    ab02:	0089      	lsls	r1, r1, #2
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
    ab04:	f020 0020 	bic.w	r0, r0, #32
    ab08:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    ab0c:	04c0      	lsls	r0, r0, #19
    ab0e:	f501 41c0 	add.w	r1, r1, #24576	; 0x6000
    ab12:	0cc0      	lsrs	r0, r0, #19
    ab14:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    ab18:	2300      	movs	r3, #0
    ab1a:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
    ab1e:	7855      	ldrb	r5, [r2, #1]
    ab20:	2d00      	cmp	r5, #0
    ab22:	d0e2      	beq.n	aaea <nrfx_gpiote_output_configure+0x66>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    ab24:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
    ab28:	7892      	ldrb	r2, [r2, #2]
    ab2a:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
    ab2e:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    ab32:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    ab36:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
    ab3a:	0223      	lsls	r3, r4, #8
    ab3c:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    ab40:	042d      	lsls	r5, r5, #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    ab42:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    ab46:	f405 3540 	and.w	r5, r5, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    ab4a:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    ab4c:	432b      	orrs	r3, r5
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    ab4e:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    ab52:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    ab56:	4313      	orrs	r3, r2
    ab58:	f040 0020 	orr.w	r0, r0, #32
    ab5c:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    ab60:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
    ab64:	e7c1      	b.n	aaea <nrfx_gpiote_output_configure+0x66>
    ab66:	bf00      	nop
    ab68:	200004ac 	.word	0x200004ac
    ab6c:	0bad0004 	.word	0x0bad0004
    ab70:	0bad0000 	.word	0x0bad0000

0000ab74 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
    ab74:	4b01      	ldr	r3, [pc, #4]	; (ab7c <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
    ab76:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
    ab7a:	4770      	bx	lr
    ab7c:	200004ac 	.word	0x200004ac

0000ab80 <nrfx_gpiote_channel_get>:
{
    ab80:	b508      	push	{r3, lr}
    ab82:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
    ab84:	f7ff fe66 	bl	a854 <pin_in_use_by_te>
    ab88:	b138      	cbz	r0, ab9a <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    ab8a:	4b05      	ldr	r3, [pc, #20]	; (aba0 <nrfx_gpiote_channel_get+0x20>)
        return NRFX_SUCCESS;
    ab8c:	4805      	ldr	r0, [pc, #20]	; (aba4 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    ab8e:	3208      	adds	r2, #8
    ab90:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    ab94:	0b5b      	lsrs	r3, r3, #13
    ab96:	700b      	strb	r3, [r1, #0]
}
    ab98:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
    ab9a:	4803      	ldr	r0, [pc, #12]	; (aba8 <nrfx_gpiote_channel_get+0x28>)
    ab9c:	e7fc      	b.n	ab98 <nrfx_gpiote_channel_get+0x18>
    ab9e:	bf00      	nop
    aba0:	200004ac 	.word	0x200004ac
    aba4:	0bad0000 	.word	0x0bad0000
    aba8:	0bad0004 	.word	0x0bad0004

0000abac <nrfx_gpiote_init>:
{
    abac:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    abae:	4c0f      	ldr	r4, [pc, #60]	; (abec <nrfx_gpiote_init+0x40>)
    abb0:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
    abb4:	b9bd      	cbnz	r5, abe6 <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
    abb6:	2240      	movs	r2, #64	; 0x40
    abb8:	4629      	mov	r1, r5
    abba:	f104 0010 	add.w	r0, r4, #16
    abbe:	f002 ff2d 	bl	da1c <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
    abc2:	2006      	movs	r0, #6
    abc4:	f7f7 faee 	bl	21a4 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    abc8:	4b09      	ldr	r3, [pc, #36]	; (abf0 <nrfx_gpiote_init+0x44>)
    return err_code;
    abca:	480a      	ldr	r0, [pc, #40]	; (abf4 <nrfx_gpiote_init+0x48>)
    abcc:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
    abd0:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
    abd4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    abd8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    abdc:	2301      	movs	r3, #1
    abde:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
    abe2:	6563      	str	r3, [r4, #84]	; 0x54
}
    abe4:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
    abe6:	4804      	ldr	r0, [pc, #16]	; (abf8 <nrfx_gpiote_init+0x4c>)
    abe8:	e7fc      	b.n	abe4 <nrfx_gpiote_init+0x38>
    abea:	bf00      	nop
    abec:	200004ac 	.word	0x200004ac
    abf0:	40006000 	.word	0x40006000
    abf4:	0bad0000 	.word	0x0bad0000
    abf8:	0bad0005 	.word	0x0bad0005

0000abfc <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
    abfc:	4b03      	ldr	r3, [pc, #12]	; (ac0c <nrfx_gpiote_is_init+0x10>)
    abfe:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
    ac02:	3800      	subs	r0, #0
    ac04:	bf18      	it	ne
    ac06:	2001      	movne	r0, #1
    ac08:	4770      	bx	lr
    ac0a:	bf00      	nop
    ac0c:	200004ac 	.word	0x200004ac

0000ac10 <nrfx_gpiote_channel_free>:
{
    ac10:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
    ac12:	4801      	ldr	r0, [pc, #4]	; (ac18 <nrfx_gpiote_channel_free+0x8>)
    ac14:	f7ff bd34 	b.w	a680 <nrfx_flag32_free>
    ac18:	200004fc 	.word	0x200004fc

0000ac1c <nrfx_gpiote_channel_alloc>:
{
    ac1c:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
    ac1e:	4801      	ldr	r0, [pc, #4]	; (ac24 <nrfx_gpiote_channel_alloc+0x8>)
    ac20:	f7ff bd08 	b.w	a634 <nrfx_flag32_alloc>
    ac24:	200004fc 	.word	0x200004fc

0000ac28 <nrfx_gpiote_trigger_enable>:
{
    ac28:	b510      	push	{r4, lr}
    ac2a:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    ac2c:	f7ff fe12 	bl	a854 <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    ac30:	f102 0408 	add.w	r4, r2, #8
    ac34:	4b1c      	ldr	r3, [pc, #112]	; (aca8 <nrfx_gpiote_trigger_enable+0x80>)
    ac36:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    ac3a:	b1e0      	cbz	r0, ac76 <nrfx_gpiote_trigger_enable+0x4e>
    ac3c:	f013 0402 	ands.w	r4, r3, #2
    ac40:	d119      	bne.n	ac76 <nrfx_gpiote_trigger_enable+0x4e>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    ac42:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
    ac44:	009a      	lsls	r2, r3, #2
    return ((uint32_t)p_reg + event);
    ac46:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
    ac4a:	f500 40c2 	add.w	r0, r0, #24832	; 0x6100
    ac4e:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    ac52:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    ac56:	6004      	str	r4, [r0, #0]
    ac58:	6800      	ldr	r0, [r0, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    ac5a:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
    ac5e:	f040 0001 	orr.w	r0, r0, #1
    ac62:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
    ac66:	b129      	cbz	r1, ac74 <nrfx_gpiote_trigger_enable+0x4c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
    ac68:	2201      	movs	r2, #1
    ac6a:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
    ac6e:	4a0f      	ldr	r2, [pc, #60]	; (acac <nrfx_gpiote_trigger_enable+0x84>)
    ac70:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    ac74:	bd10      	pop	{r4, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    ac76:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
    ac7a:	2b04      	cmp	r3, #4
    ac7c:	d010      	beq.n	aca0 <nrfx_gpiote_trigger_enable+0x78>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
    ac7e:	2b05      	cmp	r3, #5
    ac80:	d010      	beq.n	aca4 <nrfx_gpiote_trigger_enable+0x7c>
    return p_reg->IN;
    ac82:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    ac86:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
    *p_pin = pin_number & 0x1F;
    ac8a:	f002 031f 	and.w	r3, r2, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    ac8e:	40d9      	lsrs	r1, r3
    ac90:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    ac94:	3102      	adds	r1, #2
}
    ac96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
    ac9a:	4610      	mov	r0, r2
    ac9c:	f004 bb70 	b.w	f380 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
    aca0:	2103      	movs	r1, #3
    aca2:	e7f8      	b.n	ac96 <nrfx_gpiote_trigger_enable+0x6e>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
    aca4:	2102      	movs	r1, #2
    aca6:	e7f6      	b.n	ac96 <nrfx_gpiote_trigger_enable+0x6e>
    aca8:	200004ac 	.word	0x200004ac
    acac:	40006000 	.word	0x40006000

0000acb0 <nrfx_gpiote_trigger_disable>:
{
    acb0:	b508      	push	{r3, lr}
    acb2:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    acb4:	f7ff fdce 	bl	a854 <pin_in_use_by_te>
    acb8:	b1c0      	cbz	r0, acec <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    acba:	f102 0108 	add.w	r1, r2, #8
    acbe:	4b0e      	ldr	r3, [pc, #56]	; (acf8 <nrfx_gpiote_trigger_disable+0x48>)
    acc0:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    acc4:	0799      	lsls	r1, r3, #30
    acc6:	d411      	bmi.n	acec <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    acc8:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
    acca:	2201      	movs	r2, #1
    accc:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
    acce:	009b      	lsls	r3, r3, #2
    acd0:	490a      	ldr	r1, [pc, #40]	; (acfc <nrfx_gpiote_trigger_disable+0x4c>)
    acd2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    acd6:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    acda:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    acde:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    ace2:	f022 0203 	bic.w	r2, r2, #3
    ace6:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
    acea:	bd08      	pop	{r3, pc}
    acec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    acf0:	2100      	movs	r1, #0
    acf2:	4610      	mov	r0, r2
    acf4:	f004 bb44 	b.w	f380 <nrf_gpio_cfg_sense_set>
    acf8:	200004ac 	.word	0x200004ac
    acfc:	40006000 	.word	0x40006000

0000ad00 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    ad00:	4b0d      	ldr	r3, [pc, #52]	; (ad38 <nrfx_gpiote_pin_uninit+0x38>)
    ad02:	f100 0208 	add.w	r2, r0, #8
{
    ad06:	b510      	push	{r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    ad08:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (!pin_in_use(pin))
    ad0c:	07db      	lsls	r3, r3, #31
{
    ad0e:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
    ad10:	d50f      	bpl.n	ad32 <nrfx_gpiote_pin_uninit+0x32>
    nrfx_gpiote_trigger_disable(pin);
    ad12:	f7ff ffcd 	bl	acb0 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
    ad16:	4620      	mov	r0, r4
    *p_pin = pin_number & 0x1F;
    ad18:	f004 041f 	and.w	r4, r4, #31
    ad1c:	f7ff fdec 	bl	a8f8 <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
    ad20:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
    ad24:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    ad28:	2202      	movs	r2, #2
    ad2a:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    ad2e:	4803      	ldr	r0, [pc, #12]	; (ad3c <nrfx_gpiote_pin_uninit+0x3c>)
}
    ad30:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
    ad32:	4803      	ldr	r0, [pc, #12]	; (ad40 <nrfx_gpiote_pin_uninit+0x40>)
    ad34:	e7fc      	b.n	ad30 <nrfx_gpiote_pin_uninit+0x30>
    ad36:	bf00      	nop
    ad38:	200004ac 	.word	0x200004ac
    ad3c:	0bad0000 	.word	0x0bad0000
    ad40:	0bad0004 	.word	0x0bad0004

0000ad44 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
    ad44:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ad48:	4b4e      	ldr	r3, [pc, #312]	; (ae84 <nrfx_gpiote_irq_handler+0x140>)
    return p_reg->INTENSET & mask;
    ad4a:	484f      	ldr	r0, [pc, #316]	; (ae88 <nrfx_gpiote_irq_handler+0x144>)
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    ad4c:	494f      	ldr	r1, [pc, #316]	; (ae8c <nrfx_gpiote_irq_handler+0x148>)
    uint32_t status = 0;
    ad4e:	2500      	movs	r5, #0
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    ad50:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    ad52:	462c      	mov	r4, r5
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ad54:	681e      	ldr	r6, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
    ad56:	b136      	cbz	r6, ad66 <nrfx_gpiote_irq_handler+0x22>
    return p_reg->INTENSET & mask;
    ad58:	f8d0 6304 	ldr.w	r6, [r0, #772]	; 0x304
    ad5c:	4216      	tst	r6, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    ad5e:	bf1e      	ittt	ne
    ad60:	601c      	strne	r4, [r3, #0]
    ad62:	681e      	ldrne	r6, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
    ad64:	4315      	orrne	r5, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    ad66:	3304      	adds	r3, #4
    ad68:	428b      	cmp	r3, r1
        }
        mask <<= 1;
    ad6a:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    ad6e:	d1f1      	bne.n	ad54 <nrfx_gpiote_irq_handler+0x10>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ad70:	4b45      	ldr	r3, [pc, #276]	; (ae88 <nrfx_gpiote_irq_handler+0x144>)
    ad72:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
    ad76:	b1bb      	cbz	r3, ada8 <nrfx_gpiote_irq_handler+0x64>
        *p_masks = gpio_regs[i]->LATCH;
    ad78:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
    ad7c:	f8d6 3520 	ldr.w	r3, [r6, #1312]	; 0x520
    ad80:	9301      	str	r3, [sp, #4]
        gpio_regs[i]->LATCH = *p_masks;
    ad82:	f8c6 3520 	str.w	r3, [r6, #1312]	; 0x520
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
    ad86:	af01      	add	r7, sp, #4
    ad88:	f04f 0801 	mov.w	r8, #1
            while (latch[i])
    ad8c:	9c01      	ldr	r4, [sp, #4]
    ad8e:	b96c      	cbnz	r4, adac <nrfx_gpiote_irq_handler+0x68>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    ad90:	4b3d      	ldr	r3, [pc, #244]	; (ae88 <nrfx_gpiote_irq_handler+0x144>)
    ad92:	f8c3 417c 	str.w	r4, [r3, #380]	; 0x17c
    ad96:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
    ad9a:	f8d6 3520 	ldr.w	r3, [r6, #1312]	; 0x520
    ad9e:	9301      	str	r3, [sp, #4]
        gpio_regs[i]->LATCH = *p_masks;
    ada0:	f8c6 3520 	str.w	r3, [r6, #1312]	; 0x520
        if (latch[port_idx])
    ada4:	2b00      	cmp	r3, #0
    ada6:	d1ee      	bne.n	ad86 <nrfx_gpiote_irq_handler+0x42>
        mask &= ~NRFX_BIT(ch);
    ada8:	2401      	movs	r4, #1
    adaa:	e066      	b.n	ae7a <nrfx_gpiote_irq_handler+0x136>
                uint32_t pin = NRF_CTZ(latch[i]);
    adac:	fa94 f4a4 	rbit	r4, r4
    adb0:	fab4 f484 	clz	r4, r4
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    adb4:	4a36      	ldr	r2, [pc, #216]	; (ae90 <nrfx_gpiote_irq_handler+0x14c>)
    adb6:	f104 0308 	add.w	r3, r4, #8
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    adba:	08e0      	lsrs	r0, r4, #3
    adbc:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    bit = BITMASK_RELBIT_GET(bit);
    adc0:	f004 0307 	and.w	r3, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
    adc4:	fa08 f203 	lsl.w	r2, r8, r3
    adc8:	5c3b      	ldrb	r3, [r7, r0]
    adca:	ea23 0302 	bic.w	r3, r3, r2
    adce:	543b      	strb	r3, [r7, r0]
    add0:	00a3      	lsls	r3, r4, #2
    add2:	f103 49a0 	add.w	r9, r3, #1342177280	; 0x50000000
    add6:	f3c1 0a82 	ubfx	sl, r1, #2, #3
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    adda:	f8d9 2700 	ldr.w	r2, [r9, #1792]	; 0x700
    if (is_level(trigger))
    adde:	06cb      	lsls	r3, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    ade0:	46d3      	mov	fp, sl
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
    ade2:	f3c2 4201 	ubfx	r2, r2, #16, #2
    if (is_level(trigger))
    ade6:	d518      	bpl.n	ae1a <nrfx_gpiote_irq_handler+0xd6>
        call_handler(pin, trigger);
    ade8:	4659      	mov	r1, fp
    adea:	4620      	mov	r0, r4
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    adec:	fa5f fa82 	uxtb.w	sl, r2
    adf0:	f7ff fd3a 	bl	a868 <call_handler>
    adf4:	f8d9 3700 	ldr.w	r3, [r9, #1792]	; 0x700
        if (nrf_gpio_pin_sense_get(pin) == sense)
    adf8:	f3c3 4301 	ubfx	r3, r3, #16, #2
    adfc:	459a      	cmp	sl, r3
    adfe:	d107      	bne.n	ae10 <nrfx_gpiote_irq_handler+0xcc>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    ae00:	2100      	movs	r1, #0
    ae02:	4620      	mov	r0, r4
    ae04:	f004 fabc 	bl	f380 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
    ae08:	4651      	mov	r1, sl
    ae0a:	4620      	mov	r0, r4
    ae0c:	f004 fab8 	bl	f380 <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
    ae10:	fa08 f404 	lsl.w	r4, r8, r4
    ae14:	f8c6 4520 	str.w	r4, [r6, #1312]	; 0x520
}
    ae18:	e7b8      	b.n	ad8c <nrfx_gpiote_irq_handler+0x48>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    ae1a:	2a02      	cmp	r2, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
    ae1c:	bf0c      	ite	eq
    ae1e:	2103      	moveq	r1, #3
    ae20:	2102      	movne	r1, #2
    ae22:	4620      	mov	r0, r4
    ae24:	f004 faac 	bl	f380 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
    ae28:	f1ba 0f03 	cmp.w	sl, #3
    ae2c:	d004      	beq.n	ae38 <nrfx_gpiote_irq_handler+0xf4>
    ae2e:	2a02      	cmp	r2, #2
    ae30:	d107      	bne.n	ae42 <nrfx_gpiote_irq_handler+0xfe>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    ae32:	f1ba 0f01 	cmp.w	sl, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    ae36:	d1eb      	bne.n	ae10 <nrfx_gpiote_irq_handler+0xcc>
            call_handler(pin, trigger);
    ae38:	4659      	mov	r1, fp
    ae3a:	4620      	mov	r0, r4
    ae3c:	f7ff fd14 	bl	a868 <call_handler>
    ae40:	e7e6      	b.n	ae10 <nrfx_gpiote_irq_handler+0xcc>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    ae42:	2a03      	cmp	r2, #3
    ae44:	d1e4      	bne.n	ae10 <nrfx_gpiote_irq_handler+0xcc>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    ae46:	f1ba 0f02 	cmp.w	sl, #2
    ae4a:	e7f4      	b.n	ae36 <nrfx_gpiote_irq_handler+0xf2>
        uint32_t ch = NRF_CTZ(mask);
    ae4c:	fa95 f3a5 	rbit	r3, r5
    ae50:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
    ae54:	fa04 f203 	lsl.w	r2, r4, r3
    ae58:	009b      	lsls	r3, r3, #2
    ae5a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    ae5e:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    ae62:	ea25 0502 	bic.w	r5, r5, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    ae66:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
    ae6a:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    ae6e:	f3c0 2004 	ubfx	r0, r0, #8, #5
    ae72:	f3c1 4101 	ubfx	r1, r1, #16, #2
    ae76:	f7ff fcf7 	bl	a868 <call_handler>
    while (mask)
    ae7a:	2d00      	cmp	r5, #0
    ae7c:	d1e6      	bne.n	ae4c <nrfx_gpiote_irq_handler+0x108>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
    ae7e:	b003      	add	sp, #12
    ae80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ae84:	40006100 	.word	0x40006100
    ae88:	40006000 	.word	0x40006000
    ae8c:	40006120 	.word	0x40006120
    ae90:	200004ac 	.word	0x200004ac

0000ae94 <nrfx_ppi_channel_alloc>:
    nrfx_flag32_init(&m_groups_allocated, NRFX_PPI_ALL_APP_GROUPS_MASK);
}


nrfx_err_t nrfx_ppi_channel_alloc(nrf_ppi_channel_t * p_channel)
{
    ae94:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_channels_allocated, (uint8_t *)p_channel);
    ae96:	4801      	ldr	r0, [pc, #4]	; (ae9c <nrfx_ppi_channel_alloc+0x8>)
    ae98:	f7ff bbcc 	b.w	a634 <nrfx_flag32_alloc>
    ae9c:	20000508 	.word	0x20000508

0000aea0 <twim_irq_handler>:
{
    return nrf_twim_event_address_get(p_instance->p_twim, NRF_TWIM_EVENT_STOPPED);
}

static void twim_irq_handler(NRF_TWIM_Type * p_twim, twim_control_block_t * p_cb)
{
    aea0:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    aea2:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
    aea6:	b087      	sub	sp, #28
    aea8:	4604      	mov	r4, r0
    aeaa:	460d      	mov	r5, r1
    }
#endif

    NRFX_ASSERT(p_cb->handler);

    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
    aeac:	b1f3      	cbz	r3, aeec <twim_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    aeae:	2300      	movs	r3, #0
    aeb0:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
    aeb4:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    aeb8:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
    {
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_ERROR);
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_ERROR));
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
    aebc:	b9b3      	cbnz	r3, aeec <twim_irq_handler+0x4c>
        {
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
    aebe:	688b      	ldr	r3, [r1, #8]
    p_reg->INTENCLR = mask;
    aec0:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    aec4:	2302      	movs	r3, #2
    aec6:	608b      	str	r3, [r1, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
    aec8:	688b      	ldr	r3, [r1, #8]
    p_reg->INTENSET = mask;
    aeca:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    aece:	f8d0 3160 	ldr.w	r3, [r0, #352]	; 0x160

            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
    aed2:	b11b      	cbz	r3, aedc <twim_irq_handler+0x3c>
    p_reg->SHORTS = mask;
}

NRF_STATIC_INLINE uint32_t nrf_twim_shorts_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->SHORTS;
    aed4:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    aed8:	059f      	lsls	r7, r3, #22
    aeda:	d402      	bmi.n	aee2 <twim_irq_handler+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    aedc:	2301      	movs	r3, #1
    aede:	6223      	str	r3, [r4, #32]
    aee0:	6163      	str	r3, [r4, #20]
            {
                nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_RESUME);
                nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_STOP);
            }

            p_cb->error = true;
    aee2:	2301      	movs	r3, #1
    aee4:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e

    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
    {
        p_cb->handler(&event, p_cb->p_context);
    }
}
    aee8:	b007      	add	sp, #28
    aeea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    aeec:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
    aef0:	2b00      	cmp	r3, #0
    aef2:	d044      	beq.n	af7e <twim_irq_handler+0xde>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    aef4:	2300      	movs	r3, #0
    aef6:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    aefa:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
    aefe:	6a2b      	ldr	r3, [r5, #32]
    af00:	065e      	lsls	r6, r3, #25
    af02:	d40a      	bmi.n	af1a <twim_irq_handler+0x7a>
    af04:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
    af08:	b93b      	cbnz	r3, af1a <twim_irq_handler+0x7a>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
    af0a:	4629      	mov	r1, r5
    af0c:	4620      	mov	r0, r4
    af0e:	f004 fa45 	bl	f39c <xfer_completeness_check>
    af12:	f080 0001 	eor.w	r0, r0, #1
    af16:	f885 002e 	strb.w	r0, [r5, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
    af1a:	6a2b      	ldr	r3, [r5, #32]
    af1c:	f013 0c04 	ands.w	ip, r3, #4
    af20:	d13e      	bne.n	afa0 <twim_irq_handler+0x100>
            event.xfer_desc = p_cb->xfer_desc;
    af22:	f105 070c 	add.w	r7, r5, #12
    af26:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    af28:	ae01      	add	r6, sp, #4
    af2a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
            if (!p_cb->repeated || p_cb->error)
    af2c:	f895 e030 	ldrb.w	lr, [r5, #48]	; 0x30
            event.xfer_desc = p_cb->xfer_desc;
    af30:	683b      	ldr	r3, [r7, #0]
    af32:	f8c4 c160 	str.w	ip, [r4, #352]	; 0x160
    af36:	6033      	str	r3, [r6, #0]
    af38:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
    af3c:	f8c4 c15c 	str.w	ip, [r4, #348]	; 0x15c
    af40:	f8d4 315c 	ldr.w	r3, [r4, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
    af44:	f1be 0f00 	cmp.w	lr, #0
    af48:	d002      	beq.n	af50 <twim_irq_handler+0xb0>
    af4a:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
    af4e:	b33b      	cbz	r3, afa0 <twim_irq_handler+0x100>
    p_reg->SHORTS = mask;
    af50:	2300      	movs	r3, #0
    af52:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
                p_cb->int_mask = 0;
    af56:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
    af58:	4b2e      	ldr	r3, [pc, #184]	; (b014 <twim_irq_handler+0x174>)
    af5a:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
    af5e:	f344 3307 	sbfx	r3, r4, #12, #8
  if ((int32_t)(IRQn) >= 0)
    af62:	2b00      	cmp	r3, #0
    af64:	ea4f 3214 	mov.w	r2, r4, lsr #12
    af68:	db1a      	blt.n	afa0 <twim_irq_handler+0x100>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    af6a:	f002 011f 	and.w	r1, r2, #31
    af6e:	095b      	lsrs	r3, r3, #5
    af70:	2201      	movs	r2, #1
    af72:	408a      	lsls	r2, r1
    af74:	3360      	adds	r3, #96	; 0x60
    af76:	4928      	ldr	r1, [pc, #160]	; (b018 <twim_irq_handler+0x178>)
    af78:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    af7c:	e010      	b.n	afa0 <twim_irq_handler+0x100>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    af7e:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    af82:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
    af86:	7b2b      	ldrb	r3, [r5, #12]
    af88:	bb23      	cbnz	r3, afd4 <twim_irq_handler+0x134>
            event.xfer_desc = p_cb->xfer_desc;
    af8a:	f105 070c 	add.w	r7, r5, #12
    af8e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    af90:	ae01      	add	r6, sp, #4
    af92:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    af94:	683b      	ldr	r3, [r7, #0]
    af96:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
    af98:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
    af9c:	2b00      	cmp	r3, #0
    af9e:	d0d8      	beq.n	af52 <twim_irq_handler+0xb2>
    uint32_t error_source = p_reg->ERRORSRC;
    afa0:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    afa4:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
    afa8:	0798      	lsls	r0, r3, #30
    afaa:	d525      	bpl.n	aff8 <twim_irq_handler+0x158>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
    afac:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
    afae:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
    afb2:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
    afb6:	b90b      	cbnz	r3, afbc <twim_irq_handler+0x11c>
        p_cb->busy = false;
    afb8:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
    afbc:	6a2b      	ldr	r3, [r5, #32]
    afbe:	075b      	lsls	r3, r3, #29
    afc0:	d503      	bpl.n	afca <twim_irq_handler+0x12a>
    afc2:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
    afc6:	2b00      	cmp	r3, #0
    afc8:	d08e      	beq.n	aee8 <twim_irq_handler+0x48>
        p_cb->handler(&event, p_cb->p_context);
    afca:	e9d5 3100 	ldrd	r3, r1, [r5]
    afce:	4668      	mov	r0, sp
    afd0:	4798      	blx	r3
    afd2:	e789      	b.n	aee8 <twim_irq_handler+0x48>
    p_reg->SHORTS = mask;
    afd4:	f44f 7300 	mov.w	r3, #512	; 0x200
    afd8:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
    afdc:	f240 2302 	movw	r3, #514	; 0x202
    afe0:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
    afe2:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
    afe6:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
    afea:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
    afec:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    aff0:	2301      	movs	r3, #1
    aff2:	60a3      	str	r3, [r4, #8]
    aff4:	6223      	str	r3, [r4, #32]
            return;
    aff6:	e777      	b.n	aee8 <twim_irq_handler+0x48>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
    aff8:	0759      	lsls	r1, r3, #29
    affa:	d501      	bpl.n	b000 <twim_irq_handler+0x160>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
    affc:	2302      	movs	r3, #2
    affe:	e7d6      	b.n	afae <twim_irq_handler+0x10e>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
    b000:	07da      	lsls	r2, r3, #31
    b002:	d501      	bpl.n	b008 <twim_irq_handler+0x168>
        event.type = NRFX_TWIM_EVT_OVERRUN;
    b004:	2303      	movs	r3, #3
    b006:	e7d2      	b.n	afae <twim_irq_handler+0x10e>
    else if (p_cb->error)
    b008:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
    b00c:	2b00      	cmp	r3, #0
    b00e:	d0ce      	beq.n	afae <twim_irq_handler+0x10e>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
    b010:	2304      	movs	r3, #4
    b012:	e7cc      	b.n	afae <twim_irq_handler+0x10e>
    b014:	019c0202 	.word	0x019c0202
    b018:	e000e100 	.word	0xe000e100

0000b01c <nrfx_twim_init>:
{
    b01c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    b01e:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    b020:	4d23      	ldr	r5, [pc, #140]	; (b0b0 <nrfx_twim_init+0x94>)
    b022:	f04f 0c34 	mov.w	ip, #52	; 0x34
    b026:	fb0c fc06 	mul.w	ip, ip, r6
    b02a:	eb05 040c 	add.w	r4, r5, ip
    b02e:	f894 702d 	ldrb.w	r7, [r4, #45]	; 0x2d
    b032:	2f00      	cmp	r7, #0
    b034:	d13a      	bne.n	b0ac <nrfx_twim_init+0x90>
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    b036:	6800      	ldr	r0, [r0, #0]
    p_cb->p_context       = p_context;
    b038:	6063      	str	r3, [r4, #4]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
    b03a:	7b4b      	ldrb	r3, [r1, #13]
    b03c:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
    b040:	7b8b      	ldrb	r3, [r1, #14]
    p_cb->int_mask        = 0;
    b042:	60a7      	str	r7, [r4, #8]
    p_cb->repeated        = false;
    b044:	f884 7030 	strb.w	r7, [r4, #48]	; 0x30
    p_cb->busy            = false;
    b048:	f884 702f 	strb.w	r7, [r4, #47]	; 0x2f
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
    b04c:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
    p_cb->handler         = event_handler;
    b050:	f845 200c 	str.w	r2, [r5, ip]
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
    b054:	7bcc      	ldrb	r4, [r1, #15]
    b056:	b1b3      	cbz	r3, b086 <nrfx_twim_init+0x6a>
    b058:	b92c      	cbnz	r4, b066 <nrfx_twim_init+0x4a>
        nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
    b05a:	e9d1 4300 	ldrd	r4, r3, [r1]
    p_reg->PSEL.SCL = scl_pin;
    b05e:	f8c0 4508 	str.w	r4, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
    b062:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
    nrf_twim_frequency_set(p_twim, (nrf_twim_frequency_t)p_config->frequency);
    b066:	688b      	ldr	r3, [r1, #8]
    p_reg->FREQUENCY = frequency;
    b068:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
    if (p_cb->handler)
    b06c:	b11a      	cbz	r2, b076 <nrfx_twim_init+0x5a>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
    b06e:	f340 3007 	sbfx	r0, r0, #12, #8
    b072:	f7f7 f897 	bl	21a4 <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    b076:	2334      	movs	r3, #52	; 0x34
    b078:	fb03 5506 	mla	r5, r3, r6, r5
    return err_code;
    b07c:	480d      	ldr	r0, [pc, #52]	; (b0b4 <nrfx_twim_init+0x98>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    b07e:	2301      	movs	r3, #1
    b080:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
    b084:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    *p_pin = pin_number & 0x1F;
    b086:	680b      	ldr	r3, [r1, #0]
    b088:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    b08c:	f04f 47a0 	mov.w	r7, #1342177280	; 0x50000000
    b090:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    b094:	f240 6c0c 	movw	ip, #1548	; 0x60c
    b098:	f847 c023 	str.w	ip, [r7, r3, lsl #2]
    *p_pin = pin_number & 0x1F;
    b09c:	684b      	ldr	r3, [r1, #4]
    b09e:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    b0a2:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    b0a6:	f847 c023 	str.w	ip, [r7, r3, lsl #2]
    if (!p_config->skip_psel_cfg)
    b0aa:	e7d5      	b.n	b058 <nrfx_twim_init+0x3c>
        return err_code;
    b0ac:	4802      	ldr	r0, [pc, #8]	; (b0b8 <nrfx_twim_init+0x9c>)
    b0ae:	e7e9      	b.n	b084 <nrfx_twim_init+0x68>
    b0b0:	20001ab4 	.word	0x20001ab4
    b0b4:	0bad0000 	.word	0x0bad0000
    b0b8:	0bad0005 	.word	0x0bad0005

0000b0bc <nrfx_twim_enable>:
    nrf_twim_enable(p_instance->p_twim);
    b0bc:	6803      	ldr	r3, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    b0be:	7902      	ldrb	r2, [r0, #4]
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
    b0c0:	2106      	movs	r1, #6
    b0c2:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
    b0c6:	4b04      	ldr	r3, [pc, #16]	; (b0d8 <nrfx_twim_enable+0x1c>)
    b0c8:	2134      	movs	r1, #52	; 0x34
    b0ca:	fb01 3302 	mla	r3, r1, r2, r3
    b0ce:	2202      	movs	r2, #2
    b0d0:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
}
    b0d4:	4770      	bx	lr
    b0d6:	bf00      	nop
    b0d8:	20001ab4 	.word	0x20001ab4

0000b0dc <nrfx_twim_disable>:
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    b0dc:	7901      	ldrb	r1, [r0, #4]
    p_cb->int_mask = 0;
    b0de:	4b0c      	ldr	r3, [pc, #48]	; (b110 <nrfx_twim_disable+0x34>)
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    b0e0:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
    b0e2:	2034      	movs	r0, #52	; 0x34
    b0e4:	fb00 3301 	mla	r3, r0, r1, r3
    b0e8:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
    b0ea:	480a      	ldr	r0, [pc, #40]	; (b114 <nrfx_twim_disable+0x38>)
    b0ec:	6099      	str	r1, [r3, #8]
    b0ee:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
    b0f2:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
    b0f6:	f420 50bc 	bic.w	r0, r0, #6016	; 0x1780
    b0fa:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
    b0fe:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    b102:	2201      	movs	r2, #1
    b104:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    p_cb->busy = false;
    b108:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
}
    b10c:	4770      	bx	lr
    b10e:	bf00      	nop
    b110:	20001ab4 	.word	0x20001ab4
    b114:	019c0202 	.word	0x019c0202

0000b118 <nrfx_twim_xfer>:
{
    b118:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    p_cb->error = false;
    b11c:	f8df c2d0 	ldr.w	ip, [pc, #720]	; b3f0 <nrfx_twim_xfer+0x2d8>
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    b120:	f890 e004 	ldrb.w	lr, [r0, #4]
    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
    b124:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
    b126:	2334      	movs	r3, #52	; 0x34
    b128:	fb03 c30e 	mla	r3, r3, lr, ip
{
    b12c:	4617      	mov	r7, r2
    p_cb->error = false;
    b12e:	2200      	movs	r2, #0
    b130:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
    b134:	684b      	ldr	r3, [r1, #4]
{
    b136:	460d      	mov	r5, r1
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
    b138:	b14b      	cbz	r3, b14e <nrfx_twim_xfer+0x36>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    b13a:	68cb      	ldr	r3, [r1, #12]
    b13c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
    b140:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    b144:	d003      	beq.n	b14e <nrfx_twim_xfer+0x36>
        return err_code;
    b146:	4eab      	ldr	r6, [pc, #684]	; (b3f4 <nrfx_twim_xfer+0x2dc>)
}
    b148:	4630      	mov	r0, r6
    b14a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (p_cb->busy)
    b14e:	2634      	movs	r6, #52	; 0x34
    p_reg->INTENCLR = mask;
    b150:	4ba9      	ldr	r3, [pc, #676]	; (b3f8 <nrfx_twim_xfer+0x2e0>)
    b152:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    b156:	fb06 c60e 	mla	r6, r6, lr, ip
    b15a:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
    b15e:	f003 0aff 	and.w	sl, r3, #255	; 0xff
    b162:	b123      	cbz	r3, b16e <nrfx_twim_xfer+0x56>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
    b164:	68b3      	ldr	r3, [r6, #8]
    p_reg->INTENSET = mask;
    b166:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
        return err_code;
    b16a:	4ea4      	ldr	r6, [pc, #656]	; (b3fc <nrfx_twim_xfer+0x2e4>)
    b16c:	e7ec      	b.n	b148 <nrfx_twim_xfer+0x30>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
    b16e:	f017 0f14 	tst.w	r7, #20
    b172:	bf0c      	ite	eq
    b174:	2301      	moveq	r3, #1
    b176:	2300      	movne	r3, #0
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
    b178:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
    b17c:	46a9      	mov	r9, r5
    b17e:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
    b182:	f106 080c 	add.w	r8, r6, #12
    b186:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
    b18a:	f8d9 3000 	ldr.w	r3, [r9]
    b18e:	f8c8 3000 	str.w	r3, [r8]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
    b192:	f3c7 1300 	ubfx	r3, r7, #4, #1
    b196:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
    p_cb->flags = flags;
    b19a:	6237      	str	r7, [r6, #32]
    p_reg->ADDRESS = address;
    b19c:	786b      	ldrb	r3, [r5, #1]
    b19e:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    b1a2:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
    b1a6:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    b1aa:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
    b1ae:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
    b1b2:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
    b1b6:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
    b1ba:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
    b1be:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
    b1c2:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
    b1c6:	bf18      	it	ne
    b1c8:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
    b1ca:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
    b1ce:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
    b1d2:	bf18      	it	ne
    b1d4:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
    b1d6:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
    b1da:	782a      	ldrb	r2, [r5, #0]
    b1dc:	2a03      	cmp	r2, #3
    b1de:	f200 80b5 	bhi.w	b34c <nrfx_twim_xfer+0x234>
    b1e2:	e8df f002 	tbb	[pc, r2]
    b1e6:	a084      	.short	0xa084
    b1e8:	0269      	.short	0x0269
    b1ea:	692b      	ldr	r3, [r5, #16]
    b1ec:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
    b1f0:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    b1f4:	d1a7      	bne.n	b146 <nrfx_twim_xfer+0x2e>
    p_reg->SHORTS = mask;
    b1f6:	f44f 7180 	mov.w	r1, #256	; 0x100
    b1fa:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    b1fe:	68e8      	ldr	r0, [r5, #12]
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    b200:	6869      	ldr	r1, [r5, #4]
    b202:	f8c4 0544 	str.w	r0, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    b206:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    b20a:	2100      	movs	r1, #0
    b20c:	f8c4 1150 	str.w	r1, [r4, #336]	; 0x150
    b210:	f8d4 0150 	ldr.w	r0, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    b214:	2001      	movs	r0, #1
    b216:	6220      	str	r0, [r4, #32]
    b218:	60a0      	str	r0, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    b21a:	f8d4 0150 	ldr.w	r0, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
    b21e:	2800      	cmp	r0, #0
    b220:	d0fb      	beq.n	b21a <nrfx_twim_xfer+0x102>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    b222:	f8c4 1150 	str.w	r1, [r4, #336]	; 0x150
    b226:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
    b22a:	68a9      	ldr	r1, [r5, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    b22c:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
    b230:	2334      	movs	r3, #52	; 0x34
    b232:	fb03 c30e 	mla	r3, r3, lr, ip
    p_reg->TXD.MAXCNT = length;
    b236:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
    b23a:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    b23e:	6099      	str	r1, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
    b240:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
    b242:	4e6f      	ldr	r6, [pc, #444]	; (b400 <nrfx_twim_xfer+0x2e8>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
    b244:	0739      	lsls	r1, r7, #28
    b246:	d406      	bmi.n	b256 <nrfx_twim_xfer+0x13e>
    b248:	2a03      	cmp	r2, #3
    b24a:	d004      	beq.n	b256 <nrfx_twim_xfer+0x13e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    b24c:	2201      	movs	r2, #1
    b24e:	50e2      	str	r2, [r4, r3]
        if (p_xfer_desc->primary_length == 0)
    b250:	686b      	ldr	r3, [r5, #4]
    b252:	b903      	cbnz	r3, b256 <nrfx_twim_xfer+0x13e>
    b254:	6162      	str	r2, [r4, #20]
    if (p_cb->handler)
    b256:	2334      	movs	r3, #52	; 0x34
    b258:	fb03 f30e 	mul.w	r3, r3, lr
    b25c:	eb0c 0103 	add.w	r1, ip, r3
    b260:	f85c 2003 	ldr.w	r2, [ip, r3]
    b264:	2a00      	cmp	r2, #0
    b266:	d174      	bne.n	b352 <nrfx_twim_xfer+0x23a>
                transmission_finished = true;
    b268:	2101      	movs	r1, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    b26a:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    b26e:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
    b272:	2800      	cmp	r0, #0
    b274:	f040 8088 	bne.w	b388 <nrfx_twim_xfer+0x270>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
    b278:	3b00      	subs	r3, #0
    b27a:	bf18      	it	ne
    b27c:	2301      	movne	r3, #1
    b27e:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
    b282:	2800      	cmp	r0, #0
    b284:	f000 8086 	beq.w	b394 <nrfx_twim_xfer+0x27c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    b288:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
    b28c:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    b290:	f8d4 5160 	ldr.w	r5, [r4, #352]	; 0x160
    return p_reg->SHORTS;
    b294:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
    b298:	b115      	cbz	r5, b2a0 <nrfx_twim_xfer+0x188>
    b29a:	f410 7f00 	tst.w	r0, #512	; 0x200
    b29e:	d104      	bne.n	b2aa <nrfx_twim_xfer+0x192>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    b2a0:	6221      	str	r1, [r4, #32]
    b2a2:	6161      	str	r1, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
    b2a4:	2d00      	cmp	r5, #0
    b2a6:	d0e0      	beq.n	b26a <nrfx_twim_xfer+0x152>
                    transmission_finished = false;
    b2a8:	2300      	movs	r3, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
    b2aa:	05c0      	lsls	r0, r0, #23
    b2ac:	d572      	bpl.n	b394 <nrfx_twim_xfer+0x27c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    b2ae:	f8c4 2148 	str.w	r2, [r4, #328]	; 0x148
    b2b2:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
        } while (!transmission_finished);
    b2b6:	e7d8      	b.n	b26a <nrfx_twim_xfer+0x152>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    b2b8:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    b2ba:	68e9      	ldr	r1, [r5, #12]
    b2bc:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    b2c0:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    b2c4:	692b      	ldr	r3, [r5, #16]
    b2c6:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
    b2ca:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    b2ce:	f47f af3a 	bne.w	b146 <nrfx_twim_xfer+0x2e>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
    b2d2:	68a9      	ldr	r1, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    b2d4:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
    b2d8:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
    b2dc:	f8c4 1538 	str.w	r1, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
    b2e0:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    b2e4:	2334      	movs	r3, #52	; 0x34
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    b2e6:	fb03 c30e 	mla	r3, r3, lr, ip
    b2ea:	2102      	movs	r1, #2
    b2ec:	e012      	b.n	b314 <nrfx_twim_xfer+0x1fc>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    b2ee:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    b2f0:	68e9      	ldr	r1, [r5, #12]
    b2f2:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
    b2f6:	f017 0f20 	tst.w	r7, #32
    p_reg->TXD.MAXCNT = length;
    b2fa:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    b2fe:	f04f 0334 	mov.w	r3, #52	; 0x34
    b302:	d00b      	beq.n	b31c <nrfx_twim_xfer+0x204>
    p_reg->SHORTS = mask;
    b304:	f44f 7180 	mov.w	r1, #256	; 0x100
    b308:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
    b30c:	fb03 c30e 	mla	r3, r3, lr, ip
    b310:	f44f 2180 	mov.w	r1, #262144	; 0x40000
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    b314:	6099      	str	r1, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    b316:	2301      	movs	r3, #1
    b318:	6223      	str	r3, [r4, #32]
    b31a:	e791      	b.n	b240 <nrfx_twim_xfer+0x128>
    p_reg->SHORTS = mask;
    b31c:	f44f 7100 	mov.w	r1, #512	; 0x200
    b320:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
    b324:	e7df      	b.n	b2e6 <nrfx_twim_xfer+0x1ce>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    b326:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    b328:	68e9      	ldr	r1, [r5, #12]
    b32a:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    b32e:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
    b332:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    b336:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    b33a:	2334      	movs	r3, #52	; 0x34
    b33c:	fb03 c30e 	mla	r3, r3, lr, ip
    b340:	2102      	movs	r1, #2
    b342:	6099      	str	r1, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    b344:	2301      	movs	r3, #1
    b346:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
    b348:	2300      	movs	r3, #0
    b34a:	e77a      	b.n	b242 <nrfx_twim_xfer+0x12a>
    switch (p_xfer_desc->type)
    b34c:	4e2d      	ldr	r6, [pc, #180]	; (b404 <nrfx_twim_xfer+0x2ec>)
    b34e:	2308      	movs	r3, #8
    b350:	e778      	b.n	b244 <nrfx_twim_xfer+0x12c>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
    b352:	077a      	lsls	r2, r7, #29
            p_cb->int_mask = 0;
    b354:	bf44      	itt	mi
    b356:	2300      	movmi	r3, #0
    b358:	608b      	strmi	r3, [r1, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
    b35a:	067b      	lsls	r3, r7, #25
    b35c:	d406      	bmi.n	b36c <nrfx_twim_xfer+0x254>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
    b35e:	2334      	movs	r3, #52	; 0x34
    b360:	fb03 c30e 	mla	r3, r3, lr, ip
    b364:	689a      	ldr	r2, [r3, #8]
    b366:	f042 0202 	orr.w	r2, r2, #2
    b36a:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
    b36c:	2334      	movs	r3, #52	; 0x34
    b36e:	fb03 cc0e 	mla	ip, r3, lr, ip
    b372:	f8dc 3008 	ldr.w	r3, [ip, #8]
    b376:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    b37a:	f8cc 3008 	str.w	r3, [ip, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
    b37e:	f8dc 3008 	ldr.w	r3, [ip, #8]
    p_reg->INTENSET = mask;
    b382:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
    b386:	e6df      	b.n	b148 <nrfx_twim_xfer+0x30>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    b388:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
    b38c:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
    b390:	2301      	movs	r3, #1
    b392:	e774      	b.n	b27e <nrfx_twim_xfer+0x166>
        } while (!transmission_finished);
    b394:	2b00      	cmp	r3, #0
    b396:	f43f af68 	beq.w	b26a <nrfx_twim_xfer+0x152>
        p_cb->busy = false;
    b39a:	2134      	movs	r1, #52	; 0x34
    uint32_t error_source = p_reg->ERRORSRC;
    b39c:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    b3a0:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
    b3a4:	fb01 c20e 	mla	r2, r1, lr, ip
    b3a8:	2000      	movs	r0, #0
    b3aa:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
    b3ae:	b18b      	cbz	r3, b3d4 <nrfx_twim_xfer+0x2bc>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    b3b0:	4a15      	ldr	r2, [pc, #84]	; (b408 <nrfx_twim_xfer+0x2f0>)
    b3b2:	4e16      	ldr	r6, [pc, #88]	; (b40c <nrfx_twim_xfer+0x2f4>)
    b3b4:	f013 0f01 	tst.w	r3, #1
    b3b8:	bf18      	it	ne
    b3ba:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    b3bc:	f013 0f02 	tst.w	r3, #2
    b3c0:	f102 0201 	add.w	r2, r2, #1
    b3c4:	bf18      	it	ne
    b3c6:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    b3c8:	f013 0f04 	tst.w	r3, #4
    b3cc:	4b10      	ldr	r3, [pc, #64]	; (b410 <nrfx_twim_xfer+0x2f8>)
    b3ce:	bf18      	it	ne
    b3d0:	461e      	movne	r6, r3
    b3d2:	e6b9      	b.n	b148 <nrfx_twim_xfer+0x30>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
    b3d4:	067b      	lsls	r3, r7, #25
    b3d6:	f53f aeb7 	bmi.w	b148 <nrfx_twim_xfer+0x30>
                !xfer_completeness_check(p_twim, p_cb))
    b3da:	fb0e c101 	mla	r1, lr, r1, ip
    b3de:	4620      	mov	r0, r4
    b3e0:	f003 ffdc 	bl	f39c <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
    b3e4:	4b09      	ldr	r3, [pc, #36]	; (b40c <nrfx_twim_xfer+0x2f4>)
    b3e6:	2800      	cmp	r0, #0
    b3e8:	bf08      	it	eq
    b3ea:	461e      	moveq	r6, r3
    b3ec:	e6ac      	b.n	b148 <nrfx_twim_xfer+0x30>
    b3ee:	bf00      	nop
    b3f0:	20001ab4 	.word	0x20001ab4
    b3f4:	0bad000a 	.word	0x0bad000a
    b3f8:	019c0202 	.word	0x019c0202
    b3fc:	0bad000b 	.word	0x0bad000b
    b400:	0bad0000 	.word	0x0bad0000
    b404:	0bad0004 	.word	0x0bad0004
    b408:	0bae0000 	.word	0x0bae0000
    b40c:	0bad0001 	.word	0x0bad0001
    b410:	0bae0002 	.word	0x0bae0002

0000b414 <nrfx_twim_0_irq_handler>:

#if NRFX_CHECK(NRFX_TWIM0_ENABLED)
void nrfx_twim_0_irq_handler(void)
{
    twim_irq_handler(NRF_TWIM0, &m_cb[NRFX_TWIM0_INST_IDX]);
    b414:	4901      	ldr	r1, [pc, #4]	; (b41c <nrfx_twim_0_irq_handler+0x8>)
    b416:	4802      	ldr	r0, [pc, #8]	; (b420 <nrfx_twim_0_irq_handler+0xc>)
    b418:	f7ff bd42 	b.w	aea0 <twim_irq_handler>
    b41c:	20001ab4 	.word	0x20001ab4
    b420:	40003000 	.word	0x40003000

0000b424 <nrfx_twim_1_irq_handler>:
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
    b424:	4902      	ldr	r1, [pc, #8]	; (b430 <nrfx_twim_1_irq_handler+0xc>)
    b426:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
    b42a:	f7ff bd39 	b.w	aea0 <twim_irq_handler>
    b42e:	bf00      	nop
    b430:	20001ae8 	.word	0x20001ae8

0000b434 <nrfx_twi_twim_bus_recover>:
                                                  NRF_GPIO_PIN_PULLUP,        \
                                                  NRF_GPIO_PIN_S0D1,          \
                                                  NRF_GPIO_PIN_NOSENSE)

nrfx_err_t nrfx_twi_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    b434:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    *p_pin = pin_number & 0x1F;
    b438:	f000 001f 	and.w	r0, r0, #31
    b43c:	f001 061f 	and.w	r6, r1, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    b440:	2401      	movs	r4, #1
    p_reg->OUTSET = set_mask;
    b442:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    b446:	fa04 f800 	lsl.w	r8, r4, r0
    reg->PIN_CNF[pin_number] = cnf;
    b44a:	f506 72e0 	add.w	r2, r6, #448	; 0x1c0
    b44e:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
    b452:	f240 630d 	movw	r3, #1549	; 0x60d
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    b456:	40b4      	lsls	r4, r6
    p_reg->OUTSET = set_mask;
    b458:	f8c5 8508 	str.w	r8, [r5, #1288]	; 0x508
    b45c:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = cnf;
    b460:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
    b464:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
    nrf_gpio_pin_set(scl_pin);
    nrf_gpio_pin_set(sda_pin);

    TWI_TWIM_PIN_CONFIGURE(scl_pin);
    TWI_TWIM_PIN_CONFIGURE(sda_pin);
    NRFX_DELAY_US(4);
    b468:	2004      	movs	r0, #4
    b46a:	f003 ff7d 	bl	f368 <nrfx_busy_wait>
    b46e:	2709      	movs	r7, #9
    return p_reg->IN;
    b470:	f8d5 3510 	ldr.w	r3, [r5, #1296]	; 0x510

    for (uint8_t i = 0; i < 9; i++)
    {
        if (nrf_gpio_pin_read(sda_pin))
    b474:	421c      	tst	r4, r3
    b476:	d10d      	bne.n	b494 <nrfx_twi_twim_bus_recover+0x60>
        }
        else
        {
            // Pulse CLOCK signal
            nrf_gpio_pin_clear(scl_pin);
            NRFX_DELAY_US(4);
    b478:	2004      	movs	r0, #4
    p_reg->OUTCLR = clr_mask;
    b47a:	f8c5 850c 	str.w	r8, [r5, #1292]	; 0x50c
    b47e:	f003 ff73 	bl	f368 <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
    b482:	3f01      	subs	r7, #1
    p_reg->OUTSET = set_mask;
    b484:	f8c5 8508 	str.w	r8, [r5, #1288]	; 0x508
            nrf_gpio_pin_set(scl_pin);
            NRFX_DELAY_US(4);
    b488:	2004      	movs	r0, #4
    b48a:	f003 ff6d 	bl	f368 <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
    b48e:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
    b492:	d1ed      	bne.n	b470 <nrfx_twi_twim_bus_recover+0x3c>
    p_reg->OUTCLR = clr_mask;
    b494:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
        }
    }

    // Generate a STOP condition on the bus
    nrf_gpio_pin_clear(sda_pin);
    NRFX_DELAY_US(4);
    b498:	2004      	movs	r0, #4
    b49a:	f8c5 450c 	str.w	r4, [r5, #1292]	; 0x50c
    b49e:	f003 ff63 	bl	f368 <nrfx_busy_wait>
    p_reg->OUTSET = set_mask;
    b4a2:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    nrf_gpio_pin_set(sda_pin);
    NRFX_DELAY_US(4);
    b4a6:	2004      	movs	r0, #4
    b4a8:	f003 ff5e 	bl	f368 <nrfx_busy_wait>
    return p_reg->IN;
    b4ac:	f8d5 1510 	ldr.w	r1, [r5, #1296]	; 0x510

    if (nrf_gpio_pin_read(sda_pin))
    b4b0:	4803      	ldr	r0, [pc, #12]	; (b4c0 <nrfx_twi_twim_bus_recover+0x8c>)
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    b4b2:	fa21 f606 	lsr.w	r6, r1, r6
    b4b6:	f006 0601 	and.w	r6, r6, #1
    b4ba:	1b80      	subs	r0, r0, r6
    }
    else
    {
        return NRFX_ERROR_INTERNAL;
    }
}
    b4bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b4c0:	0bad0001 	.word	0x0bad0001

0000b4c4 <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
    b4c4:	b510      	push	{r4, lr}
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    b4c6:	4c11      	ldr	r4, [pc, #68]	; (b50c <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    b4c8:	4a11      	ldr	r2, [pc, #68]	; (b510 <_DoInit+0x4c>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
    b4ca:	4912      	ldr	r1, [pc, #72]	; (b514 <_DoInit+0x50>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    b4cc:	2303      	movs	r3, #3
    b4ce:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    b4d0:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
    b4d2:	4b11      	ldr	r3, [pc, #68]	; (b518 <_DoInit+0x54>)
  p->aUp[0].sName         = "Terminal";
    b4d4:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    b4d6:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    b4d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
    b4dc:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
    b4de:	2300      	movs	r3, #0
    b4e0:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    b4e2:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    b4e4:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].sName         = "Terminal";
    b4e6:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    b4e8:	4a0c      	ldr	r2, [pc, #48]	; (b51c <_DoInit+0x58>)
    b4ea:	6662      	str	r2, [r4, #100]	; 0x64
  STRCPY((char*)&p->acID[7], "RTT");
    b4ec:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    b4ee:	2210      	movs	r2, #16
    b4f0:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    b4f2:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    b4f4:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    b4f6:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
    b4f8:	f002 fa4e 	bl	d998 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
    b4fc:	4908      	ldr	r1, [pc, #32]	; (b520 <_DoInit+0x5c>)
    b4fe:	4620      	mov	r0, r4
    b500:	f002 fa4a 	bl	d998 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
    b504:	2320      	movs	r3, #32
    b506:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
    b508:	bd10      	pop	{r4, pc}
    b50a:	bf00      	nop
    b50c:	20001b1c 	.word	0x20001b1c
    b510:	00012023 	.word	0x00012023
    b514:	0001202c 	.word	0x0001202c
    b518:	20001e62 	.word	0x20001e62
    b51c:	20001e52 	.word	0x20001e52
    b520:	00012030 	.word	0x00012030

0000b524 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    b524:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
    b528:	4f23      	ldr	r7, [pc, #140]	; (b5b8 <SEGGER_RTT_WriteSkipNoLock+0x94>)
    b52a:	f04f 0b18 	mov.w	fp, #24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    b52e:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
    b530:	fb0b 7200 	mla	r2, fp, r0, r7
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    b534:	4606      	mov	r6, r0
  RdOff = pRing->RdOff;
    b536:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
    b538:	6a55      	ldr	r5, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    b53a:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    b53c:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    b53e:	d834      	bhi.n	b5aa <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
    b540:	f8d2 a020 	ldr.w	sl, [r2, #32]
    b544:	ebaa 0905 	sub.w	r9, sl, r5
    b548:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
    b54c:	4294      	cmp	r4, r2
    b54e:	d811      	bhi.n	b574 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    b550:	f04f 0918 	mov.w	r9, #24
    b554:	fb06 9309 	mla	r3, r6, r9, r9
    b558:	443b      	add	r3, r7
      memcpy((void*)pDst, pData, NumBytes);
    b55a:	4622      	mov	r2, r4
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    b55c:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
    b55e:	4641      	mov	r1, r8
    b560:	4428      	add	r0, r5
    b562:	f002 fa50 	bl	da06 <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
    b566:	fb09 7606 	mla	r6, r9, r6, r7
    b56a:	442c      	add	r4, r5
      if (NumBytes) {
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
    b56c:	6274      	str	r4, [r6, #36]	; 0x24
      return 1;
    b56e:	2001      	movs	r0, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
    b570:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
    b574:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
    b576:	429c      	cmp	r4, r3
    b578:	d81b      	bhi.n	b5b2 <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    b57a:	fb00 bb0b 	mla	fp, r0, fp, fp
    b57e:	44bb      	add	fp, r7
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
    b580:	464a      	mov	r2, r9
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    b582:	f8db 0004 	ldr.w	r0, [fp, #4]
    b586:	442c      	add	r4, r5
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
    b588:	4428      	add	r0, r5
    b58a:	f002 fa3c 	bl	da06 <memcpy>
      if (NumBytes) {
    b58e:	ebb4 040a 	subs.w	r4, r4, sl
    b592:	d006      	beq.n	b5a2 <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
    b594:	f8db 0004 	ldr.w	r0, [fp, #4]
    b598:	4622      	mov	r2, r4
    b59a:	eb08 0109 	add.w	r1, r8, r9
    b59e:	f002 fa32 	bl	da06 <memcpy>
      pRing->WrOff = NumBytes;
    b5a2:	2018      	movs	r0, #24
    b5a4:	fb00 7606 	mla	r6, r0, r6, r7
    b5a8:	e7e0      	b.n	b56c <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
    b5aa:	3b01      	subs	r3, #1
    b5ac:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
    b5ae:	42a3      	cmp	r3, r4
    b5b0:	d2ce      	bcs.n	b550 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
    b5b2:	2000      	movs	r0, #0
    b5b4:	e7dc      	b.n	b570 <SEGGER_RTT_WriteSkipNoLock+0x4c>
    b5b6:	bf00      	nop
    b5b8:	20001b1c 	.word	0x20001b1c

0000b5bc <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    b5bc:	b570      	push	{r4, r5, r6, lr}
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
    b5be:	4b16      	ldr	r3, [pc, #88]	; (b618 <SEGGER_RTT_WriteNoLock+0x5c>)
    b5c0:	2418      	movs	r4, #24
    b5c2:	fb00 4504 	mla	r5, r0, r4, r4
    b5c6:	441d      	add	r5, r3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
    b5c8:	fb04 3300 	mla	r3, r4, r0, r3
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    b5cc:	4616      	mov	r6, r2
  switch (pRing->Flags) {
    b5ce:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    b5d0:	2c01      	cmp	r4, #1
    b5d2:	d00e      	beq.n	b5f2 <SEGGER_RTT_WriteNoLock+0x36>
    b5d4:	2c02      	cmp	r4, #2
    b5d6:	d018      	beq.n	b60a <SEGGER_RTT_WriteNoLock+0x4e>
    b5d8:	b9e4      	cbnz	r4, b614 <SEGGER_RTT_WriteNoLock+0x58>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
    b5da:	4628      	mov	r0, r5
    b5dc:	f003 ff0e 	bl	f3fc <_GetAvailWriteSpace>
    if (Avail < NumBytes) {
    b5e0:	4286      	cmp	r6, r0
    b5e2:	d804      	bhi.n	b5ee <SEGGER_RTT_WriteNoLock+0x32>
      Status = 0u;
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    b5e4:	4632      	mov	r2, r6
    b5e6:	4628      	mov	r0, r5
    b5e8:	f003 ff11 	bl	f40e <_WriteNoCheck>
    b5ec:	4634      	mov	r4, r6
  }
  //
  // Finish up.
  //
  return Status;
}
    b5ee:	4620      	mov	r0, r4
    b5f0:	bd70      	pop	{r4, r5, r6, pc}
    Avail = _GetAvailWriteSpace(pRing);
    b5f2:	4628      	mov	r0, r5
    b5f4:	f003 ff02 	bl	f3fc <_GetAvailWriteSpace>
    Status = Avail < NumBytes ? Avail : NumBytes;
    b5f8:	4286      	cmp	r6, r0
    b5fa:	4634      	mov	r4, r6
    b5fc:	bf28      	it	cs
    b5fe:	4604      	movcs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
    b600:	4622      	mov	r2, r4
    b602:	4628      	mov	r0, r5
    b604:	f003 ff03 	bl	f40e <_WriteNoCheck>
    break;
    b608:	e7f1      	b.n	b5ee <SEGGER_RTT_WriteNoLock+0x32>
    Status = _WriteBlocking(pRing, pData, NumBytes);
    b60a:	4628      	mov	r0, r5
}
    b60c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Status = _WriteBlocking(pRing, pData, NumBytes);
    b610:	f003 bf19 	b.w	f446 <_WriteBlocking>
  switch (pRing->Flags) {
    b614:	2400      	movs	r4, #0
  return Status;
    b616:	e7ea      	b.n	b5ee <SEGGER_RTT_WriteNoLock+0x32>
    b618:	20001b1c 	.word	0x20001b1c

0000b61c <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
    b61c:	4b03      	ldr	r3, [pc, #12]	; (b62c <SEGGER_RTT_HasDataUp+0x10>)
    b61e:	2218      	movs	r2, #24
    b620:	fb02 3300 	mla	r3, r2, r0, r3
    b624:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
    b626:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
    b628:	1a80      	subs	r0, r0, r2
    b62a:	4770      	bx	lr
    b62c:	20001b1c 	.word	0x20001b1c

0000b630 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    b630:	4b0e      	ldr	r3, [pc, #56]	; (b66c <z_sys_init_run_level+0x3c>)
{
    b632:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    b634:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    b638:	3001      	adds	r0, #1
    b63a:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
    b63e:	42a6      	cmp	r6, r4
    b640:	d800      	bhi.n	b644 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
    b642:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
    b644:	e9d4 3500 	ldrd	r3, r5, [r4]
    b648:	4628      	mov	r0, r5
    b64a:	4798      	blx	r3
		if (dev != NULL) {
    b64c:	b165      	cbz	r5, b668 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
    b64e:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
    b650:	b130      	cbz	r0, b660 <z_sys_init_run_level+0x30>
				if (rc < 0) {
    b652:	2800      	cmp	r0, #0
    b654:	bfb8      	it	lt
    b656:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
    b658:	28ff      	cmp	r0, #255	; 0xff
    b65a:	bfa8      	it	ge
    b65c:	20ff      	movge	r0, #255	; 0xff
    b65e:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
    b660:	785a      	ldrb	r2, [r3, #1]
    b662:	f042 0201 	orr.w	r2, r2, #1
    b666:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    b668:	3408      	adds	r4, #8
    b66a:	e7e8      	b.n	b63e <z_sys_init_run_level+0xe>
    b66c:	0001070c 	.word	0x0001070c

0000b670 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    b670:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    b672:	4605      	mov	r5, r0
    b674:	b910      	cbnz	r0, b67c <z_impl_device_get_binding+0xc>
		return NULL;
    b676:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
    b678:	4620      	mov	r0, r4
    b67a:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
    b67c:	7803      	ldrb	r3, [r0, #0]
    b67e:	2b00      	cmp	r3, #0
    b680:	d0f9      	beq.n	b676 <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
    b682:	4c0e      	ldr	r4, [pc, #56]	; (b6bc <z_impl_device_get_binding+0x4c>)
    b684:	4e0e      	ldr	r6, [pc, #56]	; (b6c0 <z_impl_device_get_binding+0x50>)
    b686:	42b4      	cmp	r4, r6
    b688:	d108      	bne.n	b69c <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
    b68a:	4c0c      	ldr	r4, [pc, #48]	; (b6bc <z_impl_device_get_binding+0x4c>)
    b68c:	42b4      	cmp	r4, r6
    b68e:	d0f2      	beq.n	b676 <z_impl_device_get_binding+0x6>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
    b690:	4620      	mov	r0, r4
    b692:	f003 ff09 	bl	f4a8 <z_device_is_ready>
    b696:	b950      	cbnz	r0, b6ae <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
    b698:	3418      	adds	r4, #24
    b69a:	e7f7      	b.n	b68c <z_impl_device_get_binding+0x1c>
		if (z_device_is_ready(dev) && (dev->name == name)) {
    b69c:	4620      	mov	r0, r4
    b69e:	f003 ff03 	bl	f4a8 <z_device_is_ready>
    b6a2:	b110      	cbz	r0, b6aa <z_impl_device_get_binding+0x3a>
    b6a4:	6823      	ldr	r3, [r4, #0]
    b6a6:	42ab      	cmp	r3, r5
    b6a8:	d0e6      	beq.n	b678 <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
    b6aa:	3418      	adds	r4, #24
    b6ac:	e7eb      	b.n	b686 <z_impl_device_get_binding+0x16>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
    b6ae:	6821      	ldr	r1, [r4, #0]
    b6b0:	4628      	mov	r0, r5
    b6b2:	f002 f98b 	bl	d9cc <strcmp>
    b6b6:	2800      	cmp	r0, #0
    b6b8:	d1ee      	bne.n	b698 <z_impl_device_get_binding+0x28>
    b6ba:	e7dd      	b.n	b678 <z_impl_device_get_binding+0x8>
    b6bc:	0000ff90 	.word	0x0000ff90
    b6c0:	000100c8 	.word	0x000100c8

0000b6c4 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    b6c4:	b510      	push	{r4, lr}
    b6c6:	4604      	mov	r4, r0
    b6c8:	b088      	sub	sp, #32
	z_impl_log_panic();
    b6ca:	f7f6 f895 	bl	17f8 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
    b6ce:	4b07      	ldr	r3, [pc, #28]	; (b6ec <k_sys_fatal_error_handler+0x28>)
    b6d0:	9306      	str	r3, [sp, #24]
    b6d2:	2302      	movs	r3, #2
    b6d4:	9301      	str	r3, [sp, #4]
    b6d6:	9305      	str	r3, [sp, #20]
    b6d8:	4805      	ldr	r0, [pc, #20]	; (b6f0 <k_sys_fatal_error_handler+0x2c>)
    b6da:	2300      	movs	r3, #0
    b6dc:	aa05      	add	r2, sp, #20
    b6de:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    b6e2:	f002 f927 	bl	d934 <z_impl_z_log_msg2_static_create>
	arch_system_halt(reason);
    b6e6:	4620      	mov	r0, r4
    b6e8:	f003 fef7 	bl	f4da <arch_system_halt>
    b6ec:	00012037 	.word	0x00012037
    b6f0:	000102d8 	.word	0x000102d8

0000b6f4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    b6f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b6f8:	4605      	mov	r5, r0
    b6fa:	b08e      	sub	sp, #56	; 0x38
    b6fc:	460e      	mov	r6, r1
	__asm__ volatile(
    b6fe:	f04f 0320 	mov.w	r3, #32
    b702:	f3ef 8811 	mrs	r8, BASEPRI
    b706:	f383 8812 	msr	BASEPRI_MAX, r3
    b70a:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
    b70e:	f000 ffd9 	bl	c6c4 <z_impl_z_current_get>
    b712:	2d04      	cmp	r5, #4
    b714:	bf96      	itet	ls
    b716:	4b22      	ldrls	r3, [pc, #136]	; (b7a0 <z_fatal_error+0xac>)
    b718:	4b22      	ldrhi	r3, [pc, #136]	; (b7a4 <z_fatal_error+0xb0>)
    b71a:	f853 3025 	ldrls.w	r3, [r3, r5, lsl #2]
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    b71e:	4922      	ldr	r1, [pc, #136]	; (b7a8 <z_fatal_error+0xb4>)
    b720:	9502      	str	r5, [sp, #8]
    b722:	2700      	movs	r7, #0
    b724:	e9cd 3703 	strd	r3, r7, [sp, #12]
    b728:	4b20      	ldr	r3, [pc, #128]	; (b7ac <z_fatal_error+0xb8>)
    b72a:	4604      	mov	r4, r0
    b72c:	e9cd 7300 	strd	r7, r3, [sp]
    b730:	2201      	movs	r2, #1
    b732:	463b      	mov	r3, r7
    b734:	4638      	mov	r0, r7
    b736:	f003 fec1 	bl	f4bc <z_log_msg2_runtime_create.constprop.0>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    b73a:	b17e      	cbz	r6, b75c <z_fatal_error+0x68>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    b73c:	69f3      	ldr	r3, [r6, #28]
    b73e:	f3c3 0308 	ubfx	r3, r3, #0, #9
    b742:	b15b      	cbz	r3, b75c <z_fatal_error+0x68>
		LOG_ERR("Fault during interrupt handling\n");
    b744:	4b1a      	ldr	r3, [pc, #104]	; (b7b0 <z_fatal_error+0xbc>)
    b746:	930c      	str	r3, [sp, #48]	; 0x30
    b748:	2302      	movs	r3, #2
    b74a:	9307      	str	r3, [sp, #28]
    b74c:	930b      	str	r3, [sp, #44]	; 0x2c
    b74e:	4816      	ldr	r0, [pc, #88]	; (b7a8 <z_fatal_error+0xb4>)
    b750:	463b      	mov	r3, r7
    b752:	aa0b      	add	r2, sp, #44	; 0x2c
    b754:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    b758:	f002 f8ec 	bl	d934 <z_impl_z_log_msg2_static_create>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    b75c:	b12c      	cbz	r4, b76a <z_fatal_error+0x76>
    b75e:	4620      	mov	r0, r4
    b760:	f003 ff33 	bl	f5ca <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
    b764:	b108      	cbz	r0, b76a <z_fatal_error+0x76>
    b766:	7803      	ldrb	r3, [r0, #0]
    b768:	b903      	cbnz	r3, b76c <z_fatal_error+0x78>
		thread_name = "unknown";
    b76a:	4812      	ldr	r0, [pc, #72]	; (b7b4 <z_fatal_error+0xc0>)
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    b76c:	4b12      	ldr	r3, [pc, #72]	; (b7b8 <z_fatal_error+0xc4>)
    b76e:	9301      	str	r3, [sp, #4]
    b770:	2300      	movs	r3, #0
    b772:	e9cd 4002 	strd	r4, r0, [sp, #8]
    b776:	9300      	str	r3, [sp, #0]
    b778:	4618      	mov	r0, r3
    b77a:	2201      	movs	r2, #1
    b77c:	490a      	ldr	r1, [pc, #40]	; (b7a8 <z_fatal_error+0xb4>)
    b77e:	f003 fe9d 	bl	f4bc <z_log_msg2_runtime_create.constprop.0>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    b782:	4631      	mov	r1, r6
    b784:	4628      	mov	r0, r5
    b786:	f7ff ff9d 	bl	b6c4 <k_sys_fatal_error_handler>
	__asm__ volatile(
    b78a:	f388 8811 	msr	BASEPRI, r8
    b78e:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    b792:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    b794:	b00e      	add	sp, #56	; 0x38
    b796:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    b79a:	f7f7 b949 	b.w	2a30 <z_impl_k_thread_abort>
    b79e:	bf00      	nop
    b7a0:	00010724 	.word	0x00010724
    b7a4:	00012046 	.word	0x00012046
    b7a8:	000102d8 	.word	0x000102d8
    b7ac:	00012054 	.word	0x00012054
    b7b0:	0001207c 	.word	0x0001207c
    b7b4:	00010e41 	.word	0x00010e41
    b7b8:	0001209d 	.word	0x0001209d

0000b7bc <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    b7bc:	b530      	push	{r4, r5, lr}
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    b7be:	2300      	movs	r3, #0
{
    b7c0:	b087      	sub	sp, #28
	z_setup_new_thread(thread, stack,
    b7c2:	2201      	movs	r2, #1
    b7c4:	e9cd 2304 	strd	r2, r3, [sp, #16]
    b7c8:	220f      	movs	r2, #15
    b7ca:	e9cd 3202 	strd	r3, r2, [sp, #8]
    b7ce:	9301      	str	r3, [sp, #4]
	struct k_thread *thread = &z_idle_threads[i];
    b7d0:	4c0c      	ldr	r4, [pc, #48]	; (b804 <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    b7d2:	4b0d      	ldr	r3, [pc, #52]	; (b808 <init_idle_thread+0x4c>)
	z_setup_new_thread(thread, stack,
    b7d4:	490d      	ldr	r1, [pc, #52]	; (b80c <init_idle_thread+0x50>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    b7d6:	2218      	movs	r2, #24
	struct k_thread *thread = &z_idle_threads[i];
    b7d8:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    b7dc:	fb02 3300 	mla	r3, r2, r0, r3
	z_setup_new_thread(thread, stack,
    b7e0:	f44f 75b0 	mov.w	r5, #352	; 0x160
    b7e4:	9300      	str	r3, [sp, #0]
    b7e6:	fb05 1100 	mla	r1, r5, r0, r1
    b7ea:	4b09      	ldr	r3, [pc, #36]	; (b810 <init_idle_thread+0x54>)
    b7ec:	f44f 72a0 	mov.w	r2, #320	; 0x140
    b7f0:	4620      	mov	r0, r4
    b7f2:	f000 f8dd 	bl	b9b0 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    b7f6:	7b63      	ldrb	r3, [r4, #13]
    b7f8:	f023 0304 	bic.w	r3, r3, #4
    b7fc:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    b7fe:	b007      	add	sp, #28
    b800:	bd30      	pop	{r4, r5, pc}
    b802:	bf00      	nop
    b804:	20000de0 	.word	0x20000de0
    b808:	20001bc4 	.word	0x20001bc4
    b80c:	20003260 	.word	0x20003260
    b810:	0000bb25 	.word	0x0000bb25

0000b814 <bg_thread_main>:
{
    b814:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    b816:	4b0a      	ldr	r3, [pc, #40]	; (b840 <bg_thread_main+0x2c>)
    b818:	2201      	movs	r2, #1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    b81a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    b81c:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    b81e:	f7ff ff07 	bl	b630 <z_sys_init_run_level>
	boot_banner();
    b822:	f001 fa59 	bl	ccd8 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    b826:	2003      	movs	r0, #3
    b828:	f7ff ff02 	bl	b630 <z_sys_init_run_level>
	z_init_static_threads();
    b82c:	f000 f91e 	bl	ba6c <z_init_static_threads>
	main();
    b830:	f7f4 ff50 	bl	6d4 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    b834:	4a03      	ldr	r2, [pc, #12]	; (b844 <bg_thread_main+0x30>)
    b836:	7b13      	ldrb	r3, [r2, #12]
    b838:	f023 0301 	bic.w	r3, r3, #1
    b83c:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    b83e:	bd08      	pop	{r3, pc}
    b840:	20002262 	.word	0x20002262
    b844:	20000e60 	.word	0x20000e60

0000b848 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    b848:	4802      	ldr	r0, [pc, #8]	; (b854 <z_bss_zero+0xc>)
    b84a:	4a03      	ldr	r2, [pc, #12]	; (b858 <z_bss_zero+0x10>)
    b84c:	2100      	movs	r1, #0
    b84e:	1a12      	subs	r2, r2, r0
    b850:	f002 b8e4 	b.w	da1c <memset>
    b854:	20000648 	.word	0x20000648
    b858:	20002264 	.word	0x20002264

0000b85c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    b85c:	b580      	push	{r7, lr}
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
    b85e:	f8df 80c8 	ldr.w	r8, [pc, #200]	; b928 <z_cstart+0xcc>
    b862:	b0a6      	sub	sp, #152	; 0x98
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    b864:	f388 8808 	msr	MSP, r8
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    b868:	4d30      	ldr	r5, [pc, #192]	; (b92c <z_cstart+0xd0>)
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
    b86a:	4e31      	ldr	r6, [pc, #196]	; (b930 <z_cstart+0xd4>)
    b86c:	696b      	ldr	r3, [r5, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    b86e:	f8df 90c4 	ldr.w	r9, [pc, #196]	; b934 <z_cstart+0xd8>
    b872:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    b876:	2400      	movs	r4, #0
    b878:	616b      	str	r3, [r5, #20]
    b87a:	23e0      	movs	r3, #224	; 0xe0
    b87c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
    b880:	77ec      	strb	r4, [r5, #31]
    b882:	762c      	strb	r4, [r5, #24]
    b884:	766c      	strb	r4, [r5, #25]
    b886:	76ac      	strb	r4, [r5, #26]
    b888:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    b88c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    b88e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    b892:	626b      	str	r3, [r5, #36]	; 0x24
    b894:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    b898:	f7f7 f894 	bl	29c4 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    b89c:	f7f6 fbfe 	bl	209c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    b8a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    b8a4:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    b8a6:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
    b8a8:	f7f7 f984 	bl	2bb4 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    b8ac:	f7f7 f8d2 	bl	2a54 <z_arm_configure_static_mpu_regions>
	gcov_static_init();

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
    b8b0:	f7f5 feac 	bl	160c <log_core_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
    b8b4:	f240 1301 	movw	r3, #257	; 0x101
    b8b8:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
    b8bc:	ab06      	add	r3, sp, #24
    b8be:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
    b8c0:	e9cd 4420 	strd	r4, r4, [sp, #128]	; 0x80
	dummy_thread->resource_pool = NULL;
    b8c4:	9423      	str	r4, [sp, #140]	; 0x8c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    b8c6:	f003 fdee 	bl	f4a6 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    b8ca:	4620      	mov	r0, r4
    b8cc:	f7ff feb0 	bl	b630 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    b8d0:	2001      	movs	r0, #1
	_kernel.ready_q.cache = &z_main_thread;
    b8d2:	4d19      	ldr	r5, [pc, #100]	; (b938 <z_cstart+0xdc>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    b8d4:	f7ff feac 	bl	b630 <z_sys_init_run_level>
	z_sched_init();
    b8d8:	f000 fe46 	bl	c568 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    b8dc:	4b17      	ldr	r3, [pc, #92]	; (b93c <z_cstart+0xe0>)
    b8de:	9305      	str	r3, [sp, #20]
    b8e0:	2301      	movs	r3, #1
    b8e2:	4917      	ldr	r1, [pc, #92]	; (b940 <z_cstart+0xe4>)
    b8e4:	9400      	str	r4, [sp, #0]
    b8e6:	e9cd 4303 	strd	r4, r3, [sp, #12]
    b8ea:	f44f 6280 	mov.w	r2, #1024	; 0x400
    b8ee:	464b      	mov	r3, r9
    b8f0:	e9cd 4401 	strd	r4, r4, [sp, #4]
    b8f4:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
    b8f6:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    b8f8:	f000 f85a 	bl	b9b0 <z_setup_new_thread>
    b8fc:	7b6a      	ldrb	r2, [r5, #13]
    b8fe:	4607      	mov	r7, r0
    b900:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
    b904:	4628      	mov	r0, r5
    b906:	736a      	strb	r2, [r5, #13]
    b908:	f004 f84b 	bl	f9a2 <z_ready_thread>
		init_idle_thread(i);
    b90c:	4620      	mov	r0, r4
    b90e:	f7ff ff55 	bl	b7bc <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    b912:	4b0c      	ldr	r3, [pc, #48]	; (b944 <z_cstart+0xe8>)
    b914:	60f3      	str	r3, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    b916:	464a      	mov	r2, r9
    b918:	4639      	mov	r1, r7
    b91a:	4628      	mov	r0, r5
		_kernel.cpus[i].id = i;
    b91c:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
    b91e:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    b922:	f7f6 fd45 	bl	23b0 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    b926:	bf00      	nop
    b928:	20003be0 	.word	0x20003be0
    b92c:	e000ed00 	.word	0xe000ed00
    b930:	20001bc4 	.word	0x20001bc4
    b934:	0000b815 	.word	0x0000b815
    b938:	20000e60 	.word	0x20000e60
    b93c:	000120ff 	.word	0x000120ff
    b940:	20002e40 	.word	0x20002e40
    b944:	20000de0 	.word	0x20000de0

0000b948 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
    b948:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    b94a:	4c06      	ldr	r4, [pc, #24]	; (b964 <statics_init+0x1c>)
    b94c:	4d06      	ldr	r5, [pc, #24]	; (b968 <statics_init+0x20>)
    b94e:	42ac      	cmp	r4, r5
    b950:	d301      	bcc.n	b956 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
    b952:	2000      	movs	r0, #0
    b954:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    b956:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
    b95a:	4620      	mov	r0, r4
    b95c:	f003 fdc6 	bl	f4ec <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    b960:	3414      	adds	r4, #20
    b962:	e7f4      	b.n	b94e <statics_init+0x6>
    b964:	20000568 	.word	0x20000568
    b968:	20000568 	.word	0x20000568

0000b96c <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
    b96c:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    b96e:	4b0e      	ldr	r3, [pc, #56]	; (b9a8 <init_mem_slab_module+0x3c>)
    b970:	4c0e      	ldr	r4, [pc, #56]	; (b9ac <init_mem_slab_module+0x40>)
    b972:	42a3      	cmp	r3, r4
    b974:	d301      	bcc.n	b97a <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
    b976:	2000      	movs	r0, #0
	return rc;
}
    b978:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    b97a:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
    b97e:	ea41 0200 	orr.w	r2, r1, r0
    b982:	f012 0203 	ands.w	r2, r2, #3
    b986:	d10b      	bne.n	b9a0 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
    b988:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    b98a:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    b98c:	42aa      	cmp	r2, r5
    b98e:	d101      	bne.n	b994 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    b990:	331c      	adds	r3, #28
    b992:	e7ee      	b.n	b972 <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
    b994:	695e      	ldr	r6, [r3, #20]
    b996:	600e      	str	r6, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
    b998:	3201      	adds	r2, #1
		slab->free_list = p;
    b99a:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
    b99c:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
    b99e:	e7f5      	b.n	b98c <init_mem_slab_module+0x20>
	return rc;
    b9a0:	f06f 0015 	mvn.w	r0, #21
    b9a4:	e7e8      	b.n	b978 <init_mem_slab_module+0xc>
    b9a6:	bf00      	nop
    b9a8:	20000568 	.word	0x20000568
    b9ac:	20000568 	.word	0x20000568

0000b9b0 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    b9b0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    b9b4:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    b9b6:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    b9b8:	2604      	movs	r6, #4
    b9ba:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
    b9bc:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    b9be:	7386      	strb	r6, [r0, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    b9c0:	f100 0558 	add.w	r5, r0, #88	; 0x58
{
    b9c4:	460f      	mov	r7, r1
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    b9c6:	1dd6      	adds	r6, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
    b9c8:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    b9cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
    b9ce:	2500      	movs	r5, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    b9d0:	f026 0607 	bic.w	r6, r6, #7

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
    b9d4:	3720      	adds	r7, #32
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
    b9d6:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
    b9da:	e9c0 761a 	strd	r7, r6, [r0, #104]	; 0x68
	thread_base->pended_on = NULL;
    b9de:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
    b9e0:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
    b9e2:	6705      	str	r5, [r0, #112]	; 0x70
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    b9e4:	f106 0820 	add.w	r8, r6, #32
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    b9e8:	9202      	str	r2, [sp, #8]
    b9ea:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    b9ec:	9201      	str	r2, [sp, #4]
	stack_ptr = (char *)stack + stack_obj_size;
    b9ee:	4488      	add	r8, r1
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    b9f0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    b9f2:	9200      	str	r2, [sp, #0]
    b9f4:	4642      	mov	r2, r8
{
    b9f6:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    b9f8:	f7f6 fca8 	bl	234c <arch_new_thread>
	if (!_current) {
    b9fc:	4b04      	ldr	r3, [pc, #16]	; (ba10 <z_setup_new_thread+0x60>)
	new_thread->init_data = NULL;
    b9fe:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
    ba00:	689b      	ldr	r3, [r3, #8]
    ba02:	b103      	cbz	r3, ba06 <z_setup_new_thread+0x56>
	new_thread->resource_pool = _current->resource_pool;
    ba04:	6f5b      	ldr	r3, [r3, #116]	; 0x74
	return stack_ptr;
    ba06:	6763      	str	r3, [r4, #116]	; 0x74
}
    ba08:	4640      	mov	r0, r8
    ba0a:	b004      	add	sp, #16
    ba0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ba10:	20001bc4 	.word	0x20001bc4

0000ba14 <z_impl_k_thread_create>:
{
    ba14:	b5f0      	push	{r4, r5, r6, r7, lr}
    ba16:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    ba18:	2700      	movs	r7, #0
    ba1a:	9705      	str	r7, [sp, #20]
    ba1c:	9f10      	ldr	r7, [sp, #64]	; 0x40
    ba1e:	9704      	str	r7, [sp, #16]
    ba20:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    ba22:	9703      	str	r7, [sp, #12]
    ba24:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    ba26:	9702      	str	r7, [sp, #8]
{
    ba28:	e9dd 6512 	ldrd	r6, r5, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    ba2c:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    ba2e:	9701      	str	r7, [sp, #4]
    ba30:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    ba32:	9700      	str	r7, [sp, #0]
{
    ba34:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    ba36:	f7ff ffbb 	bl	b9b0 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    ba3a:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
    ba3e:	bf08      	it	eq
    ba40:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
    ba44:	d005      	beq.n	ba52 <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    ba46:	ea55 0306 	orrs.w	r3, r5, r6
    ba4a:	d105      	bne.n	ba58 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
    ba4c:	4620      	mov	r0, r4
    ba4e:	f000 fc85 	bl	c35c <z_sched_start>
}
    ba52:	4620      	mov	r0, r4
    ba54:	b007      	add	sp, #28
    ba56:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    ba58:	4903      	ldr	r1, [pc, #12]	; (ba68 <z_impl_k_thread_create+0x54>)
    ba5a:	4632      	mov	r2, r6
    ba5c:	462b      	mov	r3, r5
    ba5e:	f104 0018 	add.w	r0, r4, #24
    ba62:	f000 ff0f 	bl	c884 <z_add_timeout>
    ba66:	e7f4      	b.n	ba52 <z_impl_k_thread_create+0x3e>
    ba68:	0000f9c3 	.word	0x0000f9c3

0000ba6c <z_init_static_threads>:
{
    ba6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ba70:	4c29      	ldr	r4, [pc, #164]	; (bb18 <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
    ba72:	4d2a      	ldr	r5, [pc, #168]	; (bb1c <z_init_static_threads+0xb0>)
{
    ba74:	b087      	sub	sp, #28
    ba76:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
    ba78:	42ae      	cmp	r6, r5
    ba7a:	f104 0430 	add.w	r4, r4, #48	; 0x30
    ba7e:	d30f      	bcc.n	baa0 <z_init_static_threads+0x34>
	k_sched_lock();
    ba80:	f000 fb88 	bl	c194 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    ba84:	4c24      	ldr	r4, [pc, #144]	; (bb18 <z_init_static_threads+0xac>)
    ba86:	f8df 9098 	ldr.w	r9, [pc, #152]	; bb20 <z_init_static_threads+0xb4>
    ba8a:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    ba8e:	f240 37e7 	movw	r7, #999	; 0x3e7
    ba92:	42ac      	cmp	r4, r5
    ba94:	d320      	bcc.n	bad8 <z_init_static_threads+0x6c>
}
    ba96:	b007      	add	sp, #28
    ba98:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
    ba9c:	f000 bd48 	b.w	c530 <k_sched_unlock>
		z_setup_new_thread(
    baa0:	f854 3c04 	ldr.w	r3, [r4, #-4]
    baa4:	9305      	str	r3, [sp, #20]
    baa6:	f854 3c10 	ldr.w	r3, [r4, #-16]
    baaa:	9304      	str	r3, [sp, #16]
    baac:	f854 3c14 	ldr.w	r3, [r4, #-20]
    bab0:	9303      	str	r3, [sp, #12]
    bab2:	f854 3c18 	ldr.w	r3, [r4, #-24]
    bab6:	9302      	str	r3, [sp, #8]
    bab8:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    babc:	9301      	str	r3, [sp, #4]
    babe:	f854 3c20 	ldr.w	r3, [r4, #-32]
    bac2:	9300      	str	r3, [sp, #0]
    bac4:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    bac8:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    bacc:	f7ff ff70 	bl	b9b0 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    bad0:	f854 3c30 	ldr.w	r3, [r4, #-48]
    bad4:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    bad6:	e7ce      	b.n	ba76 <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    bad8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    bada:	1c5a      	adds	r2, r3, #1
    badc:	d00d      	beq.n	bafa <z_init_static_threads+0x8e>
					    K_MSEC(thread_data->init_delay));
    bade:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    bae2:	2100      	movs	r1, #0
    bae4:	4638      	mov	r0, r7
    bae6:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    baea:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
    baee:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    baf2:	d104      	bne.n	bafe <z_init_static_threads+0x92>
	z_sched_start(thread);
    baf4:	4640      	mov	r0, r8
    baf6:	f000 fc31 	bl	c35c <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    bafa:	3430      	adds	r4, #48	; 0x30
    bafc:	e7c9      	b.n	ba92 <z_init_static_threads+0x26>
    bafe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    bb02:	2300      	movs	r3, #0
    bb04:	f7f4 faec 	bl	e0 <__aeabi_uldivmod>
    bb08:	4602      	mov	r2, r0
    bb0a:	460b      	mov	r3, r1
    bb0c:	f108 0018 	add.w	r0, r8, #24
    bb10:	4649      	mov	r1, r9
    bb12:	f000 feb7 	bl	c884 <z_add_timeout>
    bb16:	e7f0      	b.n	bafa <z_init_static_threads+0x8e>
    bb18:	20000568 	.word	0x20000568
    bb1c:	20000568 	.word	0x20000568
    bb20:	0000f9c3 	.word	0x0000f9c3

0000bb24 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    bb24:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
    bb26:	4c0b      	ldr	r4, [pc, #44]	; (bb54 <idle+0x30>)
	return !z_sys_post_kernel;
    bb28:	4d0b      	ldr	r5, [pc, #44]	; (bb58 <idle+0x34>)
	__asm__ volatile(
    bb2a:	f04f 0220 	mov.w	r2, #32
    bb2e:	f3ef 8311 	mrs	r3, BASEPRI
    bb32:	f382 8812 	msr	BASEPRI_MAX, r2
    bb36:	f3bf 8f6f 	isb	sy
    bb3a:	f003 fffe 	bl	fb3a <z_get_next_timeout_expiry>
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
    bb3e:	782b      	ldrb	r3, [r5, #0]
		_kernel.idle = z_get_next_timeout_expiry();
    bb40:	61a0      	str	r0, [r4, #24]
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
    bb42:	b913      	cbnz	r3, bb4a <idle+0x26>
	arch_cpu_idle();
    bb44:	f7f6 fab0 	bl	20a8 <arch_cpu_idle>
}
    bb48:	e7ef      	b.n	bb2a <idle+0x6>
    bb4a:	f7f6 f9cf 	bl	1eec <pm_system_suspend>
    bb4e:	2800      	cmp	r0, #0
    bb50:	d1eb      	bne.n	bb2a <idle+0x6>
    bb52:	e7f7      	b.n	bb44 <idle+0x20>
    bb54:	20001bc4 	.word	0x20001bc4
    bb58:	20002262 	.word	0x20002262

0000bb5c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    bb5c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    bb60:	4604      	mov	r4, r0
    bb62:	4617      	mov	r7, r2
    bb64:	461e      	mov	r6, r3
    bb66:	f04f 0320 	mov.w	r3, #32
    bb6a:	f3ef 8811 	mrs	r8, BASEPRI
    bb6e:	f383 8812 	msr	BASEPRI_MAX, r3
    bb72:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    bb76:	68c3      	ldr	r3, [r0, #12]
    bb78:	4a32      	ldr	r2, [pc, #200]	; (bc44 <z_impl_k_mutex_lock+0xe8>)
    bb7a:	b16b      	cbz	r3, bb98 <z_impl_k_mutex_lock+0x3c>
    bb7c:	6880      	ldr	r0, [r0, #8]
    bb7e:	6891      	ldr	r1, [r2, #8]
    bb80:	4288      	cmp	r0, r1
    bb82:	d019      	beq.n	bbb8 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    bb84:	ea57 0306 	orrs.w	r3, r7, r6
    bb88:	d118      	bne.n	bbbc <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
    bb8a:	f388 8811 	msr	BASEPRI, r8
    bb8e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
    bb92:	f06f 000f 	mvn.w	r0, #15
    bb96:	e00c      	b.n	bbb2 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
    bb98:	6891      	ldr	r1, [r2, #8]
    bb9a:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    bb9e:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
    bba0:	3301      	adds	r3, #1
    bba2:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
    bba4:	6893      	ldr	r3, [r2, #8]
    bba6:	60a3      	str	r3, [r4, #8]
    bba8:	f388 8811 	msr	BASEPRI, r8
    bbac:	f3bf 8f6f 	isb	sy
		return 0;
    bbb0:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    bbb2:	b002      	add	sp, #8
    bbb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
    bbb8:	6921      	ldr	r1, [r4, #16]
    bbba:	e7f0      	b.n	bb9e <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    bbbc:	f991 100e 	ldrsb.w	r1, [r1, #14]
    bbc0:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
    bbc4:	4299      	cmp	r1, r3
    bbc6:	bfa8      	it	ge
    bbc8:	4619      	movge	r1, r3
    bbca:	f06f 027e 	mvn.w	r2, #126	; 0x7e
    bbce:	4291      	cmp	r1, r2
    bbd0:	bfb8      	it	lt
    bbd2:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    bbd4:	428b      	cmp	r3, r1
    bbd6:	dd2e      	ble.n	bc36 <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
    bbd8:	f003 fd02 	bl	f5e0 <adjust_owner_prio.isra.0>
    bbdc:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    bbde:	e9cd 7600 	strd	r7, r6, [sp]
    bbe2:	4819      	ldr	r0, [pc, #100]	; (bc48 <z_impl_k_mutex_lock+0xec>)
    bbe4:	4622      	mov	r2, r4
    bbe6:	4641      	mov	r1, r8
    bbe8:	f000 fc14 	bl	c414 <z_pend_curr>
	if (got_mutex == 0) {
    bbec:	2800      	cmp	r0, #0
    bbee:	d0e0      	beq.n	bbb2 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
    bbf0:	f04f 0320 	mov.w	r3, #32
    bbf4:	f3ef 8611 	mrs	r6, BASEPRI
    bbf8:	f383 8812 	msr	BASEPRI_MAX, r3
    bbfc:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    bc00:	6823      	ldr	r3, [r4, #0]
    bc02:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    bc04:	429c      	cmp	r4, r3
    bc06:	d00a      	beq.n	bc1e <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    bc08:	b14b      	cbz	r3, bc1e <z_impl_k_mutex_lock+0xc2>
    bc0a:	f993 300e 	ldrsb.w	r3, [r3, #14]
    bc0e:	4299      	cmp	r1, r3
    bc10:	bfa8      	it	ge
    bc12:	4619      	movge	r1, r3
    bc14:	f06f 037e 	mvn.w	r3, #126	; 0x7e
    bc18:	4299      	cmp	r1, r3
    bc1a:	bfb8      	it	lt
    bc1c:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    bc1e:	68a0      	ldr	r0, [r4, #8]
    bc20:	f003 fcde 	bl	f5e0 <adjust_owner_prio.isra.0>
    bc24:	b900      	cbnz	r0, bc28 <z_impl_k_mutex_lock+0xcc>
	if (resched) {
    bc26:	b145      	cbz	r5, bc3a <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
    bc28:	4807      	ldr	r0, [pc, #28]	; (bc48 <z_impl_k_mutex_lock+0xec>)
    bc2a:	4631      	mov	r1, r6
    bc2c:	f000 faa0 	bl	c170 <z_reschedule>
	return -EAGAIN;
    bc30:	f06f 000a 	mvn.w	r0, #10
    bc34:	e7bd      	b.n	bbb2 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
    bc36:	2500      	movs	r5, #0
    bc38:	e7d1      	b.n	bbde <z_impl_k_mutex_lock+0x82>
	__asm__ volatile(
    bc3a:	f386 8811 	msr	BASEPRI, r6
    bc3e:	f3bf 8f6f 	isb	sy
    bc42:	e7f5      	b.n	bc30 <z_impl_k_mutex_lock+0xd4>
    bc44:	20001bc4 	.word	0x20001bc4
    bc48:	20002263 	.word	0x20002263

0000bc4c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    bc4c:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    bc4e:	6883      	ldr	r3, [r0, #8]
{
    bc50:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
    bc52:	2b00      	cmp	r3, #0
    bc54:	d032      	beq.n	bcbc <z_impl_k_mutex_unlock+0x70>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    bc56:	4a1c      	ldr	r2, [pc, #112]	; (bcc8 <z_impl_k_mutex_unlock+0x7c>)
    bc58:	6892      	ldr	r2, [r2, #8]
    bc5a:	4293      	cmp	r3, r2
    bc5c:	d131      	bne.n	bcc2 <z_impl_k_mutex_unlock+0x76>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    bc5e:	7bda      	ldrb	r2, [r3, #15]
    bc60:	3a01      	subs	r2, #1
    bc62:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    bc64:	68c3      	ldr	r3, [r0, #12]
    bc66:	2b01      	cmp	r3, #1
    bc68:	d905      	bls.n	bc76 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
    bc6a:	3b01      	subs	r3, #1
    bc6c:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    bc6e:	f000 fc5f 	bl	c530 <k_sched_unlock>

	return 0;
    bc72:	2000      	movs	r0, #0
}
    bc74:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    bc76:	f04f 0320 	mov.w	r3, #32
    bc7a:	f3ef 8511 	mrs	r5, BASEPRI
    bc7e:	f383 8812 	msr	BASEPRI_MAX, r3
    bc82:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    bc86:	6901      	ldr	r1, [r0, #16]
    bc88:	6880      	ldr	r0, [r0, #8]
    bc8a:	f003 fca9 	bl	f5e0 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    bc8e:	4620      	mov	r0, r4
    bc90:	f003 fef8 	bl	fa84 <z_unpend_first_thread>
	mutex->owner = new_owner;
    bc94:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    bc96:	b158      	cbz	r0, bcb0 <z_impl_k_mutex_unlock+0x64>
		mutex->owner_orig_prio = new_owner->base.prio;
    bc98:	f990 200e 	ldrsb.w	r2, [r0, #14]
    bc9c:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    bc9e:	2200      	movs	r2, #0
    bca0:	67c2      	str	r2, [r0, #124]	; 0x7c
		z_ready_thread(new_owner);
    bca2:	f003 fe7e 	bl	f9a2 <z_ready_thread>
		z_reschedule(&lock, key);
    bca6:	4809      	ldr	r0, [pc, #36]	; (bccc <z_impl_k_mutex_unlock+0x80>)
    bca8:	4629      	mov	r1, r5
    bcaa:	f000 fa61 	bl	c170 <z_reschedule>
    bcae:	e7de      	b.n	bc6e <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
    bcb0:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    bcb2:	f385 8811 	msr	BASEPRI, r5
    bcb6:	f3bf 8f6f 	isb	sy
    bcba:	e7d8      	b.n	bc6e <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
    bcbc:	f06f 0015 	mvn.w	r0, #21
    bcc0:	e7d8      	b.n	bc74 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
    bcc2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    bcc6:	e7d5      	b.n	bc74 <z_impl_k_mutex_unlock+0x28>
    bcc8:	20001bc4 	.word	0x20001bc4
    bccc:	20002263 	.word	0x20002263

0000bcd0 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
    bcd0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    bcd2:	4611      	mov	r1, r2
	__asm__ volatile(
    bcd4:	f04f 0220 	mov.w	r2, #32
    bcd8:	f3ef 8511 	mrs	r5, BASEPRI
    bcdc:	f382 8812 	msr	BASEPRI_MAX, r2
    bce0:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
    bce4:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
    bce6:	b19c      	cbz	r4, bd10 <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    bce8:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    bcea:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    bcec:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    bcf0:	4294      	cmp	r4, r2
	list->head = node;
    bcf2:	6003      	str	r3, [r0, #0]
	list->tail = node;
    bcf4:	bf08      	it	eq
    bcf6:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
    bcf8:	2101      	movs	r1, #1
    bcfa:	4620      	mov	r0, r4
    bcfc:	f003 fcdc 	bl	f6b8 <z_queue_node_peek>
    bd00:	4604      	mov	r4, r0
	__asm__ volatile(
    bd02:	f385 8811 	msr	BASEPRI, r5
    bd06:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
    bd0a:	4620      	mov	r0, r4
    bd0c:	b003      	add	sp, #12
    bd0e:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    bd10:	ea51 0203 	orrs.w	r2, r1, r3
    bd14:	d0f5      	beq.n	bd02 <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    bd16:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    bd1a:	e9cd 1300 	strd	r1, r3, [sp]
    bd1e:	4610      	mov	r0, r2
    bd20:	4629      	mov	r1, r5
    bd22:	f000 fb77 	bl	c414 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
    bd26:	2800      	cmp	r0, #0
    bd28:	d1ef      	bne.n	bd0a <z_impl_k_queue_get+0x3a>
    bd2a:	4b02      	ldr	r3, [pc, #8]	; (bd34 <z_impl_k_queue_get+0x64>)
    bd2c:	689b      	ldr	r3, [r3, #8]
    bd2e:	695c      	ldr	r4, [r3, #20]
    bd30:	e7eb      	b.n	bd0a <z_impl_k_queue_get+0x3a>
    bd32:	bf00      	nop
    bd34:	20001bc4 	.word	0x20001bc4

0000bd38 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    bd38:	b538      	push	{r3, r4, r5, lr}
    bd3a:	4604      	mov	r4, r0
	__asm__ volatile(
    bd3c:	f04f 0320 	mov.w	r3, #32
    bd40:	f3ef 8511 	mrs	r5, BASEPRI
    bd44:	f383 8812 	msr	BASEPRI_MAX, r3
    bd48:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    bd4c:	f003 fe9a 	bl	fa84 <z_unpend_first_thread>

	if (thread != NULL) {
    bd50:	b148      	cbz	r0, bd66 <z_impl_k_sem_give+0x2e>
    bd52:	2200      	movs	r2, #0
    bd54:	67c2      	str	r2, [r0, #124]	; 0x7c
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    bd56:	f003 fe24 	bl	f9a2 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    bd5a:	4629      	mov	r1, r5
    bd5c:	4808      	ldr	r0, [pc, #32]	; (bd80 <z_impl_k_sem_give+0x48>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    bd5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
    bd62:	f000 ba05 	b.w	c170 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    bd66:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    bd6a:	429a      	cmp	r2, r3
    bd6c:	bf18      	it	ne
    bd6e:	3301      	addne	r3, #1
    bd70:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    bd72:	2102      	movs	r1, #2
    bd74:	f104 0010 	add.w	r0, r4, #16
    bd78:	f004 f896 	bl	fea8 <z_handle_obj_poll_events>
}
    bd7c:	e7ed      	b.n	bd5a <z_impl_k_sem_give+0x22>
    bd7e:	bf00      	nop
    bd80:	20002263 	.word	0x20002263

0000bd84 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    bd84:	b513      	push	{r0, r1, r4, lr}
    bd86:	f04f 0420 	mov.w	r4, #32
    bd8a:	f3ef 8111 	mrs	r1, BASEPRI
    bd8e:	f384 8812 	msr	BASEPRI_MAX, r4
    bd92:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    bd96:	6884      	ldr	r4, [r0, #8]
    bd98:	b144      	cbz	r4, bdac <z_impl_k_sem_take+0x28>
		sem->count--;
    bd9a:	3c01      	subs	r4, #1
    bd9c:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
    bd9e:	f381 8811 	msr	BASEPRI, r1
    bda2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    bda6:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    bda8:	b002      	add	sp, #8
    bdaa:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    bdac:	ea52 0403 	orrs.w	r4, r2, r3
    bdb0:	d106      	bne.n	bdc0 <z_impl_k_sem_take+0x3c>
    bdb2:	f381 8811 	msr	BASEPRI, r1
    bdb6:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    bdba:	f06f 000f 	mvn.w	r0, #15
    bdbe:	e7f3      	b.n	bda8 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    bdc0:	e9cd 2300 	strd	r2, r3, [sp]
    bdc4:	4602      	mov	r2, r0
    bdc6:	4802      	ldr	r0, [pc, #8]	; (bdd0 <z_impl_k_sem_take+0x4c>)
    bdc8:	f000 fb24 	bl	c414 <z_pend_curr>
	return ret;
    bdcc:	e7ec      	b.n	bda8 <z_impl_k_sem_take+0x24>
    bdce:	bf00      	nop
    bdd0:	20002263 	.word	0x20002263

0000bdd4 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
    bdd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return list->head;
    bdd8:	4e47      	ldr	r6, [pc, #284]	; (bef8 <work_queue_main+0x124>)
    bdda:	b085      	sub	sp, #20
    bddc:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
    bdde:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    bde2:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	__asm__ volatile(
    bde6:	f04f 0320 	mov.w	r3, #32
    bdea:	f3ef 8711 	mrs	r7, BASEPRI
    bdee:	f383 8812 	msr	BASEPRI_MAX, r3
    bdf2:	f3bf 8f6f 	isb	sy
    bdf6:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    bdfa:	b98d      	cbnz	r5, be20 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
    bdfc:	2102      	movs	r1, #2
    bdfe:	f104 0098 	add.w	r0, r4, #152	; 0x98
    be02:	f003 fcc6 	bl	f792 <flag_test_and_clear>
    be06:	2800      	cmp	r0, #0
    be08:	d135      	bne.n	be76 <work_queue_main+0xa2>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
    be0a:	2300      	movs	r3, #0
    be0c:	e9cd 8900 	strd	r8, r9, [sp]
    be10:	9302      	str	r3, [sp, #8]
    be12:	f104 0288 	add.w	r2, r4, #136	; 0x88
    be16:	4639      	mov	r1, r7
    be18:	4838      	ldr	r0, [pc, #224]	; (befc <work_queue_main+0x128>)
    be1a:	f000 fcbb 	bl	c794 <z_sched_wait>
			continue;
    be1e:	e7e2      	b.n	bde6 <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    be20:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
    be24:	682b      	ldr	r3, [r5, #0]
	list->head = node;
    be26:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    be2a:	4295      	cmp	r5, r2
    be2c:	d101      	bne.n	be32 <work_queue_main+0x5e>
	list->tail = node;
    be2e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
    be32:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    be36:	f043 0302 	orr.w	r3, r3, #2
    be3a:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
    be3e:	68eb      	ldr	r3, [r5, #12]
    be40:	f023 0304 	bic.w	r3, r3, #4
    be44:	f043 0301 	orr.w	r3, r3, #1
    be48:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
    be4a:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
    be4c:	f387 8811 	msr	BASEPRI, r7
    be50:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
    be54:	4628      	mov	r0, r5
    be56:	4798      	blx	r3
	__asm__ volatile(
    be58:	f04f 0320 	mov.w	r3, #32
    be5c:	f3ef 8b11 	mrs	fp, BASEPRI
    be60:	f383 8812 	msr	BASEPRI_MAX, r3
    be64:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
    be68:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    be6a:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
    be6c:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    be70:	d40b      	bmi.n	be8a <work_queue_main+0xb6>
	*flagp &= ~BIT(bit);
    be72:	60ea      	str	r2, [r5, #12]
    be74:	e00e      	b.n	be94 <work_queue_main+0xc0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    be76:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    be7a:	2200      	movs	r2, #0
    be7c:	2101      	movs	r1, #1
    be7e:	4628      	mov	r0, r5
    be80:	f003 fe28 	bl	fad4 <z_sched_wake>
    be84:	2800      	cmp	r0, #0
    be86:	d1f8      	bne.n	be7a <work_queue_main+0xa6>
    be88:	e7bf      	b.n	be0a <work_queue_main+0x36>
	return list->head;
    be8a:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
    be8c:	f023 0303 	bic.w	r3, r3, #3
    be90:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    be92:	b970      	cbnz	r0, beb2 <work_queue_main+0xde>
	*flagp &= ~BIT(bit);
    be94:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    be98:	f023 0302 	bic.w	r3, r3, #2
    be9c:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
    bea0:	f38b 8811 	msr	BASEPRI, fp
    bea4:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
    bea8:	05d8      	lsls	r0, r3, #23
    beaa:	d49c      	bmi.n	bde6 <work_queue_main+0x12>
	z_impl_k_yield();
    beac:	f000 fb68 	bl	c580 <z_impl_k_yield>
}
    beb0:	e799      	b.n	bde6 <work_queue_main+0x12>
	return node->next;
    beb2:	2700      	movs	r7, #0
    beb4:	f8d0 a000 	ldr.w	sl, [r0]
	parent->next = child;
    beb8:	463b      	mov	r3, r7
		if (wc->work == work) {
    beba:	6842      	ldr	r2, [r0, #4]
    bebc:	4295      	cmp	r5, r2
			sys_slist_remove(&pending_cancels, prev, &wc->node);
    bebe:	4601      	mov	r1, r0
		if (wc->work == work) {
    bec0:	d10c      	bne.n	bedc <work_queue_main+0x108>
	return node->next;
    bec2:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    bec4:	b997      	cbnz	r7, beec <work_queue_main+0x118>
    bec6:	6872      	ldr	r2, [r6, #4]
	list->head = node;
    bec8:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
    beca:	4282      	cmp	r2, r0
    becc:	d100      	bne.n	bed0 <work_queue_main+0xfc>
	list->tail = node;
    bece:	6071      	str	r1, [r6, #4]
	parent->next = child;
    bed0:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
    bed4:	f7ff ff30 	bl	bd38 <z_impl_k_sem_give>
}
    bed8:	4639      	mov	r1, r7
    beda:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    bedc:	f1ba 0f00 	cmp.w	sl, #0
    bee0:	d0d8      	beq.n	be94 <work_queue_main+0xc0>
	return node->next;
    bee2:	4650      	mov	r0, sl
    bee4:	460f      	mov	r7, r1
    bee6:	f8da a000 	ldr.w	sl, [sl]
    beea:	e7e6      	b.n	beba <work_queue_main+0xe6>
	return list->tail;
    beec:	6872      	ldr	r2, [r6, #4]
	parent->next = child;
    beee:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
    bef0:	4290      	cmp	r0, r2
	list->tail = node;
    bef2:	bf08      	it	eq
    bef4:	6077      	streq	r7, [r6, #4]
}
    bef6:	e7eb      	b.n	bed0 <work_queue_main+0xfc>
    bef8:	20001bec 	.word	0x20001bec
    befc:	20002263 	.word	0x20002263

0000bf00 <submit_to_queue_locked>:
{
    bf00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
    bf02:	68c3      	ldr	r3, [r0, #12]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    bf04:	079a      	lsls	r2, r3, #30
{
    bf06:	4604      	mov	r4, r0
    bf08:	460e      	mov	r6, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    bf0a:	f3c3 0540 	ubfx	r5, r3, #1, #1
    bf0e:	d41f      	bmi.n	bf50 <submit_to_queue_locked+0x50>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
    bf10:	075f      	lsls	r7, r3, #29
    bf12:	d41f      	bmi.n	bf54 <submit_to_queue_locked+0x54>
		if (*queuep == NULL) {
    bf14:	680a      	ldr	r2, [r1, #0]
    bf16:	b90a      	cbnz	r2, bf1c <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
    bf18:	6882      	ldr	r2, [r0, #8]
    bf1a:	600a      	str	r2, [r1, #0]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
    bf1c:	07d8      	lsls	r0, r3, #31
			*queuep = work->queue;
    bf1e:	bf44      	itt	mi
    bf20:	68a3      	ldrmi	r3, [r4, #8]
    bf22:	6033      	strmi	r3, [r6, #0]
		int rc = queue_submit_locked(*queuep, work);
    bf24:	6837      	ldr	r7, [r6, #0]
			ret = 2;
    bf26:	bf4c      	ite	mi
    bf28:	2502      	movmi	r5, #2
		ret = 1;
    bf2a:	2501      	movpl	r5, #1
	if (queue == NULL) {
    bf2c:	b37f      	cbz	r7, bf8e <submit_to_queue_locked+0x8e>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    bf2e:	4b1b      	ldr	r3, [pc, #108]	; (bf9c <submit_to_queue_locked+0x9c>)
    bf30:	689b      	ldr	r3, [r3, #8]
    bf32:	42bb      	cmp	r3, r7
    bf34:	d111      	bne.n	bf5a <submit_to_queue_locked+0x5a>
    bf36:	f003 fb3f 	bl	f5b8 <k_is_in_isr>
    bf3a:	f080 0001 	eor.w	r0, r0, #1
    bf3e:	b2c0      	uxtb	r0, r0
	return (*flagp & BIT(bit)) != 0U;
    bf40:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    bf44:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
    bf46:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    bf4a:	d523      	bpl.n	bf94 <submit_to_queue_locked+0x94>
	} else if (draining && !chained) {
    bf4c:	b13a      	cbz	r2, bf5e <submit_to_queue_locked+0x5e>
    bf4e:	b940      	cbnz	r0, bf62 <submit_to_queue_locked+0x62>
		ret = -EBUSY;
    bf50:	f06f 050f 	mvn.w	r5, #15
		*queuep = NULL;
    bf54:	2300      	movs	r3, #0
    bf56:	6033      	str	r3, [r6, #0]
	return ret;
    bf58:	e013      	b.n	bf82 <submit_to_queue_locked+0x82>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    bf5a:	2000      	movs	r0, #0
    bf5c:	e7f0      	b.n	bf40 <submit_to_queue_locked+0x40>
	} else if (plugged && !draining) {
    bf5e:	071b      	lsls	r3, r3, #28
    bf60:	d4f6      	bmi.n	bf50 <submit_to_queue_locked+0x50>
	parent->next = child;
    bf62:	2300      	movs	r3, #0
    bf64:	6023      	str	r3, [r4, #0]
	return list->tail;
    bf66:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
    bf6a:	b963      	cbnz	r3, bf86 <submit_to_queue_locked+0x86>
	list->head = node;
    bf6c:	e9c7 4420 	strd	r4, r4, [r7, #128]	; 0x80
		(void)notify_queue_locked(queue);
    bf70:	4638      	mov	r0, r7
    bf72:	f003 fc27 	bl	f7c4 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
    bf76:	68e3      	ldr	r3, [r4, #12]
    bf78:	f043 0304 	orr.w	r3, r3, #4
    bf7c:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
    bf7e:	6833      	ldr	r3, [r6, #0]
    bf80:	60a3      	str	r3, [r4, #8]
}
    bf82:	4628      	mov	r0, r5
    bf84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
    bf86:	601c      	str	r4, [r3, #0]
	list->tail = node;
    bf88:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
}
    bf8c:	e7f0      	b.n	bf70 <submit_to_queue_locked+0x70>
		return -EINVAL;
    bf8e:	f06f 0515 	mvn.w	r5, #21
    bf92:	e7df      	b.n	bf54 <submit_to_queue_locked+0x54>
		ret = -ENODEV;
    bf94:	f06f 0512 	mvn.w	r5, #18
    bf98:	e7dc      	b.n	bf54 <submit_to_queue_locked+0x54>
    bf9a:	bf00      	nop
    bf9c:	20001bc4 	.word	0x20001bc4

0000bfa0 <k_work_submit>:
{
    bfa0:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
    bfa2:	4801      	ldr	r0, [pc, #4]	; (bfa8 <k_work_submit+0x8>)
    bfa4:	f003 bc65 	b.w	f872 <k_work_submit_to_queue>
    bfa8:	20000ee8 	.word	0x20000ee8

0000bfac <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
    bfac:	b5f0      	push	{r4, r5, r6, r7, lr}
    bfae:	b089      	sub	sp, #36	; 0x24
    bfb0:	4604      	mov	r4, r0
	list->head = NULL;
    bfb2:	2000      	movs	r0, #0
	list->tail = NULL;
    bfb4:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
    bfb8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    bfba:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
    bfbe:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
    bfc2:	f104 0090 	add.w	r0, r4, #144	; 0x90
    bfc6:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
    bfca:	b31d      	cbz	r5, c014 <k_work_queue_start+0x68>
    bfcc:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
    bfce:	2800      	cmp	r0, #0
    bfd0:	f240 1001 	movw	r0, #257	; 0x101
    bfd4:	bf08      	it	eq
    bfd6:	2001      	moveq	r0, #1
	*flagp = flags;
    bfd8:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    bfdc:	2000      	movs	r0, #0
    bfde:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    bfe2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    bfe6:	e9cd 3003 	strd	r3, r0, [sp, #12]
    bfea:	e9cd 0001 	strd	r0, r0, [sp, #4]
    bfee:	e9cd 6706 	strd	r6, r7, [sp, #24]
    bff2:	4b09      	ldr	r3, [pc, #36]	; (c018 <k_work_queue_start+0x6c>)
    bff4:	9400      	str	r4, [sp, #0]
    bff6:	4620      	mov	r0, r4
    bff8:	f7ff fd0c 	bl	ba14 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
    bffc:	b125      	cbz	r5, c008 <k_work_queue_start+0x5c>
    bffe:	6829      	ldr	r1, [r5, #0]
    c000:	b111      	cbz	r1, c008 <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
    c002:	4620      	mov	r0, r4
    c004:	f003 fade 	bl	f5c4 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
    c008:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
    c00a:	b009      	add	sp, #36	; 0x24
    c00c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    c010:	f003 badd 	b.w	f5ce <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
    c014:	2001      	movs	r0, #1
    c016:	e7df      	b.n	bfd8 <k_work_queue_start+0x2c>
    c018:	0000bdd5 	.word	0x0000bdd5

0000c01c <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
    c01c:	b513      	push	{r0, r1, r4, lr}
    c01e:	9001      	str	r0, [sp, #4]
    c020:	4608      	mov	r0, r1
	__asm__ volatile(
    c022:	f04f 0120 	mov.w	r1, #32
    c026:	f3ef 8411 	mrs	r4, BASEPRI
    c02a:	f381 8812 	msr	BASEPRI_MAX, r1
    c02e:	f3bf 8f6f 	isb	sy
	return *flagp;
    c032:	68c1      	ldr	r1, [r0, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
    c034:	f011 0f0e 	tst.w	r1, #14
    c038:	d116      	bne.n	c068 <k_work_schedule_for_queue+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    c03a:	ea53 0c02 	orrs.w	ip, r3, r2
    c03e:	d108      	bne.n	c052 <k_work_schedule_for_queue+0x36>
		return submit_to_queue_locked(work, queuep);
    c040:	a901      	add	r1, sp, #4
    c042:	f7ff ff5d 	bl	bf00 <submit_to_queue_locked>
	__asm__ volatile(
    c046:	f384 8811 	msr	BASEPRI, r4
    c04a:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
    c04e:	b002      	add	sp, #8
    c050:	bd10      	pop	{r4, pc}
	*flagp |= BIT(bit);
    c052:	f041 0108 	orr.w	r1, r1, #8
    c056:	60c1      	str	r1, [r0, #12]
	dwork->queue = *queuep;
    c058:	9901      	ldr	r1, [sp, #4]
    c05a:	6281      	str	r1, [r0, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
    c05c:	3010      	adds	r0, #16
    c05e:	4903      	ldr	r1, [pc, #12]	; (c06c <k_work_schedule_for_queue+0x50>)
    c060:	f000 fc10 	bl	c884 <z_add_timeout>
	return ret;
    c064:	2001      	movs	r0, #1
    c066:	e7ee      	b.n	c046 <k_work_schedule_for_queue+0x2a>
	int ret = 0;
    c068:	2000      	movs	r0, #0
    c06a:	e7ec      	b.n	c046 <k_work_schedule_for_queue+0x2a>
    c06c:	0000f835 	.word	0x0000f835

0000c070 <k_work_schedule>:

int k_work_schedule(struct k_work_delayable *dwork,
				   k_timeout_t delay)
{
    c070:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule, dwork, delay);

	int ret = k_work_schedule_for_queue(&k_sys_work_q, dwork, delay);
    c072:	4801      	ldr	r0, [pc, #4]	; (c078 <k_work_schedule+0x8>)
    c074:	f7ff bfd2 	b.w	c01c <k_work_schedule_for_queue>
    c078:	20000ee8 	.word	0x20000ee8

0000c07c <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
    c07c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    c07e:	460c      	mov	r4, r1
    c080:	9001      	str	r0, [sp, #4]
    c082:	4616      	mov	r6, r2
    c084:	461d      	mov	r5, r3
	__asm__ volatile(
    c086:	f04f 0320 	mov.w	r3, #32
    c08a:	f3ef 8711 	mrs	r7, BASEPRI
    c08e:	f383 8812 	msr	BASEPRI_MAX, r3
    c092:	f3bf 8f6f 	isb	sy

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
    c096:	4608      	mov	r0, r1
    c098:	f003 fb86 	bl	f7a8 <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    c09c:	ea55 0306 	orrs.w	r3, r5, r6
    c0a0:	d109      	bne.n	c0b6 <k_work_reschedule_for_queue+0x3a>
		return submit_to_queue_locked(work, queuep);
    c0a2:	a901      	add	r1, sp, #4
    c0a4:	4620      	mov	r0, r4
    c0a6:	f7ff ff2b 	bl	bf00 <submit_to_queue_locked>
	__asm__ volatile(
    c0aa:	f387 8811 	msr	BASEPRI, r7
    c0ae:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
    c0b2:	b003      	add	sp, #12
    c0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	*flagp |= BIT(bit);
    c0b6:	68e3      	ldr	r3, [r4, #12]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
    c0b8:	4906      	ldr	r1, [pc, #24]	; (c0d4 <k_work_reschedule_for_queue+0x58>)
	*flagp |= BIT(bit);
    c0ba:	f043 0308 	orr.w	r3, r3, #8
    c0be:	60e3      	str	r3, [r4, #12]
	dwork->queue = *queuep;
    c0c0:	9b01      	ldr	r3, [sp, #4]
    c0c2:	62a3      	str	r3, [r4, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
    c0c4:	f104 0010 	add.w	r0, r4, #16
    c0c8:	4632      	mov	r2, r6
    c0ca:	462b      	mov	r3, r5
    c0cc:	f000 fbda 	bl	c884 <z_add_timeout>
	return ret;
    c0d0:	2001      	movs	r0, #1
    c0d2:	e7ea      	b.n	c0aa <k_work_reschedule_for_queue+0x2e>
    c0d4:	0000f835 	.word	0x0000f835

0000c0d8 <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
    c0d8:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
    c0da:	4801      	ldr	r0, [pc, #4]	; (c0e0 <k_work_reschedule+0x8>)
    c0dc:	f7ff bfce 	b.w	c07c <k_work_reschedule_for_queue>
    c0e0:	20000ee8 	.word	0x20000ee8

0000c0e4 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    c0e4:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    c0e6:	4c08      	ldr	r4, [pc, #32]	; (c108 <z_reset_time_slice+0x24>)
    c0e8:	6823      	ldr	r3, [r4, #0]
    c0ea:	b15b      	cbz	r3, c104 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    c0ec:	f7fe f938 	bl	a360 <sys_clock_elapsed>
    c0f0:	4603      	mov	r3, r0
    c0f2:	6820      	ldr	r0, [r4, #0]
    c0f4:	4a05      	ldr	r2, [pc, #20]	; (c10c <z_reset_time_slice+0x28>)
    c0f6:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
	}
}
    c0f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    c0fc:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    c0fe:	2100      	movs	r1, #0
    c100:	f003 bd2b 	b.w	fb5a <z_set_timeout_expiry>
}
    c104:	bd10      	pop	{r4, pc}
    c106:	bf00      	nop
    c108:	20001bfc 	.word	0x20001bfc
    c10c:	20001bc4 	.word	0x20001bc4

0000c110 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    c110:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c112:	4604      	mov	r4, r0
    c114:	460d      	mov	r5, r1
	__asm__ volatile(
    c116:	f04f 0320 	mov.w	r3, #32
    c11a:	f3ef 8611 	mrs	r6, BASEPRI
    c11e:	f383 8812 	msr	BASEPRI_MAX, r3
    c122:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    c126:	4b0f      	ldr	r3, [pc, #60]	; (c164 <k_sched_time_slice_set+0x54>)
    c128:	2100      	movs	r1, #0
			return (uint32_t)((t * to_hz + off) / from_hz);
    c12a:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    c12e:	f240 30e7 	movw	r0, #999	; 0x3e7
    c132:	6119      	str	r1, [r3, #16]
    c134:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c138:	2300      	movs	r3, #0
    c13a:	fbe4 0107 	umlal	r0, r1, r4, r7
    c13e:	f7f3 ffcf 	bl	e0 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    c142:	2c00      	cmp	r4, #0
    c144:	4b08      	ldr	r3, [pc, #32]	; (c168 <k_sched_time_slice_set+0x58>)
    c146:	dc09      	bgt.n	c15c <k_sched_time_slice_set+0x4c>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
    c148:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
    c14a:	4b08      	ldr	r3, [pc, #32]	; (c16c <k_sched_time_slice_set+0x5c>)
    c14c:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    c14e:	f7ff ffc9 	bl	c0e4 <z_reset_time_slice>
	__asm__ volatile(
    c152:	f386 8811 	msr	BASEPRI, r6
    c156:	f3bf 8f6f 	isb	sy
	}
}
    c15a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			slice_time = MAX(2, slice_time);
    c15c:	2802      	cmp	r0, #2
    c15e:	bfb8      	it	lt
    c160:	2002      	movlt	r0, #2
    c162:	e7f1      	b.n	c148 <k_sched_time_slice_set+0x38>
    c164:	20001bc4 	.word	0x20001bc4
    c168:	20001bfc 	.word	0x20001bfc
    c16c:	20001bf8 	.word	0x20001bf8

0000c170 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
    c170:	b949      	cbnz	r1, c186 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    c172:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
    c176:	b930      	cbnz	r0, c186 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
    c178:	4b05      	ldr	r3, [pc, #20]	; (c190 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
    c17a:	69da      	ldr	r2, [r3, #28]
    c17c:	689b      	ldr	r3, [r3, #8]
    c17e:	429a      	cmp	r2, r3
    c180:	d001      	beq.n	c186 <z_reschedule+0x16>
	ret = arch_swap(key);
    c182:	f7f6 b88f 	b.w	22a4 <arch_swap>
    c186:	f381 8811 	msr	BASEPRI, r1
    c18a:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
    c18e:	4770      	bx	lr
    c190:	20001bc4 	.word	0x20001bc4

0000c194 <k_sched_lock>:
	__asm__ volatile(
    c194:	f04f 0320 	mov.w	r3, #32
    c198:	f3ef 8111 	mrs	r1, BASEPRI
    c19c:	f383 8812 	msr	BASEPRI_MAX, r3
    c1a0:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
    c1a4:	4b04      	ldr	r3, [pc, #16]	; (c1b8 <k_sched_lock+0x24>)
    c1a6:	689a      	ldr	r2, [r3, #8]
    c1a8:	7bd3      	ldrb	r3, [r2, #15]
    c1aa:	3b01      	subs	r3, #1
    c1ac:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    c1ae:	f381 8811 	msr	BASEPRI, r1
    c1b2:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    c1b6:	4770      	bx	lr
    c1b8:	20001bc4 	.word	0x20001bc4

0000c1bc <update_cache>:
{
    c1bc:	b538      	push	{r3, r4, r5, lr}
    c1be:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
    c1c0:	480c      	ldr	r0, [pc, #48]	; (c1f4 <update_cache+0x38>)
    c1c2:	4d0d      	ldr	r5, [pc, #52]	; (c1f8 <update_cache+0x3c>)
    c1c4:	f003 fbe7 	bl	f996 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    c1c8:	4604      	mov	r4, r0
    c1ca:	b900      	cbnz	r0, c1ce <update_cache+0x12>
    c1cc:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
    c1ce:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
    c1d0:	b94a      	cbnz	r2, c1e6 <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
    c1d2:	7b5a      	ldrb	r2, [r3, #13]
    c1d4:	06d2      	lsls	r2, r2, #27
    c1d6:	d106      	bne.n	c1e6 <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    c1d8:	69a2      	ldr	r2, [r4, #24]
    c1da:	b922      	cbnz	r2, c1e6 <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
    c1dc:	89da      	ldrh	r2, [r3, #14]
    c1de:	2a7f      	cmp	r2, #127	; 0x7f
    c1e0:	d901      	bls.n	c1e6 <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
    c1e2:	61eb      	str	r3, [r5, #28]
}
    c1e4:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
    c1e6:	429c      	cmp	r4, r3
    c1e8:	d001      	beq.n	c1ee <update_cache+0x32>
			z_reset_time_slice();
    c1ea:	f7ff ff7b 	bl	c0e4 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    c1ee:	61ec      	str	r4, [r5, #28]
}
    c1f0:	e7f8      	b.n	c1e4 <update_cache+0x28>
    c1f2:	bf00      	nop
    c1f4:	20001be4 	.word	0x20001be4
    c1f8:	20001bc4 	.word	0x20001bc4

0000c1fc <move_thread_to_end_of_prio_q>:
{
    c1fc:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
    c1fe:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
    c202:	7b43      	ldrb	r3, [r0, #13]
    c204:	2a00      	cmp	r2, #0
{
    c206:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    c208:	da04      	bge.n	c214 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    c20a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    c20e:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    c210:	f003 fb6c 	bl	f8ec <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    c214:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
    c216:	4a15      	ldr	r2, [pc, #84]	; (c26c <move_thread_to_end_of_prio_q+0x70>)
    c218:	f063 037f 	orn	r3, r3, #127	; 0x7f
    c21c:	734b      	strb	r3, [r1, #13]
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    c21e:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c222:	f102 0520 	add.w	r5, r2, #32
    c226:	42ab      	cmp	r3, r5
    c228:	d01b      	beq.n	c262 <move_thread_to_end_of_prio_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c22a:	b1d3      	cbz	r3, c262 <move_thread_to_end_of_prio_q+0x66>
	int32_t b1 = thread_1->base.prio;
    c22c:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
    c230:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
    c234:	4286      	cmp	r6, r0
    c236:	d00f      	beq.n	c258 <move_thread_to_end_of_prio_q+0x5c>
		return b2 - b1;
    c238:	1b80      	subs	r0, r0, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    c23a:	2800      	cmp	r0, #0
    c23c:	dd0c      	ble.n	c258 <move_thread_to_end_of_prio_q+0x5c>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
    c23e:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
    c240:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
    c244:	6001      	str	r1, [r0, #0]
	successor->prev = node;
    c246:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
    c248:	6890      	ldr	r0, [r2, #8]
    c24a:	1a43      	subs	r3, r0, r1
    c24c:	4258      	negs	r0, r3
}
    c24e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
    c252:	4158      	adcs	r0, r3
    c254:	f7ff bfb2 	b.w	c1bc <update_cache>
	return (node == list->tail) ? NULL : node->next;
    c258:	42a3      	cmp	r3, r4
    c25a:	d002      	beq.n	c262 <move_thread_to_end_of_prio_q+0x66>
    c25c:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c25e:	2b00      	cmp	r3, #0
    c260:	d1e6      	bne.n	c230 <move_thread_to_end_of_prio_q+0x34>
	node->prev = tail;
    c262:	e9c1 5400 	strd	r5, r4, [r1]
	tail->next = node;
    c266:	6021      	str	r1, [r4, #0]
	list->tail = node;
    c268:	6251      	str	r1, [r2, #36]	; 0x24
}
    c26a:	e7ed      	b.n	c248 <move_thread_to_end_of_prio_q+0x4c>
    c26c:	20001bc4 	.word	0x20001bc4

0000c270 <z_time_slice>:
{
    c270:	b538      	push	{r3, r4, r5, lr}
    c272:	4601      	mov	r1, r0
	__asm__ volatile(
    c274:	f04f 0320 	mov.w	r3, #32
    c278:	f3ef 8411 	mrs	r4, BASEPRI
    c27c:	f383 8812 	msr	BASEPRI_MAX, r3
    c280:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
    c284:	4b15      	ldr	r3, [pc, #84]	; (c2dc <z_time_slice+0x6c>)
    c286:	4a16      	ldr	r2, [pc, #88]	; (c2e0 <z_time_slice+0x70>)
    c288:	6898      	ldr	r0, [r3, #8]
    c28a:	6815      	ldr	r5, [r2, #0]
    c28c:	42a8      	cmp	r0, r5
    c28e:	d106      	bne.n	c29e <z_time_slice+0x2e>
			z_reset_time_slice();
    c290:	f7ff ff28 	bl	c0e4 <z_reset_time_slice>
	__asm__ volatile(
    c294:	f384 8811 	msr	BASEPRI, r4
    c298:	f3bf 8f6f 	isb	sy
}
    c29c:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
    c29e:	2500      	movs	r5, #0
    c2a0:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
    c2a2:	4a10      	ldr	r2, [pc, #64]	; (c2e4 <z_time_slice+0x74>)
    c2a4:	6812      	ldr	r2, [r2, #0]
    c2a6:	b1ba      	cbz	r2, c2d8 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
    c2a8:	89c2      	ldrh	r2, [r0, #14]
    c2aa:	2a7f      	cmp	r2, #127	; 0x7f
    c2ac:	d814      	bhi.n	c2d8 <z_time_slice+0x68>
		&& !z_is_thread_prevented_from_running(thread)
    c2ae:	7b42      	ldrb	r2, [r0, #13]
    c2b0:	06d2      	lsls	r2, r2, #27
    c2b2:	d111      	bne.n	c2d8 <z_time_slice+0x68>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    c2b4:	4a0c      	ldr	r2, [pc, #48]	; (c2e8 <z_time_slice+0x78>)
    c2b6:	f990 500e 	ldrsb.w	r5, [r0, #14]
    c2ba:	6812      	ldr	r2, [r2, #0]
    c2bc:	4295      	cmp	r5, r2
    c2be:	db0b      	blt.n	c2d8 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
    c2c0:	4a0a      	ldr	r2, [pc, #40]	; (c2ec <z_time_slice+0x7c>)
    c2c2:	4290      	cmp	r0, r2
    c2c4:	d008      	beq.n	c2d8 <z_time_slice+0x68>
		if (ticks >= _current_cpu->slice_ticks) {
    c2c6:	691a      	ldr	r2, [r3, #16]
    c2c8:	428a      	cmp	r2, r1
    c2ca:	dc02      	bgt.n	c2d2 <z_time_slice+0x62>
			move_thread_to_end_of_prio_q(_current);
    c2cc:	f7ff ff96 	bl	c1fc <move_thread_to_end_of_prio_q>
    c2d0:	e7de      	b.n	c290 <z_time_slice+0x20>
			_current_cpu->slice_ticks -= ticks;
    c2d2:	1a52      	subs	r2, r2, r1
		_current_cpu->slice_ticks = 0;
    c2d4:	611a      	str	r2, [r3, #16]
    c2d6:	e7dd      	b.n	c294 <z_time_slice+0x24>
    c2d8:	2200      	movs	r2, #0
    c2da:	e7fb      	b.n	c2d4 <z_time_slice+0x64>
    c2dc:	20001bc4 	.word	0x20001bc4
    c2e0:	20001bf4 	.word	0x20001bf4
    c2e4:	20001bfc 	.word	0x20001bfc
    c2e8:	20001bf8 	.word	0x20001bf8
    c2ec:	20000de0 	.word	0x20000de0

0000c2f0 <ready_thread>:
{
    c2f0:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    c2f2:	f990 200d 	ldrsb.w	r2, [r0, #13]
    c2f6:	7b43      	ldrb	r3, [r0, #13]
    c2f8:	2a00      	cmp	r2, #0
    c2fa:	db2a      	blt.n	c352 <ready_thread+0x62>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    c2fc:	06da      	lsls	r2, r3, #27
    c2fe:	d128      	bne.n	c352 <ready_thread+0x62>
    c300:	6982      	ldr	r2, [r0, #24]
    c302:	bb32      	cbnz	r2, c352 <ready_thread+0x62>
	return list->head == list;
    c304:	4a14      	ldr	r2, [pc, #80]	; (c358 <ready_thread+0x68>)
	thread->base.thread_state |= _THREAD_QUEUED;
    c306:	f063 037f 	orn	r3, r3, #127	; 0x7f
    c30a:	7343      	strb	r3, [r0, #13]
	return (node == list->tail) ? NULL : node->next;
    c30c:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c310:	f102 0520 	add.w	r5, r2, #32
    c314:	42ab      	cmp	r3, r5
    c316:	d017      	beq.n	c348 <ready_thread+0x58>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c318:	b1b3      	cbz	r3, c348 <ready_thread+0x58>
	int32_t b1 = thread_1->base.prio;
    c31a:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
    c31e:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
    c322:	428e      	cmp	r6, r1
    c324:	d00b      	beq.n	c33e <ready_thread+0x4e>
		return b2 - b1;
    c326:	1b89      	subs	r1, r1, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    c328:	2900      	cmp	r1, #0
    c32a:	dd08      	ble.n	c33e <ready_thread+0x4e>
	sys_dnode_t *const prev = successor->prev;
    c32c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    c32e:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
    c332:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    c334:	6058      	str	r0, [r3, #4]
}
    c336:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
    c338:	2000      	movs	r0, #0
    c33a:	f7ff bf3f 	b.w	c1bc <update_cache>
	return (node == list->tail) ? NULL : node->next;
    c33e:	42a3      	cmp	r3, r4
    c340:	d002      	beq.n	c348 <ready_thread+0x58>
    c342:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c344:	2b00      	cmp	r3, #0
    c346:	d1ea      	bne.n	c31e <ready_thread+0x2e>
	node->prev = tail;
    c348:	e9c0 5400 	strd	r5, r4, [r0]
	tail->next = node;
    c34c:	6020      	str	r0, [r4, #0]
	list->tail = node;
    c34e:	6250      	str	r0, [r2, #36]	; 0x24
}
    c350:	e7f1      	b.n	c336 <ready_thread+0x46>
}
    c352:	bc70      	pop	{r4, r5, r6}
    c354:	4770      	bx	lr
    c356:	bf00      	nop
    c358:	20001bc4 	.word	0x20001bc4

0000c35c <z_sched_start>:
{
    c35c:	b510      	push	{r4, lr}
	__asm__ volatile(
    c35e:	f04f 0220 	mov.w	r2, #32
    c362:	f3ef 8411 	mrs	r4, BASEPRI
    c366:	f382 8812 	msr	BASEPRI_MAX, r2
    c36a:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    c36e:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
    c370:	0751      	lsls	r1, r2, #29
    c372:	d404      	bmi.n	c37e <z_sched_start+0x22>
	__asm__ volatile(
    c374:	f384 8811 	msr	BASEPRI, r4
    c378:	f3bf 8f6f 	isb	sy
}
    c37c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    c37e:	f022 0204 	bic.w	r2, r2, #4
    c382:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
    c384:	f7ff ffb4 	bl	c2f0 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    c388:	4621      	mov	r1, r4
    c38a:	4802      	ldr	r0, [pc, #8]	; (c394 <z_sched_start+0x38>)
}
    c38c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
    c390:	f7ff beee 	b.w	c170 <z_reschedule>
    c394:	20002263 	.word	0x20002263

0000c398 <unready_thread>:
{
    c398:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
    c39a:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
    c39e:	7b43      	ldrb	r3, [r0, #13]
    c3a0:	2a00      	cmp	r2, #0
{
    c3a2:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    c3a4:	da04      	bge.n	c3b0 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    c3a6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    c3aa:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    c3ac:	f003 fa9e 	bl	f8ec <sys_dlist_remove>
	update_cache(thread == _current);
    c3b0:	4b04      	ldr	r3, [pc, #16]	; (c3c4 <unready_thread+0x2c>)
    c3b2:	6898      	ldr	r0, [r3, #8]
    c3b4:	1a43      	subs	r3, r0, r1
    c3b6:	4258      	negs	r0, r3
    c3b8:	4158      	adcs	r0, r3
}
    c3ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
    c3be:	f7ff befd 	b.w	c1bc <update_cache>
    c3c2:	bf00      	nop
    c3c4:	20001bc4 	.word	0x20001bc4

0000c3c8 <pend>:
{
    c3c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c3cc:	4606      	mov	r6, r0
    c3ce:	4615      	mov	r5, r2
    c3d0:	461c      	mov	r4, r3
	__asm__ volatile(
    c3d2:	f04f 0320 	mov.w	r3, #32
    c3d6:	f3ef 8711 	mrs	r7, BASEPRI
    c3da:	f383 8812 	msr	BASEPRI_MAX, r3
    c3de:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
    c3e2:	f003 fb10 	bl	fa06 <add_to_waitq_locked>
	__asm__ volatile(
    c3e6:	f387 8811 	msr	BASEPRI, r7
    c3ea:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    c3ee:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
    c3f2:	bf08      	it	eq
    c3f4:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
    c3f8:	d008      	beq.n	c40c <pend+0x44>
    c3fa:	462a      	mov	r2, r5
    c3fc:	4623      	mov	r3, r4
    c3fe:	f106 0018 	add.w	r0, r6, #24
    c402:	4903      	ldr	r1, [pc, #12]	; (c410 <pend+0x48>)
}
    c404:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    c408:	f000 ba3c 	b.w	c884 <z_add_timeout>
    c40c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c410:	0000f9c3 	.word	0x0000f9c3

0000c414 <z_pend_curr>:
{
    c414:	b510      	push	{r4, lr}
	pending_current = _current;
    c416:	4b07      	ldr	r3, [pc, #28]	; (c434 <z_pend_curr+0x20>)
    c418:	6898      	ldr	r0, [r3, #8]
    c41a:	4b07      	ldr	r3, [pc, #28]	; (c438 <z_pend_curr+0x24>)
{
    c41c:	460c      	mov	r4, r1
	pending_current = _current;
    c41e:	6018      	str	r0, [r3, #0]
{
    c420:	4611      	mov	r1, r2
	pend(_current, wait_q, timeout);
    c422:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c426:	f7ff ffcf 	bl	c3c8 <pend>
    c42a:	4620      	mov	r0, r4
}
    c42c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    c430:	f7f5 bf38 	b.w	22a4 <arch_swap>
    c434:	20001bc4 	.word	0x20001bc4
    c438:	20001bf4 	.word	0x20001bf4

0000c43c <z_set_prio>:
{
    c43c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c43e:	4604      	mov	r4, r0
	__asm__ volatile(
    c440:	f04f 0320 	mov.w	r3, #32
    c444:	f3ef 8611 	mrs	r6, BASEPRI
    c448:	f383 8812 	msr	BASEPRI_MAX, r3
    c44c:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
    c450:	7b43      	ldrb	r3, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    c452:	06da      	lsls	r2, r3, #27
				thread->base.prio = prio;
    c454:	b249      	sxtb	r1, r1
    c456:	d133      	bne.n	c4c0 <z_set_prio+0x84>
		if (need_sched) {
    c458:	6982      	ldr	r2, [r0, #24]
    c45a:	bb8a      	cbnz	r2, c4c0 <z_set_prio+0x84>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    c45c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    c460:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    c462:	f003 fa43 	bl	f8ec <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    c466:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
    c468:	4a17      	ldr	r2, [pc, #92]	; (c4c8 <z_set_prio+0x8c>)
				thread->base.prio = prio;
    c46a:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
    c46c:	f063 037f 	orn	r3, r3, #127	; 0x7f
    c470:	7343      	strb	r3, [r0, #13]
    c472:	4610      	mov	r0, r2
    c474:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c478:	4283      	cmp	r3, r0
    c47a:	d01b      	beq.n	c4b4 <z_set_prio+0x78>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c47c:	b1d3      	cbz	r3, c4b4 <z_set_prio+0x78>
	return (node == list->tail) ? NULL : node->next;
    c47e:	6a57      	ldr	r7, [r2, #36]	; 0x24
	int32_t b2 = thread_2->base.prio;
    c480:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
    c484:	42a9      	cmp	r1, r5
    c486:	d010      	beq.n	c4aa <z_set_prio+0x6e>
		return b2 - b1;
    c488:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
    c48a:	2d00      	cmp	r5, #0
    c48c:	dd0d      	ble.n	c4aa <z_set_prio+0x6e>
	sys_dnode_t *const prev = successor->prev;
    c48e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    c490:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
    c494:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    c496:	605c      	str	r4, [r3, #4]
			update_cache(1);
    c498:	2001      	movs	r0, #1
    c49a:	f7ff fe8f 	bl	c1bc <update_cache>
    c49e:	2001      	movs	r0, #1
	__asm__ volatile(
    c4a0:	f386 8811 	msr	BASEPRI, r6
    c4a4:	f3bf 8f6f 	isb	sy
}
    c4a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    c4aa:	42bb      	cmp	r3, r7
    c4ac:	d002      	beq.n	c4b4 <z_set_prio+0x78>
    c4ae:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c4b0:	2b00      	cmp	r3, #0
    c4b2:	d1e5      	bne.n	c480 <z_set_prio+0x44>
	sys_dnode_t *const tail = list->tail;
    c4b4:	6a53      	ldr	r3, [r2, #36]	; 0x24
	node->prev = tail;
    c4b6:	e9c4 0300 	strd	r0, r3, [r4]
	tail->next = node;
    c4ba:	601c      	str	r4, [r3, #0]
	list->tail = node;
    c4bc:	6254      	str	r4, [r2, #36]	; 0x24
}
    c4be:	e7eb      	b.n	c498 <z_set_prio+0x5c>
			thread->base.prio = prio;
    c4c0:	73a1      	strb	r1, [r4, #14]
    c4c2:	2000      	movs	r0, #0
    c4c4:	e7ec      	b.n	c4a0 <z_set_prio+0x64>
    c4c6:	bf00      	nop
    c4c8:	20001bc4 	.word	0x20001bc4

0000c4cc <z_impl_k_thread_suspend>:
{
    c4cc:	b570      	push	{r4, r5, r6, lr}
    c4ce:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    c4d0:	3018      	adds	r0, #24
    c4d2:	f003 fb1c 	bl	fb0e <z_abort_timeout>
	__asm__ volatile(
    c4d6:	f04f 0320 	mov.w	r3, #32
    c4da:	f3ef 8611 	mrs	r6, BASEPRI
    c4de:	f383 8812 	msr	BASEPRI_MAX, r3
    c4e2:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    c4e6:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
    c4ea:	7b63      	ldrb	r3, [r4, #13]
    c4ec:	2a00      	cmp	r2, #0
    c4ee:	da05      	bge.n	c4fc <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    c4f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    c4f4:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    c4f6:	4620      	mov	r0, r4
    c4f8:	f003 f9f8 	bl	f8ec <sys_dlist_remove>
		update_cache(thread == _current);
    c4fc:	4d0b      	ldr	r5, [pc, #44]	; (c52c <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
    c4fe:	7b63      	ldrb	r3, [r4, #13]
    c500:	68a8      	ldr	r0, [r5, #8]
    c502:	f043 0310 	orr.w	r3, r3, #16
    c506:	7363      	strb	r3, [r4, #13]
    c508:	1b03      	subs	r3, r0, r4
    c50a:	4258      	negs	r0, r3
    c50c:	4158      	adcs	r0, r3
    c50e:	f7ff fe55 	bl	c1bc <update_cache>
	__asm__ volatile(
    c512:	f386 8811 	msr	BASEPRI, r6
    c516:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
    c51a:	68ab      	ldr	r3, [r5, #8]
    c51c:	42a3      	cmp	r3, r4
    c51e:	d103      	bne.n	c528 <z_impl_k_thread_suspend+0x5c>
}
    c520:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
    c524:	f003 ba2d 	b.w	f982 <z_reschedule_unlocked>
}
    c528:	bd70      	pop	{r4, r5, r6, pc}
    c52a:	bf00      	nop
    c52c:	20001bc4 	.word	0x20001bc4

0000c530 <k_sched_unlock>:
{
    c530:	b510      	push	{r4, lr}
	__asm__ volatile(
    c532:	f04f 0320 	mov.w	r3, #32
    c536:	f3ef 8411 	mrs	r4, BASEPRI
    c53a:	f383 8812 	msr	BASEPRI_MAX, r3
    c53e:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    c542:	4b08      	ldr	r3, [pc, #32]	; (c564 <k_sched_unlock+0x34>)
    c544:	689a      	ldr	r2, [r3, #8]
    c546:	7bd3      	ldrb	r3, [r2, #15]
    c548:	3301      	adds	r3, #1
    c54a:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    c54c:	2000      	movs	r0, #0
    c54e:	f7ff fe35 	bl	c1bc <update_cache>
	__asm__ volatile(
    c552:	f384 8811 	msr	BASEPRI, r4
    c556:	f3bf 8f6f 	isb	sy
}
    c55a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    c55e:	f003 ba10 	b.w	f982 <z_reschedule_unlocked>
    c562:	bf00      	nop
    c564:	20001bc4 	.word	0x20001bc4

0000c568 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    c568:	4b04      	ldr	r3, [pc, #16]	; (c57c <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    c56a:	2100      	movs	r1, #0
    c56c:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
    c570:	e9c3 2208 	strd	r2, r2, [r3, #32]
    c574:	4608      	mov	r0, r1
    c576:	f7ff bdcb 	b.w	c110 <k_sched_time_slice_set>
    c57a:	bf00      	nop
    c57c:	20001bc4 	.word	0x20001bc4

0000c580 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    c580:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    c582:	f04f 0320 	mov.w	r3, #32
    c586:	f3ef 8511 	mrs	r5, BASEPRI
    c58a:	f383 8812 	msr	BASEPRI_MAX, r3
    c58e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
    c592:	491a      	ldr	r1, [pc, #104]	; (c5fc <z_impl_k_yield+0x7c>)
    c594:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    c596:	7b43      	ldrb	r3, [r0, #13]
    c598:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    c59c:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    c59e:	f003 f9a5 	bl	f8ec <sys_dlist_remove>
	}
	queue_thread(_current);
    c5a2:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    c5a4:	7b5a      	ldrb	r2, [r3, #13]
	return list->head == list;
    c5a6:	4608      	mov	r0, r1
    c5a8:	f062 027f 	orn	r2, r2, #127	; 0x7f
    c5ac:	735a      	strb	r2, [r3, #13]
    c5ae:	f850 2f20 	ldr.w	r2, [r0, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c5b2:	4282      	cmp	r2, r0
    c5b4:	d01c      	beq.n	c5f0 <z_impl_k_yield+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c5b6:	b1da      	cbz	r2, c5f0 <z_impl_k_yield+0x70>
	return (node == list->tail) ? NULL : node->next;
    c5b8:	6a4f      	ldr	r7, [r1, #36]	; 0x24
	int32_t b1 = thread_1->base.prio;
    c5ba:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
    c5be:	f992 400e 	ldrsb.w	r4, [r2, #14]
	if (b1 != b2) {
    c5c2:	42a6      	cmp	r6, r4
    c5c4:	d00f      	beq.n	c5e6 <z_impl_k_yield+0x66>
		return b2 - b1;
    c5c6:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    c5c8:	2c00      	cmp	r4, #0
    c5ca:	dd0c      	ble.n	c5e6 <z_impl_k_yield+0x66>
	sys_dnode_t *const prev = successor->prev;
    c5cc:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    c5ce:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
    c5d2:	600b      	str	r3, [r1, #0]
	successor->prev = node;
    c5d4:	6053      	str	r3, [r2, #4]
	update_cache(1);
    c5d6:	2001      	movs	r0, #1
    c5d8:	f7ff fdf0 	bl	c1bc <update_cache>
    c5dc:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
    c5de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    c5e2:	f7f5 be5f 	b.w	22a4 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
    c5e6:	42ba      	cmp	r2, r7
    c5e8:	d002      	beq.n	c5f0 <z_impl_k_yield+0x70>
    c5ea:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    c5ec:	2a00      	cmp	r2, #0
    c5ee:	d1e6      	bne.n	c5be <z_impl_k_yield+0x3e>
	sys_dnode_t *const tail = list->tail;
    c5f0:	6a4a      	ldr	r2, [r1, #36]	; 0x24
	node->prev = tail;
    c5f2:	e9c3 0200 	strd	r0, r2, [r3]
	tail->next = node;
    c5f6:	6013      	str	r3, [r2, #0]
	list->tail = node;
    c5f8:	624b      	str	r3, [r1, #36]	; 0x24
}
    c5fa:	e7ec      	b.n	c5d6 <z_impl_k_yield+0x56>
    c5fc:	20001bc4 	.word	0x20001bc4

0000c600 <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    c600:	ea50 0301 	orrs.w	r3, r0, r1
{
    c604:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c608:	4605      	mov	r5, r0
    c60a:	460e      	mov	r6, r1
	if (ticks == 0) {
    c60c:	d103      	bne.n	c616 <z_tick_sleep+0x16>
	z_impl_k_yield();
    c60e:	f7ff ffb7 	bl	c580 <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
    c612:	2000      	movs	r0, #0
    c614:	e033      	b.n	c67e <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
    c616:	f06f 0401 	mvn.w	r4, #1
    c61a:	1a24      	subs	r4, r4, r0
    c61c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c620:	eb63 0301 	sbc.w	r3, r3, r1
    c624:	2c01      	cmp	r4, #1
    c626:	f173 0300 	sbcs.w	r3, r3, #0
    c62a:	da02      	bge.n	c632 <z_tick_sleep+0x32>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    c62c:	f003 faaf 	bl	fb8e <sys_clock_tick_get_32>
    c630:	1944      	adds	r4, r0, r5
    c632:	f04f 0320 	mov.w	r3, #32
    c636:	f3ef 8811 	mrs	r8, BASEPRI
    c63a:	f383 8812 	msr	BASEPRI_MAX, r3
    c63e:	f3bf 8f6f 	isb	sy
	pending_current = _current;
    c642:	4f10      	ldr	r7, [pc, #64]	; (c684 <z_tick_sleep+0x84>)
    c644:	4b10      	ldr	r3, [pc, #64]	; (c688 <z_tick_sleep+0x88>)
    c646:	68b8      	ldr	r0, [r7, #8]
    c648:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
    c64a:	f7ff fea5 	bl	c398 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    c64e:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    c650:	490e      	ldr	r1, [pc, #56]	; (c68c <z_tick_sleep+0x8c>)
    c652:	462a      	mov	r2, r5
    c654:	4633      	mov	r3, r6
    c656:	3018      	adds	r0, #24
    c658:	f000 f914 	bl	c884 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    c65c:	68ba      	ldr	r2, [r7, #8]
    c65e:	7b53      	ldrb	r3, [r2, #13]
    c660:	f043 0310 	orr.w	r3, r3, #16
    c664:	7353      	strb	r3, [r2, #13]
    c666:	4640      	mov	r0, r8
    c668:	f7f5 fe1c 	bl	22a4 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    c66c:	f003 fa8f 	bl	fb8e <sys_clock_tick_get_32>
    c670:	1a20      	subs	r0, r4, r0
    c672:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
    c676:	2801      	cmp	r0, #1
    c678:	f173 0300 	sbcs.w	r3, r3, #0
    c67c:	dbc9      	blt.n	c612 <z_tick_sleep+0x12>
}
    c67e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c682:	bf00      	nop
    c684:	20001bc4 	.word	0x20001bc4
    c688:	20001bf4 	.word	0x20001bf4
    c68c:	0000f9c3 	.word	0x0000f9c3

0000c690 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    c690:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    c694:	bf08      	it	eq
    c696:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
    c69a:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    c69c:	d106      	bne.n	c6ac <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
    c69e:	4b08      	ldr	r3, [pc, #32]	; (c6c0 <z_impl_k_sleep+0x30>)
    c6a0:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    c6a2:	f7ff ff13 	bl	c4cc <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
    c6a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
    c6aa:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
    c6ac:	f7ff ffa8 	bl	c600 <z_tick_sleep>
			return ((t * to_hz + off) / from_hz);
    c6b0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    c6b4:	fb80 0303 	smull	r0, r3, r0, r3
    c6b8:	0bc0      	lsrs	r0, r0, #15
    c6ba:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
    c6be:	e7f4      	b.n	c6aa <z_impl_k_sleep+0x1a>
    c6c0:	20001bc4 	.word	0x20001bc4

0000c6c4 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    c6c4:	4b01      	ldr	r3, [pc, #4]	; (c6cc <z_impl_z_current_get+0x8>)
    c6c6:	6898      	ldr	r0, [r3, #8]
    c6c8:	4770      	bx	lr
    c6ca:	bf00      	nop
    c6cc:	20001bc4 	.word	0x20001bc4

0000c6d0 <z_impl_k_is_preempt_thread>:
    c6d0:	f3ef 8305 	mrs	r3, IPSR
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
    c6d4:	b93b      	cbnz	r3, c6e6 <z_impl_k_is_preempt_thread+0x16>
    c6d6:	4b05      	ldr	r3, [pc, #20]	; (c6ec <z_impl_k_is_preempt_thread+0x1c>)
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    c6d8:	689b      	ldr	r3, [r3, #8]
	return !arch_is_in_isr() && is_preempt(_current);
    c6da:	89d8      	ldrh	r0, [r3, #14]
    c6dc:	287f      	cmp	r0, #127	; 0x7f
    c6de:	bf8c      	ite	hi
    c6e0:	2000      	movhi	r0, #0
    c6e2:	2001      	movls	r0, #1
    c6e4:	4770      	bx	lr
    c6e6:	2000      	movs	r0, #0
}
    c6e8:	4770      	bx	lr
    c6ea:	bf00      	nop
    c6ec:	20001bc4 	.word	0x20001bc4

0000c6f0 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    c6f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c6f4:	4604      	mov	r4, r0
    c6f6:	f04f 0320 	mov.w	r3, #32
    c6fa:	f3ef 8611 	mrs	r6, BASEPRI
    c6fe:	f383 8812 	msr	BASEPRI_MAX, r3
    c702:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    c706:	7b43      	ldrb	r3, [r0, #13]
    c708:	071a      	lsls	r2, r3, #28
    c70a:	d505      	bpl.n	c718 <z_thread_abort+0x28>
	__asm__ volatile(
    c70c:	f386 8811 	msr	BASEPRI, r6
    c710:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    c714:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
    c718:	f023 0220 	bic.w	r2, r3, #32
    c71c:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
    c720:	09d2      	lsrs	r2, r2, #7
    c722:	d120      	bne.n	c766 <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    c724:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
    c726:	68a3      	ldr	r3, [r4, #8]
    c728:	b113      	cbz	r3, c730 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
    c72a:	4620      	mov	r0, r4
    c72c:	f003 f8e6 	bl	f8fc <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
    c730:	f104 0018 	add.w	r0, r4, #24
    c734:	f003 f9eb 	bl	fb0e <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    c738:	f104 0758 	add.w	r7, r4, #88	; 0x58
    c73c:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
    c740:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c742:	42bd      	cmp	r5, r7
    c744:	d000      	beq.n	c748 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    c746:	b9b5      	cbnz	r5, c776 <z_thread_abort+0x86>
		update_cache(1);
    c748:	2001      	movs	r0, #1
    c74a:	f7ff fd37 	bl	c1bc <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    c74e:	4b10      	ldr	r3, [pc, #64]	; (c790 <z_thread_abort+0xa0>)
    c750:	689b      	ldr	r3, [r3, #8]
    c752:	42a3      	cmp	r3, r4
    c754:	d1da      	bne.n	c70c <z_thread_abort+0x1c>
    c756:	f3ef 8305 	mrs	r3, IPSR
    c75a:	2b00      	cmp	r3, #0
    c75c:	d1d6      	bne.n	c70c <z_thread_abort+0x1c>
    c75e:	4630      	mov	r0, r6
    c760:	f7f5 fda0 	bl	22a4 <arch_swap>
	return ret;
    c764:	e7d2      	b.n	c70c <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    c766:	f003 035f 	and.w	r3, r3, #95	; 0x5f
    c76a:	f043 0308 	orr.w	r3, r3, #8
    c76e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    c770:	f003 f8bc 	bl	f8ec <sys_dlist_remove>
}
    c774:	e7d7      	b.n	c726 <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
    c776:	4628      	mov	r0, r5
    c778:	f003 f8c0 	bl	f8fc <unpend_thread_no_timeout>
    c77c:	f105 0018 	add.w	r0, r5, #24
    c780:	f003 f9c5 	bl	fb0e <z_abort_timeout>
    c784:	f8c5 807c 	str.w	r8, [r5, #124]	; 0x7c
		ready_thread(thread);
    c788:	4628      	mov	r0, r5
    c78a:	f7ff fdb1 	bl	c2f0 <ready_thread>
    c78e:	e7d7      	b.n	c740 <z_thread_abort+0x50>
    c790:	20001bc4 	.word	0x20001bc4

0000c794 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
    c794:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    c796:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
    c79a:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    c79c:	e9cd 6700 	strd	r6, r7, [sp]
    c7a0:	f7ff fe38 	bl	c414 <z_pend_curr>

	if (data != NULL) {
    c7a4:	b11c      	cbz	r4, c7ae <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
    c7a6:	4b03      	ldr	r3, [pc, #12]	; (c7b4 <z_sched_wait+0x20>)
    c7a8:	689b      	ldr	r3, [r3, #8]
    c7aa:	695b      	ldr	r3, [r3, #20]
    c7ac:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
    c7ae:	b002      	add	sp, #8
    c7b0:	bdd0      	pop	{r4, r6, r7, pc}
    c7b2:	bf00      	nop
    c7b4:	20001bc4 	.word	0x20001bc4

0000c7b8 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
    c7b8:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
    c7ba:	4806      	ldr	r0, [pc, #24]	; (c7d4 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
    c7bc:	4a06      	ldr	r2, [pc, #24]	; (c7d8 <z_data_copy+0x20>)
    c7be:	4907      	ldr	r1, [pc, #28]	; (c7dc <z_data_copy+0x24>)
    c7c0:	1a12      	subs	r2, r2, r0
    c7c2:	f001 f920 	bl	da06 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    c7c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
    c7ca:	4a05      	ldr	r2, [pc, #20]	; (c7e0 <z_data_copy+0x28>)
    c7cc:	4905      	ldr	r1, [pc, #20]	; (c7e4 <z_data_copy+0x2c>)
    c7ce:	4806      	ldr	r0, [pc, #24]	; (c7e8 <z_data_copy+0x30>)
    c7d0:	f001 b919 	b.w	da06 <memcpy>
    c7d4:	20000000 	.word	0x20000000
    c7d8:	20000648 	.word	0x20000648
    c7dc:	00012154 	.word	0x00012154
    c7e0:	00000000 	.word	0x00000000
    c7e4:	00012154 	.word	0x00012154
    c7e8:	20000000 	.word	0x20000000

0000c7ec <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    c7ec:	4b03      	ldr	r3, [pc, #12]	; (c7fc <elapsed+0x10>)
    c7ee:	681b      	ldr	r3, [r3, #0]
    c7f0:	b90b      	cbnz	r3, c7f6 <elapsed+0xa>
    c7f2:	f7fd bdb5 	b.w	a360 <sys_clock_elapsed>
}
    c7f6:	2000      	movs	r0, #0
    c7f8:	4770      	bx	lr
    c7fa:	bf00      	nop
    c7fc:	20001c00 	.word	0x20001c00

0000c800 <next_timeout>:
	return list->head == list;
    c800:	4b11      	ldr	r3, [pc, #68]	; (c848 <next_timeout+0x48>)

static int32_t next_timeout(void)
{
    c802:	b510      	push	{r4, lr}
    c804:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c806:	429c      	cmp	r4, r3
    c808:	bf08      	it	eq
    c80a:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    c80c:	f7ff ffee 	bl	c7ec <elapsed>
    c810:	4603      	mov	r3, r0
	int32_t ret = to == NULL ? MAX_WAIT
    c812:	b16c      	cbz	r4, c830 <next_timeout+0x30>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    c814:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
    c818:	1ac0      	subs	r0, r0, r3
    c81a:	eb62 73e3 	sbc.w	r3, r2, r3, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
    c81e:	2801      	cmp	r0, #1
    c820:	f173 0200 	sbcs.w	r2, r3, #0
    c824:	db0d      	blt.n	c842 <next_timeout+0x42>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    c826:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
    c82a:	f173 0300 	sbcs.w	r3, r3, #0
    c82e:	db01      	blt.n	c834 <next_timeout+0x34>
	int32_t ret = to == NULL ? MAX_WAIT
    c830:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    c834:	4b05      	ldr	r3, [pc, #20]	; (c84c <next_timeout+0x4c>)
    c836:	691b      	ldr	r3, [r3, #16]
    c838:	b113      	cbz	r3, c840 <next_timeout+0x40>
    c83a:	4298      	cmp	r0, r3
    c83c:	bfa8      	it	ge
    c83e:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    c840:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
    c842:	2000      	movs	r0, #0
    c844:	e7f6      	b.n	c834 <next_timeout+0x34>
    c846:	bf00      	nop
    c848:	2000050c 	.word	0x2000050c
    c84c:	20001bc4 	.word	0x20001bc4

0000c850 <remove_timeout>:
{
    c850:	b530      	push	{r4, r5, lr}
	return (node == list->tail) ? NULL : node->next;
    c852:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    c854:	b168      	cbz	r0, c872 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
    c856:	4a0a      	ldr	r2, [pc, #40]	; (c880 <remove_timeout+0x30>)
    c858:	6852      	ldr	r2, [r2, #4]
    c85a:	4290      	cmp	r0, r2
    c85c:	d009      	beq.n	c872 <remove_timeout+0x22>
	if (next(t) != NULL) {
    c85e:	b143      	cbz	r3, c872 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
    c860:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
    c864:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
    c868:	1912      	adds	r2, r2, r4
    c86a:	eb41 0105 	adc.w	r1, r1, r5
    c86e:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    c872:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    c874:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    c876:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    c878:	2300      	movs	r3, #0
	node->prev = NULL;
    c87a:	e9c0 3300 	strd	r3, r3, [r0]
}
    c87e:	bd30      	pop	{r4, r5, pc}
    c880:	2000050c 	.word	0x2000050c

0000c884 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    c884:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    c888:	bf08      	it	eq
    c88a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
    c88e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c890:	4604      	mov	r4, r0
    c892:	461f      	mov	r7, r3
    c894:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    c896:	d067      	beq.n	c968 <z_add_timeout+0xe4>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    c898:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
    c89a:	f04f 0320 	mov.w	r3, #32
    c89e:	f3ef 8611 	mrs	r6, BASEPRI
    c8a2:	f383 8812 	msr	BASEPRI_MAX, r3
    c8a6:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    c8aa:	f06f 0201 	mvn.w	r2, #1
    c8ae:	1b53      	subs	r3, r2, r5
    c8b0:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    c8b4:	eb6c 0307 	sbc.w	r3, ip, r7
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    c8b8:	2b00      	cmp	r3, #0
    c8ba:	db1b      	blt.n	c8f4 <z_add_timeout+0x70>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    c8bc:	4b2b      	ldr	r3, [pc, #172]	; (c96c <z_add_timeout+0xe8>)
    c8be:	e9d3 1300 	ldrd	r1, r3, [r3]
    c8c2:	1a52      	subs	r2, r2, r1
    c8c4:	eb6c 0303 	sbc.w	r3, ip, r3
    c8c8:	1b55      	subs	r5, r2, r5

			to->dticks = MAX(1, ticks);
    c8ca:	eb63 0307 	sbc.w	r3, r3, r7
    c8ce:	2d01      	cmp	r5, #1
    c8d0:	f173 0200 	sbcs.w	r2, r3, #0
    c8d4:	bfbc      	itt	lt
    c8d6:	2501      	movlt	r5, #1
    c8d8:	2300      	movlt	r3, #0
    c8da:	e9c0 5304 	strd	r5, r3, [r0, #16]
	return list->head == list;
    c8de:	4824      	ldr	r0, [pc, #144]	; (c970 <z_add_timeout+0xec>)
	sys_dnode_t *const tail = list->tail;
    c8e0:	e9d0 3c00 	ldrd	r3, ip, [r0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c8e4:	4283      	cmp	r3, r0
    c8e6:	d118      	bne.n	c91a <z_add_timeout+0x96>
	node->prev = tail;
    c8e8:	e9c4 0c00 	strd	r0, ip, [r4]
	tail->next = node;
    c8ec:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
    c8f0:	6044      	str	r4, [r0, #4]
}
    c8f2:	e026      	b.n	c942 <z_add_timeout+0xbe>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    c8f4:	f7ff ff7a 	bl	c7ec <elapsed>
    c8f8:	3501      	adds	r5, #1
    c8fa:	f147 0700 	adc.w	r7, r7, #0
    c8fe:	182d      	adds	r5, r5, r0
    c900:	eb47 77e0 	adc.w	r7, r7, r0, asr #31
    c904:	e9c4 5704 	strd	r5, r7, [r4, #16]
    c908:	e7e9      	b.n	c8de <z_add_timeout+0x5a>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    c90a:	1a52      	subs	r2, r2, r1
    c90c:	eb65 0507 	sbc.w	r5, r5, r7
	return (node == list->tail) ? NULL : node->next;
    c910:	459c      	cmp	ip, r3
    c912:	e9c4 2504 	strd	r2, r5, [r4, #16]
    c916:	d0e7      	beq.n	c8e8 <z_add_timeout+0x64>
    c918:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
    c91a:	2b00      	cmp	r3, #0
    c91c:	d0e4      	beq.n	c8e8 <z_add_timeout+0x64>
			if (t->dticks > to->dticks) {
    c91e:	e9d3 1704 	ldrd	r1, r7, [r3, #16]
    c922:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
    c926:	428a      	cmp	r2, r1
    c928:	eb75 0e07 	sbcs.w	lr, r5, r7
    c92c:	daed      	bge.n	c90a <z_add_timeout+0x86>
				t->dticks -= to->dticks;
    c92e:	1a8a      	subs	r2, r1, r2
    c930:	eb67 0505 	sbc.w	r5, r7, r5
    c934:	e9c3 2504 	strd	r2, r5, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
    c938:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    c93a:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
    c93e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    c940:	605c      	str	r4, [r3, #4]
	return list->head == list;
    c942:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c944:	4283      	cmp	r3, r0
    c946:	d00b      	beq.n	c960 <z_add_timeout+0xdc>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    c948:	429c      	cmp	r4, r3
    c94a:	d109      	bne.n	c960 <z_add_timeout+0xdc>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    c94c:	f7ff ff58 	bl	c800 <next_timeout>

			if (next_time == 0 ||
    c950:	b118      	cbz	r0, c95a <z_add_timeout+0xd6>
			    _current_cpu->slice_ticks != next_time) {
    c952:	4b08      	ldr	r3, [pc, #32]	; (c974 <z_add_timeout+0xf0>)
			if (next_time == 0 ||
    c954:	691b      	ldr	r3, [r3, #16]
    c956:	4283      	cmp	r3, r0
    c958:	d002      	beq.n	c960 <z_add_timeout+0xdc>
				sys_clock_set_timeout(next_time, false);
    c95a:	2100      	movs	r1, #0
    c95c:	f7fd fcce 	bl	a2fc <sys_clock_set_timeout>
	__asm__ volatile(
    c960:	f386 8811 	msr	BASEPRI, r6
    c964:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    c968:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c96a:	bf00      	nop
    c96c:	20000ee0 	.word	0x20000ee0
    c970:	2000050c 	.word	0x2000050c
    c974:	20001bc4 	.word	0x20001bc4

0000c978 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
    c978:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c97c:	4605      	mov	r5, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    c97e:	f7ff fc77 	bl	c270 <z_time_slice>
	__asm__ volatile(
    c982:	f04f 0320 	mov.w	r3, #32
    c986:	f3ef 8411 	mrs	r4, BASEPRI
    c98a:	f383 8812 	msr	BASEPRI_MAX, r3
    c98e:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    c992:	4e24      	ldr	r6, [pc, #144]	; (ca24 <sys_clock_announce+0xac>)
	return list->head == list;
    c994:	f8df 8090 	ldr.w	r8, [pc, #144]	; ca28 <sys_clock_announce+0xb0>
    c998:	6035      	str	r5, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    c99a:	4d24      	ldr	r5, [pc, #144]	; (ca2c <sys_clock_announce+0xb4>)
    c99c:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
    c9a0:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    c9a2:	4540      	cmp	r0, r8
		curr_tick += dt;
    c9a4:	e9d5 1e00 	ldrd	r1, lr, [r5]
    c9a8:	ea4f 77e2 	mov.w	r7, r2, asr #31
    c9ac:	d00b      	beq.n	c9c6 <sys_clock_announce+0x4e>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    c9ae:	b150      	cbz	r0, c9c6 <sys_clock_announce+0x4e>
    c9b0:	e9d0 3c04 	ldrd	r3, ip, [r0, #16]
    c9b4:	429a      	cmp	r2, r3
    c9b6:	eb77 090c 	sbcs.w	r9, r7, ip
    c9ba:	da16      	bge.n	c9ea <sys_clock_announce+0x72>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    c9bc:	1a9b      	subs	r3, r3, r2
    c9be:	eb6c 0c07 	sbc.w	ip, ip, r7
    c9c2:	e9c0 3c04 	strd	r3, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
    c9c6:	1852      	adds	r2, r2, r1
    c9c8:	eb4e 0707 	adc.w	r7, lr, r7
    c9cc:	e9c5 2700 	strd	r2, r7, [r5]
	announce_remaining = 0;
    c9d0:	2500      	movs	r5, #0
    c9d2:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
    c9d4:	f7ff ff14 	bl	c800 <next_timeout>
    c9d8:	4629      	mov	r1, r5
    c9da:	f7fd fc8f 	bl	a2fc <sys_clock_set_timeout>
	__asm__ volatile(
    c9de:	f384 8811 	msr	BASEPRI, r4
    c9e2:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    c9e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
    c9ea:	1859      	adds	r1, r3, r1
    c9ec:	eb4e 77e3 	adc.w	r7, lr, r3, asr #31
		announce_remaining -= dt;
    c9f0:	1ad3      	subs	r3, r2, r3
    c9f2:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    c9f4:	2200      	movs	r2, #0
    c9f6:	2300      	movs	r3, #0
    c9f8:	e9c0 2304 	strd	r2, r3, [r0, #16]
		curr_tick += dt;
    c9fc:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
    ca00:	f7ff ff26 	bl	c850 <remove_timeout>
    ca04:	f384 8811 	msr	BASEPRI, r4
    ca08:	f3bf 8f6f 	isb	sy
		t->fn(t);
    ca0c:	6883      	ldr	r3, [r0, #8]
    ca0e:	4798      	blx	r3
	__asm__ volatile(
    ca10:	f04f 0320 	mov.w	r3, #32
    ca14:	f3ef 8411 	mrs	r4, BASEPRI
    ca18:	f383 8812 	msr	BASEPRI_MAX, r3
    ca1c:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    ca20:	e7bc      	b.n	c99c <sys_clock_announce+0x24>
    ca22:	bf00      	nop
    ca24:	20001c00 	.word	0x20001c00
    ca28:	2000050c 	.word	0x2000050c
    ca2c:	20000ee0 	.word	0x20000ee0

0000ca30 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    ca30:	b510      	push	{r4, lr}
    ca32:	f04f 0320 	mov.w	r3, #32
    ca36:	f3ef 8411 	mrs	r4, BASEPRI
    ca3a:	f383 8812 	msr	BASEPRI_MAX, r3
    ca3e:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    ca42:	f7fd fc8d 	bl	a360 <sys_clock_elapsed>
    ca46:	4a05      	ldr	r2, [pc, #20]	; (ca5c <sys_clock_tick_get+0x2c>)
    ca48:	e9d2 3100 	ldrd	r3, r1, [r2]
    ca4c:	18c0      	adds	r0, r0, r3
    ca4e:	f141 0100 	adc.w	r1, r1, #0
	__asm__ volatile(
    ca52:	f384 8811 	msr	BASEPRI, r4
    ca56:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    ca5a:	bd10      	pop	{r4, pc}
    ca5c:	20000ee0 	.word	0x20000ee0

0000ca60 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    ca60:	b570      	push	{r4, r5, r6, lr}
    ca62:	4604      	mov	r4, r0
	__asm__ volatile(
    ca64:	f04f 0320 	mov.w	r3, #32
    ca68:	f3ef 8511 	mrs	r5, BASEPRI
    ca6c:	f383 8812 	msr	BASEPRI_MAX, r3
    ca70:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    ca74:	e9d0 320a 	ldrd	r3, r2, [r0, #40]	; 0x28
    ca78:	3301      	adds	r3, #1
    ca7a:	f142 0200 	adc.w	r2, r2, #0
    ca7e:	2b02      	cmp	r3, #2
    ca80:	f172 0300 	sbcs.w	r3, r2, #0
    ca84:	d304      	bcc.n	ca90 <z_timer_expiration_handler+0x30>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    ca86:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
    ca8a:	4917      	ldr	r1, [pc, #92]	; (cae8 <z_timer_expiration_handler+0x88>)
    ca8c:	f7ff fefa 	bl	c884 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    ca90:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ca92:	3301      	adds	r3, #1
    ca94:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    ca96:	6a23      	ldr	r3, [r4, #32]
    ca98:	b173      	cbz	r3, cab8 <z_timer_expiration_handler+0x58>
	__asm__ volatile(
    ca9a:	f385 8811 	msr	BASEPRI, r5
    ca9e:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
    caa2:	6a23      	ldr	r3, [r4, #32]
    caa4:	4620      	mov	r0, r4
    caa6:	4798      	blx	r3
	__asm__ volatile(
    caa8:	f04f 0320 	mov.w	r3, #32
    caac:	f3ef 8511 	mrs	r5, BASEPRI
    cab0:	f383 8812 	msr	BASEPRI_MAX, r3
    cab4:	f3bf 8f6f 	isb	sy
	return list->head == list;
    cab8:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    cabc:	42a6      	cmp	r6, r4
    cabe:	d000      	beq.n	cac2 <z_timer_expiration_handler+0x62>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    cac0:	b926      	cbnz	r6, cacc <z_timer_expiration_handler+0x6c>
	__asm__ volatile(
    cac2:	f385 8811 	msr	BASEPRI, r5
    cac6:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
    caca:	bd70      	pop	{r4, r5, r6, pc}
	z_unpend_thread_no_timeout(thread);
    cacc:	4630      	mov	r0, r6
    cace:	f002 ff28 	bl	f922 <z_unpend_thread_no_timeout>
    cad2:	2300      	movs	r3, #0
    cad4:	67f3      	str	r3, [r6, #124]	; 0x7c
    cad6:	f385 8811 	msr	BASEPRI, r5
    cada:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
    cade:	4630      	mov	r0, r6
}
    cae0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
    cae4:	f002 bf5d 	b.w	f9a2 <z_ready_thread>
    cae8:	0000ca61 	.word	0x0000ca61

0000caec <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
    caec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    caf0:	4611      	mov	r1, r2
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    caf2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    caf6:	bf08      	it	eq
    caf8:	f1b1 3fff 	cmpeq.w	r1, #4294967295	; 0xffffffff
{
    cafc:	4606      	mov	r6, r0
    cafe:	461c      	mov	r4, r3
    cb00:	e9dd 2008 	ldrd	r2, r0, [sp, #32]
    cb04:	4689      	mov	r9, r1
    cb06:	4698      	mov	r8, r3
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    cb08:	d03e      	beq.n	cb88 <z_impl_k_timer_start+0x9c>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    cb0a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    cb0e:	bf08      	it	eq
    cb10:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    cb14:	4615      	mov	r5, r2
    cb16:	4607      	mov	r7, r0
    cb18:	d014      	beq.n	cb44 <z_impl_k_timer_start+0x58>
    cb1a:	ea50 0302 	orrs.w	r3, r0, r2
    cb1e:	d011      	beq.n	cb44 <z_impl_k_timer_start+0x58>
	    Z_TICK_ABS(period.ticks) < 0) {
    cb20:	f06f 0301 	mvn.w	r3, #1
    cb24:	1a9b      	subs	r3, r3, r2
    cb26:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cb2a:	eb63 0300 	sbc.w	r3, r3, r0
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    cb2e:	2b00      	cmp	r3, #0
    cb30:	da08      	bge.n	cb44 <z_impl_k_timer_start+0x58>
		period.ticks = MAX(period.ticks - 1, 1);
    cb32:	2a02      	cmp	r2, #2
    cb34:	f170 0300 	sbcs.w	r3, r0, #0
    cb38:	bfbc      	itt	lt
    cb3a:	2502      	movlt	r5, #2
    cb3c:	2700      	movlt	r7, #0
    cb3e:	3d01      	subs	r5, #1
    cb40:	f147 37ff 	adc.w	r7, r7, #4294967295	; 0xffffffff
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    cb44:	f06f 0301 	mvn.w	r3, #1
    cb48:	1a5b      	subs	r3, r3, r1
    cb4a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cb4e:	eb63 0304 	sbc.w	r3, r3, r4
    cb52:	2b00      	cmp	r3, #0
    cb54:	da09      	bge.n	cb6a <z_impl_k_timer_start+0x7e>
		duration.ticks = MAX(duration.ticks - 1, 0);
    cb56:	2901      	cmp	r1, #1
    cb58:	f174 0300 	sbcs.w	r3, r4, #0
    cb5c:	bfbc      	itt	lt
    cb5e:	2101      	movlt	r1, #1
    cb60:	2400      	movlt	r4, #0
    cb62:	f111 39ff 	adds.w	r9, r1, #4294967295	; 0xffffffff
    cb66:	f144 38ff 	adc.w	r8, r4, #4294967295	; 0xffffffff
	}

	(void)z_abort_timeout(&timer->timeout);
    cb6a:	4630      	mov	r0, r6
    cb6c:	f002 ffcf 	bl	fb0e <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
    cb70:	2300      	movs	r3, #0
    cb72:	6333      	str	r3, [r6, #48]	; 0x30
	timer->period = period;
    cb74:	e9c6 570a 	strd	r5, r7, [r6, #40]	; 0x28

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    cb78:	464a      	mov	r2, r9
    cb7a:	4643      	mov	r3, r8
    cb7c:	4630      	mov	r0, r6
    cb7e:	4903      	ldr	r1, [pc, #12]	; (cb8c <z_impl_k_timer_start+0xa0>)
		     duration);
}
    cb80:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    cb84:	f7ff be7e 	b.w	c884 <z_add_timeout>
}
    cb88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cb8c:	0000ca61 	.word	0x0000ca61

0000cb90 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
    cb90:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    cb94:	461d      	mov	r5, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
    cb96:	4b29      	ldr	r3, [pc, #164]	; (cc3c <z_impl_k_poll+0xac>)
    cb98:	689f      	ldr	r7, [r3, #8]

	poller->is_polling = true;
    cb9a:	2301      	movs	r3, #1
    cb9c:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	poller->mode = MODE_POLL;
    cba0:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
    cba4:	ea52 0305 	orrs.w	r3, r2, r5
{
    cba8:	4616      	mov	r6, r2
	events_registered = register_events(events, num_events, poller,
    cbaa:	bf0c      	ite	eq
    cbac:	2301      	moveq	r3, #1
    cbae:	2300      	movne	r3, #0
    cbb0:	f107 0260 	add.w	r2, r7, #96	; 0x60
{
    cbb4:	4680      	mov	r8, r0
	events_registered = register_events(events, num_events, poller,
    cbb6:	f003 f877 	bl	fca8 <register_events>
    cbba:	4681      	mov	r9, r0
	__asm__ volatile(
    cbbc:	f04f 0320 	mov.w	r3, #32
    cbc0:	f3ef 8a11 	mrs	sl, BASEPRI
    cbc4:	f383 8812 	msr	BASEPRI_MAX, r3
    cbc8:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
    cbcc:	f897 4060 	ldrb.w	r4, [r7, #96]	; 0x60
    cbd0:	b964      	cbnz	r4, cbec <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
    cbd2:	4601      	mov	r1, r0
    cbd4:	4652      	mov	r2, sl
    cbd6:	4640      	mov	r0, r8
    cbd8:	f003 f937 	bl	fe4a <clear_event_registrations>
	__asm__ volatile(
    cbdc:	f38a 8811 	msr	BASEPRI, sl
    cbe0:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
    cbe4:	4620      	mov	r0, r4
    cbe6:	b002      	add	sp, #8
    cbe8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	poller->is_polling = false;
    cbec:	2300      	movs	r3, #0
    cbee:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    cbf2:	ea56 0305 	orrs.w	r3, r6, r5
    cbf6:	d106      	bne.n	cc06 <z_impl_k_poll+0x76>
    cbf8:	f38a 8811 	msr	BASEPRI, sl
    cbfc:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
    cc00:	f06f 040a 	mvn.w	r4, #10
    cc04:	e7ee      	b.n	cbe4 <z_impl_k_poll+0x54>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    cc06:	e9cd 6500 	strd	r6, r5, [sp]
    cc0a:	4a0d      	ldr	r2, [pc, #52]	; (cc40 <z_impl_k_poll+0xb0>)
    cc0c:	480d      	ldr	r0, [pc, #52]	; (cc44 <z_impl_k_poll+0xb4>)
    cc0e:	4651      	mov	r1, sl
    cc10:	f7ff fc00 	bl	c414 <z_pend_curr>
    cc14:	4604      	mov	r4, r0
	__asm__ volatile(
    cc16:	f04f 0320 	mov.w	r3, #32
    cc1a:	f3ef 8511 	mrs	r5, BASEPRI
    cc1e:	f383 8812 	msr	BASEPRI_MAX, r3
    cc22:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
    cc26:	462a      	mov	r2, r5
    cc28:	4649      	mov	r1, r9
    cc2a:	4640      	mov	r0, r8
    cc2c:	f003 f90d 	bl	fe4a <clear_event_registrations>
	__asm__ volatile(
    cc30:	f385 8811 	msr	BASEPRI, r5
    cc34:	f3bf 8f6f 	isb	sy
	return swap_rc;
    cc38:	e7d4      	b.n	cbe4 <z_impl_k_poll+0x54>
    cc3a:	bf00      	nop
    cc3c:	20001bc4 	.word	0x20001bc4
    cc40:	20000514 	.word	0x20000514
    cc44:	20002263 	.word	0x20002263

0000cc48 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
    cc48:	b538      	push	{r3, r4, r5, lr}
    cc4a:	4603      	mov	r3, r0
	__asm__ volatile(
    cc4c:	f04f 0220 	mov.w	r2, #32
    cc50:	f3ef 8511 	mrs	r5, BASEPRI
    cc54:	f382 8812 	msr	BASEPRI_MAX, r2
    cc58:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
    cc5c:	60c1      	str	r1, [r0, #12]
	sig->signaled = 1U;
    cc5e:	2101      	movs	r1, #1
    cc60:	6081      	str	r1, [r0, #8]
	return list->head == list;
    cc62:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    cc64:	4283      	cmp	r3, r0
    cc66:	d106      	bne.n	cc76 <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
    cc68:	f385 8811 	msr	BASEPRI, r5
    cc6c:	f3bf 8f6f 	isb	sy
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
    cc70:	2400      	movs	r4, #0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
	return rc;
}
    cc72:	4620      	mov	r0, r4
    cc74:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const next = node->next;
    cc76:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
    cc7a:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    cc7c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    cc7e:	2300      	movs	r3, #0
	node->prev = NULL;
    cc80:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
    cc84:	f003 f887 	bl	fd96 <signal_poll_event>
	z_reschedule(&lock, key);
    cc88:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
    cc8a:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
    cc8c:	4801      	ldr	r0, [pc, #4]	; (cc94 <z_impl_k_poll_signal_raise+0x4c>)
    cc8e:	f7ff fa6f 	bl	c170 <z_reschedule>
	return rc;
    cc92:	e7ee      	b.n	cc72 <z_impl_k_poll_signal_raise+0x2a>
    cc94:	20002263 	.word	0x20002263

0000cc98 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
    cc98:	b573      	push	{r0, r1, r4, r5, r6, lr}
    cc9a:	4606      	mov	r6, r0
    cc9c:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
    cc9e:	f002 fc8b 	bl	f5b8 <k_is_in_isr>
    cca2:	b978      	cbnz	r0, ccc4 <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
    cca4:	4b0b      	ldr	r3, [pc, #44]	; (ccd4 <z_thread_aligned_alloc+0x3c>)
    cca6:	689b      	ldr	r3, [r3, #8]
    cca8:	6f5c      	ldr	r4, [r3, #116]	; 0x74
	}

	if (heap != NULL) {
    ccaa:	b17c      	cbz	r4, cccc <z_thread_aligned_alloc+0x34>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
    ccac:	1d2a      	adds	r2, r5, #4
    ccae:	d209      	bcs.n	ccc4 <z_thread_aligned_alloc+0x2c>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
    ccb0:	2000      	movs	r0, #0
    ccb2:	2100      	movs	r1, #0
    ccb4:	e9cd 0100 	strd	r0, r1, [sp]
    ccb8:	f046 0104 	orr.w	r1, r6, #4
    ccbc:	4620      	mov	r0, r4
    ccbe:	f002 fc1d 	bl	f4fc <k_heap_aligned_alloc>
	if (mem == NULL) {
    ccc2:	b908      	cbnz	r0, ccc8 <z_thread_aligned_alloc+0x30>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
    ccc4:	2400      	movs	r4, #0
	}

	return ret;
    ccc6:	e001      	b.n	cccc <z_thread_aligned_alloc+0x34>
	*heap_ref = heap;
    ccc8:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
    ccca:	1d04      	adds	r4, r0, #4
}
    cccc:	4620      	mov	r0, r4
    ccce:	b002      	add	sp, #8
    ccd0:	bd70      	pop	{r4, r5, r6, pc}
    ccd2:	bf00      	nop
    ccd4:	20001bc4 	.word	0x20001bc4

0000ccd8 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    ccd8:	4a02      	ldr	r2, [pc, #8]	; (cce4 <boot_banner+0xc>)
    ccda:	4903      	ldr	r1, [pc, #12]	; (cce8 <boot_banner+0x10>)
    ccdc:	4803      	ldr	r0, [pc, #12]	; (ccec <boot_banner+0x14>)
    ccde:	f000 b88e 	b.w	cdfe <printk>
    cce2:	bf00      	nop
    cce4:	00010833 	.word	0x00010833
    cce8:	00012107 	.word	0x00012107
    ccec:	00012123 	.word	0x00012123

0000ccf0 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
    ccf0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
    ccf2:	4b09      	ldr	r3, [pc, #36]	; (cd18 <k_sys_work_q_init+0x28>)
    ccf4:	9302      	str	r3, [sp, #8]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
    ccf6:	ab02      	add	r3, sp, #8
	struct k_work_queue_config cfg = {
    ccf8:	2400      	movs	r4, #0
	k_work_queue_start(&k_sys_work_q,
    ccfa:	9300      	str	r3, [sp, #0]
    ccfc:	4907      	ldr	r1, [pc, #28]	; (cd1c <k_sys_work_q_init+0x2c>)
    ccfe:	4808      	ldr	r0, [pc, #32]	; (cd20 <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
    cd00:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
    cd04:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cd08:	f44f 6280 	mov.w	r2, #1024	; 0x400
    cd0c:	f7ff f94e 	bl	bfac <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
    cd10:	4620      	mov	r0, r4
    cd12:	b004      	add	sp, #16
    cd14:	bd10      	pop	{r4, pc}
    cd16:	bf00      	nop
    cd18:	0001214a 	.word	0x0001214a
    cd1c:	20003be0 	.word	0x20003be0
    cd20:	20000ee8 	.word	0x20000ee8

0000cd24 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    cd24:	4770      	bx	lr

0000cd26 <cbpprintf>:
	va_end(ap);
	return ret;
}

int cbpprintf(cbprintf_cb out, void *ctx, void *packaged)
{
    cd26:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    cd2a:	4606      	mov	r6, r0
    cd2c:	460f      	mov	r7, r1
	uint8_t *buf = packaged;
	char *fmt, *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, s_idx;

	if (buf == NULL) {
    cd2e:	4615      	mov	r5, r2
    cd30:	b1fa      	cbz	r2, cd72 <cbpprintf+0x4c>
	args_size = buf[0] * sizeof(int);
	s_nbr     = buf[1];
	ros_nbr   = buf[2];

	/* Locate the string table */
	s = (char *)(buf + args_size + ros_nbr);
    cd32:	7810      	ldrb	r0, [r2, #0]
    cd34:	7894      	ldrb	r4, [r2, #2]
	s_nbr     = buf[1];
    cd36:	f892 9001 	ldrb.w	r9, [r2, #1]
	s = (char *)(buf + args_size + ros_nbr);
    cd3a:	eb04 0480 	add.w	r4, r4, r0, lsl #2
    cd3e:	4414      	add	r4, r2

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
    cd40:	f04f 0800 	mov.w	r8, #0
    cd44:	45c8      	cmp	r8, r9
    cd46:	d308      	bcc.n	cd5a <cbpprintf+0x34>
	return cbvprintf(out, ctx, fmt, u.ap);
    cd48:	686a      	ldr	r2, [r5, #4]
    cd4a:	f105 0308 	add.w	r3, r5, #8
    cd4e:	4639      	mov	r1, r7
    cd50:	4630      	mov	r0, r6
	/* skip past format string pointer */
	buf += sizeof(char *) * 2;

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, ctx, fmt, buf);
}
    cd52:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return cbvprintf(out, ctx, fmt, u.ap);
    cd56:	f7f3 bfd7 	b.w	d08 <cbvprintf>
		ps = (char **)(buf + s_idx * sizeof(int));
    cd5a:	f814 3b01 	ldrb.w	r3, [r4], #1
		*ps = s;
    cd5e:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
		s += strlen(s) + 1;
    cd62:	4620      	mov	r0, r4
    cd64:	f000 fe22 	bl	d9ac <strlen>
    cd68:	3001      	adds	r0, #1
    cd6a:	4404      	add	r4, r0
	for (i = 0; i < s_nbr; i++) {
    cd6c:	f108 0801 	add.w	r8, r8, #1
    cd70:	e7e8      	b.n	cd44 <cbpprintf+0x1e>
}
    cd72:	f06f 0015 	mvn.w	r0, #21
    cd76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000cd7a <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    cd7a:	4603      	mov	r3, r0
    cd7c:	b140      	cbz	r0, cd90 <sys_notify_validate+0x16>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    cd7e:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    cd80:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    cd84:	2a02      	cmp	r2, #2
    cd86:	d006      	beq.n	cd96 <sys_notify_validate+0x1c>
    cd88:	2a03      	cmp	r2, #3
    cd8a:	d004      	beq.n	cd96 <sys_notify_validate+0x1c>
    cd8c:	2a01      	cmp	r2, #1
    cd8e:	d005      	beq.n	cd9c <sys_notify_validate+0x22>
		return -EINVAL;
    cd90:	f06f 0015 	mvn.w	r0, #21
	if (rv == 0) {
		notify->result = 0;
	}

	return rv;
}
    cd94:	4770      	bx	lr
		if (notify->method.signal == NULL) {
    cd96:	681a      	ldr	r2, [r3, #0]
    cd98:	2a00      	cmp	r2, #0
    cd9a:	d0f9      	beq.n	cd90 <sys_notify_validate+0x16>
		notify->result = 0;
    cd9c:	2000      	movs	r0, #0
    cd9e:	6098      	str	r0, [r3, #8]
    cda0:	4770      	bx	lr

0000cda2 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    cda2:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    cda4:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
    cda8:	2a02      	cmp	r2, #2
{
    cdaa:	b510      	push	{r4, lr}
    cdac:	4603      	mov	r3, r0
	notify->result = res;
    cdae:	6081      	str	r1, [r0, #8]
	switch (method) {
    cdb0:	d00a      	beq.n	cdc8 <sys_notify_finalize+0x26>
    cdb2:	2a03      	cmp	r2, #3
    cdb4:	d10b      	bne.n	cdce <sys_notify_finalize+0x2c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    cdb6:	6804      	ldr	r4, [r0, #0]
	struct k_poll_signal *sig = NULL;
    cdb8:	2000      	movs	r0, #0
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    cdba:	2200      	movs	r2, #0
    cdbc:	605a      	str	r2, [r3, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
    cdbe:	b108      	cbz	r0, cdc4 <sys_notify_finalize+0x22>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
    cdc0:	f7ff ff42 	bl	cc48 <z_impl_k_poll_signal_raise>
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    cdc4:	4620      	mov	r0, r4
    cdc6:	bd10      	pop	{r4, pc}
		sig = notify->method.signal;
    cdc8:	6800      	ldr	r0, [r0, #0]
	sys_notify_generic_callback rv = NULL;
    cdca:	2400      	movs	r4, #0
		break;
    cdcc:	e7f5      	b.n	cdba <sys_notify_finalize+0x18>
	switch (method) {
    cdce:	2400      	movs	r4, #0
    cdd0:	4620      	mov	r0, r4
    cdd2:	e7f2      	b.n	cdba <sys_notify_finalize+0x18>

0000cdd4 <arch_printk_char_out>:
}
    cdd4:	2000      	movs	r0, #0
    cdd6:	4770      	bx	lr

0000cdd8 <str_out>:
{
    cdd8:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    cdda:	688a      	ldr	r2, [r1, #8]
    cddc:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
    cdde:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    cde0:	b114      	cbz	r4, cde8 <str_out+0x10>
    cde2:	684b      	ldr	r3, [r1, #4]
    cde4:	4293      	cmp	r3, r2
    cde6:	dc01      	bgt.n	cdec <str_out+0x14>
		ctx->count++;
    cde8:	608d      	str	r5, [r1, #8]
}
    cdea:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
    cdec:	3b01      	subs	r3, #1
    cdee:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
    cdf0:	bf08      	it	eq
    cdf2:	2200      	moveq	r2, #0
    cdf4:	608d      	str	r5, [r1, #8]
    cdf6:	bf0c      	ite	eq
    cdf8:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
    cdfa:	54a0      	strbne	r0, [r4, r2]
    cdfc:	e7f5      	b.n	cdea <str_out+0x12>

0000cdfe <printk>:
{
    cdfe:	b40f      	push	{r0, r1, r2, r3}
    ce00:	b507      	push	{r0, r1, r2, lr}
    ce02:	a904      	add	r1, sp, #16
    ce04:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    ce08:	9101      	str	r1, [sp, #4]
		z_log_vprintk(fmt, ap);
    ce0a:	f000 fd20 	bl	d84e <z_log_vprintk>
}
    ce0e:	b003      	add	sp, #12
    ce10:	f85d eb04 	ldr.w	lr, [sp], #4
    ce14:	b004      	add	sp, #16
    ce16:	4770      	bx	lr

0000ce18 <snprintk>:
{
    ce18:	b40c      	push	{r2, r3}
    ce1a:	b507      	push	{r0, r1, r2, lr}
    ce1c:	ab04      	add	r3, sp, #16
    ce1e:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
    ce22:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
    ce24:	f7f3 fe7c 	bl	b20 <vsnprintk>
}
    ce28:	b003      	add	sp, #12
    ce2a:	f85d eb04 	ldr.w	lr, [sp], #4
    ce2e:	b002      	add	sp, #8
    ce30:	4770      	bx	lr

0000ce32 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    ce32:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
    ce34:	f013 0307 	ands.w	r3, r3, #7
    ce38:	d105      	bne.n	ce46 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
    ce3a:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
    ce3c:	2b00      	cmp	r3, #0
    ce3e:	bf0c      	ite	eq
    ce40:	2000      	moveq	r0, #0
    ce42:	2003      	movne	r0, #3
    ce44:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
    ce46:	2b02      	cmp	r3, #2
    ce48:	d105      	bne.n	ce56 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
    ce4a:	8b43      	ldrh	r3, [r0, #26]
		evt = EVT_STOP;
    ce4c:	2b00      	cmp	r3, #0
    ce4e:	bf14      	ite	ne
    ce50:	2000      	movne	r0, #0
    ce52:	2004      	moveq	r0, #4
    ce54:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
    ce56:	2b01      	cmp	r3, #1
    ce58:	d105      	bne.n	ce66 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
    ce5a:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
    ce5c:	2b00      	cmp	r3, #0
    ce5e:	bf0c      	ite	eq
    ce60:	2000      	moveq	r0, #0
    ce62:	2005      	movne	r0, #5
    ce64:	4770      	bx	lr
	int evt = EVT_NOP;
    ce66:	2000      	movs	r0, #0
}
    ce68:	4770      	bx	lr

0000ce6a <notify_one>:
{
    ce6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ce6e:	460d      	mov	r5, r1
    ce70:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    ce72:	4619      	mov	r1, r3
    ce74:	1d28      	adds	r0, r5, #4
{
    ce76:	4690      	mov	r8, r2
    ce78:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    ce7a:	f7ff ff92 	bl	cda2 <sys_notify_finalize>
	if (cb) {
    ce7e:	4604      	mov	r4, r0
    ce80:	b138      	cbz	r0, ce92 <notify_one+0x28>
		cb(mgr, cli, state, res);
    ce82:	4633      	mov	r3, r6
    ce84:	4642      	mov	r2, r8
    ce86:	4629      	mov	r1, r5
    ce88:	4638      	mov	r0, r7
    ce8a:	46a4      	mov	ip, r4
}
    ce8c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
    ce90:	4760      	bx	ip
}
    ce92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000ce96 <transition_complete>:
{
    ce96:	b410      	push	{r4}
	__asm__ volatile(
    ce98:	f04f 0420 	mov.w	r4, #32
    ce9c:	f3ef 8211 	mrs	r2, BASEPRI
    cea0:	f384 8812 	msr	BASEPRI_MAX, r4
    cea4:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
    cea8:	6141      	str	r1, [r0, #20]
}
    ceaa:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
    ceac:	2101      	movs	r1, #1
    ceae:	f7f3 be4b 	b.w	b48 <process_event>

0000ceb2 <validate_args>:
{
    ceb2:	b510      	push	{r4, lr}
    ceb4:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    ceb6:	b140      	cbz	r0, ceca <validate_args+0x18>
    ceb8:	b139      	cbz	r1, ceca <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
    ceba:	1d08      	adds	r0, r1, #4
    cebc:	f7ff ff5d 	bl	cd7a <sys_notify_validate>
	if ((rv == 0)
    cec0:	b928      	cbnz	r0, cece <validate_args+0x1c>
	    && ((cli->notify.flags
    cec2:	68a3      	ldr	r3, [r4, #8]
    cec4:	f033 0303 	bics.w	r3, r3, #3
    cec8:	d001      	beq.n	cece <validate_args+0x1c>
		rv = -EINVAL;
    ceca:	f06f 0015 	mvn.w	r0, #21
}
    cece:	bd10      	pop	{r4, pc}

0000ced0 <onoff_manager_init>:
{
    ced0:	b538      	push	{r3, r4, r5, lr}
    ced2:	460c      	mov	r4, r1
	if ((mgr == NULL)
    ced4:	4605      	mov	r5, r0
    ced6:	b158      	cbz	r0, cef0 <onoff_manager_init+0x20>
	    || (transitions == NULL)
    ced8:	b151      	cbz	r1, cef0 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
    ceda:	680b      	ldr	r3, [r1, #0]
    cedc:	b143      	cbz	r3, cef0 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
    cede:	684b      	ldr	r3, [r1, #4]
    cee0:	b133      	cbz	r3, cef0 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    cee2:	221c      	movs	r2, #28
    cee4:	2100      	movs	r1, #0
    cee6:	f000 fd99 	bl	da1c <memset>
    ceea:	612c      	str	r4, [r5, #16]
	return 0;
    ceec:	2000      	movs	r0, #0
}
    ceee:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    cef0:	f06f 0015 	mvn.w	r0, #21
    cef4:	e7fb      	b.n	ceee <onoff_manager_init+0x1e>

0000cef6 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
    cef6:	b570      	push	{r4, r5, r6, lr}
    cef8:	4604      	mov	r4, r0
    cefa:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
    cefc:	f7ff ffd9 	bl	ceb2 <validate_args>

	if (rv < 0) {
    cf00:	1e05      	subs	r5, r0, #0
    cf02:	db31      	blt.n	cf68 <onoff_request+0x72>
    cf04:	f04f 0320 	mov.w	r3, #32
    cf08:	f3ef 8111 	mrs	r1, BASEPRI
    cf0c:	f383 8812 	msr	BASEPRI_MAX, r3
    cf10:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
    cf14:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    cf16:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
    cf18:	f64f 75ff 	movw	r5, #65535	; 0xffff
    cf1c:	42ab      	cmp	r3, r5
    cf1e:	f000 0207 	and.w	r2, r0, #7
    cf22:	d02e      	beq.n	cf82 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
    cf24:	2a02      	cmp	r2, #2
    cf26:	d10e      	bne.n	cf46 <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
    cf28:	3301      	adds	r3, #1
    cf2a:	8363      	strh	r3, [r4, #26]
	rv = state;
    cf2c:	4615      	mov	r5, r2
		notify = true;
    cf2e:	2301      	movs	r3, #1
	__asm__ volatile(
    cf30:	f381 8811 	msr	BASEPRI, r1
    cf34:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
    cf38:	b1b3      	cbz	r3, cf68 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
    cf3a:	2300      	movs	r3, #0
    cf3c:	4631      	mov	r1, r6
    cf3e:	4620      	mov	r0, r4
    cf40:	f7ff ff93 	bl	ce6a <notify_one>
    cf44:	e010      	b.n	cf68 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
    cf46:	0783      	lsls	r3, r0, #30
    cf48:	d001      	beq.n	cf4e <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
    cf4a:	2a06      	cmp	r2, #6
    cf4c:	d10e      	bne.n	cf6c <onoff_request+0x76>
	parent->next = child;
    cf4e:	2300      	movs	r3, #0
    cf50:	6033      	str	r3, [r6, #0]
	return list->tail;
    cf52:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_APPEND(slist, snode)
    cf54:	b993      	cbnz	r3, cf7c <onoff_request+0x86>
	list->head = node;
    cf56:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
    cf5a:	4615      	mov	r5, r2
    cf5c:	b962      	cbnz	r2, cf78 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
    cf5e:	460a      	mov	r2, r1
    cf60:	4620      	mov	r0, r4
    cf62:	2102      	movs	r1, #2
    cf64:	f7f3 fdf0 	bl	b48 <process_event>
		}
	}

	return rv;
}
    cf68:	4628      	mov	r0, r5
    cf6a:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
    cf6c:	2a05      	cmp	r2, #5
    cf6e:	bf0c      	ite	eq
    cf70:	f06f 0585 	mvneq.w	r5, #133	; 0x85
    cf74:	f06f 0504 	mvnne.w	r5, #4
    cf78:	2300      	movs	r3, #0
    cf7a:	e7d9      	b.n	cf30 <onoff_request+0x3a>
	parent->next = child;
    cf7c:	601e      	str	r6, [r3, #0]
	list->tail = node;
    cf7e:	6066      	str	r6, [r4, #4]
}
    cf80:	e7eb      	b.n	cf5a <onoff_request+0x64>
		rv = -EAGAIN;
    cf82:	f06f 050a 	mvn.w	r5, #10
    cf86:	e7f7      	b.n	cf78 <onoff_request+0x82>

0000cf88 <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
    cf88:	b510      	push	{r4, lr}
	__asm__ volatile(
    cf8a:	f04f 0320 	mov.w	r3, #32
    cf8e:	f3ef 8211 	mrs	r2, BASEPRI
    cf92:	f383 8812 	msr	BASEPRI_MAX, r3
    cf96:	f3bf 8f6f 	isb	sy
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    cf9a:	8b04      	ldrh	r4, [r0, #24]
    cf9c:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
    cfa0:	2c02      	cmp	r4, #2
    cfa2:	d00a      	beq.n	cfba <onoff_release+0x32>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
    cfa4:	2c01      	cmp	r4, #1
    cfa6:	bf0c      	ite	eq
    cfa8:	f06f 0004 	mvneq.w	r0, #4
    cfac:	f06f 0085 	mvnne.w	r0, #133	; 0x85
	__asm__ volatile(
    cfb0:	f382 8811 	msr	BASEPRI, r2
    cfb4:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
    cfb8:	e008      	b.n	cfcc <onoff_release+0x44>
	mgr->refs -= 1U;
    cfba:	8b43      	ldrh	r3, [r0, #26]
    cfbc:	3b01      	subs	r3, #1
    cfbe:	b29b      	uxth	r3, r3
    cfc0:	8343      	strh	r3, [r0, #26]
	if (stop) {
    cfc2:	b923      	cbnz	r3, cfce <onoff_release+0x46>
		process_event(mgr, EVT_RECHECK, key);
    cfc4:	4621      	mov	r1, r4
    cfc6:	f7f3 fdbf 	bl	b48 <process_event>
	int rv = state;
    cfca:	4620      	mov	r0, r4
}
    cfcc:	bd10      	pop	{r4, pc}
	int rv = state;
    cfce:	4620      	mov	r0, r4
    cfd0:	e7ee      	b.n	cfb0 <onoff_release+0x28>

0000cfd2 <onoff_sync_lock>:
	__asm__ volatile(
    cfd2:	f04f 0220 	mov.w	r2, #32
    cfd6:	f3ef 8311 	mrs	r3, BASEPRI
    cfda:	f382 8812 	msr	BASEPRI_MAX, r2
    cfde:	f3bf 8f6f 	isb	sy
int onoff_sync_lock(struct onoff_sync_service *srv,
		    k_spinlock_key_t *keyp)
{
	*keyp = k_spin_lock(&srv->lock);
	return srv->count;
}
    cfe2:	6800      	ldr	r0, [r0, #0]
	*keyp = k_spin_lock(&srv->lock);
    cfe4:	600b      	str	r3, [r1, #0]
}
    cfe6:	4770      	bx	lr

0000cfe8 <onoff_sync_finalize>:
int onoff_sync_finalize(struct onoff_sync_service *srv,
			k_spinlock_key_t key,
			struct onoff_client *cli,
			int res,
			bool on)
{
    cfe8:	b538      	push	{r3, r4, r5, lr}

	/* Clear errors visible when locked.  If they are to be
	 * preserved the caller must finalize with the previous
	 * error code.
	 */
	if (srv->count < 0) {
    cfea:	6804      	ldr	r4, [r0, #0]
    cfec:	2c00      	cmp	r4, #0
		srv->count = 0;
    cfee:	bfbc      	itt	lt
    cff0:	2400      	movlt	r4, #0
    cff2:	6004      	strlt	r4, [r0, #0]
	}
	if (res < 0) {
    cff4:	2b00      	cmp	r3, #0
{
    cff6:	460d      	mov	r5, r1
    cff8:	4611      	mov	r1, r2
    cffa:	f89d 2010 	ldrb.w	r2, [sp, #16]
	if (res < 0) {
    cffe:	da0c      	bge.n	d01a <onoff_sync_finalize+0x32>
		srv->count = res;
    d000:	6003      	str	r3, [r0, #0]
		state = ONOFF_STATE_ERROR;
    d002:	2201      	movs	r2, #1
		 * callbacks are used only when turning on don't
		 * bother changing it.
		 */
	}

	int rv = srv->count;
    d004:	6804      	ldr	r4, [r0, #0]
	__asm__ volatile(
    d006:	f385 8811 	msr	BASEPRI, r5
    d00a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&srv->lock, key);

	if (cli) {
    d00e:	b111      	cbz	r1, d016 <onoff_sync_finalize+0x2e>
		/* Detect service mis-use: onoff does not callback on transition
		 * to off, so no client should have been passed.
		 */
		__ASSERT_NO_MSG(on);
		notify_one(NULL, cli, state, res);
    d010:	2000      	movs	r0, #0
    d012:	f7ff ff2a 	bl	ce6a <notify_one>
	}

	return rv;
}
    d016:	4620      	mov	r0, r4
    d018:	bd38      	pop	{r3, r4, r5, pc}
		srv->count += 1;
    d01a:	6804      	ldr	r4, [r0, #0]
	} else if (on) {
    d01c:	b11a      	cbz	r2, d026 <onoff_sync_finalize+0x3e>
		srv->count += 1;
    d01e:	3401      	adds	r4, #1
		srv->count -= 1;
    d020:	6004      	str	r4, [r0, #0]
	uint32_t state = ONOFF_STATE_ON;
    d022:	2202      	movs	r2, #2
    d024:	e7ee      	b.n	d004 <onoff_sync_finalize+0x1c>
		srv->count -= 1;
    d026:	3c01      	subs	r4, #1
    d028:	e7fa      	b.n	d020 <onoff_sync_finalize+0x38>

0000d02a <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    d02a:	4604      	mov	r4, r0
    d02c:	b508      	push	{r3, lr}
    d02e:	4608      	mov	r0, r1
    d030:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    d032:	461a      	mov	r2, r3
    d034:	47a0      	blx	r4
	return z_impl_z_current_get();
    d036:	f7ff fb45 	bl	c6c4 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    d03a:	f7f5 fcf9 	bl	2a30 <z_impl_k_thread_abort>

0000d03e <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
    d03e:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    d042:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
    d044:	0840      	lsrs	r0, r0, #1
    d046:	4770      	bx	lr

0000d048 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    d048:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d04a:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
    d04c:	f7ff fff7 	bl	d03e <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
    d050:	fab0 f080 	clz	r0, r0
    d054:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
    d058:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
	void *cmem = &buf[c];
    d05c:	00ca      	lsls	r2, r1, #3
    d05e:	f8dc 6010 	ldr.w	r6, [ip, #16]
		((uint16_t *)cmem)[f] = val;
    d062:	1d17      	adds	r7, r2, #4
{
    d064:	460c      	mov	r4, r1
    d066:	3206      	adds	r2, #6
    d068:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
    d06a:	b956      	cbnz	r6, d082 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
    d06c:	2101      	movs	r1, #1
    d06e:	fa01 f000 	lsl.w	r0, r1, r0
    d072:	68d9      	ldr	r1, [r3, #12]
    d074:	4301      	orrs	r1, r0
    d076:	60d9      	str	r1, [r3, #12]
		b->next = c;
    d078:	f8cc 4010 	str.w	r4, [ip, #16]
    d07c:	53dd      	strh	r5, [r3, r7]
    d07e:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
    d080:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
    d082:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
    d084:	3104      	adds	r1, #4
    d086:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
    d088:	53d8      	strh	r0, [r3, r7]
    d08a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    d08e:	529e      	strh	r6, [r3, r2]
    d090:	80c5      	strh	r5, [r0, #6]
    d092:	525d      	strh	r5, [r3, r1]
    d094:	e7f4      	b.n	d080 <free_list_add+0x38>

0000d096 <free_list_remove_bidx>:
{
    d096:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
    d098:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    d09c:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
    d09e:	4299      	cmp	r1, r3
    d0a0:	f102 0104 	add.w	r1, r2, #4
    d0a4:	d10a      	bne.n	d0bc <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
    d0a6:	2301      	movs	r3, #1
    d0a8:	fa03 f202 	lsl.w	r2, r3, r2
    d0ac:	68c3      	ldr	r3, [r0, #12]
    d0ae:	ea23 0302 	bic.w	r3, r3, r2
    d0b2:	60c3      	str	r3, [r0, #12]
		b->next = 0;
    d0b4:	2300      	movs	r3, #0
    d0b6:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
    d0ba:	bd10      	pop	{r4, pc}
    d0bc:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
    d0be:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
    d0c2:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
    d0c6:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    d0ca:	80cb      	strh	r3, [r1, #6]
    d0cc:	8082      	strh	r2, [r0, #4]
}
    d0ce:	e7f4      	b.n	d0ba <free_list_remove_bidx+0x24>

0000d0d0 <free_list_remove>:
{
    d0d0:	b508      	push	{r3, lr}
    d0d2:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
    d0d4:	f7ff ffb3 	bl	d03e <chunk_size>
	return 31 - __builtin_clz(usable_sz);
    d0d8:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
    d0dc:	f1c2 021f 	rsb	r2, r2, #31
    d0e0:	4618      	mov	r0, r3
}
    d0e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
    d0e6:	f7ff bfd6 	b.w	d096 <free_list_remove_bidx>

0000d0ea <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
    d0ea:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d0ee:	fab1 f581 	clz	r5, r1
    d0f2:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
    d0f6:	eb00 0789 	add.w	r7, r0, r9, lsl #2
{
    d0fa:	4603      	mov	r3, r0
	if (b->next) {
    d0fc:	693a      	ldr	r2, [r7, #16]
{
    d0fe:	460e      	mov	r6, r1
	if (b->next) {
    d100:	b1c2      	cbz	r2, d134 <alloc_chunk+0x4a>
    d102:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
    d106:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
    d108:	4618      	mov	r0, r3
    d10a:	4621      	mov	r1, r4
    d10c:	f7ff ff97 	bl	d03e <chunk_size>
    d110:	42b0      	cmp	r0, r6
    d112:	d306      	bcc.n	d122 <alloc_chunk+0x38>
				free_list_remove_bidx(h, c, bi);
    d114:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
    d116:	4618      	mov	r0, r3
    d118:	f7ff ffbd 	bl	d096 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
    d11c:	4620      	mov	r0, r4
    d11e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
    d122:	eb03 00c4 	add.w	r0, r3, r4, lsl #3
		} while (--i && b->next != first);
    d126:	f1b8 0801 	subs.w	r8, r8, #1
    d12a:	88c0      	ldrh	r0, [r0, #6]
			b->next = next_free_chunk(h, c);
    d12c:	6138      	str	r0, [r7, #16]
		} while (--i && b->next != first);
    d12e:	d001      	beq.n	d134 <alloc_chunk+0x4a>
    d130:	4282      	cmp	r2, r0
    d132:	d1e8      	bne.n	d106 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
    d134:	f1c5 0220 	rsb	r2, r5, #32
    d138:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    d13c:	4094      	lsls	r4, r2
    d13e:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
    d140:	4014      	ands	r4, r2
    d142:	d0eb      	beq.n	d11c <alloc_chunk+0x32>
		int minbucket = __builtin_ctz(bmask);
    d144:	fa94 f2a4 	rbit	r2, r4
    d148:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
    d14c:	1d11      	adds	r1, r2, #4
    d14e:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
    d152:	4621      	mov	r1, r4
    d154:	e7df      	b.n	d116 <alloc_chunk+0x2c>

0000d156 <merge_chunks>:
{
    d156:	b538      	push	{r3, r4, r5, lr}
    d158:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    d15a:	f7ff ff70 	bl	d03e <chunk_size>
{
    d15e:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    d160:	4604      	mov	r4, r0
    d162:	4611      	mov	r1, r2
    d164:	4618      	mov	r0, r3
    d166:	f7ff ff6a 	bl	d03e <chunk_size>
		((uint16_t *)cmem)[f] = val;
    d16a:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
    d16e:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    d170:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
    d172:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
    d174:	4618      	mov	r0, r3
    d176:	f7ff ff62 	bl	d03e <chunk_size>
	void *cmem = &buf[c];
    d17a:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
    d17c:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
    d180:	bd38      	pop	{r3, r4, r5, pc}

0000d182 <split_chunks>:
{
    d182:	b538      	push	{r3, r4, r5, lr}
    d184:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
    d186:	f7ff ff5a 	bl	d03e <chunk_size>
{
    d18a:	460c      	mov	r4, r1
	chunksz_t rsz = sz0 - lsz;
    d18c:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
    d18e:	1a51      	subs	r1, r2, r1
    d190:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunksz_t rsz = sz0 - lsz;
    d194:	4405      	add	r5, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    d196:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
    d198:	8060      	strh	r0, [r4, #2]
    d19a:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    d19e:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
    d1a0:	8044      	strh	r4, [r0, #2]
    d1a2:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
    d1a6:	4618      	mov	r0, r3
    d1a8:	4611      	mov	r1, r2
    d1aa:	f7ff ff48 	bl	d03e <chunk_size>
	void *cmem = &buf[c];
    d1ae:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
    d1b0:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
    d1b4:	bd38      	pop	{r3, r4, r5, pc}

0000d1b6 <free_chunk>:
{
    d1b6:	b538      	push	{r3, r4, r5, lr}
    d1b8:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
    d1ba:	f7ff ff40 	bl	d03e <chunk_size>
    d1be:	460c      	mov	r4, r1
    d1c0:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
    d1c2:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    d1c6:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
    d1c8:	07da      	lsls	r2, r3, #31
    d1ca:	d40a      	bmi.n	d1e2 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
    d1cc:	4628      	mov	r0, r5
    d1ce:	f7ff ff7f 	bl	d0d0 <free_list_remove>
	return c + chunk_size(h, c);
    d1d2:	4621      	mov	r1, r4
    d1d4:	4628      	mov	r0, r5
    d1d6:	f7ff ff32 	bl	d03e <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
    d1da:	1822      	adds	r2, r4, r0
    d1dc:	4628      	mov	r0, r5
    d1de:	f7ff ffba 	bl	d156 <merge_chunks>
		return ((uint16_t *)cmem)[f];
    d1e2:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
    d1e6:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
    d1e8:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    d1ec:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
    d1ee:	07db      	lsls	r3, r3, #31
    d1f0:	d40c      	bmi.n	d20c <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
    d1f2:	4628      	mov	r0, r5
    d1f4:	f7ff ff6c 	bl	d0d0 <free_list_remove>
		return ((uint16_t *)cmem)[f];
    d1f8:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
    d1fc:	4622      	mov	r2, r4
    d1fe:	1a61      	subs	r1, r4, r1
    d200:	4628      	mov	r0, r5
    d202:	f7ff ffa8 	bl	d156 <merge_chunks>
    d206:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
    d20a:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
    d20c:	4621      	mov	r1, r4
    d20e:	4628      	mov	r0, r5
}
    d210:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
    d214:	f7ff bf18 	b.w	d048 <free_list_add>

0000d218 <sys_heap_free>:
	if (mem == NULL) {
    d218:	b161      	cbz	r1, d234 <sys_heap_free+0x1c>
    d21a:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    d21c:	3904      	subs	r1, #4
    d21e:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
    d220:	f021 0307 	bic.w	r3, r1, #7
    d224:	4403      	add	r3, r0
	free_chunk(h, c);
    d226:	08c9      	lsrs	r1, r1, #3
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
    d228:	885a      	ldrh	r2, [r3, #2]
    d22a:	f022 0201 	bic.w	r2, r2, #1
    d22e:	805a      	strh	r2, [r3, #2]
    d230:	f7ff bfc1 	b.w	d1b6 <free_chunk>
}
    d234:	4770      	bx	lr

0000d236 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
    d236:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
    d238:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
    d23a:	b909      	cbnz	r1, d240 <sys_heap_alloc+0xa>
		return NULL;
    d23c:	2000      	movs	r0, #0
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
}
    d23e:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
    d240:	68ab      	ldr	r3, [r5, #8]
    d242:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
    d246:	d9f9      	bls.n	d23c <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    d248:	310b      	adds	r1, #11
    d24a:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
    d24c:	4621      	mov	r1, r4
    d24e:	4628      	mov	r0, r5
    d250:	f7ff ff4b 	bl	d0ea <alloc_chunk>
	if (c == 0U) {
    d254:	4606      	mov	r6, r0
    d256:	2800      	cmp	r0, #0
    d258:	d0f0      	beq.n	d23c <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
    d25a:	4601      	mov	r1, r0
    d25c:	4628      	mov	r0, r5
    d25e:	f7ff feee 	bl	d03e <chunk_size>
    d262:	42a0      	cmp	r0, r4
    d264:	d907      	bls.n	d276 <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
    d266:	1932      	adds	r2, r6, r4
    d268:	4628      	mov	r0, r5
    d26a:	f7ff ff8a 	bl	d182 <split_chunks>
		free_list_add(h, c + chunk_sz);
    d26e:	4611      	mov	r1, r2
    d270:	4628      	mov	r0, r5
    d272:	f7ff fee9 	bl	d048 <free_list_add>
	void *cmem = &buf[c];
    d276:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
    d27a:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    d27c:	8853      	ldrh	r3, [r2, #2]
    d27e:	f043 0301 	orr.w	r3, r3, #1
    d282:	8053      	strh	r3, [r2, #2]
    d284:	3004      	adds	r0, #4
	return mem;
    d286:	e7da      	b.n	d23e <sys_heap_alloc+0x8>

0000d288 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
    d288:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d28c:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
    d28e:	424a      	negs	r2, r1
    d290:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
    d294:	ea31 0202 	bics.w	r2, r1, r2
{
    d298:	4603      	mov	r3, r0
	if (align != rew) {
    d29a:	d00a      	beq.n	d2b2 <sys_heap_aligned_alloc+0x2a>
		return false;
    d29c:	2f04      	cmp	r7, #4
    d29e:	463a      	mov	r2, r7
    d2a0:	46b9      	mov	r9, r7
    d2a2:	bf28      	it	cs
    d2a4:	2204      	movcs	r2, #4
		align -= rew;
    d2a6:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
    d2a8:	b974      	cbnz	r4, d2c8 <sys_heap_aligned_alloc+0x40>
		return NULL;
    d2aa:	2500      	movs	r5, #0
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
}
    d2ac:	4628      	mov	r0, r5
    d2ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
    d2b2:	2904      	cmp	r1, #4
    d2b4:	d804      	bhi.n	d2c0 <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
    d2b6:	4621      	mov	r1, r4
}
    d2b8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
    d2bc:	f7ff bfbb 	b.w	d236 <sys_heap_alloc>
		rew = 0;
    d2c0:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
    d2c4:	2204      	movs	r2, #4
    d2c6:	e7ef      	b.n	d2a8 <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
    d2c8:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
    d2ca:	68b3      	ldr	r3, [r6, #8]
    d2cc:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
    d2d0:	d9eb      	bls.n	d2aa <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    d2d2:	f104 010b 	add.w	r1, r4, #11
    d2d6:	4439      	add	r1, r7
    d2d8:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    d2da:	08c9      	lsrs	r1, r1, #3
    d2dc:	4630      	mov	r0, r6
    d2de:	f7ff ff04 	bl	d0ea <alloc_chunk>
	if (c0 == 0) {
    d2e2:	4680      	mov	r8, r0
    d2e4:	2800      	cmp	r0, #0
    d2e6:	d0e0      	beq.n	d2aa <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
    d2e8:	f109 0504 	add.w	r5, r9, #4
    d2ec:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
    d2f0:	1e7b      	subs	r3, r7, #1
    d2f2:	4435      	add	r5, r6
    d2f4:	441d      	add	r5, r3
    d2f6:	427f      	negs	r7, r7
    d2f8:	403d      	ands	r5, r7
    d2fa:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    d2fe:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    d300:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    d302:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    d304:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    d306:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
    d30a:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
    d30c:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    d310:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
    d314:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
    d318:	d208      	bcs.n	d32c <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
    d31a:	4601      	mov	r1, r0
    d31c:	463a      	mov	r2, r7
    d31e:	4630      	mov	r0, r6
    d320:	f7ff ff2f 	bl	d182 <split_chunks>
		free_list_add(h, c0);
    d324:	4641      	mov	r1, r8
    d326:	4630      	mov	r0, r6
    d328:	f7ff fe8e 	bl	d048 <free_list_add>
	return c + chunk_size(h, c);
    d32c:	4639      	mov	r1, r7
    d32e:	4630      	mov	r0, r6
    d330:	f7ff fe85 	bl	d03e <chunk_size>
    d334:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
    d336:	4284      	cmp	r4, r0
    d338:	d207      	bcs.n	d34a <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
    d33a:	4630      	mov	r0, r6
    d33c:	4622      	mov	r2, r4
    d33e:	f7ff ff20 	bl	d182 <split_chunks>
		free_list_add(h, c_end);
    d342:	4621      	mov	r1, r4
    d344:	4630      	mov	r0, r6
    d346:	f7ff fe7f 	bl	d048 <free_list_add>
	void *cmem = &buf[c];
    d34a:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    d34e:	8873      	ldrh	r3, [r6, #2]
    d350:	f043 0301 	orr.w	r3, r3, #1
    d354:	8073      	strh	r3, [r6, #2]
    d356:	e7a9      	b.n	d2ac <sys_heap_aligned_alloc+0x24>

0000d358 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    d358:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    d35a:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    d35c:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    d35e:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    d362:	f021 0107 	bic.w	r1, r1, #7
{
    d366:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    d368:	1acd      	subs	r5, r1, r3
    d36a:	08ea      	lsrs	r2, r5, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
    d36c:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
    d36e:	fab2 f082 	clz	r0, r2
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    d372:	f1c0 0424 	rsb	r4, r0, #36	; 0x24
    d376:	00a4      	lsls	r4, r4, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    d378:	3407      	adds	r4, #7
	h->avail_buckets = 0;
    d37a:	2600      	movs	r6, #0
    d37c:	08e1      	lsrs	r1, r4, #3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    d37e:	f1c0 0020 	rsb	r0, r0, #32
    d382:	f103 0410 	add.w	r4, r3, #16
	h->end_chunk = heap_sz;
    d386:	609a      	str	r2, [r3, #8]
	h->avail_buckets = 0;
    d388:	60de      	str	r6, [r3, #12]
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    d38a:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    d38e:	4284      	cmp	r4, r0
    d390:	d118      	bne.n	d3c4 <sys_heap_init+0x6c>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    d392:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    d394:	f040 0001 	orr.w	r0, r0, #1
    d398:	8058      	strh	r0, [r3, #2]
		((uint16_t *)cmem)[f] = val;
    d39a:	eb03 04c1 	add.w	r4, r3, r1, lsl #3
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    d39e:	1a50      	subs	r0, r2, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    d3a0:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
    d3a2:	801e      	strh	r6, [r3, #0]
    d3a4:	8067      	strh	r7, [r4, #2]
    d3a6:	195c      	adds	r4, r3, r5
    d3a8:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
    d3ac:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
		((uint16_t *)cmem)[f] = val;
    d3b0:	8066      	strh	r6, [r4, #2]
    d3b2:	5358      	strh	r0, [r3, r5]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    d3b4:	8850      	ldrh	r0, [r2, #2]
    d3b6:	f040 0001 	orr.w	r0, r0, #1
    d3ba:	8050      	strh	r0, [r2, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
    d3bc:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
    d3be:	4618      	mov	r0, r3
    d3c0:	f7ff be42 	b.w	d048 <free_list_add>
		h->buckets[i].next = 0;
    d3c4:	f844 6b04 	str.w	r6, [r4], #4
	for (int i = 0; i < nb_buckets; i++) {
    d3c8:	e7e1      	b.n	d38e <sys_heap_init+0x36>

0000d3ca <encode_uint>:
{
    d3ca:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d3ce:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
    d3d0:	78d3      	ldrb	r3, [r2, #3]
	switch (specifier) {
    d3d2:	2b6f      	cmp	r3, #111	; 0x6f
{
    d3d4:	4680      	mov	r8, r0
    d3d6:	460f      	mov	r7, r1
    d3d8:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    d3da:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
    d3de:	d029      	beq.n	d434 <encode_uint+0x6a>
    d3e0:	d824      	bhi.n	d42c <encode_uint+0x62>
		return 16;
    d3e2:	2b58      	cmp	r3, #88	; 0x58
    d3e4:	bf14      	ite	ne
    d3e6:	260a      	movne	r6, #10
    d3e8:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
    d3ea:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
    d3ee:	4632      	mov	r2, r6
    d3f0:	2300      	movs	r3, #0
    d3f2:	4640      	mov	r0, r8
    d3f4:	4639      	mov	r1, r7
    d3f6:	f7f2 fe73 	bl	e0 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    d3fa:	2a09      	cmp	r2, #9
    d3fc:	b2d4      	uxtb	r4, r2
    d3fe:	d81e      	bhi.n	d43e <encode_uint+0x74>
    d400:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
    d402:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
    d404:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
    d406:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
    d40a:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
    d40e:	d301      	bcc.n	d414 <encode_uint+0x4a>
    d410:	45d1      	cmp	r9, sl
    d412:	d811      	bhi.n	d438 <encode_uint+0x6e>
	if (conv->flag_hash) {
    d414:	782b      	ldrb	r3, [r5, #0]
    d416:	069b      	lsls	r3, r3, #26
    d418:	d505      	bpl.n	d426 <encode_uint+0x5c>
		if (radix == 8) {
    d41a:	2e08      	cmp	r6, #8
    d41c:	d115      	bne.n	d44a <encode_uint+0x80>
			conv->altform_0 = true;
    d41e:	78ab      	ldrb	r3, [r5, #2]
    d420:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
    d424:	70ab      	strb	r3, [r5, #2]
}
    d426:	4648      	mov	r0, r9
    d428:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
    d42c:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
    d430:	2b70      	cmp	r3, #112	; 0x70
    d432:	e7d7      	b.n	d3e4 <encode_uint+0x1a>
	switch (specifier) {
    d434:	2608      	movs	r6, #8
    d436:	e7d8      	b.n	d3ea <encode_uint+0x20>
		value /= radix;
    d438:	4680      	mov	r8, r0
    d43a:	460f      	mov	r7, r1
    d43c:	e7d7      	b.n	d3ee <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    d43e:	f1bb 0f19 	cmp.w	fp, #25
    d442:	bf94      	ite	ls
    d444:	3437      	addls	r4, #55	; 0x37
    d446:	3457      	addhi	r4, #87	; 0x57
    d448:	e7db      	b.n	d402 <encode_uint+0x38>
		} else if (radix == 16) {
    d44a:	2e10      	cmp	r6, #16
    d44c:	d1eb      	bne.n	d426 <encode_uint+0x5c>
			conv->altform_0c = true;
    d44e:	78ab      	ldrb	r3, [r5, #2]
    d450:	f043 0310 	orr.w	r3, r3, #16
    d454:	e7e6      	b.n	d424 <encode_uint+0x5a>

0000d456 <outs>:
{
    d456:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d45a:	4607      	mov	r7, r0
    d45c:	4688      	mov	r8, r1
    d45e:	4615      	mov	r5, r2
    d460:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    d462:	4614      	mov	r4, r2
    d464:	42b4      	cmp	r4, r6
    d466:	eba4 0005 	sub.w	r0, r4, r5
    d46a:	d302      	bcc.n	d472 <outs+0x1c>
    d46c:	b93e      	cbnz	r6, d47e <outs+0x28>
    d46e:	7823      	ldrb	r3, [r4, #0]
    d470:	b12b      	cbz	r3, d47e <outs+0x28>
		int rc = out((int)*sp++, ctx);
    d472:	f814 0b01 	ldrb.w	r0, [r4], #1
    d476:	4641      	mov	r1, r8
    d478:	47b8      	blx	r7
		if (rc < 0) {
    d47a:	2800      	cmp	r0, #0
    d47c:	daf2      	bge.n	d464 <outs+0xe>
}
    d47e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000d482 <free_space>:
	err = k_sem_init(&buffer->sem, 0, 1);
	__ASSERT_NO_MSG(err == 0);
}

static inline bool free_space(struct mpsc_pbuf_buffer *buffer, uint32_t *res)
{
    d482:	4602      	mov	r2, r0
    d484:	b510      	push	{r4, lr}
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
    d486:	68c0      	ldr	r0, [r0, #12]
    d488:	6814      	ldr	r4, [r2, #0]
    d48a:	42a0      	cmp	r0, r4
    d48c:	d904      	bls.n	d498 <free_space+0x16>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx - 1;
    d48e:	3801      	subs	r0, #1
    d490:	1b00      	subs	r0, r0, r4
    d492:	6008      	str	r0, [r1, #0]

		return false;
    d494:	2000      	movs	r0, #0
	}

	*res = buffer->size - buffer->tmp_wr_idx;

	return true;
}
    d496:	bd10      	pop	{r4, pc}
		*res = buffer->size - buffer->tmp_wr_idx - 1;
    d498:	6a13      	ldr	r3, [r2, #32]
	} else if (!buffer->rd_idx) {
    d49a:	b918      	cbnz	r0, d4a4 <free_space+0x22>
		*res = buffer->size - buffer->tmp_wr_idx - 1;
    d49c:	3b01      	subs	r3, #1
    d49e:	1b1b      	subs	r3, r3, r4
    d4a0:	600b      	str	r3, [r1, #0]
		return false;
    d4a2:	e7f8      	b.n	d496 <free_space+0x14>
	*res = buffer->size - buffer->tmp_wr_idx;
    d4a4:	1b1b      	subs	r3, r3, r4
    d4a6:	600b      	str	r3, [r1, #0]
	return true;
    d4a8:	2001      	movs	r0, #1
    d4aa:	e7f4      	b.n	d496 <free_space+0x14>

0000d4ac <idx_inc>:
	return !item->hdr.valid && !item->hdr.busy;
}

static inline uint32_t idx_inc(struct mpsc_pbuf_buffer *buffer,
				uint32_t idx, uint32_t val)
{
    d4ac:	b510      	push	{r4, lr}
    d4ae:	4604      	mov	r4, r0
	uint32_t i = idx + val;
    d4b0:	1888      	adds	r0, r1, r2

	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
    d4b2:	6922      	ldr	r2, [r4, #16]
		return i & (buffer->size - 1);
    d4b4:	6a23      	ldr	r3, [r4, #32]
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
    d4b6:	07d2      	lsls	r2, r2, #31
    d4b8:	d502      	bpl.n	d4c0 <idx_inc+0x14>
		return i & (buffer->size - 1);
    d4ba:	3b01      	subs	r3, #1
    d4bc:	4018      	ands	r0, r3
	}

	return (i >= buffer->size) ? i - buffer->size : i;
}
    d4be:	bd10      	pop	{r4, pc}
	return (i >= buffer->size) ? i - buffer->size : i;
    d4c0:	4298      	cmp	r0, r3
    d4c2:	bf28      	it	cs
    d4c4:	1ac0      	subcs	r0, r0, r3
    d4c6:	e7fa      	b.n	d4be <idx_inc+0x12>

0000d4c8 <add_skip_item>:

	return 0;
}

static void add_skip_item(struct mpsc_pbuf_buffer *buffer, uint32_t wlen)
{
    d4c8:	b538      	push	{r3, r4, r5, lr}
	union mpsc_pbuf_generic skip = {
		.skip = { .valid = 0, .busy = 1, .len = wlen }
	};

	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
    d4ca:	69c2      	ldr	r2, [r0, #28]
{
    d4cc:	460d      	mov	r5, r1
	union mpsc_pbuf_generic skip = {
    d4ce:	008b      	lsls	r3, r1, #2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
    d4d0:	6801      	ldr	r1, [r0, #0]
	union mpsc_pbuf_generic skip = {
    d4d2:	f043 0302 	orr.w	r3, r3, #2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
    d4d6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
    d4da:	462a      	mov	r2, r5
    d4dc:	6801      	ldr	r1, [r0, #0]
{
    d4de:	4604      	mov	r4, r0
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
    d4e0:	f7ff ffe4 	bl	d4ac <idx_inc>
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
    d4e4:	6861      	ldr	r1, [r4, #4]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
    d4e6:	6020      	str	r0, [r4, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
    d4e8:	462a      	mov	r2, r5
    d4ea:	4620      	mov	r0, r4
    d4ec:	f7ff ffde 	bl	d4ac <idx_inc>
    d4f0:	6060      	str	r0, [r4, #4]
}
    d4f2:	bd38      	pop	{r3, r4, r5, pc}

0000d4f4 <drop_item_locked>:
 */
static union mpsc_pbuf_generic *drop_item_locked(struct mpsc_pbuf_buffer *buffer,
						 uint32_t free_wlen,
						 bool allow_drop,
						 bool *user_packet)
{
    d4f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	union mpsc_pbuf_generic *item;
	uint32_t rd_wlen;
	uint32_t skip_wlen;

	*user_packet = false;
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
    d4f8:	f8d0 a00c 	ldr.w	sl, [r0, #12]
    d4fc:	f8d0 901c 	ldr.w	r9, [r0, #28]
{
    d500:	461f      	mov	r7, r3
	*user_packet = false;
    d502:	2300      	movs	r3, #0
    d504:	703b      	strb	r3, [r7, #0]
	if (item->hdr.busy && !item->hdr.valid) {
    d506:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
    d50a:	f003 0303 	and.w	r3, r3, #3
    d50e:	2b02      	cmp	r3, #2
{
    d510:	4604      	mov	r4, r0
    d512:	468b      	mov	fp, r1
    d514:	4690      	mov	r8, r2
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
    d516:	eb09 068a 	add.w	r6, r9, sl, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
    d51a:	d103      	bne.n	d524 <drop_item_locked+0x30>
		return item->skip.len;
    d51c:	f859 502a 	ldr.w	r5, [r9, sl, lsl #2]
	skip_wlen = get_skip(item);

	rd_wlen = skip_wlen ? skip_wlen : buffer->get_wlen(item);
    d520:	08ad      	lsrs	r5, r5, #2
    d522:	d12e      	bne.n	d582 <drop_item_locked+0x8e>
    d524:	69a3      	ldr	r3, [r4, #24]
    d526:	4630      	mov	r0, r6
    d528:	4798      	blx	r3
    d52a:	4605      	mov	r5, r0
	if (skip_wlen) {
		allow_drop = true;
	} else if (allow_drop) {
    d52c:	f1b8 0f00 	cmp.w	r8, #0
    d530:	d036      	beq.n	d5a0 <drop_item_locked+0xac>
		if (item->hdr.busy) {
    d532:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
    d536:	079b      	lsls	r3, r3, #30
    d538:	d52f      	bpl.n	d59a <drop_item_locked+0xa6>
			/* item is currently processed and cannot be overwritten. */
			add_skip_item(buffer, free_wlen + 1);
    d53a:	f10b 0101 	add.w	r1, fp, #1
    d53e:	4620      	mov	r0, r4
    d540:	f7ff ffc2 	bl	d4c8 <add_skip_item>
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
    d544:	6861      	ldr	r1, [r4, #4]
    d546:	462a      	mov	r2, r5
    d548:	4620      	mov	r0, r4
    d54a:	f7ff ffaf 	bl	d4ac <idx_inc>
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
    d54e:	6821      	ldr	r1, [r4, #0]
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
    d550:	6060      	str	r0, [r4, #4]
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
    d552:	462a      	mov	r2, r5
    d554:	4620      	mov	r0, r4
    d556:	f7ff ffa9 	bl	d4ac <idx_inc>

			/* Get next itme followed the busy one. */
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
    d55a:	462a      	mov	r2, r5
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
    d55c:	6020      	str	r0, [r4, #0]
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
    d55e:	68e1      	ldr	r1, [r4, #12]
    d560:	4620      	mov	r0, r4
    d562:	f7ff ffa3 	bl	d4ac <idx_inc>

			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
    d566:	69e3      	ldr	r3, [r4, #28]
	if (item->hdr.busy && !item->hdr.valid) {
    d568:	f813 2020 	ldrb.w	r2, [r3, r0, lsl #2]
    d56c:	f002 0203 	and.w	r2, r2, #3
    d570:	2a02      	cmp	r2, #2
			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
    d572:	eb03 0680 	add.w	r6, r3, r0, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
    d576:	d10c      	bne.n	d592 <drop_item_locked+0x9e>
		return item->skip.len;
    d578:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			skip_wlen = get_skip(item);
			if (skip_wlen) {
    d57c:	089b      	lsrs	r3, r3, #2
    d57e:	d008      	beq.n	d592 <drop_item_locked+0x9e>
				rd_wlen += skip_wlen;
    d580:	441d      	add	r5, r3
	} else {
		item = NULL;
	}

	if (allow_drop) {
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
    d582:	68e1      	ldr	r1, [r4, #12]
    d584:	462a      	mov	r2, r5
    d586:	4620      	mov	r0, r4
    d588:	f7ff ff90 	bl	d4ac <idx_inc>
		buffer->tmp_rd_idx = buffer->rd_idx;
    d58c:	e9c4 0002 	strd	r0, r0, [r4, #8]
    d590:	e007      	b.n	d5a2 <drop_item_locked+0xae>
				rd_wlen += buffer->get_wlen(item);
    d592:	69a3      	ldr	r3, [r4, #24]
    d594:	4630      	mov	r0, r6
    d596:	4798      	blx	r3
    d598:	4405      	add	r5, r0
			*user_packet = true;
    d59a:	2301      	movs	r3, #1
    d59c:	703b      	strb	r3, [r7, #0]
    d59e:	e7f0      	b.n	d582 <drop_item_locked+0x8e>
		item = NULL;
    d5a0:	4646      	mov	r6, r8
	}

	return item;
}
    d5a2:	4630      	mov	r0, r6
    d5a4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d5a8 <mpsc_pbuf_init>:
{
    d5a8:	b538      	push	{r3, r4, r5, lr}
    d5aa:	460d      	mov	r5, r1
    d5ac:	4604      	mov	r4, r0
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
    d5ae:	221c      	movs	r2, #28
    d5b0:	2100      	movs	r1, #0
    d5b2:	f000 fa33 	bl	da1c <memset>
	buffer->get_wlen = cfg->get_wlen;
    d5b6:	68eb      	ldr	r3, [r5, #12]
	buffer->size = cfg->size;
    d5b8:	686a      	ldr	r2, [r5, #4]
	buffer->get_wlen = cfg->get_wlen;
    d5ba:	61a3      	str	r3, [r4, #24]
	buffer->notify_drop = cfg->notify_drop;
    d5bc:	68ab      	ldr	r3, [r5, #8]
    d5be:	6163      	str	r3, [r4, #20]
	buffer->buf = cfg->buf;
    d5c0:	682b      	ldr	r3, [r5, #0]
    d5c2:	61e3      	str	r3, [r4, #28]
	buffer->size = cfg->size;
    d5c4:	6222      	str	r2, [r4, #32]
	buffer->flags = cfg->flags;
    d5c6:	692b      	ldr	r3, [r5, #16]
 * @param x value to check
 * @return true if @p x is a power of two, false otherwise
 */
static inline bool is_power_of_two(unsigned int x)
{
	return (x != 0U) && ((x & (x - 1U)) == 0U);
    d5c8:	b122      	cbz	r2, d5d4 <mpsc_pbuf_init+0x2c>
    d5ca:	1e51      	subs	r1, r2, #1
    d5cc:	4211      	tst	r1, r2
		buffer->flags |= MPSC_PBUF_SIZE_POW2;
    d5ce:	bf08      	it	eq
    d5d0:	f043 0301 	orreq.w	r3, r3, #1
	buffer->flags = cfg->flags;
    d5d4:	6123      	str	r3, [r4, #16]
	return z_impl_k_sem_init(sem, initial_count, limit);
    d5d6:	2201      	movs	r2, #1
    d5d8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    d5dc:	2100      	movs	r1, #0
}
    d5de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    d5e2:	f002 b8c6 	b.w	f772 <z_impl_k_sem_init>

0000d5e6 <mpsc_pbuf_alloc>:

}

union mpsc_pbuf_generic *mpsc_pbuf_alloc(struct mpsc_pbuf_buffer *buffer,
					 size_t wlen, k_timeout_t timeout)
{
    d5e6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d5ea:	4699      	mov	r9, r3
	uint32_t free_wlen;
	bool valid_drop;

	MPSC_PBUF_DBG(buffer, "alloc %d words, ", (int)wlen);

	if (wlen > (buffer->size - 1)) {
    d5ec:	6a03      	ldr	r3, [r0, #32]
    d5ee:	3b01      	subs	r3, #1
    d5f0:	428b      	cmp	r3, r1
{
    d5f2:	b085      	sub	sp, #20
    d5f4:	4604      	mov	r4, r0
    d5f6:	460f      	mov	r7, r1
    d5f8:	4690      	mov	r8, r2
	if (wlen > (buffer->size - 1)) {
    d5fa:	d364      	bcc.n	d6c6 <mpsc_pbuf_alloc+0xe0>
	union mpsc_pbuf_generic *dropped_item = NULL;
    d5fc:	2500      	movs	r5, #0
	union mpsc_pbuf_generic *item = NULL;
    d5fe:	46aa      	mov	sl, r5
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
			   !k_is_in_isr()) {
			int err;

			k_spin_unlock(&buffer->lock, key);
			err = k_sem_take(&buffer->sem, timeout);
    d600:	f100 0b24 	add.w	fp, r0, #36	; 0x24
	__asm__ volatile(
    d604:	f04f 0320 	mov.w	r3, #32
    d608:	f3ef 8611 	mrs	r6, BASEPRI
    d60c:	f383 8812 	msr	BASEPRI_MAX, r3
    d610:	f3bf 8f6f 	isb	sy
		wrap = free_space(buffer, &free_wlen);
    d614:	a903      	add	r1, sp, #12
    d616:	4620      	mov	r0, r4
    d618:	f7ff ff33 	bl	d482 <free_space>
		if (free_wlen >= wlen) {
    d61c:	9903      	ldr	r1, [sp, #12]
    d61e:	42b9      	cmp	r1, r7
    d620:	d321      	bcc.n	d666 <mpsc_pbuf_alloc+0x80>
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
    d622:	6821      	ldr	r1, [r4, #0]
			item =
    d624:	69e3      	ldr	r3, [r4, #28]
			item->hdr.valid = 0;
    d626:	f813 2021 	ldrb.w	r2, [r3, r1, lsl #2]
    d62a:	f022 0203 	bic.w	r2, r2, #3
    d62e:	f803 2021 	strb.w	r2, [r3, r1, lsl #2]
			buffer->tmp_wr_idx = idx_inc(buffer,
    d632:	4620      	mov	r0, r4
    d634:	463a      	mov	r2, r7
			item =
    d636:	eb03 0a81 	add.w	sl, r3, r1, lsl #2
			buffer->tmp_wr_idx = idx_inc(buffer,
    d63a:	f7ff ff37 	bl	d4ac <idx_inc>
		cont = false;
    d63e:	2300      	movs	r3, #0
			buffer->tmp_wr_idx = idx_inc(buffer,
    d640:	6020      	str	r0, [r4, #0]
	__asm__ volatile(
    d642:	f386 8811 	msr	BASEPRI, r6
    d646:	f3bf 8f6f 	isb	sy
			cont = dropped_item != NULL;
		}

		k_spin_unlock(&buffer->lock, key);

		if (cont && dropped_item && valid_drop) {
    d64a:	2b00      	cmp	r3, #0
    d64c:	d03d      	beq.n	d6ca <mpsc_pbuf_alloc+0xe4>
    d64e:	2d00      	cmp	r5, #0
    d650:	d0d8      	beq.n	d604 <mpsc_pbuf_alloc+0x1e>
    d652:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d656:	2b00      	cmp	r3, #0
    d658:	d0d4      	beq.n	d604 <mpsc_pbuf_alloc+0x1e>
			/* Notify about item being dropped. */
			buffer->notify_drop(buffer, dropped_item);
    d65a:	4629      	mov	r1, r5
    d65c:	6963      	ldr	r3, [r4, #20]
    d65e:	4620      	mov	r0, r4
    d660:	4798      	blx	r3
			dropped_item = NULL;
    d662:	2500      	movs	r5, #0
    d664:	e7ce      	b.n	d604 <mpsc_pbuf_alloc+0x1e>
		} else if (wrap) {
    d666:	b128      	cbz	r0, d674 <mpsc_pbuf_alloc+0x8e>
    d668:	9001      	str	r0, [sp, #4]
			add_skip_item(buffer, free_wlen);
    d66a:	4620      	mov	r0, r4
    d66c:	f7ff ff2c 	bl	d4c8 <add_skip_item>
			cont = true;
    d670:	9b01      	ldr	r3, [sp, #4]
    d672:	e7e6      	b.n	d642 <mpsc_pbuf_alloc+0x5c>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    d674:	ea58 0309 	orrs.w	r3, r8, r9
    d678:	d017      	beq.n	d6aa <mpsc_pbuf_alloc+0xc4>
			   !k_is_in_isr()) {
    d67a:	f001 ff9d 	bl	f5b8 <k_is_in_isr>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    d67e:	b9a0      	cbnz	r0, d6aa <mpsc_pbuf_alloc+0xc4>
    d680:	f386 8811 	msr	BASEPRI, r6
    d684:	f3bf 8f6f 	isb	sy
	return z_impl_k_sem_take(sem, timeout);
    d688:	4642      	mov	r2, r8
    d68a:	464b      	mov	r3, r9
    d68c:	4658      	mov	r0, fp
    d68e:	f7fe fb79 	bl	bd84 <z_impl_k_sem_take>
	__asm__ volatile(
    d692:	f04f 0320 	mov.w	r3, #32
    d696:	f3ef 8611 	mrs	r6, BASEPRI
    d69a:	f383 8812 	msr	BASEPRI_MAX, r3
    d69e:	f3bf 8f6f 	isb	sy
			if (err == 0) {
    d6a2:	fab0 f380 	clz	r3, r0
    d6a6:	095b      	lsrs	r3, r3, #5
    d6a8:	e7cb      	b.n	d642 <mpsc_pbuf_alloc+0x5c>
			bool user_drop = buffer->flags & MPSC_PBUF_MODE_OVERWRITE;
    d6aa:	6922      	ldr	r2, [r4, #16]
			dropped_item = drop_item_locked(buffer, free_wlen,
    d6ac:	9903      	ldr	r1, [sp, #12]
    d6ae:	f10d 030b 	add.w	r3, sp, #11
    d6b2:	f3c2 0240 	ubfx	r2, r2, #1, #1
    d6b6:	4620      	mov	r0, r4
    d6b8:	f7ff ff1c 	bl	d4f4 <drop_item_locked>
			cont = dropped_item != NULL;
    d6bc:	1e03      	subs	r3, r0, #0
    d6be:	4605      	mov	r5, r0
    d6c0:	bf18      	it	ne
    d6c2:	2301      	movne	r3, #1
    d6c4:	e7bd      	b.n	d642 <mpsc_pbuf_alloc+0x5c>
		return NULL;
    d6c6:	f04f 0a00 	mov.w	sl, #0
		/* During test fill with 0's to simplify message comparison */
		memset(item, 0, sizeof(int) * wlen);
	}

	return item;
}
    d6ca:	4650      	mov	r0, sl
    d6cc:	b005      	add	sp, #20
    d6ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d6d2 <mpsc_pbuf_commit>:

void mpsc_pbuf_commit(struct mpsc_pbuf_buffer *buffer,
		       union mpsc_pbuf_generic *item)
{
    d6d2:	b570      	push	{r4, r5, r6, lr}
	uint32_t wlen = buffer->get_wlen(item);
    d6d4:	6983      	ldr	r3, [r0, #24]
{
    d6d6:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
    d6d8:	4608      	mov	r0, r1
{
    d6da:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
    d6dc:	4798      	blx	r3
    d6de:	4602      	mov	r2, r0
    d6e0:	f04f 0320 	mov.w	r3, #32
    d6e4:	f3ef 8611 	mrs	r6, BASEPRI
    d6e8:	f383 8812 	msr	BASEPRI_MAX, r3
    d6ec:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&buffer->lock);

	item->hdr.valid = 1;
    d6f0:	782b      	ldrb	r3, [r5, #0]
    d6f2:	f043 0301 	orr.w	r3, r3, #1
    d6f6:	702b      	strb	r3, [r5, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
    d6f8:	6861      	ldr	r1, [r4, #4]
    d6fa:	4620      	mov	r0, r4
    d6fc:	f7ff fed6 	bl	d4ac <idx_inc>
    d700:	6060      	str	r0, [r4, #4]
	__asm__ volatile(
    d702:	f386 8811 	msr	BASEPRI, r6
    d706:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&buffer->lock, key);
	MPSC_PBUF_DBG(buffer, "committed %p ", item);
}
    d70a:	bd70      	pop	{r4, r5, r6, pc}

0000d70c <mpsc_pbuf_claim>:
		}
	} while (cont);
}

const union mpsc_pbuf_generic *mpsc_pbuf_claim(struct mpsc_pbuf_buffer *buffer)
{
    d70c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d710:	4604      	mov	r4, r0
	__asm__ volatile(
    d712:	f04f 0320 	mov.w	r3, #32
    d716:	f3ef 8611 	mrs	r6, BASEPRI
    d71a:	f383 8812 	msr	BASEPRI_MAX, r3
    d71e:	f3bf 8f6f 	isb	sy
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
    d722:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
    d726:	429f      	cmp	r7, r3
	*res = buffer->size - buffer->tmp_rd_idx;
    d728:	bf88      	it	hi
    d72a:	6a23      	ldrhi	r3, [r4, #32]
    d72c:	1bdb      	subs	r3, r3, r7
		key = k_spin_lock(&buffer->lock);
		wrap = available(buffer, &a);
		item = (union mpsc_pbuf_generic *)
			&buffer->buf[buffer->tmp_rd_idx];

		if (!a || is_invalid(item)) {
    d72e:	b1f3      	cbz	r3, d76e <mpsc_pbuf_claim+0x62>
		item = (union mpsc_pbuf_generic *)
    d730:	69e1      	ldr	r1, [r4, #28]
	return !item->hdr.valid && !item->hdr.busy;
    d732:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
		if (!a || is_invalid(item)) {
    d736:	f012 0303 	ands.w	r3, r2, #3
		item = (union mpsc_pbuf_generic *)
    d73a:	eb01 0887 	add.w	r8, r1, r7, lsl #2
		if (!a || is_invalid(item)) {
    d73e:	d016      	beq.n	d76e <mpsc_pbuf_claim+0x62>
	if (item->hdr.busy && !item->hdr.valid) {
    d740:	2b02      	cmp	r3, #2
    d742:	d103      	bne.n	d74c <mpsc_pbuf_claim+0x40>
		return item->skip.len;
    d744:	f851 5027 	ldr.w	r5, [r1, r7, lsl #2]
			item = NULL;
		} else {
			uint32_t skip = get_skip(item);

			if (skip || !is_valid(item)) {
    d748:	08ad      	lsrs	r5, r5, #2
    d74a:	d115      	bne.n	d778 <mpsc_pbuf_claim+0x6c>
    d74c:	07d0      	lsls	r0, r2, #31
				cont = true;
			} else {
				item->hdr.busy = 1;
				buffer->tmp_rd_idx =
					idx_inc(buffer, buffer->tmp_rd_idx,
						buffer->get_wlen(item));
    d74e:	69a3      	ldr	r3, [r4, #24]
			if (skip || !is_valid(item)) {
    d750:	d50f      	bpl.n	d772 <mpsc_pbuf_claim+0x66>
				item->hdr.busy = 1;
    d752:	f042 0202 	orr.w	r2, r2, #2
    d756:	f801 2027 	strb.w	r2, [r1, r7, lsl #2]
					idx_inc(buffer, buffer->tmp_rd_idx,
    d75a:	4640      	mov	r0, r8
    d75c:	4798      	blx	r3
    d75e:	4639      	mov	r1, r7
    d760:	4602      	mov	r2, r0
    d762:	4620      	mov	r0, r4
    d764:	f7ff fea2 	bl	d4ac <idx_inc>
		cont = false;
    d768:	2300      	movs	r3, #0
				buffer->tmp_rd_idx =
    d76a:	60a0      	str	r0, [r4, #8]
    d76c:	e011      	b.n	d792 <mpsc_pbuf_claim+0x86>
			item = NULL;
    d76e:	4698      	mov	r8, r3
    d770:	e00f      	b.n	d792 <mpsc_pbuf_claim+0x86>
					skip ? skip : buffer->get_wlen(item);
    d772:	4640      	mov	r0, r8
    d774:	4798      	blx	r3
    d776:	4605      	mov	r5, r0
				      idx_inc(buffer, buffer->tmp_rd_idx, inc);
    d778:	68a1      	ldr	r1, [r4, #8]
    d77a:	462a      	mov	r2, r5
    d77c:	4620      	mov	r0, r4
    d77e:	f7ff fe95 	bl	d4ac <idx_inc>
					idx_inc(buffer, buffer->rd_idx, inc);
    d782:	68e1      	ldr	r1, [r4, #12]
				buffer->tmp_rd_idx =
    d784:	60a0      	str	r0, [r4, #8]
					idx_inc(buffer, buffer->rd_idx, inc);
    d786:	462a      	mov	r2, r5
    d788:	4620      	mov	r0, r4
    d78a:	f7ff fe8f 	bl	d4ac <idx_inc>
				cont = true;
    d78e:	2301      	movs	r3, #1
				buffer->rd_idx =
    d790:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    d792:	f386 8811 	msr	BASEPRI, r6
    d796:	f3bf 8f6f 	isb	sy

		if (!cont) {
			MPSC_PBUF_DBG(buffer, "claimed: %p ", item);
		}
		k_spin_unlock(&buffer->lock, key);
	} while (cont);
    d79a:	2b00      	cmp	r3, #0
    d79c:	d1b9      	bne.n	d712 <mpsc_pbuf_claim+0x6>

	return item;
}
    d79e:	4640      	mov	r0, r8
    d7a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000d7a4 <mpsc_pbuf_free>:

void mpsc_pbuf_free(struct mpsc_pbuf_buffer *buffer,
		     const union mpsc_pbuf_generic *item)
{
    d7a4:	b570      	push	{r4, r5, r6, lr}
	uint32_t wlen = buffer->get_wlen(item);
    d7a6:	6983      	ldr	r3, [r0, #24]
{
    d7a8:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
    d7aa:	4608      	mov	r0, r1
{
    d7ac:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
    d7ae:	4798      	blx	r3
    d7b0:	4602      	mov	r2, r0
	__asm__ volatile(
    d7b2:	f04f 0320 	mov.w	r3, #32
    d7b6:	f3ef 8611 	mrs	r6, BASEPRI
    d7ba:	f383 8812 	msr	BASEPRI_MAX, r3
    d7be:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&buffer->lock);
	union mpsc_pbuf_generic *witem = (union mpsc_pbuf_generic *)item;

	witem->hdr.valid = 0;
    d7c2:	782b      	ldrb	r3, [r5, #0]
    d7c4:	f36f 0300 	bfc	r3, #0, #1
    d7c8:	702b      	strb	r3, [r5, #0]
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
    d7ca:	6923      	ldr	r3, [r4, #16]
    d7cc:	079b      	lsls	r3, r3, #30
    d7ce:	d505      	bpl.n	d7dc <mpsc_pbuf_free+0x38>
		 ((uint32_t *)item == &buffer->buf[buffer->rd_idx])) {
    d7d0:	68e1      	ldr	r1, [r4, #12]
    d7d2:	69e3      	ldr	r3, [r4, #28]
    d7d4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
    d7d8:	429d      	cmp	r5, r3
    d7da:	d112      	bne.n	d802 <mpsc_pbuf_free+0x5e>
		witem->hdr.busy = 0;
    d7dc:	782b      	ldrb	r3, [r5, #0]
    d7de:	f36f 0341 	bfc	r3, #1, #1
    d7e2:	702b      	strb	r3, [r5, #0]
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
    d7e4:	68e1      	ldr	r1, [r4, #12]
    d7e6:	4620      	mov	r0, r4
    d7e8:	f7ff fe60 	bl	d4ac <idx_inc>
    d7ec:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    d7ee:	f386 8811 	msr	BASEPRI, r6
    d7f2:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
    d7f6:	f104 0024 	add.w	r0, r4, #36	; 0x24
	}
	MPSC_PBUF_DBG(buffer, "freed: %p ", item);

	k_spin_unlock(&buffer->lock, key);
	k_sem_give(&buffer->sem);
}
    d7fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    d7fe:	f7fe ba9b 	b.w	bd38 <z_impl_k_sem_give>
		witem->skip.len = wlen;
    d802:	682b      	ldr	r3, [r5, #0]
    d804:	f360 039f 	bfi	r3, r0, #2, #30
    d808:	602b      	str	r3, [r5, #0]
    d80a:	e7f0      	b.n	d7ee <mpsc_pbuf_free+0x4a>

0000d80c <mpsc_pbuf_is_pending>:
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
    d80c:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
    d810:	4293      	cmp	r3, r2
	*res = buffer->size - buffer->tmp_rd_idx;
    d812:	bf8a      	itet	hi
    d814:	6a00      	ldrhi	r0, [r0, #32]
		*res = (buffer->wr_idx - buffer->tmp_rd_idx);
    d816:	1ad3      	subls	r3, r2, r3
	*res = buffer->size - buffer->tmp_rd_idx;
    d818:	1ac3      	subhi	r3, r0, r3
	uint32_t a;

	(void)available(buffer, &a);

	return a ? true : false;
}
    d81a:	1e18      	subs	r0, r3, #0
    d81c:	bf18      	it	ne
    d81e:	2001      	movne	r0, #1
    d820:	4770      	bx	lr

0000d822 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    d822:	4770      	bx	lr

0000d824 <log_msg2_generic_get_wlen>:
	return msg->generic.type == Z_LOG_MSG2_LOG;
    d824:	7803      	ldrb	r3, [r0, #0]
	if (z_log_item_is_msg(generic_msg)) {
    d826:	075b      	lsls	r3, r3, #29
    d828:	d40b      	bmi.n	d842 <log_msg2_generic_get_wlen+0x1e>
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
    d82a:	6803      	ldr	r3, [r0, #0]
    d82c:	8840      	ldrh	r0, [r0, #2]
    d82e:	f3c3 2349 	ubfx	r3, r3, #9, #10
    d832:	f3c0 00cb 	ubfx	r0, r0, #3, #12
    d836:	4418      	add	r0, r3
    d838:	3013      	adds	r0, #19
    d83a:	f020 0007 	bic.w	r0, r0, #7
    d83e:	0880      	lsrs	r0, r0, #2
		return log_msg2_get_total_wlen(msg->hdr.desc);
    d840:	4770      	bx	lr
	return 0;
    d842:	2000      	movs	r0, #0
}
    d844:	4770      	bx	lr

0000d846 <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    d846:	f001 bd7c 	b.w	f342 <sys_clock_cycle_get_32>

0000d84a <dummy_timestamp>:
    d84a:	2000      	movs	r0, #0
    d84c:	4770      	bx	lr

0000d84e <z_log_vprintk>:
{
    d84e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    d850:	2300      	movs	r3, #0
    d852:	e9cd 0101 	strd	r0, r1, [sp, #4]
    d856:	9300      	str	r3, [sp, #0]
    d858:	461a      	mov	r2, r3
    d85a:	4619      	mov	r1, r3
    d85c:	4618      	mov	r0, r3
    d85e:	f7f4 f9f1 	bl	1c44 <z_impl_z_log_msg2_runtime_vcreate>
}
    d862:	b005      	add	sp, #20
    d864:	f85d fb04 	ldr.w	pc, [sp], #4

0000d868 <notify_drop>:
	z_log_dropped(true);
    d868:	2001      	movs	r0, #1
    d86a:	f7f3 be7d 	b.w	1568 <z_log_dropped>

0000d86e <get_msg>:
{
    d86e:	b508      	push	{r3, lr}
		msg.msg2 = z_log_msg2_claim();
    d870:	f7f3 feee 	bl	1650 <z_log_msg2_claim>
}
    d874:	bd08      	pop	{r3, pc}

0000d876 <z_log_get_tag>:
}
    d876:	2000      	movs	r0, #0
    d878:	4770      	bx	lr

0000d87a <buffer_write>:
{
    d87a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d87c:	4606      	mov	r6, r0
    d87e:	460d      	mov	r5, r1
    d880:	4614      	mov	r4, r2
    d882:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
    d884:	4621      	mov	r1, r4
    d886:	4628      	mov	r0, r5
    d888:	463a      	mov	r2, r7
    d88a:	47b0      	blx	r6
	} while (len != 0);
    d88c:	1a24      	subs	r4, r4, r0
		buf += processed;
    d88e:	4405      	add	r5, r0
	} while (len != 0);
    d890:	d1f8      	bne.n	d884 <buffer_write+0xa>
}
    d892:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000d894 <log_output_flush>:
		     output->control_block->offset,
    d894:	6842      	ldr	r2, [r0, #4]
	buffer_write(output->func, output->buf,
    d896:	6881      	ldr	r1, [r0, #8]
{
    d898:	b510      	push	{r4, lr}
    d89a:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
    d89c:	e9d2 2300 	ldrd	r2, r3, [r2]
    d8a0:	6800      	ldr	r0, [r0, #0]
    d8a2:	f7ff ffea 	bl	d87a <buffer_write>
	output->control_block->offset = 0;
    d8a6:	6863      	ldr	r3, [r4, #4]
    d8a8:	2200      	movs	r2, #0
    d8aa:	601a      	str	r2, [r3, #0]
}
    d8ac:	bd10      	pop	{r4, pc}

0000d8ae <out_func>:
{
    d8ae:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
    d8b0:	684b      	ldr	r3, [r1, #4]
    d8b2:	681a      	ldr	r2, [r3, #0]
    d8b4:	68cb      	ldr	r3, [r1, #12]
    d8b6:	429a      	cmp	r2, r3
{
    d8b8:	4605      	mov	r5, r0
    d8ba:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
    d8bc:	d102      	bne.n	d8c4 <out_func+0x16>
		log_output_flush(out_ctx);
    d8be:	4608      	mov	r0, r1
    d8c0:	f7ff ffe8 	bl	d894 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    d8c4:	6863      	ldr	r3, [r4, #4]
    d8c6:	f3bf 8f5b 	dmb	ish
    d8ca:	e853 2f00 	ldrex	r2, [r3]
    d8ce:	1c51      	adds	r1, r2, #1
    d8d0:	e843 1000 	strex	r0, r1, [r3]
    d8d4:	2800      	cmp	r0, #0
    d8d6:	d1f8      	bne.n	d8ca <out_func+0x1c>
    d8d8:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (uint8_t)c;
    d8dc:	68a3      	ldr	r3, [r4, #8]
    d8de:	549d      	strb	r5, [r3, r2]
}
    d8e0:	2000      	movs	r0, #0
    d8e2:	bd38      	pop	{r3, r4, r5, pc}

0000d8e4 <cr_out_func>:
{
    d8e4:	b538      	push	{r3, r4, r5, lr}
    d8e6:	4605      	mov	r5, r0
    d8e8:	460c      	mov	r4, r1
	out_func(c, ctx);
    d8ea:	f7ff ffe0 	bl	d8ae <out_func>
	if (c == '\n') {
    d8ee:	2d0a      	cmp	r5, #10
    d8f0:	d103      	bne.n	d8fa <cr_out_func+0x16>
		out_func((int)'\r', ctx);
    d8f2:	4621      	mov	r1, r4
    d8f4:	200d      	movs	r0, #13
    d8f6:	f7ff ffda 	bl	d8ae <out_func>
}
    d8fa:	2000      	movs	r0, #0
    d8fc:	bd38      	pop	{r3, r4, r5, pc}

0000d8fe <z_log_msg2_finalize>:
{
    d8fe:	b570      	push	{r4, r5, r6, lr}
    d900:	460e      	mov	r6, r1
    d902:	4615      	mov	r5, r2
    d904:	4619      	mov	r1, r3
	if (!msg) {
    d906:	4604      	mov	r4, r0
    d908:	b918      	cbnz	r0, d912 <z_log_msg2_finalize+0x14>
}
    d90a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_log_dropped(false);
    d90e:	f7f3 be2b 	b.w	1568 <z_log_dropped>
	if (data) {
    d912:	b143      	cbz	r3, d926 <z_log_msg2_finalize+0x28>
		uint8_t *d = msg->data + desc.package_len;
    d914:	f100 030c 	add.w	r3, r0, #12
    d918:	f3c2 2049 	ubfx	r0, r2, #9, #10
		memcpy(d, data, desc.data_len);
    d91c:	4418      	add	r0, r3
    d91e:	f3c2 42cb 	ubfx	r2, r2, #19, #12
    d922:	f000 f870 	bl	da06 <memcpy>
	msg->hdr.source = source;
    d926:	e9c4 5600 	strd	r5, r6, [r4]
	z_log_msg2_commit(msg);
    d92a:	4620      	mov	r0, r4
}
    d92c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_log_msg2_commit(msg);
    d930:	f7f3 bf50 	b.w	17d4 <z_log_msg2_commit>

0000d934 <z_impl_z_log_msg2_static_create>:
{
    d934:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
    d938:	f3c1 2949 	ubfx	r9, r1, #9, #10
    d93c:	f3c1 44cb 	ubfx	r4, r1, #19, #12
    d940:	444c      	add	r4, r9
    d942:	3413      	adds	r4, #19
    d944:	f024 0407 	bic.w	r4, r4, #7
    d948:	4606      	mov	r6, r0
	struct log_msg2 *msg = z_log_msg2_alloc(msg_wlen);
    d94a:	08a0      	lsrs	r0, r4, #2
{
    d94c:	460d      	mov	r5, r1
    d94e:	4690      	mov	r8, r2
    d950:	461f      	mov	r7, r3
	struct log_msg2 *msg = z_log_msg2_alloc(msg_wlen);
    d952:	f7f3 fe75 	bl	1640 <z_log_msg2_alloc>
	if (msg) {
    d956:	4604      	mov	r4, r0
    d958:	b120      	cbz	r0, d964 <z_impl_z_log_msg2_static_create+0x30>
		memcpy(msg->data, package, desc.package_len);
    d95a:	464a      	mov	r2, r9
    d95c:	4641      	mov	r1, r8
    d95e:	300c      	adds	r0, #12
    d960:	f000 f851 	bl	da06 <memcpy>
	z_log_msg2_finalize(msg, source, desc, data);
    d964:	463b      	mov	r3, r7
    d966:	462a      	mov	r2, r5
    d968:	4631      	mov	r1, r6
    d96a:	4620      	mov	r0, r4
}
    d96c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_log_msg2_finalize(msg, source, desc, data);
    d970:	f7ff bfc5 	b.w	d8fe <z_log_msg2_finalize>

0000d974 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    d974:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
    d976:	6800      	ldr	r0, [r0, #0]
    d978:	f7f4 bbae 	b.w	20d8 <z_arm_fatal_error>

0000d97c <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    d97c:	2100      	movs	r1, #0
    d97e:	2001      	movs	r0, #1
    d980:	f7f4 bbaa 	b.w	20d8 <z_arm_fatal_error>

0000d984 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
    d984:	b508      	push	{r3, lr}
	handler();
    d986:	f7f4 fc65 	bl	2254 <z_SysNmiOnReset>
	z_arm_int_exit();
}
    d98a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
    d98e:	f7f4 bd45 	b.w	241c <z_arm_exc_exit>

0000d992 <z_log_msg2_static_create.constprop.0>:
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    d992:	2300      	movs	r3, #0
    d994:	f7ff bfce 	b.w	d934 <z_impl_z_log_msg2_static_create>

0000d998 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    d998:	3901      	subs	r1, #1
    d99a:	4603      	mov	r3, r0
    d99c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    d9a0:	b90a      	cbnz	r2, d9a6 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
    d9a2:	701a      	strb	r2, [r3, #0]

	return dest;
}
    d9a4:	4770      	bx	lr
		*d = *s;
    d9a6:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
    d9aa:	e7f7      	b.n	d99c <strcpy+0x4>

0000d9ac <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    d9ac:	4603      	mov	r3, r0
	size_t n = 0;
    d9ae:	2000      	movs	r0, #0

	while (*s != '\0') {
    d9b0:	5c1a      	ldrb	r2, [r3, r0]
    d9b2:	b902      	cbnz	r2, d9b6 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
    d9b4:	4770      	bx	lr
		n++;
    d9b6:	3001      	adds	r0, #1
    d9b8:	e7fa      	b.n	d9b0 <strlen+0x4>

0000d9ba <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    d9ba:	4603      	mov	r3, r0
	size_t n = 0;
    d9bc:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    d9be:	5c1a      	ldrb	r2, [r3, r0]
    d9c0:	b10a      	cbz	r2, d9c6 <strnlen+0xc>
    d9c2:	4288      	cmp	r0, r1
    d9c4:	d100      	bne.n	d9c8 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
    d9c6:	4770      	bx	lr
		n++;
    d9c8:	3001      	adds	r0, #1
    d9ca:	e7f8      	b.n	d9be <strnlen+0x4>

0000d9cc <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    d9cc:	1e43      	subs	r3, r0, #1
    d9ce:	3901      	subs	r1, #1
    d9d0:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    d9d4:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    d9d8:	4282      	cmp	r2, r0
    d9da:	d101      	bne.n	d9e0 <strcmp+0x14>
    d9dc:	2a00      	cmp	r2, #0
    d9de:	d1f7      	bne.n	d9d0 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    d9e0:	1a10      	subs	r0, r2, r0
    d9e2:	4770      	bx	lr

0000d9e4 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
    d9e4:	b510      	push	{r4, lr}
    d9e6:	4603      	mov	r3, r0
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    d9e8:	b15a      	cbz	r2, da02 <memcmp+0x1e>
    d9ea:	3901      	subs	r1, #1
    d9ec:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    d9ee:	f813 0b01 	ldrb.w	r0, [r3], #1
    d9f2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    d9f6:	42a3      	cmp	r3, r4
    d9f8:	d001      	beq.n	d9fe <memcmp+0x1a>
    d9fa:	4290      	cmp	r0, r2
    d9fc:	d0f7      	beq.n	d9ee <memcmp+0xa>
		c1++;
		c2++;
	}

	return *c1 - *c2;
    d9fe:	1a80      	subs	r0, r0, r2
}
    da00:	bd10      	pop	{r4, pc}
		return 0;
    da02:	4610      	mov	r0, r2
    da04:	e7fc      	b.n	da00 <memcmp+0x1c>

0000da06 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
    da06:	b510      	push	{r4, lr}
    da08:	1e43      	subs	r3, r0, #1
    da0a:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    da0c:	4291      	cmp	r1, r2
    da0e:	d100      	bne.n	da12 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    da10:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
    da12:	f811 4b01 	ldrb.w	r4, [r1], #1
    da16:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    da1a:	e7f7      	b.n	da0c <memcpy+0x6>

0000da1c <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    da1c:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    da1e:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
    da20:	4603      	mov	r3, r0
	while (n > 0) {
    da22:	4293      	cmp	r3, r2
    da24:	d100      	bne.n	da28 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    da26:	4770      	bx	lr
		*(d_byte++) = c_byte;
    da28:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    da2c:	e7f9      	b.n	da22 <memset+0x6>

0000da2e <_stdout_hook_default>:
}
    da2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    da32:	4770      	bx	lr

0000da34 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
    da34:	b084      	sub	sp, #16
    da36:	ab04      	add	r3, sp, #16
    da38:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
    da3c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    da40:	2b06      	cmp	r3, #6
    da42:	d108      	bne.n	da56 <pm_power_state_set+0x22>
#endif // defined(POWER_RAMSTATUS_RAMBLOCK0_Msk)

#if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg)
{
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
    da44:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    da48:	2201      	movs	r2, #1
    da4a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
    da4e:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
    da52:	bf20      	wfe
    while (true)
    da54:	e7fd      	b.n	da52 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
    da56:	b004      	add	sp, #16
    da58:	4770      	bx	lr

0000da5a <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
    da5a:	b084      	sub	sp, #16
    da5c:	ab04      	add	r3, sp, #16
    da5e:	e903 0007 	stmdb	r3, {r0, r1, r2}
    da62:	2300      	movs	r3, #0
    da64:	f383 8811 	msr	BASEPRI, r3
    da68:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    da6c:	b004      	add	sp, #16
    da6e:	4770      	bx	lr

0000da70 <ah>:
	return bt_encrypt_le(key, plaintext, enc_data);
#endif
}

static int ah(const uint8_t irk[16], const uint8_t r[3], uint8_t out[3])
{
    da70:	b530      	push	{r4, r5, lr}
    da72:	b085      	sub	sp, #20
    da74:	4604      	mov	r4, r0
    da76:	4615      	mov	r5, r2

	BT_DBG("irk %s", bt_hex(irk, 16));
	BT_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
    da78:	4668      	mov	r0, sp
    da7a:	2203      	movs	r2, #3
    da7c:	f7ff ffc3 	bl	da06 <memcpy>
	(void)memset(res + 3, 0, 13);
    da80:	220d      	movs	r2, #13
    da82:	2100      	movs	r1, #0
    da84:	f10d 0003 	add.w	r0, sp, #3
    da88:	f7ff ffc8 	bl	da1c <memset>
	return bt_encrypt_le(key, plaintext, enc_data);
    da8c:	4620      	mov	r0, r4
    da8e:	466a      	mov	r2, sp
    da90:	4669      	mov	r1, sp
    da92:	f000 fcc6 	bl	e422 <bt_encrypt_le>

	err = internal_encrypt_le(irk, res, res);
	if (err) {
    da96:	4604      	mov	r4, r0
    da98:	b920      	cbnz	r0, daa4 <ah+0x34>
	 *      ah(h, r) = e(k, r') mod 2^24
	 * The output of the security function e is then truncated to 24 bits
	 * by taking the least significant 24 bits of the output of e as the
	 * result of ah.
	 */
	memcpy(out, res, 3);
    da9a:	2203      	movs	r2, #3
    da9c:	4669      	mov	r1, sp
    da9e:	4628      	mov	r0, r5
    daa0:	f7ff ffb1 	bl	da06 <memcpy>

	return 0;
}
    daa4:	4620      	mov	r0, r4
    daa6:	b005      	add	sp, #20
    daa8:	bd30      	pop	{r4, r5, pc}

0000daaa <bt_rpa_create>:
}
#endif

#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_CTLR_PRIVACY)
int bt_rpa_create(const uint8_t irk[16], bt_addr_t *rpa)
{
    daaa:	b570      	push	{r4, r5, r6, lr}
	int err;

	err = internal_rand(rpa->val + 3, 3);
    daac:	1cce      	adds	r6, r1, #3
{
    daae:	4605      	mov	r5, r0
    dab0:	460c      	mov	r4, r1
	return bt_rand(buf, len);
    dab2:	4630      	mov	r0, r6
    dab4:	2103      	movs	r1, #3
    dab6:	f000 fcb2 	bl	e41e <bt_rand>
	if (err) {
    daba:	b960      	cbnz	r0, dad6 <bt_rpa_create+0x2c>
		return err;
	}

	BT_ADDR_SET_RPA(rpa);
    dabc:	7963      	ldrb	r3, [r4, #5]
    dabe:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    dac2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    dac6:	7163      	strb	r3, [r4, #5]

	err = ah(irk, rpa->val + 3, rpa->val);
    dac8:	4622      	mov	r2, r4
    daca:	4631      	mov	r1, r6
    dacc:	4628      	mov	r0, r5
	}

	BT_DBG("Created RPA %s", bt_addr_str((bt_addr_t *)rpa->val));

	return 0;
}
    dace:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = ah(irk, rpa->val + 3, rpa->val);
    dad2:	f7ff bfcd 	b.w	da70 <ah>
}
    dad6:	bd70      	pop	{r4, r5, r6, pc}

0000dad8 <bt_addr_le_create_static>:
#include <bluetooth/addr.h>
#include <bluetooth/crypto.h>

static inline int create_random_addr(bt_addr_le_t *addr)
{
	addr->type = BT_ADDR_LE_RANDOM;
    dad8:	2301      	movs	r3, #1

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
    dada:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
    dadc:	2106      	movs	r1, #6
{
    dade:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
    dae0:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
    dae4:	f000 fc9b 	bl	e41e <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
    dae8:	b918      	cbnz	r0, daf2 <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
    daea:	79a3      	ldrb	r3, [r4, #6]
    daec:	f063 033f 	orn	r3, r3, #63	; 0x3f
    daf0:	71a3      	strb	r3, [r4, #6]

	return 0;
}
    daf2:	bd10      	pop	{r4, pc}

0000daf4 <z_log_msg2_static_create.constprop.0>:
    daf4:	2300      	movs	r3, #0
    daf6:	f7ff bf1d 	b.w	d934 <z_impl_z_log_msg2_static_create>

0000dafa <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    dafa:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    dafc:	ab0a      	add	r3, sp, #40	; 0x28
    dafe:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    db00:	9302      	str	r3, [sp, #8]
    db02:	9b09      	ldr	r3, [sp, #36]	; 0x24
    db04:	9301      	str	r3, [sp, #4]
    db06:	2300      	movs	r3, #0
    db08:	9300      	str	r3, [sp, #0]
    db0a:	4618      	mov	r0, r3
    db0c:	f7f4 f89a 	bl	1c44 <z_impl_z_log_msg2_runtime_vcreate>
}
    db10:	b007      	add	sp, #28
    db12:	f85d fb04 	ldr.w	pc, [sp], #4

0000db16 <bt_hci_evt_create>:
#include <stdint.h>
#include <sys/byteorder.h>
#include <drivers/bluetooth/hci_driver.h>

struct net_buf *bt_hci_evt_create(uint8_t evt, uint8_t len)
{
    db16:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_hdr *hdr;
	struct net_buf *buf;

	buf = bt_buf_get_evt(evt, false, K_FOREVER);
    db18:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
    db1c:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
    db1e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    db22:	2100      	movs	r1, #0
{
    db24:	4606      	mov	r6, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
    db26:	f7f5 f947 	bl	2db8 <bt_buf_get_evt>
	return net_buf_simple_add(&buf->b, len);
    db2a:	2102      	movs	r1, #2
    db2c:	4604      	mov	r4, r0
    db2e:	3008      	adds	r0, #8
    db30:	f000 fffd 	bl	eb2e <net_buf_simple_add>

	hdr = net_buf_add(buf, sizeof(*hdr));
	hdr->evt = evt;
    db34:	7006      	strb	r6, [r0, #0]
	hdr->len = len;
    db36:	7045      	strb	r5, [r0, #1]

	return buf;
}
    db38:	4620      	mov	r0, r4
    db3a:	bd70      	pop	{r4, r5, r6, pc}

0000db3c <bt_hci_cmd_complete_create>:
struct net_buf *bt_hci_cmd_complete_create(uint16_t op, uint8_t plen)
{
	struct net_buf *buf;
	struct bt_hci_evt_cmd_complete *cc;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    db3c:	3103      	adds	r1, #3
{
    db3e:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    db40:	b2c9      	uxtb	r1, r1
{
    db42:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    db44:	200e      	movs	r0, #14
    db46:	f7ff ffe6 	bl	db16 <bt_hci_evt_create>
    db4a:	2103      	movs	r1, #3
    db4c:	4604      	mov	r4, r0
    db4e:	3008      	adds	r0, #8
    db50:	f000 ffed 	bl	eb2e <net_buf_simple_add>

	cc = net_buf_add(buf, sizeof(*cc));
	cc->ncmd = 1U;
    db54:	2301      	movs	r3, #1
    db56:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(op);
    db58:	f8a0 5001 	strh.w	r5, [r0, #1]

	return buf;
}
    db5c:	4620      	mov	r0, r4
    db5e:	bd38      	pop	{r3, r4, r5, pc}

0000db60 <bt_hci_cmd_status_create>:

struct net_buf *bt_hci_cmd_status_create(uint16_t op, uint8_t status)
{
    db60:	b570      	push	{r4, r5, r6, lr}
    db62:	4605      	mov	r5, r0
    db64:	460e      	mov	r6, r1
	struct net_buf *buf;
	struct bt_hci_evt_cmd_status *cs;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
    db66:	200f      	movs	r0, #15
    db68:	2104      	movs	r1, #4
    db6a:	f7ff ffd4 	bl	db16 <bt_hci_evt_create>
    db6e:	2104      	movs	r1, #4
    db70:	4604      	mov	r4, r0
    db72:	3008      	adds	r0, #8
    db74:	f000 ffdb 	bl	eb2e <net_buf_simple_add>

	cs = net_buf_add(buf, sizeof(*cs));
	cs->status = status;
	cs->ncmd = 1U;
    db78:	2201      	movs	r2, #1
	cs->status = status;
    db7a:	7006      	strb	r6, [r0, #0]
	cs->ncmd = 1U;
    db7c:	7042      	strb	r2, [r0, #1]
	cs->opcode = sys_cpu_to_le16(op);
    db7e:	8045      	strh	r5, [r0, #2]

	return buf;
}
    db80:	4620      	mov	r0, r4
    db82:	bd70      	pop	{r4, r5, r6, pc}

0000db84 <bt_id_set_adv_private_addr>:
{
    db84:	b507      	push	{r0, r1, r2, lr}
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
    db86:	2106      	movs	r1, #6
    db88:	4668      	mov	r0, sp
    db8a:	f000 fc48 	bl	e41e <bt_rand>
	if (err) {
    db8e:	b940      	cbnz	r0, dba2 <bt_id_set_adv_private_addr+0x1e>
	BT_ADDR_SET_NRPA(&nrpa);
    db90:	f89d 3005 	ldrb.w	r3, [sp, #5]
		return set_random_address(addr);
    db94:	4668      	mov	r0, sp
	BT_ADDR_SET_NRPA(&nrpa);
    db96:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    db9a:	f88d 3005 	strb.w	r3, [sp, #5]
		return set_random_address(addr);
    db9e:	f7f6 f819 	bl	3bd4 <set_random_address>
}
    dba2:	b003      	add	sp, #12
    dba4:	f85d fb04 	ldr.w	pc, [sp], #4

0000dba8 <bt_id_adv_random_addr_check>:
}
    dba8:	2001      	movs	r0, #1
    dbaa:	4770      	bx	lr

0000dbac <get_adv_channel_map>:
{
    dbac:	4603      	mov	r3, r0
		channel_map &= ~0x01;
    dbae:	f410 4f00 	tst.w	r0, #32768	; 0x8000
    dbb2:	bf0c      	ite	eq
    dbb4:	2007      	moveq	r0, #7
    dbb6:	2006      	movne	r0, #6
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
    dbb8:	03da      	lsls	r2, r3, #15
		channel_map &= ~0x02;
    dbba:	bf48      	it	mi
    dbbc:	f000 0005 	andmi.w	r0, r0, #5
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
    dbc0:	039b      	lsls	r3, r3, #14
		channel_map &= ~0x04;
    dbc2:	bf48      	it	mi
    dbc4:	f000 00fb 	andmi.w	r0, r0, #251	; 0xfb
}
    dbc8:	4770      	bx	lr

0000dbca <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    dbca:	f3bf 8f5b 	dmb	ish
    dbce:	6800      	ldr	r0, [r0, #0]
    dbd0:	f3bf 8f5b 	dmb	ish
}
    dbd4:	4770      	bx	lr

0000dbd6 <atomic_and>:
{
    dbd6:	4603      	mov	r3, r0
}
    dbd8:	f3bf 8f5b 	dmb	ish
    dbdc:	e853 0f00 	ldrex	r0, [r3]
    dbe0:	ea00 0201 	and.w	r2, r0, r1
    dbe4:	e843 2c00 	strex	ip, r2, [r3]
    dbe8:	f1bc 0f00 	cmp.w	ip, #0
    dbec:	d1f6      	bne.n	dbdc <atomic_and+0x6>
    dbee:	f3bf 8f5b 	dmb	ish
    dbf2:	4770      	bx	lr

0000dbf4 <atomic_set_bit_to>:
	atomic_val_t mask = ATOMIC_MASK(bit);
    dbf4:	2301      	movs	r3, #1
{
    dbf6:	b410      	push	{r4}
	atomic_val_t mask = ATOMIC_MASK(bit);
    dbf8:	fa03 f101 	lsl.w	r1, r3, r1
{
    dbfc:	4604      	mov	r4, r0
	if (val) {
    dbfe:	b162      	cbz	r2, dc1a <atomic_set_bit_to+0x26>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    dc00:	f3bf 8f5b 	dmb	ish
    dc04:	e854 3f00 	ldrex	r3, [r4]
    dc08:	430b      	orrs	r3, r1
    dc0a:	e844 3200 	strex	r2, r3, [r4]
    dc0e:	2a00      	cmp	r2, #0
    dc10:	d1f8      	bne.n	dc04 <atomic_set_bit_to+0x10>
    dc12:	f3bf 8f5b 	dmb	ish
	}
}
    dc16:	bc10      	pop	{r4}
    dc18:	4770      	bx	lr
    dc1a:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    dc1c:	43c9      	mvns	r1, r1
    dc1e:	f7ff bfda 	b.w	dbd6 <atomic_and>

0000dc22 <le_adv_update.constprop.0>:
static int le_adv_update(struct bt_le_ext_adv *adv,
    dc22:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dc26:	b087      	sub	sp, #28
    dc28:	4605      	mov	r5, r0
    dc2a:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
    dc2e:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    dc32:	f89d a044 	ldrb.w	sl, [sp, #68]	; 0x44
    dc36:	460c      	mov	r4, r1
    dc38:	4690      	mov	r8, r2
	struct bt_ad d[2] = {};
    dc3a:	2100      	movs	r1, #0
    dc3c:	2210      	movs	r2, #16
    dc3e:	a802      	add	r0, sp, #8
static int le_adv_update(struct bt_le_ext_adv *adv,
    dc40:	461f      	mov	r7, r3
	struct bt_ad d[2] = {};
    dc42:	f7ff feeb 	bl	da1c <memset>
	if (name_type != ADV_NAME_TYPE_NONE) {
    dc46:	b186      	cbz	r6, dc6a <le_adv_update.constprop.0+0x48>
		const char *name = bt_get_name();
    dc48:	f7f5 ffa6 	bl	3b98 <bt_get_name>
    dc4c:	4683      	mov	fp, r0
		if ((ad && ad_has_name(ad, ad_len)) ||
    dc4e:	2c00      	cmp	r4, #0
    dc50:	d139      	bne.n	dcc6 <le_adv_update.constprop.0+0xa4>
    dc52:	2f00      	cmp	r7, #0
    dc54:	d142      	bne.n	dcdc <le_adv_update.constprop.0+0xba>
		data = (struct bt_data)BT_DATA(
    dc56:	4658      	mov	r0, fp
    dc58:	f7ff fea8 	bl	d9ac <strlen>
    dc5c:	2309      	movs	r3, #9
    dc5e:	f88d 3000 	strb.w	r3, [sp]
    dc62:	f88d 0001 	strb.w	r0, [sp, #1]
    dc66:	f8cd b004 	str.w	fp, [sp, #4]
		if (name_type == ADV_NAME_TYPE_AD) {
    dc6a:	2e01      	cmp	r6, #1
			d_len = 2;
    dc6c:	bf0c      	ite	eq
    dc6e:	2202      	moveq	r2, #2
		d_len = 1;
    dc70:	2201      	movne	r2, #1
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    dc72:	a902      	add	r1, sp, #8
    dc74:	f242 0008 	movw	r0, #8200	; 0x2008
		d[0].len = ad_len;
    dc78:	e9cd 4802 	strd	r4, r8, [sp, #8]
			d[1].data = &data;
    dc7c:	bf04      	itt	eq
    dc7e:	f8cd d010 	streq.w	sp, [sp, #16]
			d[1].len = 1;
    dc82:	9605      	streq	r6, [sp, #20]
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    dc84:	f7f6 fa24 	bl	40d0 <hci_set_ad>
		if (err) {
    dc88:	4604      	mov	r4, r0
    dc8a:	b978      	cbnz	r0, dcac <le_adv_update.constprop.0+0x8a>
	if (scannable) {
    dc8c:	f1ba 0f00 	cmp.w	sl, #0
    dc90:	d126      	bne.n	dce0 <le_adv_update.constprop.0+0xbe>
    dc92:	3510      	adds	r5, #16
    dc94:	f3bf 8f5b 	dmb	ish
    dc98:	e855 3f00 	ldrex	r3, [r5]
    dc9c:	f043 0304 	orr.w	r3, r3, #4
    dca0:	e845 3200 	strex	r2, r3, [r5]
    dca4:	2a00      	cmp	r2, #0
    dca6:	d1f7      	bne.n	dc98 <le_adv_update.constprop.0+0x76>
    dca8:	f3bf 8f5b 	dmb	ish
}
    dcac:	4620      	mov	r0, r4
    dcae:	b007      	add	sp, #28
    dcb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    dcb4:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
    dcb8:	3a08      	subs	r2, #8
    dcba:	2a01      	cmp	r2, #1
    dcbc:	d925      	bls.n	dd0a <le_adv_update.constprop.0+0xe8>
	for (i = 0; i < ad_len; i++) {
    dcbe:	3301      	adds	r3, #1
    dcc0:	4598      	cmp	r8, r3
    dcc2:	d1f7      	bne.n	dcb4 <le_adv_update.constprop.0+0x92>
    dcc4:	e7c5      	b.n	dc52 <le_adv_update.constprop.0+0x30>
    dcc6:	2300      	movs	r3, #0
    dcc8:	e7fa      	b.n	dcc0 <le_adv_update.constprop.0+0x9e>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    dcca:	f817 2033 	ldrb.w	r2, [r7, r3, lsl #3]
    dcce:	3a08      	subs	r2, #8
    dcd0:	2a01      	cmp	r2, #1
    dcd2:	d91a      	bls.n	dd0a <le_adv_update.constprop.0+0xe8>
	for (i = 0; i < ad_len; i++) {
    dcd4:	3301      	adds	r3, #1
    dcd6:	4599      	cmp	r9, r3
    dcd8:	d1f7      	bne.n	dcca <le_adv_update.constprop.0+0xa8>
    dcda:	e7bc      	b.n	dc56 <le_adv_update.constprop.0+0x34>
    dcdc:	2300      	movs	r3, #0
    dcde:	e7fa      	b.n	dcd6 <le_adv_update.constprop.0+0xb4>
		if (name_type == ADV_NAME_TYPE_SD) {
    dce0:	2e02      	cmp	r6, #2
    dce2:	f04f 0201 	mov.w	r2, #1
			d[1].len = 1;
    dce6:	bf08      	it	eq
    dce8:	9205      	streq	r2, [sp, #20]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    dcea:	a902      	add	r1, sp, #8
			d_len = 2;
    dcec:	bf08      	it	eq
    dcee:	4632      	moveq	r2, r6
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    dcf0:	f242 0009 	movw	r0, #8201	; 0x2009
			d[1].data = &data;
    dcf4:	bf08      	it	eq
    dcf6:	f8cd d010 	streq.w	sp, [sp, #16]
		d[0].len = sd_len;
    dcfa:	e9cd 7902 	strd	r7, r9, [sp, #8]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    dcfe:	f7f6 f9e7 	bl	40d0 <hci_set_ad>
		if (err) {
    dd02:	2800      	cmp	r0, #0
    dd04:	d0c5      	beq.n	dc92 <le_adv_update.constprop.0+0x70>
    dd06:	4604      	mov	r4, r0
    dd08:	e7d0      	b.n	dcac <le_adv_update.constprop.0+0x8a>
			return -EINVAL;
    dd0a:	f06f 0415 	mvn.w	r4, #21
    dd0e:	e7cd      	b.n	dcac <le_adv_update.constprop.0+0x8a>

0000dd10 <get_adv_name_type_param>:
	if (param->options & BT_LE_ADV_OPT_USE_NAME) {
    dd10:	6843      	ldr	r3, [r0, #4]
    dd12:	f013 0008 	ands.w	r0, r3, #8
    dd16:	d00a      	beq.n	dd2e <get_adv_name_type_param+0x1e>
		if (param->options & BT_LE_ADV_OPT_FORCE_NAME_IN_AD) {
    dd18:	035a      	lsls	r2, r3, #13
    dd1a:	d407      	bmi.n	dd2c <get_adv_name_type_param+0x1c>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
    dd1c:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
		return ADV_NAME_TYPE_SD;
    dd20:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    dd24:	bf0c      	ite	eq
    dd26:	2001      	moveq	r0, #1
    dd28:	2002      	movne	r0, #2
    dd2a:	4770      	bx	lr
			return ADV_NAME_TYPE_AD;
    dd2c:	2001      	movs	r0, #1
}
    dd2e:	4770      	bx	lr

0000dd30 <bt_le_adv_set_enable_legacy>:
{
    dd30:	b570      	push	{r4, r5, r6, lr}
    dd32:	4606      	mov	r6, r0
    dd34:	b086      	sub	sp, #24
    dd36:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    dd38:	f242 000a 	movw	r0, #8202	; 0x200a
    dd3c:	2101      	movs	r1, #1
    dd3e:	f7f5 f9f7 	bl	3130 <bt_hci_cmd_create>
	if (!buf) {
    dd42:	4604      	mov	r4, r0
    dd44:	b1b0      	cbz	r0, dd74 <bt_le_adv_set_enable_legacy+0x44>
	return net_buf_simple_add_u8(&buf->b, val);
    dd46:	3008      	adds	r0, #8
	if (enable) {
    dd48:	b195      	cbz	r5, dd70 <bt_le_adv_set_enable_legacy+0x40>
    dd4a:	2101      	movs	r1, #1
    dd4c:	f000 fefe 	bl	eb4c <net_buf_simple_add_u8>
	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_ADV_ENABLED, enable);
    dd50:	f106 0210 	add.w	r2, r6, #16
    dd54:	a903      	add	r1, sp, #12
    dd56:	4620      	mov	r0, r4
    dd58:	9500      	str	r5, [sp, #0]
    dd5a:	2306      	movs	r3, #6
    dd5c:	f7f5 f9d6 	bl	310c <bt_hci_cmd_state_set_init>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    dd60:	2200      	movs	r2, #0
    dd62:	4621      	mov	r1, r4
    dd64:	f242 000a 	movw	r0, #8202	; 0x200a
    dd68:	f7f5 fa1c 	bl	31a4 <bt_hci_cmd_send_sync>
}
    dd6c:	b006      	add	sp, #24
    dd6e:	bd70      	pop	{r4, r5, r6, pc}
    dd70:	4629      	mov	r1, r5
    dd72:	e7eb      	b.n	dd4c <bt_le_adv_set_enable_legacy+0x1c>
		return -ENOBUFS;
    dd74:	f06f 0068 	mvn.w	r0, #104	; 0x68
    dd78:	e7f8      	b.n	dd6c <bt_le_adv_set_enable_legacy+0x3c>

0000dd7a <bt_le_lim_adv_cancel_timeout>:
	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
    dd7a:	3018      	adds	r0, #24
    dd7c:	f001 bda2 	b.w	f8c4 <k_work_cancel_delayable>

0000dd80 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, uint16_t mem_size, uint16_t mem_count,
	      void **mem_head)
{
    dd80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*mem_head = mem_pool;
    dd82:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
    dd84:	1dc3      	adds	r3, r0, #7
{
    dd86:	4605      	mov	r5, r0
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
    dd88:	f023 0303 	bic.w	r3, r3, #3

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
    dd8c:	1e50      	subs	r0, r2, #1
{
    dd8e:	460e      	mov	r6, r1
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
    dd90:	b280      	uxth	r0, r0
{
    dd92:	4614      	mov	r4, r2
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
    dd94:	801a      	strh	r2, [r3, #0]
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
    dd96:	2100      	movs	r1, #0
    dd98:	2204      	movs	r2, #4
    dd9a:	fb06 5000 	mla	r0, r6, r0, r5
    dd9e:	f7ff fe3d 	bl	da1c <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
    dda2:	3c02      	subs	r4, #2
    dda4:	b2a4      	uxth	r4, r4
    dda6:	f64f 77ff 	movw	r7, #65535	; 0xffff
    ddaa:	42bc      	cmp	r4, r7
    ddac:	d101      	bne.n	ddb2 <mem_init+0x32>
		next = (uint32_t)((uint8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
    ddae:	b003      	add	sp, #12
    ddb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			       (mem_size * (mem_count + 1)));
    ddb2:	1c63      	adds	r3, r4, #1
    ddb4:	b29b      	uxth	r3, r3
    ddb6:	4373      	muls	r3, r6
		next = (uint32_t)((uint8_t *) mem_pool +
    ddb8:	18ea      	adds	r2, r5, r3
    ddba:	9201      	str	r2, [sp, #4]
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
    ddbc:	1b98      	subs	r0, r3, r6
    ddbe:	2204      	movs	r2, #4
    ddc0:	eb0d 0102 	add.w	r1, sp, r2
    ddc4:	4428      	add	r0, r5
    ddc6:	3c01      	subs	r4, #1
    ddc8:	f7ff fe1d 	bl	da06 <memcpy>
    ddcc:	b2a4      	uxth	r4, r4
    ddce:	e7ec      	b.n	ddaa <mem_init+0x2a>

0000ddd0 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
    ddd0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (*mem_head) {
    ddd2:	6804      	ldr	r4, [r0, #0]
{
    ddd4:	4605      	mov	r5, r0
	if (*mem_head) {
    ddd6:	b18c      	cbz	r4, ddfc <mem_acquire+0x2c>
		uint16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
    ddd8:	1de3      	adds	r3, r4, #7
    ddda:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
    ddde:	2204      	movs	r2, #4
    dde0:	4621      	mov	r1, r4
    dde2:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
    dde6:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
    dde8:	f7ff fe0d 	bl	da06 <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
    ddec:	9b01      	ldr	r3, [sp, #4]
    ddee:	b123      	cbz	r3, ddfa <mem_acquire+0x2a>
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
    ddf0:	1dda      	adds	r2, r3, #7
    ddf2:	f022 0203 	bic.w	r2, r2, #3
		free_count--;
    ddf6:	3e01      	subs	r6, #1
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
    ddf8:	8016      	strh	r6, [r2, #0]
				free_count;
		}

		*mem_head = head;
    ddfa:	602b      	str	r3, [r5, #0]
		return mem;
	}

	return NULL;
}
    ddfc:	4620      	mov	r0, r4
    ddfe:	b002      	add	sp, #8
    de00:	bd70      	pop	{r4, r5, r6, pc}

0000de02 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
    de02:	b570      	push	{r4, r5, r6, lr}
	uint16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
    de04:	680c      	ldr	r4, [r1, #0]
{
    de06:	4606      	mov	r6, r0
    de08:	460d      	mov	r5, r1
	if (*mem_head) {
    de0a:	b11c      	cbz	r4, de14 <mem_release+0x12>
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
    de0c:	1de3      	adds	r3, r4, #7
    de0e:	f023 0303 	bic.w	r3, r3, #3
    de12:	881c      	ldrh	r4, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
    de14:	2204      	movs	r2, #4
    de16:	4629      	mov	r1, r5
    de18:	4630      	mov	r0, r6
    de1a:	f7ff fdf4 	bl	da06 <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
    de1e:	1df2      	adds	r2, r6, #7
    de20:	f022 0203 	bic.w	r2, r2, #3
	free_count++;
    de24:	1c63      	adds	r3, r4, #1
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
    de26:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
    de28:	602e      	str	r6, [r5, #0]
}
    de2a:	bd70      	pop	{r4, r5, r6, pc}

0000de2c <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(uint8_t *dst, uint8_t const *src, uint16_t len)
{
    de2c:	b510      	push	{r4, lr}
	src += len;
    de2e:	4411      	add	r1, r2
	while (len--) {
    de30:	3801      	subs	r0, #1
    de32:	f64f 73ff 	movw	r3, #65535	; 0xffff
    de36:	3a01      	subs	r2, #1
    de38:	b292      	uxth	r2, r2
    de3a:	429a      	cmp	r2, r3
    de3c:	d100      	bne.n	de40 <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
    de3e:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
    de40:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
    de44:	f800 4f01 	strb.w	r4, [r0, #1]!
    de48:	e7f5      	b.n	de36 <mem_rcopy+0xa>

0000de4a <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
uint8_t mem_nz(uint8_t *src, uint16_t len)
{
	while (len--) {
    de4a:	4401      	add	r1, r0
    de4c:	4288      	cmp	r0, r1
    de4e:	d101      	bne.n	de54 <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
    de50:	2000      	movs	r0, #0
    de52:	4770      	bx	lr
		if (*src++) {
    de54:	f810 3b01 	ldrb.w	r3, [r0], #1
    de58:	2b00      	cmp	r3, #0
    de5a:	d0f7      	beq.n	de4c <mem_nz+0x2>
			return 1;
    de5c:	2001      	movs	r0, #1
}
    de5e:	4770      	bx	lr

0000de60 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
    de60:	6010      	str	r0, [r2, #0]
    de62:	6008      	str	r0, [r1, #0]

	return link;
}
    de64:	4770      	bx	lr

0000de66 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
    de66:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
    de68:	6814      	ldr	r4, [r2, #0]
    de6a:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
    de6c:	6814      	ldr	r4, [r2, #0]
    de6e:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	cpu_dmb(); /* Ensure data accesses are synchronized */
	*tail = link; /* Commit: enqueue of memq node */
    de70:	6010      	str	r0, [r2, #0]

	return link;
}
    de72:	bd10      	pop	{r4, pc}

0000de74 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
    de74:	4288      	cmp	r0, r1
    de76:	d003      	beq.n	de80 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
    de78:	b11a      	cbz	r2, de82 <memq_peek+0xe>
		*mem = head->mem;
    de7a:	6843      	ldr	r3, [r0, #4]
    de7c:	6013      	str	r3, [r2, #0]
    de7e:	4770      	bx	lr
		return NULL;
    de80:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
    de82:	4770      	bx	lr

0000de84 <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
    de84:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
    de86:	4283      	cmp	r3, r0
    de88:	d009      	beq.n	de9e <memq_dequeue+0x1a>
	if (mem) {
    de8a:	b122      	cbz	r2, de96 <memq_dequeue+0x12>
		*mem = head->mem;
    de8c:	6858      	ldr	r0, [r3, #4]
    de8e:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
    de90:	681a      	ldr	r2, [r3, #0]
    de92:	600a      	str	r2, [r1, #0]

	return old_head;
    de94:	e001      	b.n	de9a <memq_dequeue+0x16>
	if (old_head == NULL) {
    de96:	2b00      	cmp	r3, #0
    de98:	d1fa      	bne.n	de90 <memq_dequeue+0xc>
}
    de9a:	4618      	mov	r0, r3
    de9c:	4770      	bx	lr
		return NULL; /* queue is empty */
    de9e:	2300      	movs	r3, #0
    dea0:	e7fb      	b.n	de9a <memq_dequeue+0x16>

0000dea2 <util_ones_count_get>:
 * @param octets_len Must not be bigger than 255/8 = 31 bytes
 *
 * @return popcnt of 'octets'
 */
uint8_t util_ones_count_get(const uint8_t *octets, uint8_t octets_len)
{
    dea2:	b510      	push	{r4, lr}
    dea4:	1e43      	subs	r3, r0, #1
	uint8_t one_count = 0U;
    dea6:	2000      	movs	r0, #0

	while (octets_len--) {
    dea8:	3901      	subs	r1, #1
    deaa:	b2c9      	uxtb	r1, r1
    deac:	29ff      	cmp	r1, #255	; 0xff
    deae:	d100      	bne.n	deb2 <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
    deb0:	bd10      	pop	{r4, pc}
		bite = *octets;
    deb2:	f813 2f01 	ldrb.w	r2, [r3, #1]!
		while (bite) {
    deb6:	2a00      	cmp	r2, #0
    deb8:	d0f6      	beq.n	dea8 <util_ones_count_get+0x6>
			bite &= (bite - 1);
    deba:	1e54      	subs	r4, r2, #1
			one_count++;
    debc:	3001      	adds	r0, #1
			bite &= (bite - 1);
    debe:	4022      	ands	r2, r4
			one_count++;
    dec0:	b2c0      	uxtb	r0, r0
    dec2:	e7f8      	b.n	deb6 <util_ones_count_get+0x14>

0000dec4 <ticker_dequeue>:
{
    dec4:	b5f0      	push	{r4, r5, r6, r7, lr}
	previous = instance->ticker_id_head;
    dec6:	7f42      	ldrb	r2, [r0, #29]
	node = &instance->nodes[0];
    dec8:	6806      	ldr	r6, [r0, #0]
{
    deca:	4605      	mov	r5, r0
    decc:	468c      	mov	ip, r1
	previous = instance->ticker_id_head;
    dece:	4613      	mov	r3, r2
	total = 0U;
    ded0:	2000      	movs	r0, #0
	while (current != TICKER_NULL) {
    ded2:	2aff      	cmp	r2, #255	; 0xff
    ded4:	d101      	bne.n	deda <ticker_dequeue+0x16>
		return 0;
    ded6:	2000      	movs	r0, #0
}
    ded8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticker_current = &node[current];
    deda:	eb02 0442 	add.w	r4, r2, r2, lsl #1
    dede:	0127      	lsls	r7, r4, #4
    dee0:	eb06 1404 	add.w	r4, r6, r4, lsl #4
		if (current == id) {
    dee4:	4562      	cmp	r2, ip
		total += ticker_current->ticks_to_expire;
    dee6:	68a1      	ldr	r1, [r4, #8]
		current = ticker_current->next;
    dee8:	5df7      	ldrb	r7, [r6, r7]
		total += ticker_current->ticks_to_expire;
    deea:	4408      	add	r0, r1
		if (current == id) {
    deec:	d002      	beq.n	def4 <ticker_dequeue+0x30>
    deee:	4613      	mov	r3, r2
		current = ticker_current->next;
    def0:	463a      	mov	r2, r7
    def2:	e7ee      	b.n	ded2 <ticker_dequeue+0xe>
	if (previous == current) {
    def4:	4293      	cmp	r3, r2
    def6:	d100      	bne.n	defa <ticker_dequeue+0x36>
		instance->ticker_id_head = ticker_current->next;
    def8:	776f      	strb	r7, [r5, #29]
	node[previous].next = ticker_current->next;
    defa:	b21b      	sxth	r3, r3
    defc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    df00:	011b      	lsls	r3, r3, #4
    df02:	54f7      	strb	r7, [r6, r3]
	if (ticker_current->next != TICKER_NULL) {
    df04:	7823      	ldrb	r3, [r4, #0]
    df06:	2bff      	cmp	r3, #255	; 0xff
    df08:	d0e6      	beq.n	ded8 <ticker_dequeue+0x14>
		node[ticker_current->next].ticks_to_expire += timeout;
    df0a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    df0e:	eb06 1303 	add.w	r3, r6, r3, lsl #4
    df12:	689a      	ldr	r2, [r3, #8]
    df14:	440a      	add	r2, r1
    df16:	609a      	str	r2, [r3, #8]
	return (total + timeout);
    df18:	e7de      	b.n	ded8 <ticker_dequeue+0x14>

0000df1a <ticks_to_expire_prep>:
{
    df1a:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
    df1c:	1a55      	subs	r5, r2, r1
    df1e:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	uint32_t ticks_to_expire = ticker->ticks_to_expire;
    df22:	6883      	ldr	r3, [r0, #8]
	uint32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
    df24:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
    df26:	d109      	bne.n	df3c <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    df28:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
    df2c:	442b      	add	r3, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
    df2e:	42a3      	cmp	r3, r4
    df30:	d90e      	bls.n	df50 <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
    df32:	1b1b      	subs	r3, r3, r4
		ticks_to_expire_minus = 0U;
    df34:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
    df36:	6083      	str	r3, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
    df38:	6144      	str	r4, [r0, #20]
}
    df3a:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    df3c:	1a8a      	subs	r2, r1, r2
    df3e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
    df42:	4293      	cmp	r3, r2
    df44:	d901      	bls.n	df4a <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
    df46:	1a9b      	subs	r3, r3, r2
    df48:	e7f1      	b.n	df2e <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
    df4a:	4414      	add	r4, r2
    df4c:	1ae4      	subs	r4, r4, r3
			ticks_to_expire = 0U;
    df4e:	2300      	movs	r3, #0
		ticks_to_expire_minus -= ticks_to_expire;
    df50:	1ae4      	subs	r4, r4, r3
		ticks_to_expire = 0U;
    df52:	2300      	movs	r3, #0
    df54:	e7ef      	b.n	df36 <ticks_to_expire_prep+0x1c>

0000df56 <ticker_job_op_cb>:
{
    df56:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
    df58:	2200      	movs	r2, #0
    df5a:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
    df5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	user_op->status = status;
    df5e:	6299      	str	r1, [r3, #40]	; 0x28
{
    df60:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
    df62:	b10a      	cbz	r2, df68 <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
    df64:	6b19      	ldr	r1, [r3, #48]	; 0x30
    df66:	4710      	bx	r2
}
    df68:	4770      	bx	lr

0000df6a <ticker_job_list_insert>:
{
    df6a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    df6e:	b089      	sub	sp, #36	; 0x24
	node = &instance->nodes[0];
    df70:	6803      	ldr	r3, [r0, #0]
    df72:	9303      	str	r3, [sp, #12]
	users = &instance->users[0];
    df74:	6843      	ldr	r3, [r0, #4]
    df76:	9305      	str	r3, [sp, #20]
	while (count_user--) {
    df78:	7a43      	ldrb	r3, [r0, #9]
{
    df7a:	4606      	mov	r6, r0
    df7c:	4688      	mov	r8, r1
    df7e:	3b01      	subs	r3, #1
    df80:	fa5f fa83 	uxtb.w	sl, r3
	while (count_user--) {
    df84:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
    df88:	d102      	bne.n	df90 <ticker_job_list_insert+0x26>
}
    df8a:	b009      	add	sp, #36	; 0x24
    df8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		user = &users[count_user];
    df90:	9b05      	ldr	r3, [sp, #20]
    df92:	eb03 0bca 	add.w	fp, r3, sl, lsl #3
		user_ops = (void *)&user->user_op[0];
    df96:	f8db 3004 	ldr.w	r3, [fp, #4]
		user_ops_first = user->first;
    df9a:	f89b 7001 	ldrb.w	r7, [fp, #1]
		user_ops = (void *)&user->user_op[0];
    df9e:	9304      	str	r3, [sp, #16]
		while ((insert_head != TICKER_NULL) ||
    dfa0:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
    dfa4:	d076      	beq.n	e094 <ticker_job_list_insert+0x12a>
				ticker = &node[id_insert];
    dfa6:	eb08 0448 	add.w	r4, r8, r8, lsl #1
    dfaa:	9a03      	ldr	r2, [sp, #12]
    dfac:	f8cd 8008 	str.w	r8, [sp, #8]
    dfb0:	0123      	lsls	r3, r4, #4
				user_op = NULL;
    dfb2:	2500      	movs	r5, #0
				insert_head = ticker->next;
    dfb4:	f812 8003 	ldrb.w	r8, [r2, r3]
				ticker = &node[id_insert];
    dfb8:	eb02 1404 	add.w	r4, r2, r4, lsl #4
	ticker->next = TICKER_NULL;
    dfbc:	23ff      	movs	r3, #255	; 0xff
    dfbe:	7023      	strb	r3, [r4, #0]
	ticker_new = &node[id];
    dfc0:	f9bd c008 	ldrsh.w	ip, [sp, #8]
	node = &instance->nodes[0];
    dfc4:	6830      	ldr	r0, [r6, #0]
	ticker_new = &node[id];
    dfc6:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
    dfca:	ea4f 120c 	mov.w	r2, ip, lsl #4
    dfce:	eb00 1c0c 	add.w	ip, r0, ip, lsl #4
    dfd2:	9206      	str	r2, [sp, #24]
	ticks_to_expire = ticker_new->ticks_to_expire;
    dfd4:	f8dc 2008 	ldr.w	r2, [ip, #8]
    dfd8:	9201      	str	r2, [sp, #4]
	current = instance->ticker_id_head;
    dfda:	7f72      	ldrb	r2, [r6, #29]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
    dfdc:	2aff      	cmp	r2, #255	; 0xff
    dfde:	d00c      	beq.n	dffa <ticker_job_list_insert+0x90>
		(ticker_current = &node[current])->ticks_to_expire))) {
    dfe0:	eb02 0e42 	add.w	lr, r2, r2, lsl #1
    dfe4:	ea4f 110e 	mov.w	r1, lr, lsl #4
    dfe8:	eb00 1e0e 	add.w	lr, r0, lr, lsl #4
    dfec:	9107      	str	r1, [sp, #28]
		(ticks_to_expire_current =
    dfee:	f8de 9008 	ldr.w	r9, [lr, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
    dff2:	9901      	ldr	r1, [sp, #4]
    dff4:	4549      	cmp	r1, r9
    dff6:	f080 8085 	bcs.w	e104 <ticker_job_list_insert+0x19a>
	if (previous == TICKER_NULL) {
    dffa:	2bff      	cmp	r3, #255	; 0xff
		node[previous].next = id;
    dffc:	bf18      	it	ne
    dffe:	b21b      	sxthne	r3, r3
	ticker_new->ticks_to_expire = ticks_to_expire;
    e000:	9901      	ldr	r1, [sp, #4]
    e002:	f8cc 1008 	str.w	r1, [ip, #8]
		node[previous].next = id;
    e006:	bf18      	it	ne
    e008:	eb03 0343 	addne.w	r3, r3, r3, lsl #1
	ticker_new->next = current;
    e00c:	9906      	ldr	r1, [sp, #24]
		instance->ticker_id_head = id;
    e00e:	bf08      	it	eq
    e010:	9b02      	ldreq	r3, [sp, #8]
	ticker_new->next = current;
    e012:	5442      	strb	r2, [r0, r1]
		node[previous].next = id;
    e014:	bf1d      	ittte	ne
    e016:	011b      	lslne	r3, r3, #4
    e018:	9902      	ldrne	r1, [sp, #8]
    e01a:	54c1      	strbne	r1, [r0, r3]
		instance->ticker_id_head = id;
    e01c:	7773      	strbeq	r3, [r6, #29]
	if (current != TICKER_NULL) {
    e01e:	2aff      	cmp	r2, #255	; 0xff
    e020:	d007      	beq.n	e032 <ticker_job_list_insert+0xc8>
		node[current].ticks_to_expire -= ticks_to_expire;
    e022:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    e026:	eb00 1202 	add.w	r2, r0, r2, lsl #4
    e02a:	9901      	ldr	r1, [sp, #4]
    e02c:	6893      	ldr	r3, [r2, #8]
    e02e:	1a5b      	subs	r3, r3, r1
    e030:	6093      	str	r3, [r2, #8]
	ticker->req = ticker->ack + 1;
    e032:	78a3      	ldrb	r3, [r4, #2]
    e034:	3301      	adds	r3, #1
    e036:	7063      	strb	r3, [r4, #1]
			if (user_op) {
    e038:	2d00      	cmp	r5, #0
    e03a:	d0b1      	beq.n	dfa0 <ticker_job_list_insert+0x36>
				ticker_job_op_cb(user_op, status);
    e03c:	2100      	movs	r1, #0
    e03e:	4628      	mov	r0, r5
    e040:	f7ff ff89 	bl	df56 <ticker_job_op_cb>
				if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
    e044:	6863      	ldr	r3, [r4, #4]
    e046:	2b00      	cmp	r3, #0
    e048:	d1aa      	bne.n	dfa0 <ticker_job_list_insert+0x36>
					ticker->fp_op_func =
    e04a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e04c:	6223      	str	r3, [r4, #32]
					ticker->op_context =
    e04e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    e050:	6263      	str	r3, [r4, #36]	; 0x24
    e052:	e7a5      	b.n	dfa0 <ticker_job_list_insert+0x36>
				user_op = &user_ops[user_ops_first];
    e054:	9a04      	ldr	r2, [sp, #16]
    e056:	2334      	movs	r3, #52	; 0x34
    e058:	fb17 f303 	smulbb	r3, r7, r3
    e05c:	18d5      	adds	r5, r2, r3
				first = user_ops_first + 1;
    e05e:	3701      	adds	r7, #1
				if (first == user->count_user_op) {
    e060:	f89b 2000 	ldrb.w	r2, [fp]
				first = user_ops_first + 1;
    e064:	b2ff      	uxtb	r7, r7
					first = 0U;
    e066:	42ba      	cmp	r2, r7
    e068:	bf08      	it	eq
    e06a:	2700      	moveq	r7, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
    e06c:	9a04      	ldr	r2, [sp, #16]
    e06e:	5cd3      	ldrb	r3, [r2, r3]
    e070:	2b04      	cmp	r3, #4
    e072:	d10f      	bne.n	e094 <ticker_job_list_insert+0x12a>
				id_insert = user_op->id;
    e074:	786b      	ldrb	r3, [r5, #1]
    e076:	9302      	str	r3, [sp, #8]
				ticker = &node[id_insert];
    e078:	eb03 0443 	add.w	r4, r3, r3, lsl #1
    e07c:	9b03      	ldr	r3, [sp, #12]
    e07e:	eb03 1404 	add.w	r4, r3, r4, lsl #4
				if (((ticker->req -
    e082:	7863      	ldrb	r3, [r4, #1]
				      ticker->ack) & 0xff) != 0U) {
    e084:	78a2      	ldrb	r2, [r4, #2]
				if (((ticker->req -
    e086:	1a9b      	subs	r3, r3, r2
				      ticker->ack) & 0xff) != 0U) {
    e088:	b2db      	uxtb	r3, r3
				if (((ticker->req -
    e08a:	b153      	cbz	r3, e0a2 <ticker_job_list_insert+0x138>
					ticker_job_op_cb(user_op,
    e08c:	2101      	movs	r1, #1
    e08e:	4628      	mov	r0, r5
    e090:	f7ff ff61 	bl	df56 <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
    e094:	f89b 3002 	ldrb.w	r3, [fp, #2]
    e098:	42bb      	cmp	r3, r7
    e09a:	d1db      	bne.n	e054 <ticker_job_list_insert+0xea>
    e09c:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
    e0a0:	e76e      	b.n	df80 <ticker_job_list_insert+0x16>
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
    e0a2:	8aab      	ldrh	r3, [r5, #20]
				ticker_job_op_start(ticker, user_op,
    e0a4:	6971      	ldr	r1, [r6, #20]
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
    e0a6:	f64f 72fe 	movw	r2, #65534	; 0xfffe
    e0aa:	4293      	cmp	r3, r2
    e0ac:	d006      	beq.n	e0bc <ticker_job_list_insert+0x152>
		ticker->must_expire =
    e0ae:	f64f 72ff 	movw	r2, #65535	; 0xffff
    e0b2:	1a98      	subs	r0, r3, r2
    e0b4:	4242      	negs	r2, r0
    e0b6:	4142      	adcs	r2, r0
    e0b8:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
    e0bc:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    e0be:	62a2      	str	r2, [r4, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
    e0c0:	68ea      	ldr	r2, [r5, #12]
    e0c2:	6062      	str	r2, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
    e0c4:	692a      	ldr	r2, [r5, #16]
    e0c6:	6222      	str	r2, [r4, #32]
	ticker->lazy_periodic =
    e0c8:	f64f 72fd 	movw	r2, #65533	; 0xfffd
    e0cc:	4293      	cmp	r3, r2
    e0ce:	bf88      	it	hi
    e0d0:	2300      	movhi	r3, #0
    e0d2:	83a3      	strh	r3, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
    e0d4:	69ab      	ldr	r3, [r5, #24]
    e0d6:	61a3      	str	r3, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
    e0d8:	69eb      	ldr	r3, [r5, #28]
    e0da:	60e3      	str	r3, [r4, #12]
	ticker->context = start->context;
    e0dc:	6a2b      	ldr	r3, [r5, #32]
    e0de:	6123      	str	r3, [r4, #16]
	ticker->ticks_to_expire_minus = 0U;
    e0e0:	f04f 0900 	mov.w	r9, #0
	ticker->ticks_to_expire = start->ticks_first;
    e0e4:	68ab      	ldr	r3, [r5, #8]
    e0e6:	60a3      	str	r3, [r4, #8]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
    e0e8:	686a      	ldr	r2, [r5, #4]
	ticker->ticks_to_expire_minus = 0U;
    e0ea:	f8c4 9014 	str.w	r9, [r4, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
    e0ee:	4620      	mov	r0, r4
    e0f0:	f7ff ff13 	bl	df1a <ticks_to_expire_prep>
	ticker->force = 1U;
    e0f4:	f04f 0301 	mov.w	r3, #1
	ticker->remainder_current = 0U;
    e0f8:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
    e0fc:	f8a4 901e 	strh.w	r9, [r4, #30]
	ticker->force = 1U;
    e100:	70e3      	strb	r3, [r4, #3]
}
    e102:	e75b      	b.n	dfbc <ticker_job_list_insert+0x52>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
    e104:	9901      	ldr	r1, [sp, #4]
    e106:	ebb1 0109 	subs.w	r1, r1, r9
    e10a:	9101      	str	r1, [sp, #4]
    e10c:	d105      	bne.n	e11a <ticker_job_list_insert+0x1b0>
    e10e:	f8bc 101e 	ldrh.w	r1, [ip, #30]
    e112:	f8be e01e 	ldrh.w	lr, [lr, #30]
    e116:	4571      	cmp	r1, lr
    e118:	d803      	bhi.n	e122 <ticker_job_list_insert+0x1b8>
		current = ticker_current->next;
    e11a:	4613      	mov	r3, r2
    e11c:	9a07      	ldr	r2, [sp, #28]
    e11e:	5c82      	ldrb	r2, [r0, r2]
    e120:	e75c      	b.n	dfdc <ticker_job_list_insert+0x72>
    e122:	f8cd 9004 	str.w	r9, [sp, #4]
    e126:	e768      	b.n	dffa <ticker_job_list_insert+0x90>

0000e128 <ticker_worker>:
{
    e128:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
    e12c:	7f86      	ldrb	r6, [r0, #30]
	instance->worker_trigger = 1U;
    e12e:	2301      	movs	r3, #1
{
    e130:	b08d      	sub	sp, #52	; 0x34
    e132:	4605      	mov	r5, r0
	instance->worker_trigger = 1U;
    e134:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
    e136:	b91e      	cbnz	r6, e140 <ticker_worker+0x18>
	if (instance->ticker_id_head == TICKER_NULL) {
    e138:	7f43      	ldrb	r3, [r0, #29]
    e13a:	2bff      	cmp	r3, #255	; 0xff
    e13c:	d103      	bne.n	e146 <ticker_worker+0x1e>
		instance->worker_trigger = 0U;
    e13e:	77c6      	strb	r6, [r0, #31]
}
    e140:	b00d      	add	sp, #52	; 0x34
    e142:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
    e146:	f7f9 ffd7 	bl	80f8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    e14a:	696b      	ldr	r3, [r5, #20]
	ticker_id_head = instance->ticker_id_head;
    e14c:	7f6f      	ldrb	r7, [r5, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    e14e:	1ac0      	subs	r0, r0, r3
	if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
    e150:	7f2b      	ldrb	r3, [r5, #28]
    e152:	2bff      	cmp	r3, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    e154:	f020 4b7f 	bic.w	fp, r0, #4278190080	; 0xff000000
	if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
    e158:	d004      	beq.n	e164 <ticker_worker+0x3c>
		if (instance->ticks_slot_previous > ticks_elapsed) {
    e15a:	69ae      	ldr	r6, [r5, #24]
	uint8_t slot_reserved = 0;
    e15c:	455e      	cmp	r6, fp
    e15e:	bf94      	ite	ls
    e160:	2600      	movls	r6, #0
    e162:	2601      	movhi	r6, #1
	node = &instance->nodes[0];
    e164:	f8d5 9000 	ldr.w	r9, [r5]
	ticks_expired = 0U;
    e168:	f04f 0800 	mov.w	r8, #0
	while (ticker_id_head != TICKER_NULL) {
    e16c:	2fff      	cmp	r7, #255	; 0xff
    e16e:	d11a      	bne.n	e1a6 <ticker_worker+0x7e>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
    e170:	7aea      	ldrb	r2, [r5, #11]
    e172:	7aab      	ldrb	r3, [r5, #10]
    e174:	4293      	cmp	r3, r2
    e176:	d105      	bne.n	e184 <ticker_worker+0x5c>
	uint8_t idx = *ticks_elapsed_index + 1;
    e178:	3301      	adds	r3, #1
    e17a:	b2db      	uxtb	r3, r3
		idx = 0U;
    e17c:	2b02      	cmp	r3, #2
    e17e:	bf08      	it	eq
    e180:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
    e182:	72eb      	strb	r3, [r5, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
    e184:	7aeb      	ldrb	r3, [r5, #11]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
    e186:	6a6c      	ldr	r4, [r5, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
    e188:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
    e18c:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
    e18e:	f8c3 800c 	str.w	r8, [r3, #12]
	instance->worker_trigger = 0U;
    e192:	2300      	movs	r3, #0
    e194:	77eb      	strb	r3, [r5, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
    e196:	2104      	movs	r1, #4
    e198:	462b      	mov	r3, r5
    e19a:	2003      	movs	r0, #3
    e19c:	46a4      	mov	ip, r4
}
    e19e:	b00d      	add	sp, #52	; 0x34
    e1a0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
    e1a4:	4760      	bx	ip
		ticker = &node[ticker_id_head];
    e1a6:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    e1aa:	eb09 1407 	add.w	r4, r9, r7, lsl #4
    e1ae:	013a      	lsls	r2, r7, #4
		ticks_to_expire = ticker->ticks_to_expire;
    e1b0:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
    e1b2:	459b      	cmp	fp, r3
    e1b4:	d3dc      	bcc.n	e170 <ticker_worker+0x48>
		ticks_elapsed -= ticks_to_expire;
    e1b6:	ebab 0b03 	sub.w	fp, fp, r3
		ticks_expired += ticks_to_expire;
    e1ba:	4498      	add	r8, r3
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
    e1bc:	78a3      	ldrb	r3, [r4, #2]
    e1be:	9303      	str	r3, [sp, #12]
		ticker_id_head = ticker->next;
    e1c0:	f819 7002 	ldrb.w	r7, [r9, r2]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
    e1c4:	7863      	ldrb	r3, [r4, #1]
    e1c6:	9a03      	ldr	r2, [sp, #12]
    e1c8:	1a9b      	subs	r3, r3, r2
    e1ca:	b2db      	uxtb	r3, r3
    e1cc:	2b01      	cmp	r3, #1
    e1ce:	d1cd      	bne.n	e16c <ticker_worker+0x44>
		if (ticker->ticks_slot != 0U &&
    e1d0:	69a3      	ldr	r3, [r4, #24]
    e1d2:	9304      	str	r3, [sp, #16]
    e1d4:	2b00      	cmp	r3, #0
    e1d6:	d034      	beq.n	e242 <ticker_worker+0x11a>
    e1d8:	2e00      	cmp	r6, #0
    e1da:	f040 80a8 	bne.w	e32e <ticker_worker+0x206>
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
    e1de:	f994 302d 	ldrsb.w	r3, [r4, #45]	; 0x2d
    e1e2:	9305      	str	r3, [sp, #20]
    e1e4:	3380      	adds	r3, #128	; 0x80
    e1e6:	d02c      	beq.n	e242 <ticker_worker+0x11a>
    e1e8:	2fff      	cmp	r7, #255	; 0xff
    e1ea:	d02a      	beq.n	e242 <ticker_worker+0x11a>
		int32_t lazy_current = ticker->lazy_current;
    e1ec:	8be3      	ldrh	r3, [r4, #30]
		if (lazy_current >= ticker->lazy_periodic) {
    e1ee:	8ba2      	ldrh	r2, [r4, #28]
		uint32_t current_age = ticker->ticks_periodic +
    e1f0:	6861      	ldr	r1, [r4, #4]
		if (lazy_current >= ticker->lazy_periodic) {
    e1f2:	4293      	cmp	r3, r2
			lazy_current -= ticker->lazy_periodic;
    e1f4:	bf28      	it	cs
    e1f6:	1a9b      	subcs	r3, r3, r2
		uint32_t current_age = ticker->ticks_periodic +
    e1f8:	fb03 1201 	mla	r2, r3, r1, r1
    e1fc:	9209      	str	r2, [sp, #36]	; 0x24
		uint32_t acc_ticks_to_expire = 0U;
    e1fe:	2200      	movs	r2, #0
    e200:	9206      	str	r2, [sp, #24]
				(lazy_current - ticker->priority);
    e202:	9a05      	ldr	r2, [sp, #20]
    e204:	1a9b      	subs	r3, r3, r2
		uint32_t current_age = ticker->ticks_periodic +
    e206:	46ba      	mov	sl, r7
				(lazy_current - ticker->priority);
    e208:	930b      	str	r3, [sp, #44]	; 0x2c
			struct ticker_node *ticker_next = &nodes[id_head];
    e20a:	fa0f fa8a 	sxth.w	sl, sl
    e20e:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
    e212:	ea4f 130a 	mov.w	r3, sl, lsl #4
    e216:	eb09 1a0a 	add.w	sl, r9, sl, lsl #4
    e21a:	9308      	str	r3, [sp, #32]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
    e21c:	f8da c008 	ldr.w	ip, [sl, #8]
    e220:	9b06      	ldr	r3, [sp, #24]
    e222:	4463      	add	r3, ip
    e224:	9306      	str	r3, [sp, #24]
			if (acc_ticks_to_expire > ticker->ticks_slot) {
    e226:	9a06      	ldr	r2, [sp, #24]
    e228:	9b04      	ldr	r3, [sp, #16]
    e22a:	4293      	cmp	r3, r2
    e22c:	d309      	bcc.n	e242 <ticker_worker+0x11a>
			if (ticker_next->ticks_slot == 0U) {
    e22e:	f8da 3018 	ldr.w	r3, [sl, #24]
    e232:	2b00      	cmp	r3, #0
    e234:	d13a      	bne.n	e2ac <ticker_worker+0x184>
			id_head = ticker_next->next;
    e236:	9b08      	ldr	r3, [sp, #32]
    e238:	f819 a003 	ldrb.w	sl, [r9, r3]
		while (id_head != TICKER_NULL) {
    e23c:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
    e240:	d1e3      	bne.n	e20a <ticker_worker+0xe2>
		must_expire_skip = 0U;
    e242:	f04f 0a00 	mov.w	sl, #0
		if (ticker->ext_data) {
    e246:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e248:	2b00      	cmp	r3, #0
    e24a:	f000 809a 	beq.w	e382 <ticker_worker+0x25a>
			ticker->ext_data->ticks_drift = 0U;
    e24e:	2200      	movs	r2, #0
			ticks_drift = ticker->ext_data->ticks_drift;
    e250:	6859      	ldr	r1, [r3, #4]
			ticker->ext_data->reschedule_state =
    e252:	721a      	strb	r2, [r3, #8]
			ticker->ext_data->ticks_drift = 0U;
    e254:	605a      	str	r2, [r3, #4]
		ticker->ack--;
    e256:	9b03      	ldr	r3, [sp, #12]
    e258:	3b01      	subs	r3, #1
    e25a:	70a3      	strb	r3, [r4, #2]
		if (ticker->timeout_func) {
    e25c:	68e3      	ldr	r3, [r4, #12]
    e25e:	469e      	mov	lr, r3
    e260:	2b00      	cmp	r3, #0
    e262:	d083      	beq.n	e16c <ticker_worker+0x44>
					   ticks_expired -
    e264:	6960      	ldr	r0, [r4, #20]
    e266:	696b      	ldr	r3, [r5, #20]
			ticker->timeout_func(ticks_at_expire,
    e268:	6a62      	ldr	r2, [r4, #36]	; 0x24
					   ticks_expired -
    e26a:	eba8 0000 	sub.w	r0, r8, r0
    e26e:	4418      	add	r0, r3
			ticks_at_expire = (instance->ticks_current +
    e270:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
    e274:	f1ba 0f00 	cmp.w	sl, #0
    e278:	f040 8085 	bne.w	e386 <ticker_worker+0x25e>
    e27c:	8be3      	ldrh	r3, [r4, #30]
    e27e:	f8d4 c010 	ldr.w	ip, [r4, #16]
    e282:	f8cd c004 	str.w	ip, [sp, #4]
    e286:	f894 c003 	ldrb.w	ip, [r4, #3]
    e28a:	f8cd c000 	str.w	ip, [sp]
    e28e:	46f4      	mov	ip, lr
    e290:	47e0      	blx	ip
			if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
    e292:	f1ba 0f00 	cmp.w	sl, #0
    e296:	f47f af69 	bne.w	e16c <ticker_worker+0x44>
				if (ticker->ticks_slot != 0U) {
    e29a:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
    e29c:	f8a4 a01e 	strh.w	sl, [r4, #30]
					slot_reserved = 1U;
    e2a0:	2b00      	cmp	r3, #0
				ticker->force = 0U;
    e2a2:	f884 a003 	strb.w	sl, [r4, #3]
					slot_reserved = 1U;
    e2a6:	bf18      	it	ne
    e2a8:	2601      	movne	r6, #1
    e2aa:	e75f      	b.n	e16c <ticker_worker+0x44>
			int32_t lazy_next = ticker_next->lazy_current;
    e2ac:	f8ba 201e 	ldrh.w	r2, [sl, #30]
				ticker_next->lazy_periodic > lazy_next;
    e2b0:	f8ba 001c 	ldrh.w	r0, [sl, #28]
				ticker_next->priority;
    e2b4:	f99a e02d 	ldrsb.w	lr, [sl, #45]	; 0x2d
    e2b8:	f8cd e01c 	str.w	lr, [sp, #28]
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
    e2bc:	f8da e004 	ldr.w	lr, [sl, #4]
			if (!lazy_next_periodic_skip) {
    e2c0:	4282      	cmp	r2, r0
			int32_t lazy_next = ticker_next->lazy_current;
    e2c2:	4613      	mov	r3, r2
				lazy_next -= ticker_next->lazy_periodic;
    e2c4:	bf28      	it	cs
    e2c6:	1a13      	subcs	r3, r2, r0
					  0U :
    e2c8:	f1be 0f00 	cmp.w	lr, #0
    e2cc:	d04d      	beq.n	e36a <ticker_worker+0x242>
    e2ce:	ebae 0c0c 	sub.w	ip, lr, ip
				(ticker->ticks_periodic == 0U) ||
    e2d2:	2900      	cmp	r1, #0
    e2d4:	d04b      	beq.n	e36e <ticker_worker+0x246>
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
    e2d6:	fb0e cc03 	mla	ip, lr, r3, ip
				(ticker->ticks_periodic == 0U) ||
    e2da:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
    e2de:	45e6      	cmp	lr, ip
    e2e0:	bf8c      	ite	hi
    e2e2:	f04f 0e01 	movhi.w	lr, #1
    e2e6:	f04f 0e00 	movls.w	lr, #0
					(ticker->ticks_periodic != 0U) &&
    e2ea:	bf34      	ite	cc
    e2ec:	f04f 0c01 	movcc.w	ip, #1
    e2f0:	f04f 0c00 	movcs.w	ip, #0
			uint8_t next_force = (ticker_next->force > ticker->force);
    e2f4:	f89a a003 	ldrb.w	sl, [sl, #3]
    e2f8:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
			if (!lazy_next_periodic_skip &&
    e2fc:	4282      	cmp	r2, r0
			uint8_t next_force = (ticker_next->force > ticker->force);
    e2fe:	f894 a003 	ldrb.w	sl, [r4, #3]
			if (!lazy_next_periodic_skip &&
    e302:	d398      	bcc.n	e236 <ticker_worker+0x10e>
    e304:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    e306:	4552      	cmp	r2, sl
    e308:	d811      	bhi.n	e32e <ticker_worker+0x206>
			    (next_force ||
    e30a:	9a07      	ldr	r2, [sp, #28]
    e30c:	f112 0f80 	cmn.w	r2, #128	; 0x80
    e310:	d00d      	beq.n	e32e <ticker_worker+0x206>
				(lazy_next - ticker_next->priority) >
    e312:	1a9b      	subs	r3, r3, r2
			     next_is_critical ||
    e314:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    e316:	4293      	cmp	r3, r2
    e318:	dd02      	ble.n	e320 <ticker_worker+0x1f8>
			     (next_has_priority && !current_is_older) ||
    e31a:	f1be 0f00 	cmp.w	lr, #0
    e31e:	d006      	beq.n	e32e <ticker_worker+0x206>
    e320:	9b05      	ldr	r3, [sp, #20]
    e322:	9a07      	ldr	r2, [sp, #28]
    e324:	4293      	cmp	r3, r2
    e326:	d186      	bne.n	e236 <ticker_worker+0x10e>
			     (equal_priority && next_is_older))) {
    e328:	f1bc 0f00 	cmp.w	ip, #0
    e32c:	d083      	beq.n	e236 <ticker_worker+0x10e>
			struct ticker_ext *ext_data = ticker->ext_data;
    e32e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		int32_t lazy_current = ticker->lazy_current;
    e330:	8be2      	ldrh	r2, [r4, #30]
			if (ext_data &&
    e332:	b14b      	cbz	r3, e348 <ticker_worker+0x220>
    e334:	6819      	ldr	r1, [r3, #0]
    e336:	b1f1      	cbz	r1, e376 <ticker_worker+0x24e>
			    ext_data->ticks_slot_window != 0U &&
    e338:	7a19      	ldrb	r1, [r3, #8]
    e33a:	b9e1      	cbnz	r1, e376 <ticker_worker+0x24e>
			    TICKER_RESCHEDULE_STATE_NONE &&
    e33c:	8ba1      	ldrh	r1, [r4, #28]
    e33e:	4291      	cmp	r1, r2
    e340:	d819      	bhi.n	e376 <ticker_worker+0x24e>
				ext_data->reschedule_state =
    e342:	f04f 0101 	mov.w	r1, #1
				ext_data->reschedule_state =
    e346:	7219      	strb	r1, [r3, #8]
			ticker->lazy_current++;
    e348:	3201      	adds	r2, #1
			if ((ticker->must_expire == 0U) ||
    e34a:	f894 102c 	ldrb.w	r1, [r4, #44]	; 0x2c
			ticker->lazy_current++;
    e34e:	b292      	uxth	r2, r2
    e350:	83e2      	strh	r2, [r4, #30]
			if ((ticker->must_expire == 0U) ||
    e352:	b131      	cbz	r1, e362 <ticker_worker+0x23a>
    e354:	8ba1      	ldrh	r1, [r4, #28]
    e356:	4291      	cmp	r1, r2
    e358:	d203      	bcs.n	e362 <ticker_worker+0x23a>
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
    e35a:	b17b      	cbz	r3, e37c <ticker_worker+0x254>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
    e35c:	7a1b      	ldrb	r3, [r3, #8]
    e35e:	2b01      	cmp	r3, #1
    e360:	d10c      	bne.n	e37c <ticker_worker+0x254>
				ticker->ack--;
    e362:	9b03      	ldr	r3, [sp, #12]
    e364:	3b01      	subs	r3, #1
    e366:	70a3      	strb	r3, [r4, #2]
				continue;
    e368:	e700      	b.n	e16c <ticker_worker+0x44>
					  0U :
    e36a:	46f4      	mov	ip, lr
    e36c:	e7b1      	b.n	e2d2 <ticker_worker+0x1aa>
				(ticker->ticks_periodic == 0U) ||
    e36e:	f04f 0e01 	mov.w	lr, #1
					(ticker->ticks_periodic != 0U) &&
    e372:	468c      	mov	ip, r1
    e374:	e7be      	b.n	e2f4 <ticker_worker+0x1cc>
				ext_data->reschedule_state =
    e376:	f04f 0100 	mov.w	r1, #0
    e37a:	e7e4      	b.n	e346 <ticker_worker+0x21e>
			must_expire_skip = 1U;
    e37c:	f04f 0a01 	mov.w	sl, #1
    e380:	e761      	b.n	e246 <ticker_worker+0x11e>
			ticks_drift = 0U;
    e382:	4619      	mov	r1, r3
    e384:	e767      	b.n	e256 <ticker_worker+0x12e>
			ticker->timeout_func(ticks_at_expire,
    e386:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e38a:	e778      	b.n	e27e <ticker_worker+0x156>

0000e38c <ticker_start>:
{
    e38c:	b510      	push	{r4, lr}
    e38e:	b08a      	sub	sp, #40	; 0x28
	return ticker_start_ext(instance_index, user_id, ticker_id,
    e390:	2400      	movs	r4, #0
    e392:	9409      	str	r4, [sp, #36]	; 0x24
    e394:	9c14      	ldr	r4, [sp, #80]	; 0x50
    e396:	9408      	str	r4, [sp, #32]
    e398:	9c13      	ldr	r4, [sp, #76]	; 0x4c
    e39a:	9407      	str	r4, [sp, #28]
    e39c:	9c12      	ldr	r4, [sp, #72]	; 0x48
    e39e:	9406      	str	r4, [sp, #24]
    e3a0:	9c11      	ldr	r4, [sp, #68]	; 0x44
    e3a2:	9405      	str	r4, [sp, #20]
    e3a4:	9c10      	ldr	r4, [sp, #64]	; 0x40
    e3a6:	9404      	str	r4, [sp, #16]
    e3a8:	f8bd 403c 	ldrh.w	r4, [sp, #60]	; 0x3c
    e3ac:	9403      	str	r4, [sp, #12]
    e3ae:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    e3b0:	9402      	str	r4, [sp, #8]
    e3b2:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    e3b4:	9401      	str	r4, [sp, #4]
    e3b6:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    e3b8:	9400      	str	r4, [sp, #0]
    e3ba:	f7f6 fdb3 	bl	4f24 <ticker_start_ext>
}
    e3be:	b00a      	add	sp, #40	; 0x28
    e3c0:	bd10      	pop	{r4, pc}

0000e3c2 <ticker_update>:
{
    e3c2:	b510      	push	{r4, lr}
    e3c4:	b088      	sub	sp, #32
	return ticker_update_ext(instance_index, user_id, ticker_id,
    e3c6:	2400      	movs	r4, #0
    e3c8:	9407      	str	r4, [sp, #28]
    e3ca:	9c10      	ldr	r4, [sp, #64]	; 0x40
    e3cc:	9406      	str	r4, [sp, #24]
    e3ce:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    e3d0:	9405      	str	r4, [sp, #20]
    e3d2:	f89d 4038 	ldrb.w	r4, [sp, #56]	; 0x38
    e3d6:	9404      	str	r4, [sp, #16]
    e3d8:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
    e3dc:	9403      	str	r4, [sp, #12]
    e3de:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    e3e0:	9402      	str	r4, [sp, #8]
    e3e2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    e3e4:	9401      	str	r4, [sp, #4]
    e3e6:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    e3e8:	9400      	str	r4, [sp, #0]
    e3ea:	f7f6 fde9 	bl	4fc0 <ticker_update_ext>
}
    e3ee:	b008      	add	sp, #32
    e3f0:	bd10      	pop	{r4, pc}

0000e3f2 <ticker_ticks_now_get>:
	return cntr_cnt_get();
    e3f2:	f7f9 be81 	b.w	80f8 <cntr_cnt_get>

0000e3f6 <ll_addr_read>:

uint8_t *ll_addr_read(uint8_t addr_type, uint8_t *const bdaddr)
{
    e3f6:	b538      	push	{r3, r4, r5, lr}
	uint8_t *addr;

	addr = ll_addr_get(addr_type);
    e3f8:	f7f6 fe84 	bl	5104 <ll_addr_get>
{
    e3fc:	460d      	mov	r5, r1
	if (addr) {
    e3fe:	4604      	mov	r4, r0
    e400:	b120      	cbz	r0, e40c <ll_addr_read+0x16>
		memcpy(bdaddr, addr, BDADDR_SIZE);
    e402:	4601      	mov	r1, r0
    e404:	2206      	movs	r2, #6
    e406:	4628      	mov	r0, r5
    e408:	f7ff fafd 	bl	da06 <memcpy>
	}

	return addr;
}
    e40c:	4620      	mov	r0, r4
    e40e:	bd38      	pop	{r3, r4, r5, pc}

0000e410 <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
    e410:	2300      	movs	r3, #0
    e412:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
    e414:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
    e416:	4770      	bx	lr

0000e418 <hci_get_class>:
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
    e418:	2000      	movs	r0, #0
    e41a:	4770      	bx	lr

0000e41c <hci_init>:
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
    e41c:	4770      	bx	lr

0000e41e <bt_rand>:
#include "hal/ecb.h"
#include "lll.h"

int bt_rand(void *buf, size_t len)
{
	return lll_csrand_get(buf, len);
    e41e:	f7f9 b90b 	b.w	7638 <lll_csrand_get>

0000e422 <bt_encrypt_le>:
}

int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16],
		  uint8_t enc_data[16])
{
    e422:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
    e424:	2300      	movs	r3, #0
    e426:	f000 fa4c 	bl	e8c2 <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
    e42a:	2000      	movs	r0, #0
    e42c:	bd08      	pop	{r3, pc}

0000e42e <ll_feat_get>:

#else /* !CONFIG_BT_CTLR_SET_HOST_FEATURE */
uint64_t ll_feat_get(void)
{
	return LL_FEAT;
}
    e42e:	2040      	movs	r0, #64	; 0x40
    e430:	2100      	movs	r1, #0
    e432:	4770      	bx	lr

0000e434 <disabled_cb>:
    e434:	f7fd bc80 	b.w	bd38 <z_impl_k_sem_give>

0000e438 <ull_rxfifo_alloc>:
 * @details This function allocates up to 'max' number of MFIFO elements by
 *          enqueuing pointers to memory elements with associated memq links.
 */
void ull_rxfifo_alloc(uint8_t s, uint8_t n, uint8_t f, uint8_t *l, uint8_t *m,
		      void *mem_free, void *link_free, uint8_t max)
{
    e438:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e43c:	e9dd a60d 	ldrd	sl, r6, [sp, #52]	; 0x34
    e440:	469b      	mov	fp, r3
    e442:	f89d 703c 	ldrb.w	r7, [sp, #60]	; 0x3c
    e446:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    e448:	9100      	str	r1, [sp, #0]
    e44a:	4681      	mov	r9, r0
    e44c:	4690      	mov	r8, r2
    e44e:	9301      	str	r3, [sp, #4]
	uint8_t idx;

	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
    e450:	b177      	cbz	r7, e470 <ull_rxfifo_alloc+0x38>
	last = last + 1;
    e452:	f89b 4000 	ldrb.w	r4, [fp]
		last = 0U;
    e456:	9b00      	ldr	r3, [sp, #0]
	last = last + 1;
    e458:	3401      	adds	r4, #1
    e45a:	b2e4      	uxtb	r4, r4
		last = 0U;
    e45c:	42a3      	cmp	r3, r4
    e45e:	bf08      	it	eq
    e460:	2400      	moveq	r4, #0
	if (last == first) {
    e462:	45a0      	cmp	r8, r4
    e464:	d004      	beq.n	e470 <ull_rxfifo_alloc+0x38>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(link_free);
    e466:	4630      	mov	r0, r6
    e468:	f7ff fcb2 	bl	ddd0 <mem_acquire>
		if (!link) {
    e46c:	4605      	mov	r5, r0
    e46e:	b910      	cbnz	r0, e476 <ull_rxfifo_alloc+0x3e>
		link->mem = NULL;
		rx->link = link;

		mfifo_by_idx_enqueue(m, s, idx, rx, l);
	}
}
    e470:	b003      	add	sp, #12
    e472:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rx = mem_acquire(mem_free);
    e476:	4650      	mov	r0, sl
    e478:	f7ff fcaa 	bl	ddd0 <mem_acquire>
		if (!rx) {
    e47c:	b930      	cbnz	r0, e48c <ull_rxfifo_alloc+0x54>
			mem_release(link, link_free);
    e47e:	4631      	mov	r1, r6
    e480:	4628      	mov	r0, r5
}
    e482:	b003      	add	sp, #12
    e484:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			mem_release(link, link_free);
    e488:	f7ff bcbb 	b.w	de02 <mem_release>
		link->mem = NULL;
    e48c:	2300      	movs	r3, #0
    e48e:	606b      	str	r3, [r5, #4]
		rx->link = link;
    e490:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    e492:	f89b 5000 	ldrb.w	r5, [fp]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    e496:	9b01      	ldr	r3, [sp, #4]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    e498:	fb15 f509 	smulbb	r5, r5, r9
	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
    e49c:	1e7a      	subs	r2, r7, #1
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    e49e:	5158      	str	r0, [r3, r5]
    e4a0:	b2d7      	uxtb	r7, r2
	*last = idx; /* Commit: Update write index */
    e4a2:	f88b 4000 	strb.w	r4, [fp]
}
    e4a6:	e7d3      	b.n	e450 <ull_rxfifo_alloc+0x18>

0000e4a8 <ull_rxfifo_release>:
 * @brief   Support function for RXFIFO_RELEASE macro
 * @details This function releases a node by returning it to the FIFO.
 */
void *ull_rxfifo_release(uint8_t s, uint8_t n, uint8_t f, uint8_t *l, uint8_t *m,
			 memq_link_t *link, struct node_rx_hdr *rx)
{
    e4a8:	b530      	push	{r4, r5, lr}
	last = last + 1;
    e4aa:	781c      	ldrb	r4, [r3, #0]
    e4ac:	3401      	adds	r4, #1
    e4ae:	b2e4      	uxtb	r4, r4
		last = 0U;
    e4b0:	42a1      	cmp	r1, r4
    e4b2:	bf08      	it	eq
    e4b4:	2400      	moveq	r4, #0
	if (last == first) {
    e4b6:	42a2      	cmp	r2, r4
    e4b8:	4605      	mov	r5, r0
    e4ba:	9805      	ldr	r0, [sp, #20]
    e4bc:	d008      	beq.n	e4d0 <ull_rxfifo_release+0x28>

	if (!mfifo_enqueue_idx_get(n, f, *l, &idx)) {
		return NULL;
	}

	rx->link = link;
    e4be:	9a04      	ldr	r2, [sp, #16]
    e4c0:	6002      	str	r2, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    e4c2:	781a      	ldrb	r2, [r3, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    e4c4:	9903      	ldr	r1, [sp, #12]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    e4c6:	fb12 f205 	smulbb	r2, r2, r5
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    e4ca:	5088      	str	r0, [r1, r2]
	*last = idx; /* Commit: Update write index */
    e4cc:	701c      	strb	r4, [r3, #0]

	mfifo_by_idx_enqueue(m, s, idx, rx, l);

	return rx;
}
    e4ce:	bd30      	pop	{r4, r5, pc}
		return NULL;
    e4d0:	2000      	movs	r0, #0
    e4d2:	e7fc      	b.n	e4ce <ull_rxfifo_release+0x26>

0000e4d4 <lll_prepare>:
{
    e4d4:	b507      	push	{r0, r1, r2, lr}
	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
    e4d6:	2300      	movs	r3, #0
    e4d8:	e9cd 3300 	strd	r3, r3, [sp]
    e4dc:	9b04      	ldr	r3, [sp, #16]
    e4de:	f7f9 f9b3 	bl	7848 <lll_prepare_resolve>
}
    e4e2:	b003      	add	sp, #12
    e4e4:	f85d fb04 	ldr.w	pc, [sp], #4

0000e4e8 <adv_time_get.constprop.0.isra.0>:
static uint16_t adv_time_get(struct pdu_adv *pdu, struct pdu_adv *pdu_scan,
    e4e8:	b530      	push	{r4, r5, lr}
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
    e4ea:	7804      	ldrb	r4, [r0, #0]
    e4ec:	f004 040f 	and.w	r4, r4, #15
				   rxtx_turn_us * (adv_chn_cnt - 1);
    e4f0:	1e53      	subs	r3, r2, #1
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
    e4f2:	2c02      	cmp	r4, #2
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
    e4f4:	b29d      	uxth	r5, r3
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
    e4f6:	d10d      	bne.n	e514 <adv_time_get.constprop.0.isra.0+0x2c>
			adv_size += pdu->len;
    e4f8:	7841      	ldrb	r1, [r0, #1]
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
    e4fa:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    e4fe:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
    e502:	3110      	adds	r1, #16
    e504:	0058      	lsls	r0, r3, #1
    e506:	00c9      	lsls	r1, r1, #3
    e508:	f500 70c8 	add.w	r0, r0, #400	; 0x190
    e50c:	fb01 0002 	mla	r0, r1, r2, r0
			time_us += (BYTES2US(adv_size, PHY_1M) +
    e510:	b280      	uxth	r0, r0
}
    e512:	bd30      	pop	{r4, r5, pc}
			if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
    e514:	2c01      	cmp	r4, #1
    e516:	d016      	beq.n	e546 <adv_time_get.constprop.0.isra.0+0x5e>
			BYTES2US((PDU_OVERHEAD_SIZE(PHY_1M) +
    e518:	3110      	adds	r1, #16
		const uint16_t scan_rsp_us =
    e51a:	00c9      	lsls	r1, r1, #3
			} else if (pdu->type == PDU_ADV_TYPE_ADV_IND) {
    e51c:	b96c      	cbnz	r4, e53a <adv_time_get.constprop.0.isra.0+0x52>
				adv_size += pdu->len;
    e51e:	7840      	ldrb	r0, [r0, #1]
				time_us += scan_req_us + EVENT_IFS_MAX_US +
    e520:	f501 7136 	add.w	r1, r1, #728	; 0x2d8
				adv_size += pdu->len;
    e524:	3010      	adds	r0, #16
				   BYTES2US(adv_size, PHY_1M) + EVENT_IFS_MAX_US;
    e526:	00c3      	lsls	r3, r0, #3
				    EVENT_IFS_MAX_US + rx_to_us +
    e528:	f503 73b3 	add.w	r3, r3, #358	; 0x166
    e52c:	eb01 00c0 	add.w	r0, r1, r0, lsl #3
    e530:	3098      	adds	r0, #152	; 0x98
				    rxtx_turn_us) * (adv_chn_cnt - 1) +
    e532:	fb13 f305 	smulbb	r3, r3, r5
			time_us += (BYTES2US(adv_size, PHY_1M) +
    e536:	4418      	add	r0, r3
    e538:	e7ea      	b.n	e510 <adv_time_get.constprop.0.isra.0+0x28>
			} else if (pdu->type == PDU_ADV_TYPE_SCAN_IND) {
    e53a:	2c06      	cmp	r4, #6
    e53c:	d0ef      	beq.n	e51e <adv_time_get.constprop.0.isra.0+0x36>
		uint16_t adv_size =
    e53e:	2010      	movs	r0, #16
	uint16_t time_us = EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
    e540:	f44f 71c8 	mov.w	r1, #400	; 0x190
    e544:	e7ef      	b.n	e526 <adv_time_get.constprop.0.isra.0+0x3e>
				adv_size += TARGETA_SIZE;
    e546:	2016      	movs	r0, #22
				time_us += conn_ind_us;
    e548:	f44f 713c 	mov.w	r1, #752	; 0x2f0
    e54c:	e7eb      	b.n	e526 <adv_time_get.constprop.0.isra.0+0x3e>

0000e54e <ull_adv_init>:
	err = init_reset();
    e54e:	f7f7 bed7 	b.w	6300 <init_reset>

0000e552 <ull_adv_reset>:
{
    e552:	b508      	push	{r3, lr}
		(void)disable(handle);
    e554:	f7f8 f834 	bl	65c0 <disable.constprop.0>
}
    e558:	2000      	movs	r0, #0
    e55a:	bd08      	pop	{r3, pc}

0000e55c <ull_adv_is_enabled>:
{
    e55c:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
    e55e:	f7f8 f821 	bl	65a4 <ull_adv_is_enabled_get>
}
    e562:	3800      	subs	r0, #0
    e564:	bf18      	it	ne
    e566:	2001      	movne	r0, #1
    e568:	bd08      	pop	{r3, pc}

0000e56a <ull_adv_filter_pol_get>:
{
    e56a:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
    e56c:	f7f8 f81a 	bl	65a4 <ull_adv_is_enabled_get>
	if (!adv) {
    e570:	b110      	cbz	r0, e578 <ull_adv_filter_pol_get+0xe>
	return adv->lll.filter_policy;
    e572:	f890 0020 	ldrb.w	r0, [r0, #32]
    e576:	0980      	lsrs	r0, r0, #6
}
    e578:	bd08      	pop	{r3, pc}

0000e57a <ull_adv_pdu_update_addrs>:
{
    e57a:	b570      	push	{r4, r5, r6, lr}
    e57c:	4605      	mov	r5, r0
	const uint8_t *rpa = ull_filter_adva_get(adv->lll.rl_idx);
    e57e:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
{
    e582:	460c      	mov	r4, r1
	const uint8_t *rpa = ull_filter_adva_get(adv->lll.rl_idx);
    e584:	f7f8 fb2e 	bl	6be4 <ull_filter_adva_get>
	if (!rpa || IS_ENABLED(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)) {
    e588:	4601      	mov	r1, r0
    e58a:	bb00      	cbnz	r0, e5ce <ull_adv_pdu_update_addrs+0x54>
			own_id_addr = ll_addr_get(pdu->tx_addr);
    e58c:	7820      	ldrb	r0, [r4, #0]
    e58e:	f3c0 1080 	ubfx	r0, r0, #6, #1
    e592:	f7f6 fdb7 	bl	5104 <ll_addr_get>
    e596:	4601      	mov	r1, r0
	return pdu->adv_ind.addr;
    e598:	1ca6      	adds	r6, r4, #2
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
    e59a:	2206      	movs	r2, #6
    e59c:	4630      	mov	r0, r6
    e59e:	f7ff fa32 	bl	da06 <memcpy>
	if ((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
    e5a2:	7823      	ldrb	r3, [r4, #0]
    e5a4:	f003 030f 	and.w	r3, r3, #15
    e5a8:	2b01      	cmp	r3, #1
    e5aa:	d10e      	bne.n	e5ca <ull_adv_pdu_update_addrs+0x50>
	rx_addr = ull_filter_tgta_get(adv->lll.rl_idx);
    e5ac:	f895 0021 	ldrb.w	r0, [r5, #33]	; 0x21
    e5b0:	f7f8 fb42 	bl	6c38 <ull_filter_tgta_get>
	if (rx_addr) {
    e5b4:	4601      	mov	r1, r0
    e5b6:	b140      	cbz	r0, e5ca <ull_adv_pdu_update_addrs+0x50>
		pdu->rx_addr = 1;
    e5b8:	7823      	ldrb	r3, [r4, #0]
    e5ba:	4620      	mov	r0, r4
    e5bc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    e5c0:	f800 3b08 	strb.w	r3, [r0], #8
		memcpy(tgt_addr, rx_addr, BDADDR_SIZE);
    e5c4:	2206      	movs	r2, #6
    e5c6:	f7ff fa1e 	bl	da06 <memcpy>
}
    e5ca:	4630      	mov	r0, r6
    e5cc:	bd70      	pop	{r4, r5, r6, pc}
		pdu->tx_addr = 1;
    e5ce:	7823      	ldrb	r3, [r4, #0]
    e5d0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e5d4:	7023      	strb	r3, [r4, #0]
		tx_addr = rpa;
    e5d6:	e7df      	b.n	e598 <ull_adv_pdu_update_addrs+0x1e>

0000e5d8 <ull_adv_data_set>:
	if (len > PDU_AC_DATA_SIZE_MAX) {
    e5d8:	291f      	cmp	r1, #31
{
    e5da:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    e5de:	4604      	mov	r4, r0
    e5e0:	460d      	mov	r5, r1
    e5e2:	4690      	mov	r8, r2
	if (len > PDU_AC_DATA_SIZE_MAX) {
    e5e4:	d841      	bhi.n	e66a <ull_adv_data_set+0x92>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    e5e6:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
    e5ea:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    e5ee:	6a9e      	ldr	r6, [r3, #40]	; 0x28
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
    e5f0:	7833      	ldrb	r3, [r6, #0]
    e5f2:	f003 030f 	and.w	r3, r3, #15
    e5f6:	2b01      	cmp	r3, #1
    e5f8:	d039      	beq.n	e66e <ull_adv_data_set+0x96>
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
    e5fa:	f10d 0107 	add.w	r1, sp, #7
    e5fe:	3024      	adds	r0, #36	; 0x24
    e600:	f000 f8fa 	bl	e7f8 <lll_adv_pdu_alloc>
	pdu->tx_addr = prev->tx_addr;
    e604:	4631      	mov	r1, r6
    e606:	4607      	mov	r7, r0
    e608:	f811 2b02 	ldrb.w	r2, [r1], #2
    e60c:	f3c2 1080 	ubfx	r0, r2, #6, #1
	pdu->type = prev->type;
    e610:	f3c2 0303 	ubfx	r3, r2, #0, #4
    e614:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
    e618:	f002 0280 	and.w	r2, r2, #128	; 0x80
    e61c:	4638      	mov	r0, r7
    e61e:	4313      	orrs	r3, r2
    e620:	f800 3b02 	strb.w	r3, [r0], #2
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
    e624:	2206      	movs	r2, #6
    e626:	f7ff f9ee 	bl	da06 <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
    e62a:	462a      	mov	r2, r5
    e62c:	4641      	mov	r1, r8
    e62e:	f107 0008 	add.w	r0, r7, #8
	pdu->len = BDADDR_SIZE + len;
    e632:	3506      	adds	r5, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
    e634:	f7ff f9e7 	bl	da06 <memcpy>
	pdu->len = BDADDR_SIZE + len;
    e638:	707d      	strb	r5, [r7, #1]
	if (adv->is_enabled) {
    e63a:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    e63e:	07db      	lsls	r3, r3, #31
    e640:	d407      	bmi.n	e652 <ull_adv_data_set+0x7a>
	pdu->last = idx;
    e642:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e646:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	return 0;
    e64a:	2000      	movs	r0, #0
}
    e64c:	b002      	add	sp, #8
    e64e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    e652:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    e656:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		err = ull_adv_time_update(adv, pdu, pdu_scan);
    e65a:	4639      	mov	r1, r7
    e65c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    e65e:	4620      	mov	r0, r4
    e660:	f7f1 ff6e 	bl	540 <ull_adv_time_update>
		if (err) {
    e664:	2800      	cmp	r0, #0
    e666:	d0ec      	beq.n	e642 <ull_adv_data_set+0x6a>
    e668:	e7f0      	b.n	e64c <ull_adv_data_set+0x74>
		return BT_HCI_ERR_INVALID_PARAM;
    e66a:	2012      	movs	r0, #18
    e66c:	e7ee      	b.n	e64c <ull_adv_data_set+0x74>
		return BT_HCI_ERR_CMD_DISALLOWED;
    e66e:	200c      	movs	r0, #12
    e670:	e7ec      	b.n	e64c <ull_adv_data_set+0x74>

0000e672 <ull_scan_rsp_set>:
	if (len > PDU_AC_DATA_SIZE_MAX) {
    e672:	291f      	cmp	r1, #31
{
    e674:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    e678:	4604      	mov	r4, r0
    e67a:	460e      	mov	r6, r1
    e67c:	4617      	mov	r7, r2
	if (len > PDU_AC_DATA_SIZE_MAX) {
    e67e:	d83e      	bhi.n	e6fe <ull_scan_rsp_set+0x8c>
    e680:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
    e684:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
    e688:	f10d 0107 	add.w	r1, sp, #7
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    e68c:	f8d3 8034 	ldr.w	r8, [r3, #52]	; 0x34
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
    e690:	3030      	adds	r0, #48	; 0x30
    e692:	f000 f8b1 	bl	e7f8 <lll_adv_pdu_alloc>
	pdu->tx_addr = prev->tx_addr;
    e696:	4641      	mov	r1, r8
    e698:	4605      	mov	r5, r0
    e69a:	f811 3b02 	ldrb.w	r3, [r1], #2
    e69e:	f3c3 1380 	ubfx	r3, r3, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
    e6a2:	019b      	lsls	r3, r3, #6
    e6a4:	f043 0304 	orr.w	r3, r3, #4
    e6a8:	7003      	strb	r3, [r0, #0]
	pdu->len = BDADDR_SIZE + len;
    e6aa:	1db3      	adds	r3, r6, #6
    e6ac:	7043      	strb	r3, [r0, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
    e6ae:	2206      	movs	r2, #6
    e6b0:	3002      	adds	r0, #2
    e6b2:	f7ff f9a8 	bl	da06 <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
    e6b6:	4632      	mov	r2, r6
    e6b8:	4639      	mov	r1, r7
    e6ba:	f105 0008 	add.w	r0, r5, #8
    e6be:	f7ff f9a2 	bl	da06 <memcpy>
	if (adv->is_enabled) {
    e6c2:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    e6c6:	07db      	lsls	r3, r3, #31
    e6c8:	d407      	bmi.n	e6da <ull_scan_rsp_set+0x68>
	pdu->last = idx;
    e6ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e6ce:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
	return 0;
    e6d2:	2000      	movs	r0, #0
}
    e6d4:	b002      	add	sp, #8
    e6d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    e6da:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    e6de:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    e6e2:	6a99      	ldr	r1, [r3, #40]	; 0x28
		if ((pdu_adv_scan->type == PDU_ADV_TYPE_ADV_IND) ||
    e6e4:	780b      	ldrb	r3, [r1, #0]
    e6e6:	f013 030f 	ands.w	r3, r3, #15
    e6ea:	d001      	beq.n	e6f0 <ull_scan_rsp_set+0x7e>
    e6ec:	2b06      	cmp	r3, #6
    e6ee:	d1ec      	bne.n	e6ca <ull_scan_rsp_set+0x58>
			err = ull_adv_time_update(adv, pdu_adv_scan, pdu);
    e6f0:	462a      	mov	r2, r5
    e6f2:	4620      	mov	r0, r4
    e6f4:	f7f1 ff24 	bl	540 <ull_adv_time_update>
			if (err) {
    e6f8:	2800      	cmp	r0, #0
    e6fa:	d0e6      	beq.n	e6ca <ull_scan_rsp_set+0x58>
    e6fc:	e7ea      	b.n	e6d4 <ull_scan_rsp_set+0x62>
		return BT_HCI_ERR_INVALID_PARAM;
    e6fe:	2012      	movs	r0, #18
    e700:	e7e8      	b.n	e6d4 <ull_scan_rsp_set+0x62>

0000e702 <ll_fal_size_get>:
}
    e702:	2008      	movs	r0, #8
    e704:	4770      	bx	lr

0000e706 <ll_fal_clear>:
{
    e706:	b510      	push	{r4, lr}
	if (ull_adv_filter_pol_get(0)) {
    e708:	2000      	movs	r0, #0
    e70a:	f7ff ff2e 	bl	e56a <ull_adv_filter_pol_get>
    e70e:	4604      	mov	r4, r0
    e710:	b918      	cbnz	r0, e71a <ll_fal_clear+0x14>
	fal_clear();
    e712:	f7f7 ffd7 	bl	66c4 <fal_clear>
	return 0;
    e716:	4620      	mov	r0, r4
}
    e718:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    e71a:	200c      	movs	r0, #12
    e71c:	e7fc      	b.n	e718 <ll_fal_clear+0x12>

0000e71e <ll_rl_size_get>:
    e71e:	2008      	movs	r0, #8
    e720:	4770      	bx	lr

0000e722 <ll_rl_clear>:
{
    e722:	b508      	push	{r3, lr}
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
    e724:	2000      	movs	r0, #0
    e726:	f7ff ff19 	bl	e55c <ull_adv_is_enabled>
	if (!rl_access_check(false)) {
    e72a:	b910      	cbnz	r0, e732 <ll_rl_clear+0x10>
	rl_clear();
    e72c:	f7f7 ffe8 	bl	6700 <rl_clear>
}
    e730:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    e732:	200c      	movs	r0, #12
    e734:	e7fc      	b.n	e730 <ll_rl_clear+0xe>

0000e736 <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
    e736:	2000      	movs	r0, #0
    e738:	f7f5 bf26 	b.w	4588 <mayfly_run>

0000e73c <isr_race>:
	radio_status_reset();
    e73c:	f7f9 be06 	b.w	834c <radio_status_reset>

0000e740 <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
    e740:	4668      	mov	r0, sp
    e742:	f020 0107 	bic.w	r1, r0, #7
    e746:	468d      	mov	sp, r1
    e748:	b501      	push	{r0, lr}
	isr_radio();
    e74a:	f7f9 fd1b 	bl	8184 <isr_radio>
	ISR_DIRECT_PM();
    e74e:	f7f3 fd73 	bl	2238 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
    e752:	f7f3 fe63 	bl	241c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
    e756:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    e75a:	4685      	mov	sp, r0
    e75c:	4770      	bx	lr

0000e75e <lll_rand_isr_get>:
    e75e:	f7f8 bf79 	b.w	7654 <lll_csrand_isr_get>

0000e762 <lll_reset>:
}
    e762:	2000      	movs	r0, #0
    e764:	4770      	bx	lr

0000e766 <lll_prepare_done>:
}
    e766:	2000      	movs	r0, #0
    e768:	4770      	bx	lr

0000e76a <lll_event_offset_get>:
{
    e76a:	4603      	mov	r3, r0
		return MAX(ull->ticks_active_to_start,
    e76c:	e9d0 0201 	ldrd	r0, r2, [r0, #4]
	} else if (ull->ticks_prepare_to_start & XON_BITMASK) {
    e770:	2a00      	cmp	r2, #0
    e772:	da04      	bge.n	e77e <lll_event_offset_get+0x14>
		return MAX(ull->ticks_active_to_start,
    e774:	68db      	ldr	r3, [r3, #12]
    e776:	4298      	cmp	r0, r3
    e778:	bf38      	it	cc
    e77a:	4618      	movcc	r0, r3
    e77c:	4770      	bx	lr
		return MAX(ull->ticks_active_to_start,
    e77e:	4290      	cmp	r0, r2
    e780:	bf38      	it	cc
    e782:	4610      	movcc	r0, r2
}
    e784:	4770      	bx	lr

0000e786 <lll_preempt_calc>:
{
    e786:	b510      	push	{r4, lr}
    e788:	4614      	mov	r4, r2
	ticks_now = ticker_ticks_now_get();
    e78a:	f7ff fe32 	bl	e3f2 <ticker_ticks_now_get>
	diff = ticks_now - ticks_at_event;
    e78e:	1b00      	subs	r0, r0, r4
	if (diff & BIT(HAL_TICKER_CNTR_MSBIT)) {
    e790:	0203      	lsls	r3, r0, #8
    e792:	d405      	bmi.n	e7a0 <lll_preempt_calc+0x1a>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
    e794:	3003      	adds	r0, #3
	if (diff > HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) {
    e796:	2809      	cmp	r0, #9
    e798:	bf94      	ite	ls
    e79a:	2000      	movls	r0, #0
    e79c:	2001      	movhi	r0, #1
}
    e79e:	bd10      	pop	{r4, pc}
		return 0;
    e7a0:	2000      	movs	r0, #0
    e7a2:	e7fc      	b.n	e79e <lll_preempt_calc+0x18>

0000e7a4 <lll_isr_tx_status_reset>:
{
    e7a4:	b508      	push	{r3, lr}
	radio_status_reset();
    e7a6:	f7f9 fdd1 	bl	834c <radio_status_reset>
}
    e7aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_status_reset();
    e7ae:	f7f9 bf0f 	b.w	85d0 <radio_tmr_status_reset>

0000e7b2 <lll_isr_status_reset>:
{
    e7b2:	b508      	push	{r3, lr}
	radio_status_reset();
    e7b4:	f7f9 fdca 	bl	834c <radio_status_reset>
	radio_tmr_status_reset();
    e7b8:	f7f9 ff0a 	bl	85d0 <radio_tmr_status_reset>
	radio_filter_status_reset();
    e7bc:	f7f9 fee4 	bl	8588 <radio_filter_status_reset>
	radio_ar_status_reset();
    e7c0:	f7f9 ffe8 	bl	8794 <radio_ar_status_reset>
}
    e7c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
    e7c8:	f7f9 bea6 	b.w	8518 <radio_rssi_status_reset>

0000e7cc <is_abort_cb>:
}
    e7cc:	f06f 008b 	mvn.w	r0, #139	; 0x8b
    e7d0:	4770      	bx	lr

0000e7d2 <isr_abort>:
{
    e7d2:	b510      	push	{r4, lr}
    e7d4:	4604      	mov	r4, r0
	lll_isr_status_reset();
    e7d6:	f7ff ffec 	bl	e7b2 <lll_isr_status_reset>
	radio_filter_disable();
    e7da:	f7f9 fecb 	bl	8574 <radio_filter_disable>
	lll_isr_cleanup(param);
    e7de:	4620      	mov	r0, r4
}
    e7e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
    e7e4:	f7f9 b806 	b.w	77f4 <lll_isr_cleanup>

0000e7e8 <lll_adv_reset>:
    e7e8:	f7f9 b9a0 	b.w	7b2c <lll_adv_init>

0000e7ec <lll_adv_data_reset>:
{
    e7ec:	4603      	mov	r3, r0
	pdu->first = 0U;
    e7ee:	2000      	movs	r0, #0
    e7f0:	7018      	strb	r0, [r3, #0]
	pdu->last = 0U;
    e7f2:	7058      	strb	r0, [r3, #1]
	pdu->pdu[1] = NULL;
    e7f4:	6098      	str	r0, [r3, #8]
}
    e7f6:	4770      	bx	lr

0000e7f8 <lll_adv_pdu_alloc>:
{
    e7f8:	b510      	push	{r4, lr}
	first = pdu->first;
    e7fa:	7804      	ldrb	r4, [r0, #0]
	last = pdu->last;
    e7fc:	7843      	ldrb	r3, [r0, #1]
	if (first == last) {
    e7fe:	429c      	cmp	r4, r3
	first = pdu->first;
    e800:	b2e2      	uxtb	r2, r4
	if (first == last) {
    e802:	d10d      	bne.n	e820 <lll_adv_pdu_alloc+0x28>
		last++;
    e804:	3301      	adds	r3, #1
    e806:	b2db      	uxtb	r3, r3
		if (last == DOUBLE_BUFFER_SIZE) {
    e808:	2b02      	cmp	r3, #2
    e80a:	d100      	bne.n	e80e <lll_adv_pdu_alloc+0x16>
			last = 0U;
    e80c:	2300      	movs	r3, #0
	*idx = last;
    e80e:	eb00 0483 	add.w	r4, r0, r3, lsl #2
    e812:	700b      	strb	r3, [r1, #0]
	p = (void *)pdu->pdu[last];
    e814:	6860      	ldr	r0, [r4, #4]
	if (p) {
    e816:	b910      	cbnz	r0, e81e <lll_adv_pdu_alloc+0x26>
	p = lll_adv_pdu_alloc_pdu_adv();
    e818:	f7f9 f9b0 	bl	7b7c <lll_adv_pdu_alloc_pdu_adv>
	pdu->pdu[last] = (void *)p;
    e81c:	6060      	str	r0, [r4, #4]
}
    e81e:	bd10      	pop	{r4, pc}
		pdu->last = first;
    e820:	7042      	strb	r2, [r0, #1]
		first_latest = pdu->first;
    e822:	7804      	ldrb	r4, [r0, #0]
		if (first_latest != first) {
    e824:	42a2      	cmp	r2, r4
    e826:	d0f2      	beq.n	e80e <lll_adv_pdu_alloc+0x16>
			pdu->last = last;
    e828:	7043      	strb	r3, [r0, #1]
			last++;
    e82a:	e7eb      	b.n	e804 <lll_adv_pdu_alloc+0xc>

0000e82c <isr_done>:
{
    e82c:	b510      	push	{r4, lr}
    e82e:	4604      	mov	r4, r0
	lll_isr_status_reset();
    e830:	f7ff ffbf 	bl	e7b2 <lll_isr_status_reset>
	if (lll->chan_map_curr &&
    e834:	7923      	ldrb	r3, [r4, #4]
    e836:	f013 0f38 	tst.w	r3, #56	; 0x38
    e83a:	d008      	beq.n	e84e <isr_done+0x22>
		pdu = chan_prepare(lll);
    e83c:	4620      	mov	r0, r4
    e83e:	f7f9 fa47 	bl	7cd0 <chan_prepare.isra.0>
		radio_tx_enable();
    e842:	f7f9 fd6b 	bl	831c <radio_tx_enable>
}
    e846:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
    e84a:	f7f9 bf63 	b.w	8714 <radio_tmr_end_capture>
	radio_filter_disable();
    e84e:	f7f9 fe91 	bl	8574 <radio_filter_disable>
	lll_isr_cleanup(param);
    e852:	4620      	mov	r0, r4
}
    e854:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
    e858:	f7f8 bfcc 	b.w	77f4 <lll_isr_cleanup>

0000e85c <lll_adv_scan_req_check>:
{
    e85c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e860:	461e      	mov	r6, r3
	return ((((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0) &&
    e862:	7903      	ldrb	r3, [r0, #4]
{
    e864:	f89d 9020 	ldrb.w	r9, [sp, #32]
    e868:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    e86c:	4617      	mov	r7, r2
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
    e86e:	065a      	lsls	r2, r3, #25
{
    e870:	4605      	mov	r5, r0
    e872:	460c      	mov	r4, r1
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
    e874:	d508      	bpl.n	e888 <lll_adv_scan_req_check+0x2c>
		(((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) != 0) &&
    e876:	f1b9 0f00 	cmp.w	r9, #0
    e87a:	d10d      	bne.n	e898 <lll_adv_scan_req_check+0x3c>
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
    e87c:	f898 0000 	ldrb.w	r0, [r8]
    e880:	f7f8 fc4c 	bl	711c <ull_filter_lll_irk_in_fal>
    e884:	b940      	cbnz	r0, e898 <lll_adv_scan_req_check+0x3c>
    e886:	e00b      	b.n	e8a0 <lll_adv_scan_req_check+0x44>
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
    e888:	f811 0b02 	ldrb.w	r0, [r1], #2
    e88c:	4642      	mov	r2, r8
    e88e:	f3c0 1080 	ubfx	r0, r0, #6, #1
    e892:	f7f8 fc6b 	bl	716c <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0) &&
    e896:	b130      	cbz	r0, e8a6 <lll_adv_scan_req_check+0x4a>
}

static bool isr_rx_sr_adva_check(uint8_t tx_addr, uint8_t *addr,
				 struct pdu_adv *sr)
{
	return (tx_addr == sr->rx_addr) &&
    e898:	7823      	ldrb	r3, [r4, #0]
    e89a:	ebb7 1fd3 	cmp.w	r7, r3, lsr #7
    e89e:	d006      	beq.n	e8ae <lll_adv_scan_req_check+0x52>
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
    e8a0:	2000      	movs	r0, #0
}
    e8a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		(((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) != 0) &&
    e8a6:	792b      	ldrb	r3, [r5, #4]
						rl_idx)) ||
    e8a8:	065b      	lsls	r3, r3, #25
    e8aa:	d4e4      	bmi.n	e876 <lll_adv_scan_req_check+0x1a>
    e8ac:	e7f8      	b.n	e8a0 <lll_adv_scan_req_check+0x44>
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
    e8ae:	2206      	movs	r2, #6
    e8b0:	f104 0108 	add.w	r1, r4, #8
    e8b4:	4630      	mov	r0, r6
    e8b6:	f7ff f895 	bl	d9e4 <memcmp>
	return (tx_addr == sr->rx_addr) &&
    e8ba:	fab0 f080 	clz	r0, r0
    e8be:	0940      	lsrs	r0, r0, #5
    e8c0:	e7ef      	b.n	e8a2 <lll_adv_scan_req_check+0x46>

0000e8c2 <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(uint8_t const *const key_le, uint8_t const *const clear_text_le,
		 uint8_t * const cipher_text_le, uint8_t * const cipher_text_be)
{
    e8c2:	b570      	push	{r4, r5, r6, lr}
    e8c4:	b08c      	sub	sp, #48	; 0x30
    e8c6:	460e      	mov	r6, r1
    e8c8:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
    e8ca:	4601      	mov	r1, r0
    e8cc:	2210      	movs	r2, #16
    e8ce:	4668      	mov	r0, sp
{
    e8d0:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
    e8d2:	f7ff faab 	bl	de2c <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
    e8d6:	2210      	movs	r2, #16
    e8d8:	eb0d 0002 	add.w	r0, sp, r2
    e8dc:	4631      	mov	r1, r6
    e8de:	f7ff faa5 	bl	de2c <mem_rcopy>

	do_ecb(&ecb);
    e8e2:	4668      	mov	r0, sp
    e8e4:	f7f9 fc16 	bl	8114 <do_ecb>

	if (cipher_text_le) {
    e8e8:	b125      	cbz	r5, e8f4 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
    e8ea:	2210      	movs	r2, #16
    e8ec:	a908      	add	r1, sp, #32
    e8ee:	4628      	mov	r0, r5
    e8f0:	f7ff fa9c 	bl	de2c <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
    e8f4:	b124      	cbz	r4, e900 <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
    e8f6:	2210      	movs	r2, #16
    e8f8:	a908      	add	r1, sp, #32
    e8fa:	4620      	mov	r0, r4
    e8fc:	f7ff f883 	bl	da06 <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
    e900:	b00c      	add	sp, #48	; 0x30
    e902:	bd70      	pop	{r4, r5, r6, pc}

0000e904 <radio_setup>:
	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
    e904:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    e908:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
    e90c:	2100      	movs	r1, #0
	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
    e90e:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
	NRF_AMLI->RAMPRI.SPIS1   = 0xFFFFFFFFUL;
    e912:	f8c3 2e04 	str.w	r2, [r3, #3588]	; 0xe04
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
    e916:	f8c3 1e08 	str.w	r1, [r3, #3592]	; 0xe08
	NRF_AMLI->RAMPRI.ECB     = 0xFFFFFFFFUL;
    e91a:	f8c3 2e0c 	str.w	r2, [r3, #3596]	; 0xe0c
	NRF_AMLI->RAMPRI.CCM     = 0x00000000UL;
    e91e:	f8c3 1e10 	str.w	r1, [r3, #3600]	; 0xe10
	NRF_AMLI->RAMPRI.AAR     = 0xFFFFFFFFUL;
    e922:	f8c3 2e14 	str.w	r2, [r3, #3604]	; 0xe14
	NRF_AMLI->RAMPRI.SAADC   = 0xFFFFFFFFUL;
    e926:	f8c3 2e18 	str.w	r2, [r3, #3608]	; 0xe18
	NRF_AMLI->RAMPRI.UARTE   = 0xFFFFFFFFUL;
    e92a:	f8c3 2e1c 	str.w	r2, [r3, #3612]	; 0xe1c
	NRF_AMLI->RAMPRI.SERIAL0 = 0xFFFFFFFFUL;
    e92e:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
	NRF_AMLI->RAMPRI.SERIAL2 = 0xFFFFFFFFUL;
    e932:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
	NRF_AMLI->RAMPRI.NFCT    = 0xFFFFFFFFUL;
    e936:	f8c3 2e28 	str.w	r2, [r3, #3624]	; 0xe28
	NRF_AMLI->RAMPRI.I2S     = 0xFFFFFFFFUL;
    e93a:	f8c3 2e2c 	str.w	r2, [r3, #3628]	; 0xe2c
	NRF_AMLI->RAMPRI.PDM     = 0xFFFFFFFFUL;
    e93e:	f8c3 2e30 	str.w	r2, [r3, #3632]	; 0xe30
	NRF_AMLI->RAMPRI.PWM     = 0xFFFFFFFFUL;
    e942:	f8c3 2e34 	str.w	r2, [r3, #3636]	; 0xe34
}
    e946:	4770      	bx	lr

0000e948 <radio_tx_chain_delay_get>:
}
    e948:	2001      	movs	r0, #1
    e94a:	4770      	bx	lr

0000e94c <radio_rx_chain_delay_get>:
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_2M_US;
    e94c:	2802      	cmp	r0, #2
}
    e94e:	bf14      	ite	ne
    e950:	200a      	movne	r0, #10
    e952:	2006      	moveq	r0, #6
    e954:	4770      	bx	lr

0000e956 <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    e956:	4288      	cmp	r0, r1
    e958:	d00a      	beq.n	e970 <mayfly_prio_is_equal+0x1a>
	return (caller_id == callee_id) ||
    e95a:	2801      	cmp	r0, #1
    e95c:	d104      	bne.n	e968 <mayfly_prio_is_equal+0x12>
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
    e95e:	2902      	cmp	r1, #2
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
    e960:	bf14      	ite	ne
    e962:	2000      	movne	r0, #0
    e964:	2001      	moveq	r0, #1
    e966:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    e968:	2802      	cmp	r0, #2
    e96a:	d103      	bne.n	e974 <mayfly_prio_is_equal+0x1e>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
    e96c:	2901      	cmp	r1, #1
    e96e:	e7f7      	b.n	e960 <mayfly_prio_is_equal+0xa>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
    e970:	2001      	movs	r0, #1
    e972:	4770      	bx	lr
    e974:	2000      	movs	r0, #0
}
    e976:	4770      	bx	lr

0000e978 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(uint32_t value)
{
    e978:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
    e97a:	2000      	movs	r0, #0
    e97c:	f7f9 bbc2 	b.w	8104 <cntr_cmp_set>

0000e980 <sys_put_le32>:
	dst[1] = val >> 8;
    e980:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
    e984:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
    e986:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
    e988:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
    e98a:	0a00      	lsrs	r0, r0, #8
    e98c:	704b      	strb	r3, [r1, #1]
    e98e:	70c8      	strb	r0, [r1, #3]
}
    e990:	4770      	bx	lr

0000e992 <hci_vendor_read_static_addr>:
				 uint8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    e992:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
{
    e996:	b510      	push	{r4, lr}
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    e998:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    e99c:	3201      	adds	r2, #1
{
    e99e:	4604      	mov	r4, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    e9a0:	d106      	bne.n	e9b0 <hci_vendor_read_static_addr+0x1e>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    e9a2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    e9a6:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    e9aa:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
    e9ac:	4293      	cmp	r3, r2
    e9ae:	d044      	beq.n	ea3a <hci_vendor_read_static_addr+0xa8>
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
    e9b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e9b4:	f8d2 00a0 	ldr.w	r0, [r2, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
    e9b8:	f010 0001 	ands.w	r0, r0, #1
    e9bc:	d036      	beq.n	ea2c <hci_vendor_read_static_addr+0x9a>
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
    e9be:	4621      	mov	r1, r4
    e9c0:	f8d2 00a4 	ldr.w	r0, [r2, #164]	; 0xa4
    e9c4:	f7ff ffdc 	bl	e980 <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
    e9c8:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
	dst[0] = val;
    e9cc:	7123      	strb	r3, [r4, #4]
	dst[1] = val >> 8;
    e9ce:	f3c3 2307 	ubfx	r3, r3, #8, #8

		/* The FICR value is a just a random number, with no knowledge
		 * of the Bluetooth Specification requirements for random
		 * static addresses.
		 */
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
    e9d2:	f063 033f 	orn	r3, r3, #63	; 0x3f
    e9d6:	7163      	strb	r3, [r4, #5]

		/* If no public address is provided and a static address is
		 * available, then it is recommended to return an identity root
		 * key (if available) from this command.
		 */
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
    e9d8:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
    e9dc:	3101      	adds	r1, #1
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
    e9de:	f104 0306 	add.w	r3, r4, #6
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
    e9e2:	d024      	beq.n	ea2e <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
    e9e4:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
    e9e8:	3101      	adds	r1, #1
    e9ea:	d020      	beq.n	ea2e <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
    e9ec:	f8d2 1098 	ldr.w	r1, [r2, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
    e9f0:	3101      	adds	r1, #1
    e9f2:	d01c      	beq.n	ea2e <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
    e9f4:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
    e9f8:	3101      	adds	r1, #1
    e9fa:	d018      	beq.n	ea2e <hci_vendor_read_static_addr+0x9c>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
    e9fc:	4619      	mov	r1, r3
    e9fe:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
    ea02:	f7ff ffbd 	bl	e980 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
    ea06:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
    ea0a:	f104 010a 	add.w	r1, r4, #10
    ea0e:	f7ff ffb7 	bl	e980 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
    ea12:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
    ea16:	f104 010e 	add.w	r1, r4, #14
    ea1a:	f7ff ffb1 	bl	e980 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
    ea1e:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
    ea22:	f104 0112 	add.w	r1, r4, #18
    ea26:	f7ff ffab 	bl	e980 <sys_put_le32>
		} else {
			/* Mark IR as invalid */
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
		}

		return 1;
    ea2a:	2001      	movs	r0, #1
	}

	return 0;
}
    ea2c:	bd10      	pop	{r4, pc}
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
    ea2e:	2210      	movs	r2, #16
    ea30:	2100      	movs	r1, #0
    ea32:	4618      	mov	r0, r3
    ea34:	f7fe fff2 	bl	da1c <memset>
    ea38:	e7f7      	b.n	ea2a <hci_vendor_read_static_addr+0x98>
	return 0;
    ea3a:	2000      	movs	r0, #0
    ea3c:	e7f6      	b.n	ea2c <hci_vendor_read_static_addr+0x9a>

0000ea3e <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(uint8_t ir[16], uint8_t er[16])
{
    ea3e:	b510      	push	{r4, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
    ea40:	2210      	movs	r2, #16
{
    ea42:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
    ea44:	2100      	movs	r1, #0
    ea46:	f7fe ffe9 	bl	da1c <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
    ea4a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ea4e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    ea52:	3301      	adds	r3, #1
    ea54:	d023      	beq.n	ea9e <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
    ea56:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
    ea5a:	3301      	adds	r3, #1
    ea5c:	d01f      	beq.n	ea9e <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
    ea5e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
    ea62:	3301      	adds	r3, #1
    ea64:	d01b      	beq.n	ea9e <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
    ea66:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
    ea6a:	3301      	adds	r3, #1
    ea6c:	d017      	beq.n	ea9e <hci_vendor_read_key_hierarchy_roots+0x60>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
    ea6e:	4621      	mov	r1, r4
    ea70:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
    ea74:	f7ff ff84 	bl	e980 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
    ea78:	1d21      	adds	r1, r4, #4
    ea7a:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
    ea7e:	f7ff ff7f 	bl	e980 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
    ea82:	f104 0108 	add.w	r1, r4, #8
    ea86:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
    ea8a:	f7ff ff79 	bl	e980 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
    ea8e:	f104 010c 	add.w	r1, r4, #12
    ea92:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
    ea96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
    ea9a:	f7ff bf71 	b.w	e980 <sys_put_le32>
		(void)memset(er, 0x00, 16);
    ea9e:	4620      	mov	r0, r4
    eaa0:	2210      	movs	r2, #16
}
    eaa2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		(void)memset(er, 0x00, 16);
    eaa6:	2100      	movs	r1, #0
    eaa8:	f7fe bfb8 	b.w	da1c <memset>

0000eaac <fixed_data_unref>:
}
    eaac:	4770      	bx	lr

0000eaae <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    eaae:	6a41      	ldr	r1, [r0, #36]	; 0x24
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
    eab0:	6849      	ldr	r1, [r1, #4]
    eab2:	6809      	ldr	r1, [r1, #0]
    eab4:	f7f9 bfb6 	b.w	8a24 <net_buf_alloc_len>

0000eab8 <net_buf_get>:
{
    eab8:	b570      	push	{r4, r5, r6, lr}
    eaba:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
    eabc:	f7fd f908 	bl	bcd0 <z_impl_k_queue_get>
	if (!buf) {
    eac0:	4605      	mov	r5, r0
    eac2:	b128      	cbz	r0, ead0 <net_buf_get+0x18>
    eac4:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
    eac6:	7963      	ldrb	r3, [r4, #5]
    eac8:	f013 0301 	ands.w	r3, r3, #1
    eacc:	d102      	bne.n	ead4 <net_buf_get+0x1c>
	frag->frags = NULL;
    eace:	6023      	str	r3, [r4, #0]
}
    ead0:	4628      	mov	r0, r5
    ead2:	bd70      	pop	{r4, r5, r6, pc}
    ead4:	2300      	movs	r3, #0
    ead6:	2200      	movs	r2, #0
    ead8:	4630      	mov	r0, r6
    eada:	f7fd f8f9 	bl	bcd0 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
    eade:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
    eae0:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
    eae2:	f023 0301 	bic.w	r3, r3, #1
    eae6:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
    eae8:	4604      	mov	r4, r0
    eaea:	e7ec      	b.n	eac6 <net_buf_get+0xe>

0000eaec <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
    eaec:	6883      	ldr	r3, [r0, #8]
    eaee:	440b      	add	r3, r1
    eaf0:	6003      	str	r3, [r0, #0]
}
    eaf2:	4770      	bx	lr

0000eaf4 <net_buf_put>:
{
    eaf4:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
    eaf6:	460a      	mov	r2, r1
    eaf8:	6814      	ldr	r4, [r2, #0]
    eafa:	b914      	cbnz	r4, eb02 <net_buf_put+0xe>
}
    eafc:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
    eafe:	f000 bdfc 	b.w	f6fa <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
    eb02:	7953      	ldrb	r3, [r2, #5]
    eb04:	f043 0301 	orr.w	r3, r3, #1
    eb08:	7153      	strb	r3, [r2, #5]
    eb0a:	4622      	mov	r2, r4
    eb0c:	e7f4      	b.n	eaf8 <net_buf_put+0x4>

0000eb0e <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
    eb0e:	7902      	ldrb	r2, [r0, #4]
    eb10:	3201      	adds	r2, #1
    eb12:	7102      	strb	r2, [r0, #4]
	return buf;
}
    eb14:	4770      	bx	lr

0000eb16 <net_buf_frag_del>:
				       struct net_buf *frag,
				       const char *func, int line)
#else
struct net_buf *net_buf_frag_del(struct net_buf *parent, struct net_buf *frag)
#endif
{
    eb16:	b510      	push	{r4, lr}
	struct net_buf *next_frag;

	__ASSERT_NO_MSG(frag);

	if (parent) {
    eb18:	b108      	cbz	r0, eb1e <net_buf_frag_del+0x8>
		__ASSERT_NO_MSG(parent->frags);
		__ASSERT_NO_MSG(parent->frags == frag);
		parent->frags = frag->frags;
    eb1a:	680b      	ldr	r3, [r1, #0]
    eb1c:	6003      	str	r3, [r0, #0]
	}

	next_frag = frag->frags;
    eb1e:	680c      	ldr	r4, [r1, #0]

	frag->frags = NULL;
    eb20:	2300      	movs	r3, #0

#if defined(CONFIG_NET_BUF_LOG)
	net_buf_unref_debug(frag, func, line);
#else
	net_buf_unref(frag);
    eb22:	4608      	mov	r0, r1
	frag->frags = NULL;
    eb24:	600b      	str	r3, [r1, #0]
	net_buf_unref(frag);
    eb26:	f7fa f811 	bl	8b4c <net_buf_unref>
#endif

	return next_frag;
}
    eb2a:	4620      	mov	r0, r4
    eb2c:	bd10      	pop	{r4, pc}

0000eb2e <net_buf_simple_add>:
	return buf->data + buf->len;
    eb2e:	8883      	ldrh	r3, [r0, #4]
    eb30:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
    eb32:	4419      	add	r1, r3
    eb34:	8081      	strh	r1, [r0, #4]
	return tail;
}
    eb36:	18d0      	adds	r0, r2, r3
    eb38:	4770      	bx	lr

0000eb3a <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
    eb3a:	b430      	push	{r4, r5}
    eb3c:	8884      	ldrh	r4, [r0, #4]
    eb3e:	6805      	ldr	r5, [r0, #0]
	buf->len += len;
    eb40:	18a3      	adds	r3, r4, r2
    eb42:	8083      	strh	r3, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
    eb44:	1928      	adds	r0, r5, r4
}
    eb46:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
    eb48:	f7fe bf5d 	b.w	da06 <memcpy>

0000eb4c <net_buf_simple_add_u8>:
    eb4c:	8883      	ldrh	r3, [r0, #4]
    eb4e:	6802      	ldr	r2, [r0, #0]

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
    eb50:	b510      	push	{r4, lr}
	buf->len += len;
    eb52:	1c5c      	adds	r4, r3, #1
    eb54:	8084      	strh	r4, [r0, #4]
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
    eb56:	54d1      	strb	r1, [r2, r3]

	return u8;
}
    eb58:	18d0      	adds	r0, r2, r3
    eb5a:	bd10      	pop	{r4, pc}

0000eb5c <net_buf_simple_pull_mem>:
	buf->len -= len;
	return buf->data += len;
}

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
    eb5c:	4603      	mov	r3, r0
	void *data = buf->data;
    eb5e:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
    eb60:	889a      	ldrh	r2, [r3, #4]
    eb62:	1a52      	subs	r2, r2, r1
	buf->data += len;
    eb64:	4401      	add	r1, r0
	buf->len -= len;
    eb66:	809a      	strh	r2, [r3, #4]
	buf->data += len;
    eb68:	6019      	str	r1, [r3, #0]

	return data;
}
    eb6a:	4770      	bx	lr

0000eb6c <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
    eb6c:	6802      	ldr	r2, [r0, #0]
    eb6e:	6880      	ldr	r0, [r0, #8]
}
    eb70:	1a10      	subs	r0, r2, r0
    eb72:	4770      	bx	lr

0000eb74 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
    eb74:	6903      	ldr	r3, [r0, #16]
    eb76:	b2c9      	uxtb	r1, r1
    eb78:	220c      	movs	r2, #12
    eb7a:	fb01 3302 	mla	r3, r1, r2, r3
    eb7e:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
    eb80:	f000 0007 	and.w	r0, r0, #7
    eb84:	4770      	bx	lr

0000eb86 <set_on_state>:
	__asm__ volatile(
    eb86:	f04f 0320 	mov.w	r3, #32
    eb8a:	f3ef 8211 	mrs	r2, BASEPRI
    eb8e:	f383 8812 	msr	BASEPRI_MAX, r3
    eb92:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    eb96:	6803      	ldr	r3, [r0, #0]
    eb98:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    eb9c:	f043 0302 	orr.w	r3, r3, #2
    eba0:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
    eba2:	f382 8811 	msr	BASEPRI, r2
    eba6:	f3bf 8f6f 	isb	sy
}
    ebaa:	4770      	bx	lr

0000ebac <stop>:
{
    ebac:	4603      	mov	r3, r0
    ebae:	b570      	push	{r4, r5, r6, lr}
	struct nrf_clock_control_data *data = dev->data;
    ebb0:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
    ebb2:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
    ebb4:	f04f 0420 	mov.w	r4, #32
    ebb8:	f3ef 8611 	mrs	r6, BASEPRI
    ebbc:	f384 8812 	msr	BASEPRI_MAX, r4
    ebc0:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    ebc4:	250c      	movs	r5, #12
    ebc6:	fb05 0401 	mla	r4, r5, r1, r0
    ebca:	6c24      	ldr	r4, [r4, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    ebcc:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
    ebd0:	d001      	beq.n	ebd6 <stop+0x2a>
    ebd2:	42a2      	cmp	r2, r4
    ebd4:	d111      	bne.n	ebfa <stop+0x4e>
		*flags = CLOCK_CONTROL_STATUS_OFF;
    ebd6:	fb05 0001 	mla	r0, r5, r1, r0
    ebda:	2201      	movs	r2, #1
    ebdc:	6402      	str	r2, [r0, #64]	; 0x40
	int err = 0;
    ebde:	2000      	movs	r0, #0
	__asm__ volatile(
    ebe0:	f386 8811 	msr	BASEPRI, r6
    ebe4:	f3bf 8f6f 	isb	sy
	if (err < 0) {
    ebe8:	b930      	cbnz	r0, ebf8 <stop+0x4c>
	get_sub_config(dev, type)->stop();
    ebea:	685b      	ldr	r3, [r3, #4]
    ebec:	220c      	movs	r2, #12
    ebee:	fb02 3101 	mla	r1, r2, r1, r3
    ebf2:	684b      	ldr	r3, [r1, #4]
    ebf4:	4798      	blx	r3
	return 0;
    ebf6:	2000      	movs	r0, #0
}
    ebf8:	bd70      	pop	{r4, r5, r6, pc}
		err = -EPERM;
    ebfa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ebfe:	e7ef      	b.n	ebe0 <stop+0x34>

0000ec00 <api_stop>:
	return stop(dev, subsys, CTX_API);
    ec00:	2280      	movs	r2, #128	; 0x80
    ec02:	f7ff bfd3 	b.w	ebac <stop>

0000ec06 <async_start>:
{
    ec06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ec08:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
    ec0a:	6904      	ldr	r4, [r0, #16]
{
    ec0c:	4605      	mov	r5, r0
    ec0e:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
    ec10:	f04f 0020 	mov.w	r0, #32
    ec14:	f3ef 8c11 	mrs	ip, BASEPRI
    ec18:	f380 8812 	msr	BASEPRI_MAX, r0
    ec1c:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    ec20:	260c      	movs	r6, #12
    ec22:	fb06 4601 	mla	r6, r6, r1, r4
    ec26:	6c30      	ldr	r0, [r6, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    ec28:	f000 0e07 	and.w	lr, r0, #7
    ec2c:	f1be 0f01 	cmp.w	lr, #1
    ec30:	d110      	bne.n	ec54 <async_start+0x4e>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    ec32:	6437      	str	r7, [r6, #64]	; 0x40
	int err = 0;
    ec34:	2600      	movs	r6, #0
	__asm__ volatile(
    ec36:	f38c 8811 	msr	BASEPRI, ip
    ec3a:	f3bf 8f6f 	isb	sy
	if (err < 0) {
    ec3e:	b93e      	cbnz	r6, ec50 <async_start+0x4a>
	subdata->cb = cb;
    ec40:	200c      	movs	r0, #12
    ec42:	4341      	muls	r1, r0
    ec44:	440c      	add	r4, r1
	subdata->user_data = user_data;
    ec46:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
    ec4a:	686b      	ldr	r3, [r5, #4]
    ec4c:	585b      	ldr	r3, [r3, r1]
    ec4e:	4798      	blx	r3
}
    ec50:	4630      	mov	r0, r6
    ec52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
    ec54:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
		err = -EALREADY;
    ec58:	4287      	cmp	r7, r0
    ec5a:	bf14      	ite	ne
    ec5c:	f04f 36ff 	movne.w	r6, #4294967295	; 0xffffffff
    ec60:	f06f 0677 	mvneq.w	r6, #119	; 0x77
    ec64:	e7e7      	b.n	ec36 <async_start+0x30>

0000ec66 <api_start>:
{
    ec66:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
    ec68:	2480      	movs	r4, #128	; 0x80
    ec6a:	9400      	str	r4, [sp, #0]
    ec6c:	f7ff ffcb 	bl	ec06 <async_start>
}
    ec70:	b002      	add	sp, #8
    ec72:	bd10      	pop	{r4, pc}

0000ec74 <onoff_started_callback>:
	return &data->mgr[type];
    ec74:	6900      	ldr	r0, [r0, #16]
{
    ec76:	b410      	push	{r4}
	return &data->mgr[type];
    ec78:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
    ec7a:	241c      	movs	r4, #28
    ec7c:	fb03 0004 	mla	r0, r3, r4, r0
    ec80:	2100      	movs	r1, #0
}
    ec82:	bc10      	pop	{r4}
	notify(mgr, 0);
    ec84:	4710      	bx	r2

0000ec86 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    ec86:	2000      	movs	r0, #0
    ec88:	f7fb bd74 	b.w	a774 <nrfx_clock_stop>

0000ec8c <blocking_start_callback>:
{
    ec8c:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
    ec8e:	f7fd b853 	b.w	bd38 <z_impl_k_sem_give>

0000ec92 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    ec92:	6843      	ldr	r3, [r0, #4]
    ec94:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
    ec96:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
    ec9a:	600b      	str	r3, [r1, #0]
}
    ec9c:	2000      	movs	r0, #0
    ec9e:	4770      	bx	lr

0000eca0 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    eca0:	6843      	ldr	r3, [r0, #4]
    eca2:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
    eca4:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
    eca8:	4042      	eors	r2, r0
    ecaa:	400a      	ands	r2, r1
    ecac:	4042      	eors	r2, r0
    p_reg->OUT = value;
    ecae:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
    ecb2:	2000      	movs	r0, #0
    ecb4:	4770      	bx	lr

0000ecb6 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    ecb6:	6843      	ldr	r3, [r0, #4]
    ecb8:	685b      	ldr	r3, [r3, #4]
}
    ecba:	2000      	movs	r0, #0
    p_reg->OUTSET = set_mask;
    ecbc:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
    ecc0:	4770      	bx	lr

0000ecc2 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    ecc2:	6843      	ldr	r3, [r0, #4]
    ecc4:	685b      	ldr	r3, [r3, #4]
}
    ecc6:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
    ecc8:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
    eccc:	4770      	bx	lr

0000ecce <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    ecce:	6843      	ldr	r3, [r0, #4]
    ecd0:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
    ecd2:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
    ecd6:	404b      	eors	r3, r1
    p_reg->OUT = value;
    ecd8:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
    ecdc:	2000      	movs	r0, #0
    ecde:	4770      	bx	lr

0000ece0 <gpio_nrfx_manage_callback>:
	return port->data;
    ece0:	6903      	ldr	r3, [r0, #16]
	return list->head;
    ece2:	6858      	ldr	r0, [r3, #4]
{
    ece4:	b530      	push	{r4, r5, lr}
	if (!sys_slist_is_empty(callbacks)) {
    ece6:	b158      	cbz	r0, ed00 <gpio_nrfx_manage_callback+0x20>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    ece8:	2400      	movs	r4, #0
    ecea:	4281      	cmp	r1, r0
    ecec:	d112      	bne.n	ed14 <gpio_nrfx_manage_callback+0x34>
	return node->next;
    ecee:	6808      	ldr	r0, [r1, #0]
	return list->tail;
    ecf0:	689d      	ldr	r5, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
    ecf2:	b954      	cbnz	r4, ed0a <gpio_nrfx_manage_callback+0x2a>
    ecf4:	428d      	cmp	r5, r1
	list->head = node;
    ecf6:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
    ecf8:	d100      	bne.n	ecfc <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
    ecfa:	6098      	str	r0, [r3, #8]
	parent->next = child;
    ecfc:	2000      	movs	r0, #0
    ecfe:	6008      	str	r0, [r1, #0]
	if (set) {
    ed00:	b96a      	cbnz	r2, ed1e <gpio_nrfx_manage_callback+0x3e>
	return 0;
    ed02:	2000      	movs	r0, #0
}
    ed04:	bd30      	pop	{r4, r5, pc}
    ed06:	4628      	mov	r0, r5
    ed08:	e7ef      	b.n	ecea <gpio_nrfx_manage_callback+0xa>
Z_GENLIST_REMOVE(slist, snode)
    ed0a:	428d      	cmp	r5, r1
	parent->next = child;
    ed0c:	6020      	str	r0, [r4, #0]
	list->tail = node;
    ed0e:	bf08      	it	eq
    ed10:	609c      	streq	r4, [r3, #8]
}
    ed12:	e7f3      	b.n	ecfc <gpio_nrfx_manage_callback+0x1c>
	return node->next;
    ed14:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    ed16:	4604      	mov	r4, r0
    ed18:	2d00      	cmp	r5, #0
    ed1a:	d1f4      	bne.n	ed06 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
    ed1c:	b13a      	cbz	r2, ed2e <gpio_nrfx_manage_callback+0x4e>
Z_GENLIST_PREPEND(slist, snode)
    ed1e:	6898      	ldr	r0, [r3, #8]
	parent->next = child;
    ed20:	685a      	ldr	r2, [r3, #4]
    ed22:	600a      	str	r2, [r1, #0]
	list->head = node;
    ed24:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
    ed26:	2800      	cmp	r0, #0
    ed28:	d1eb      	bne.n	ed02 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
    ed2a:	6099      	str	r1, [r3, #8]
}
    ed2c:	e7ea      	b.n	ed04 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
    ed2e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    ed32:	e7e7      	b.n	ed04 <gpio_nrfx_manage_callback+0x24>

0000ed34 <pin_interrupt_configure>:
		return -ENOTSUP;
    ed34:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
}
    ed38:	bf14      	ite	ne
    ed3a:	f06f 0085 	mvnne.w	r0, #133	; 0x85
    ed3e:	2000      	moveq	r0, #0
    ed40:	4770      	bx	lr

0000ed42 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    ed42:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    ed44:	ab0a      	add	r3, sp, #40	; 0x28
    ed46:	9305      	str	r3, [sp, #20]
    ed48:	9302      	str	r3, [sp, #8]
    ed4a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ed4c:	9301      	str	r3, [sp, #4]
    ed4e:	2300      	movs	r3, #0
    ed50:	9300      	str	r3, [sp, #0]
    ed52:	4618      	mov	r0, r3
    ed54:	f7f2 ff76 	bl	1c44 <z_impl_z_log_msg2_runtime_vcreate>
}
    ed58:	b007      	add	sp, #28
    ed5a:	f85d fb04 	ldr.w	pc, [sp], #4

0000ed5e <k_sem_take.constprop.0.isra.0>:
	return z_impl_k_sem_take(sem, timeout);
    ed5e:	f7fd b811 	b.w	bd84 <z_impl_k_sem_take>

0000ed62 <i2c_write>:
{
    ed62:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.len = num_bytes;
    ed64:	e9cd 1201 	strd	r1, r2, [sp, #4]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
    ed68:	2202      	movs	r2, #2
    ed6a:	f88d 200c 	strb.w	r2, [sp, #12]
	int res =  api->transfer(dev, msgs, num_msgs, addr);
    ed6e:	6882      	ldr	r2, [r0, #8]
    ed70:	a901      	add	r1, sp, #4
    ed72:	6894      	ldr	r4, [r2, #8]
    ed74:	2201      	movs	r2, #1
    ed76:	47a0      	blx	r4
}
    ed78:	b004      	add	sp, #16
    ed7a:	bd10      	pop	{r4, pc}

0000ed7c <i2c_reg_write_word_be>:
{
    ed7c:	b507      	push	{r0, r1, r2, lr}
	uint8_t tx_buf[3] = { reg_addr, value >> 8, value & 0xff };
    ed7e:	f88d 2004 	strb.w	r2, [sp, #4]
    ed82:	0a1a      	lsrs	r2, r3, #8
    ed84:	f88d 2005 	strb.w	r2, [sp, #5]
    ed88:	f88d 3006 	strb.w	r3, [sp, #6]
	return i2c_write(dev, tx_buf, 3, dev_addr);
    ed8c:	2203      	movs	r2, #3
    ed8e:	460b      	mov	r3, r1
    ed90:	a901      	add	r1, sp, #4
    ed92:	f7ff ffe6 	bl	ed62 <i2c_write>
}
    ed96:	b003      	add	sp, #12
    ed98:	f85d fb04 	ldr.w	pc, [sp], #4

0000ed9c <port_write>:
{
    ed9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    eda0:	4605      	mov	r5, r0
    eda2:	4689      	mov	r9, r1
    eda4:	4614      	mov	r4, r2
    eda6:	4698      	mov	r8, r3
	if (k_is_in_isr()) {
    eda8:	f000 fc06 	bl	f5b8 <k_is_in_isr>
    edac:	bb08      	cbnz	r0, edf2 <port_write+0x56>
	const struct sx1509b_config *cfg = dev->config;
    edae:	686f      	ldr	r7, [r5, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
    edb0:	692d      	ldr	r5, [r5, #16]
	k_sem_take(&drv_data->lock, K_FOREVER);
    edb2:	f105 0620 	add.w	r6, r5, #32
    edb6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    edba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    edbe:	4630      	mov	r0, r6
    edc0:	f7ff ffcd 	bl	ed5e <k_sem_take.constprop.0.isra.0>
	uint16_t orig_out = *outp;
    edc4:	8b28      	ldrh	r0, [r5, #24]
	int rc = i2c_reg_write_word_be(drv_data->i2c_master, cfg->i2c_slave_addr,
    edc6:	8939      	ldrh	r1, [r7, #8]
	uint16_t out = ((orig_out & ~mask) | (value & mask)) ^ toggle;
    edc8:	4044      	eors	r4, r0
    edca:	ea04 0409 	and.w	r4, r4, r9
    edce:	ea84 0408 	eor.w	r4, r4, r8
    edd2:	4044      	eors	r4, r0
    edd4:	b2a4      	uxth	r4, r4
	int rc = i2c_reg_write_word_be(drv_data->i2c_master, cfg->i2c_slave_addr,
    edd6:	6868      	ldr	r0, [r5, #4]
    edd8:	4623      	mov	r3, r4
    edda:	2210      	movs	r2, #16
    eddc:	f7ff ffce 	bl	ed7c <i2c_reg_write_word_be>
	if (rc == 0) {
    ede0:	4607      	mov	r7, r0
    ede2:	b900      	cbnz	r0, ede6 <port_write+0x4a>
		*outp = out;
    ede4:	832c      	strh	r4, [r5, #24]
	z_impl_k_sem_give(sem);
    ede6:	4630      	mov	r0, r6
    ede8:	f7fc ffa6 	bl	bd38 <z_impl_k_sem_give>
}
    edec:	4638      	mov	r0, r7
    edee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EWOULDBLOCK;
    edf2:	f06f 070a 	mvn.w	r7, #10
    edf6:	e7f9      	b.n	edec <port_write+0x50>

0000edf8 <port_toggle_bits>:
	return port_write(dev, 0, 0, pins);
    edf8:	2200      	movs	r2, #0
{
    edfa:	460b      	mov	r3, r1
	return port_write(dev, 0, 0, pins);
    edfc:	4611      	mov	r1, r2
    edfe:	f7ff bfcd 	b.w	ed9c <port_write>

0000ee02 <port_clear_bits>:
	return port_write(dev, pins, 0, 0);
    ee02:	2300      	movs	r3, #0
    ee04:	461a      	mov	r2, r3
    ee06:	f7ff bfc9 	b.w	ed9c <port_write>

0000ee0a <port_set_bits>:
{
    ee0a:	460a      	mov	r2, r1
	return port_write(dev, pins, pins, 0);
    ee0c:	2300      	movs	r3, #0
    ee0e:	f7ff bfc5 	b.w	ed9c <port_write>

0000ee12 <port_set_masked>:
	return port_write(dev, mask, value, 0);
    ee12:	2300      	movs	r3, #0
    ee14:	f7ff bfc2 	b.w	ed9c <port_write>

0000ee18 <write_pin_state>:
{
    ee18:	b530      	push	{r4, r5, lr}
    ee1a:	b087      	sub	sp, #28
    ee1c:	460c      	mov	r4, r1
	pin_buf.reg = SX1509B_REG_INPUT_DISABLE;
    ee1e:	2100      	movs	r1, #0
    ee20:	f88d 1004 	strb.w	r1, [sp, #4]
	pin_buf.pins.input_disable = sys_cpu_to_be16(pins->input_disable);
    ee24:	8811      	ldrh	r1, [r2, #0]
    ee26:	ba49      	rev16	r1, r1
    ee28:	f8ad 1005 	strh.w	r1, [sp, #5]
	pin_buf.pins.long_slew = sys_cpu_to_be16(pins->long_slew);
    ee2c:	8851      	ldrh	r1, [r2, #2]
    ee2e:	ba49      	rev16	r1, r1
    ee30:	f8ad 1007 	strh.w	r1, [sp, #7]
	pin_buf.pins.low_drive = sys_cpu_to_be16(pins->low_drive);
    ee34:	8891      	ldrh	r1, [r2, #4]
    ee36:	ba49      	rev16	r1, r1
    ee38:	f8ad 1009 	strh.w	r1, [sp, #9]
	pin_buf.pins.pull_up = sys_cpu_to_be16(pins->pull_up);
    ee3c:	88d1      	ldrh	r1, [r2, #6]
    ee3e:	ba49      	rev16	r1, r1
    ee40:	f8ad 100b 	strh.w	r1, [sp, #11]
	pin_buf.pins.pull_down = sys_cpu_to_be16(pins->pull_down);
    ee44:	8911      	ldrh	r1, [r2, #8]
    ee46:	ba49      	rev16	r1, r1
    ee48:	f8ad 100d 	strh.w	r1, [sp, #13]
	pin_buf.pins.open_drain = sys_cpu_to_be16(pins->open_drain);
    ee4c:	8951      	ldrh	r1, [r2, #10]
    ee4e:	ba49      	rev16	r1, r1
    ee50:	f8ad 100f 	strh.w	r1, [sp, #15]
	pin_buf.pins.polarity = sys_cpu_to_be16(pins->polarity);
    ee54:	8991      	ldrh	r1, [r2, #12]
    ee56:	ba49      	rev16	r1, r1
    ee58:	f8ad 1011 	strh.w	r1, [sp, #17]
	pin_buf.pins.dir = sys_cpu_to_be16(pins->dir);
    ee5c:	89d1      	ldrh	r1, [r2, #14]
    ee5e:	8a12      	ldrh	r2, [r2, #16]
{
    ee60:	4605      	mov	r5, r0
	pin_buf.pins.dir = sys_cpu_to_be16(pins->dir);
    ee62:	ba49      	rev16	r1, r1
    ee64:	f8ad 1013 	strh.w	r1, [sp, #19]
	pin_buf.pins.data = sys_cpu_to_be16(pins->data);
    ee68:	ba51      	rev16	r1, r2
    ee6a:	f8ad 1015 	strh.w	r1, [sp, #21]
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
    ee6e:	6860      	ldr	r0, [r4, #4]
    ee70:	8929      	ldrh	r1, [r5, #8]
	if (data_first) {
    ee72:	b163      	cbz	r3, ee8e <write_pin_state+0x76>
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
    ee74:	4613      	mov	r3, r2
    ee76:	2210      	movs	r2, #16
    ee78:	f7ff ff80 	bl	ed7c <i2c_reg_write_word_be>
		if (rc == 0) {
    ee7c:	b928      	cbnz	r0, ee8a <write_pin_state+0x72>
			rc = i2c_write(drv_data->i2c_master, &pin_buf.reg,
    ee7e:	892b      	ldrh	r3, [r5, #8]
    ee80:	6860      	ldr	r0, [r4, #4]
    ee82:	2211      	movs	r2, #17
    ee84:	a901      	add	r1, sp, #4
		rc = i2c_write(drv_data->i2c_master, &pin_buf.reg,
    ee86:	f7ff ff6c 	bl	ed62 <i2c_write>
}
    ee8a:	b007      	add	sp, #28
    ee8c:	bd30      	pop	{r4, r5, pc}
		rc = i2c_write(drv_data->i2c_master, &pin_buf.reg,
    ee8e:	460b      	mov	r3, r1
    ee90:	2213      	movs	r2, #19
    ee92:	a901      	add	r1, sp, #4
    ee94:	e7f7      	b.n	ee86 <write_pin_state+0x6e>

0000ee96 <sx1509b_config>:
{
    ee96:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct sx1509b_config *cfg = dev->config;
    ee9a:	f8d0 a004 	ldr.w	sl, [r0, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
    ee9e:	6904      	ldr	r4, [r0, #16]
{
    eea0:	460d      	mov	r5, r1
    eea2:	4617      	mov	r7, r2
	if (k_is_in_isr()) {
    eea4:	f000 fb88 	bl	f5b8 <k_is_in_isr>
    eea8:	4683      	mov	fp, r0
    eeaa:	2800      	cmp	r0, #0
    eeac:	f040 808c 	bne.w	efc8 <sx1509b_config+0x132>
	if ((flags & GPIO_DS_ALT) != 0) {
    eeb0:	f417 0fa0 	tst.w	r7, #5242880	; 0x500000
    eeb4:	f040 808b 	bne.w	efce <sx1509b_config+0x138>
	k_sem_take(&drv_data->lock, K_FOREVER);
    eeb8:	f104 0920 	add.w	r9, r4, #32
    eebc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    eec0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    eec4:	4648      	mov	r0, r9
    eec6:	f7ff ff4a 	bl	ed5e <k_sem_take.constprop.0.isra.0>
		drv_data->led_drv_enable &= ~BIT(pin);
    eeca:	2601      	movs	r6, #1
	if (drv_data->led_drv_enable & BIT(pin)) {
    eecc:	8b63      	ldrh	r3, [r4, #26]
		drv_data->led_drv_enable &= ~BIT(pin);
    eece:	40ae      	lsls	r6, r5
    eed0:	b2b6      	uxth	r6, r6
	if (drv_data->led_drv_enable & BIT(pin)) {
    eed2:	fa23 f505 	lsr.w	r5, r3, r5
		drv_data->led_drv_enable &= ~BIT(pin);
    eed6:	ea6f 0806 	mvn.w	r8, r6
	if (drv_data->led_drv_enable & BIT(pin)) {
    eeda:	07e9      	lsls	r1, r5, #31
		drv_data->led_drv_enable &= ~BIT(pin);
    eedc:	fa1f f888 	uxth.w	r8, r8
	if (drv_data->led_drv_enable & BIT(pin)) {
    eee0:	d44f      	bmi.n	ef82 <sx1509b_config+0xec>
	pins->open_drain &= ~BIT(pin);
    eee2:	8a63      	ldrh	r3, [r4, #18]
    eee4:	ea03 0208 	and.w	r2, r3, r8
    eee8:	8262      	strh	r2, [r4, #18]
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
    eeea:	07ba      	lsls	r2, r7, #30
    eeec:	d45c      	bmi.n	efa8 <sx1509b_config+0x112>
		pins->pull_up |= BIT(pin);
    eeee:	89e3      	ldrh	r3, [r4, #14]
	if ((flags & GPIO_PULL_UP) != 0) {
    eef0:	06f8      	lsls	r0, r7, #27
		pins->pull_up |= BIT(pin);
    eef2:	bf4c      	ite	mi
    eef4:	4333      	orrmi	r3, r6
		pins->pull_up &= ~BIT(pin);
    eef6:	ea03 0308 	andpl.w	r3, r3, r8
    eefa:	81e3      	strh	r3, [r4, #14]
		pins->pull_down |= BIT(pin);
    eefc:	8a23      	ldrh	r3, [r4, #16]
	if ((flags & GPIO_PULL_DOWN) != 0) {
    eefe:	06b9      	lsls	r1, r7, #26
		pins->pull_down |= BIT(pin);
    ef00:	bf4c      	ite	mi
    ef02:	4333      	orrmi	r3, r6
		pins->pull_down &= ~BIT(pin);
    ef04:	ea03 0308 	andpl.w	r3, r3, r8
    ef08:	8223      	strh	r3, [r4, #16]
		pins->input_disable &= ~BIT(pin);
    ef0a:	8923      	ldrh	r3, [r4, #8]
	if ((flags & GPIO_INPUT) != 0) {
    ef0c:	05fa      	lsls	r2, r7, #23
		pins->input_disable &= ~BIT(pin);
    ef0e:	bf4c      	ite	mi
    ef10:	ea08 0303 	andmi.w	r3, r8, r3
		pins->input_disable |= BIT(pin);
    ef14:	4333      	orrpl	r3, r6
	if ((flags & GPIO_OUTPUT) != 0) {
    ef16:	05bd      	lsls	r5, r7, #22
    ef18:	8123      	strh	r3, [r4, #8]
		pins->dir &= ~BIT(pin);
    ef1a:	8ae3      	ldrh	r3, [r4, #22]
	if ((flags & GPIO_OUTPUT) != 0) {
    ef1c:	d54e      	bpl.n	efbc <sx1509b_config+0x126>
		pins->dir &= ~BIT(pin);
    ef1e:	ea08 0303 	and.w	r3, r8, r3
		if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    ef22:	0578      	lsls	r0, r7, #21
		pins->dir &= ~BIT(pin);
    ef24:	82e3      	strh	r3, [r4, #22]
		if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    ef26:	d544      	bpl.n	efb2 <sx1509b_config+0x11c>
			pins->data &= ~BIT(pin);
    ef28:	8b23      	ldrh	r3, [r4, #24]
    ef2a:	ea08 0303 	and.w	r3, r8, r3
			pins->data |= BIT(pin);
    ef2e:	8323      	strh	r3, [r4, #24]
			data_first = true;
    ef30:	f04f 0b01 	mov.w	fp, #1
		debounce->debounce_enable |= BIT(pin);
    ef34:	f8b4 301d 	ldrh.w	r3, [r4, #29]
	if ((flags & GPIO_INT_DEBOUNCE) != 0) {
    ef38:	033a      	lsls	r2, r7, #12
		debounce->debounce_enable |= BIT(pin);
    ef3a:	bf4c      	ite	mi
    ef3c:	431e      	orrmi	r6, r3
		debounce->debounce_enable &= ~BIT(pin);
    ef3e:	ea08 0603 	andpl.w	r6, r8, r3
    ef42:	f8a4 601d 	strh.w	r6, [r4, #29]
	rc = write_pin_state(cfg, drv_data, pins, data_first);
    ef46:	465b      	mov	r3, fp
    ef48:	f104 0208 	add.w	r2, r4, #8
    ef4c:	4621      	mov	r1, r4
    ef4e:	4650      	mov	r0, sl
    ef50:	f7ff ff62 	bl	ee18 <write_pin_state>
	if (rc == 0) {
    ef54:	4605      	mov	r5, r0
    ef56:	bb00      	cbnz	r0, ef9a <sx1509b_config+0x104>
		debounce_buf.reg = SX1509B_REG_DEBOUNCE_CONFIG;
    ef58:	2322      	movs	r3, #34	; 0x22
    ef5a:	f88d 3004 	strb.w	r3, [sp, #4]
			= debounce->debounce_config;
    ef5e:	7f23      	ldrb	r3, [r4, #28]
    ef60:	f88d 3005 	strb.w	r3, [sp, #5]
			= sys_cpu_to_be16(debounce->debounce_enable);
    ef64:	f8b4 301d 	ldrh.w	r3, [r4, #29]
		rc = i2c_write(drv_data->i2c_master,
    ef68:	6860      	ldr	r0, [r4, #4]
			= sys_cpu_to_be16(debounce->debounce_enable);
    ef6a:	ba5b      	rev16	r3, r3
		rc = i2c_write(drv_data->i2c_master,
    ef6c:	2204      	movs	r2, #4
			= sys_cpu_to_be16(debounce->debounce_enable);
    ef6e:	f8ad 3006 	strh.w	r3, [sp, #6]
		rc = i2c_write(drv_data->i2c_master,
    ef72:	eb0d 0102 	add.w	r1, sp, r2
    ef76:	f8ba 3008 	ldrh.w	r3, [sl, #8]
    ef7a:	f7ff fef2 	bl	ed62 <i2c_write>
    ef7e:	4605      	mov	r5, r0
    ef80:	e00b      	b.n	ef9a <sx1509b_config+0x104>
		drv_data->led_drv_enable &= ~BIT(pin);
    ef82:	ea03 0308 	and.w	r3, r3, r8
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
    ef86:	f8ba 1008 	ldrh.w	r1, [sl, #8]
    ef8a:	6860      	ldr	r0, [r4, #4]
		drv_data->led_drv_enable &= ~BIT(pin);
    ef8c:	8363      	strh	r3, [r4, #26]
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
    ef8e:	2220      	movs	r2, #32
    ef90:	f7ff fef4 	bl	ed7c <i2c_reg_write_word_be>
		if (rc) {
    ef94:	4605      	mov	r5, r0
    ef96:	2800      	cmp	r0, #0
    ef98:	d0a3      	beq.n	eee2 <sx1509b_config+0x4c>
    ef9a:	4648      	mov	r0, r9
    ef9c:	f7fc fecc 	bl	bd38 <z_impl_k_sem_give>
}
    efa0:	4628      	mov	r0, r5
    efa2:	b003      	add	sp, #12
    efa4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((flags & GPIO_LINE_OPEN_DRAIN) != 0) {
    efa8:	077d      	lsls	r5, r7, #29
    efaa:	d50a      	bpl.n	efc2 <sx1509b_config+0x12c>
			pins->open_drain |= BIT(pin);
    efac:	4333      	orrs	r3, r6
    efae:	8263      	strh	r3, [r4, #18]
    efb0:	e79d      	b.n	eeee <sx1509b_config+0x58>
		} else if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    efb2:	0539      	lsls	r1, r7, #20
    efb4:	d5be      	bpl.n	ef34 <sx1509b_config+0x9e>
			pins->data |= BIT(pin);
    efb6:	8b23      	ldrh	r3, [r4, #24]
    efb8:	4333      	orrs	r3, r6
    efba:	e7b8      	b.n	ef2e <sx1509b_config+0x98>
		pins->dir |= BIT(pin);
    efbc:	4333      	orrs	r3, r6
    efbe:	82e3      	strh	r3, [r4, #22]
    efc0:	e7b8      	b.n	ef34 <sx1509b_config+0x9e>
			rc = -ENOTSUP;
    efc2:	f06f 0585 	mvn.w	r5, #133	; 0x85
    efc6:	e7e8      	b.n	ef9a <sx1509b_config+0x104>
		return -EWOULDBLOCK;
    efc8:	f06f 050a 	mvn.w	r5, #10
    efcc:	e7e8      	b.n	efa0 <sx1509b_config+0x10a>
		return -ENOTSUP;
    efce:	f06f 0585 	mvn.w	r5, #133	; 0x85
    efd2:	e7e5      	b.n	efa0 <sx1509b_config+0x10a>

0000efd4 <port_get>:
{
    efd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    efd8:	b088      	sub	sp, #32
	const struct sx1509b_config *cfg = dev->config;
    efda:	f8d0 8004 	ldr.w	r8, [r0, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
    efde:	6907      	ldr	r7, [r0, #16]
{
    efe0:	460d      	mov	r5, r1
	if (k_is_in_isr()) {
    efe2:	f000 fae9 	bl	f5b8 <k_is_in_isr>
    efe6:	4604      	mov	r4, r0
    efe8:	bb78      	cbnz	r0, f04a <port_get+0x76>
	k_sem_take(&drv_data->lock, K_FOREVER);
    efea:	f107 0620 	add.w	r6, r7, #32
    efee:	4630      	mov	r0, r6
    eff0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    eff4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    eff8:	f7ff feb1 	bl	ed5e <k_sem_take.constprop.0.isra.0>
	msg[0].buf = (uint8_t *)write_buf;
    effc:	f10d 0205 	add.w	r2, sp, #5
    f000:	9202      	str	r2, [sp, #8]
	msg[0].len = num_write;
    f002:	2201      	movs	r2, #1
	rc = i2c_write_read(drv_data->i2c_master, cfg->i2c_slave_addr,
    f004:	6878      	ldr	r0, [r7, #4]
    f006:	9203      	str	r2, [sp, #12]
	uint8_t cmd = SX1509B_REG_DATA;
    f008:	2310      	movs	r3, #16
	msg[1].buf = (uint8_t *)read_buf;
    f00a:	f10d 0206 	add.w	r2, sp, #6
    f00e:	f88d 3005 	strb.w	r3, [sp, #5]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
    f012:	2107      	movs	r1, #7
	rc = i2c_write_read(drv_data->i2c_master, cfg->i2c_slave_addr,
    f014:	f8b8 3008 	ldrh.w	r3, [r8, #8]
	msg[1].buf = (uint8_t *)read_buf;
    f018:	9205      	str	r2, [sp, #20]
	msg[1].len = num_read;
    f01a:	2202      	movs	r2, #2
	msg[0].flags = I2C_MSG_WRITE;
    f01c:	f88d 4010 	strb.w	r4, [sp, #16]
	msg[1].len = num_read;
    f020:	9206      	str	r2, [sp, #24]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
    f022:	f88d 101c 	strb.w	r1, [sp, #28]
	int res =  api->transfer(dev, msgs, num_msgs, addr);
    f026:	6881      	ldr	r1, [r0, #8]
    f028:	688c      	ldr	r4, [r1, #8]
    f02a:	a902      	add	r1, sp, #8
    f02c:	47a0      	blx	r4
	if (rc != 0) {
    f02e:	4604      	mov	r4, r0
    f030:	b920      	cbnz	r0, f03c <port_get+0x68>
	*value = sys_be16_to_cpu(pin_data);
    f032:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    f036:	ba5b      	rev16	r3, r3
    f038:	b29b      	uxth	r3, r3
    f03a:	602b      	str	r3, [r5, #0]
    f03c:	4630      	mov	r0, r6
    f03e:	f7fc fe7b 	bl	bd38 <z_impl_k_sem_give>
}
    f042:	4620      	mov	r0, r4
    f044:	b008      	add	sp, #32
    f046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EWOULDBLOCK;
    f04a:	f06f 040a 	mvn.w	r4, #10
    f04e:	e7f8      	b.n	f042 <port_get+0x6e>

0000f050 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    f050:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    f052:	ab0a      	add	r3, sp, #40	; 0x28
    f054:	9305      	str	r3, [sp, #20]
    f056:	9302      	str	r3, [sp, #8]
    f058:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f05a:	9301      	str	r3, [sp, #4]
    f05c:	2300      	movs	r3, #0
    f05e:	9300      	str	r3, [sp, #0]
    f060:	2201      	movs	r2, #1
    f062:	4618      	mov	r0, r3
    f064:	f7f2 fdee 	bl	1c44 <z_impl_z_log_msg2_runtime_vcreate>
}
    f068:	b007      	add	sp, #28
    f06a:	f85d fb04 	ldr.w	pc, [sp], #4

0000f06e <twim_0_init>:
		      POST_KERNEL,					       \
		      CONFIG_I2C_INIT_PRIORITY,				       \
		      &i2c_nrfx_twim_driver_api)

#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
    f06e:	b510      	push	{r4, lr}
    f070:	2200      	movs	r2, #0
    f072:	4604      	mov	r4, r0
    f074:	2101      	movs	r1, #1
    f076:	2003      	movs	r0, #3
    f078:	f7f3 f8c6 	bl	2208 <z_arm_irq_priority_set>
    f07c:	4620      	mov	r0, r4
    f07e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f082:	f7fa b99d 	b.w	93c0 <init_twim>

0000f086 <twim_1_init>:
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
    f086:	b510      	push	{r4, lr}
    f088:	2200      	movs	r2, #0
    f08a:	4604      	mov	r4, r0
    f08c:	2101      	movs	r1, #1
    f08e:	2004      	movs	r0, #4
    f090:	f7f3 f8ba 	bl	2208 <z_arm_irq_priority_set>
    f094:	4620      	mov	r0, r4
    f096:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f09a:	f7fa b991 	b.w	93c0 <init_twim>

0000f09e <gpio_pin_set_dt>:
 * @param spec GPIO specification from devicetree
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
{
    f09e:	4603      	mov	r3, r0
    f0a0:	460a      	mov	r2, r1
	return gpio_pin_set(spec->port, spec->pin, value);
    f0a2:	6800      	ldr	r0, [r0, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    f0a4:	7919      	ldrb	r1, [r3, #4]
    f0a6:	2301      	movs	r3, #1
    f0a8:	fa03 f101 	lsl.w	r1, r3, r1
    f0ac:	6903      	ldr	r3, [r0, #16]
    f0ae:	681b      	ldr	r3, [r3, #0]
    f0b0:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
    f0b2:	bf18      	it	ne
    f0b4:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
    f0b8:	b112      	cbz	r2, f0c0 <gpio_pin_set_dt+0x22>
	return api->port_set_bits_raw(port, pins);
    f0ba:	6883      	ldr	r3, [r0, #8]
    f0bc:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
    f0be:	4718      	bx	r3
    f0c0:	6883      	ldr	r3, [r0, #8]
    f0c2:	691b      	ldr	r3, [r3, #16]
    f0c4:	e7fb      	b.n	f0be <gpio_pin_set_dt+0x20>

0000f0c6 <disable_sync>:
{
    f0c6:	b530      	push	{r4, r5, lr}
	int rc = onoff_sync_lock(&data->srv, &key);
    f0c8:	6904      	ldr	r4, [r0, #16]
	const struct driver_config *cfg = dev->config;
    f0ca:	6845      	ldr	r5, [r0, #4]
{
    f0cc:	b085      	sub	sp, #20
	int rc = onoff_sync_lock(&data->srv, &key);
    f0ce:	a903      	add	r1, sp, #12
    f0d0:	4620      	mov	r0, r4
    f0d2:	f7fd ff7e 	bl	cfd2 <onoff_sync_lock>
	if  ((cfg->options & OPTION_ALWAYS_ON) != 0) {
    f0d6:	7d29      	ldrb	r1, [r5, #20]
    f0d8:	f011 0101 	ands.w	r1, r1, #1
	int rc = onoff_sync_lock(&data->srv, &key);
    f0dc:	4603      	mov	r3, r0
	if  ((cfg->options & OPTION_ALWAYS_ON) != 0) {
    f0de:	d114      	bne.n	f10a <disable_sync+0x44>
	} else if (rc == 1) {
    f0e0:	2801      	cmp	r0, #1
    f0e2:	d10c      	bne.n	f0fe <disable_sync+0x38>
		rc = gpio_pin_set_dt(&cfg->enable, false);
    f0e4:	f105 000c 	add.w	r0, r5, #12
    f0e8:	f7ff ffd9 	bl	f09e <gpio_pin_set_dt>
    f0ec:	4603      	mov	r3, r0
	return onoff_sync_finalize(&data->srv, key, NULL, rc, false);
    f0ee:	2200      	movs	r2, #0
    f0f0:	9903      	ldr	r1, [sp, #12]
    f0f2:	9200      	str	r2, [sp, #0]
    f0f4:	4620      	mov	r0, r4
    f0f6:	f7fd ff77 	bl	cfe8 <onoff_sync_finalize>
}
    f0fa:	b005      	add	sp, #20
    f0fc:	bd30      	pop	{r4, r5, pc}
		rc = -EINVAL;
    f0fe:	2800      	cmp	r0, #0
    f100:	bf14      	ite	ne
    f102:	4603      	movne	r3, r0
    f104:	f06f 0315 	mvneq.w	r3, #21
    f108:	e7f1      	b.n	f0ee <disable_sync+0x28>
		rc = 0;
    f10a:	2300      	movs	r3, #0
    f10c:	e7ef      	b.n	f0ee <disable_sync+0x28>

0000f10e <enable_sync>:
{
    f10e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc = onoff_sync_lock(&data->srv, &key);
    f110:	6905      	ldr	r5, [r0, #16]
	const struct driver_config *cfg = dev->config;
    f112:	6846      	ldr	r6, [r0, #4]
{
    f114:	460c      	mov	r4, r1
	int rc = onoff_sync_lock(&data->srv, &key);
    f116:	4628      	mov	r0, r5
    f118:	a903      	add	r1, sp, #12
    f11a:	f7fd ff5a 	bl	cfd2 <onoff_sync_lock>
	if ((rc == 0)
    f11e:	4603      	mov	r3, r0
    f120:	b940      	cbnz	r0, f134 <enable_sync+0x26>
	    && ((cfg->options & OPTION_ALWAYS_ON) == 0)) {
    f122:	7d32      	ldrb	r2, [r6, #20]
    f124:	07d2      	lsls	r2, r2, #31
    f126:	d405      	bmi.n	f134 <enable_sync+0x26>
		rc = gpio_pin_set_dt(&cfg->enable, true);
    f128:	2101      	movs	r1, #1
    f12a:	f106 000c 	add.w	r0, r6, #12
    f12e:	f7ff ffb6 	bl	f09e <gpio_pin_set_dt>
    f132:	4603      	mov	r3, r0
	return onoff_sync_finalize(&data->srv, key, cli, rc, true);
    f134:	2201      	movs	r2, #1
    f136:	9200      	str	r2, [sp, #0]
    f138:	9903      	ldr	r1, [sp, #12]
    f13a:	4622      	mov	r2, r4
    f13c:	4628      	mov	r0, r5
    f13e:	f7fd ff53 	bl	cfe8 <onoff_sync_finalize>
}
    f142:	b004      	add	sp, #16
    f144:	bd70      	pop	{r4, r5, r6, pc}

0000f146 <disable_onoff>:
	return onoff_release(&data->mgr);
    f146:	6900      	ldr	r0, [r0, #16]
    f148:	3004      	adds	r0, #4
    f14a:	f7fd bf1d 	b.w	cf88 <onoff_release>

0000f14e <enable_onoff>:
	return onoff_request(&data->mgr, cli);
    f14e:	6900      	ldr	r0, [r0, #16]
    f150:	3004      	adds	r0, #4
    f152:	f7fd bed0 	b.w	cef6 <onoff_request>

0000f156 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    f156:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    f158:	ab0a      	add	r3, sp, #40	; 0x28
    f15a:	9305      	str	r3, [sp, #20]
    f15c:	9302      	str	r3, [sp, #8]
    f15e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f160:	9301      	str	r3, [sp, #4]
    f162:	2300      	movs	r3, #0
    f164:	9300      	str	r3, [sp, #0]
    f166:	4618      	mov	r0, r3
    f168:	f7f2 fd6c 	bl	1c44 <z_impl_z_log_msg2_runtime_vcreate>
}
    f16c:	b007      	add	sp, #28
    f16e:	f85d fb04 	ldr.w	pc, [sp], #4

0000f172 <onoff_worker>:
{
    f172:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (data->task == WORK_TASK_ENABLE) {
    f176:	f890 1034 	ldrb.w	r1, [r0, #52]	; 0x34
	const struct driver_config *cfg = data->dev->config;
    f17a:	f850 3c20 	ldr.w	r3, [r0, #-32]
	onoff_notify_fn notify = data->notify;
    f17e:	6b07      	ldr	r7, [r0, #48]	; 0x30
	const struct driver_config *cfg = data->dev->config;
    f180:	685d      	ldr	r5, [r3, #4]
	if (data->task == WORK_TASK_ENABLE) {
    f182:	2901      	cmp	r1, #1
{
    f184:	4604      	mov	r4, r0
	struct driver_data_onoff *data
    f186:	f1a0 0620 	sub.w	r6, r0, #32
	if (data->task == WORK_TASK_ENABLE) {
    f18a:	d10f      	bne.n	f1ac <onoff_worker+0x3a>
		rc = gpio_pin_set_dt(&cfg->enable, true);
    f18c:	f105 000c 	add.w	r0, r5, #12
    f190:	f7ff ff85 	bl	f09e <gpio_pin_set_dt>
		delay_us = cfg->startup_delay_us;
    f194:	686a      	ldr	r2, [r5, #4]
		rc = gpio_pin_set_dt(&cfg->enable, true);
    f196:	4603      	mov	r3, r0
	data->notify = NULL;
    f198:	2100      	movs	r1, #0
    f19a:	6321      	str	r1, [r4, #48]	; 0x30
	data->task = WORK_TASK_UNDEFINED;
    f19c:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
	finalize_transition(data, notify, delay_us, rc);
    f1a0:	4630      	mov	r0, r6
    f1a2:	4639      	mov	r1, r7
}
    f1a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	finalize_transition(data, notify, delay_us, rc);
    f1a8:	f7fa bb2a 	b.w	9800 <finalize_transition>
	} else if (data->task == WORK_TASK_DISABLE) {
    f1ac:	2902      	cmp	r1, #2
    f1ae:	d107      	bne.n	f1c0 <onoff_worker+0x4e>
		rc = gpio_pin_set_dt(&cfg->enable, false);
    f1b0:	2100      	movs	r1, #0
    f1b2:	f105 000c 	add.w	r0, r5, #12
    f1b6:	f7ff ff72 	bl	f09e <gpio_pin_set_dt>
		delay_us = cfg->off_on_delay_us;
    f1ba:	68aa      	ldr	r2, [r5, #8]
		rc = gpio_pin_set_dt(&cfg->enable, false);
    f1bc:	4603      	mov	r3, r0
		delay_us = cfg->off_on_delay_us;
    f1be:	e7eb      	b.n	f198 <onoff_worker+0x26>
	int rc = 0;
    f1c0:	2300      	movs	r3, #0
	uint32_t delay_us = 0;
    f1c2:	461a      	mov	r2, r3
    f1c4:	e7e8      	b.n	f198 <onoff_worker+0x26>

0000f1c6 <stop>:
{
    f1c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct driver_config *cfg = data->dev->config;
    f1ca:	f850 3c04 	ldr.w	r3, [r0, #-4]
{
    f1ce:	4604      	mov	r4, r0
	struct driver_data_onoff *data =
    f1d0:	1f06      	subs	r6, r0, #4
	const struct driver_config *cfg = data->dev->config;
    f1d2:	6858      	ldr	r0, [r3, #4]
{
    f1d4:	460d      	mov	r5, r1
	if ((cfg->options & OPTION_ALWAYS_ON) != 0) {
    f1d6:	7d01      	ldrb	r1, [r0, #20]
    f1d8:	f011 0101 	ands.w	r1, r1, #1
    f1dc:	d113      	bne.n	f206 <stop+0x40>
	uint32_t delay_us = cfg->off_on_delay_us;
    f1de:	6887      	ldr	r7, [r0, #8]
	rc = gpio_pin_set_dt(&cfg->enable, false);
    f1e0:	300c      	adds	r0, #12
    f1e2:	f7ff ff5c 	bl	f09e <gpio_pin_set_dt>
	if (rc == -EWOULDBLOCK) {
    f1e6:	f110 0f0b 	cmn.w	r0, #11
	rc = gpio_pin_set_dt(&cfg->enable, false);
    f1ea:	4603      	mov	r3, r0
	if (rc == -EWOULDBLOCK) {
    f1ec:	d10d      	bne.n	f20a <stop+0x44>
		data->task = WORK_TASK_DISABLE;
    f1ee:	2302      	movs	r3, #2
    f1f0:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
		data->notify = notify;
    f1f4:	64e5      	str	r5, [r4, #76]	; 0x4c
		k_work_schedule(&data->dwork, K_NO_WAIT);
    f1f6:	f104 001c 	add.w	r0, r4, #28
    f1fa:	2200      	movs	r2, #0
}
    f1fc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		k_work_schedule(&data->dwork, K_NO_WAIT);
    f200:	2300      	movs	r3, #0
    f202:	f7fc bf35 	b.w	c070 <k_work_schedule>
	int rc = 0;
    f206:	2300      	movs	r3, #0
		delay_us = 0;
    f208:	461f      	mov	r7, r3
	finalize_transition(data, notify, delay_us, rc);
    f20a:	463a      	mov	r2, r7
    f20c:	4629      	mov	r1, r5
    f20e:	4630      	mov	r0, r6
}
    f210:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	finalize_transition(data, notify, delay_us, rc);
    f214:	f7fa baf4 	b.w	9800 <finalize_transition>

0000f218 <start>:
{
    f218:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct driver_config *cfg = data->dev->config;
    f21c:	f850 3c04 	ldr.w	r3, [r0, #-4]
{
    f220:	4604      	mov	r4, r0
	struct driver_data_onoff *data =
    f222:	1f07      	subs	r7, r0, #4
	const struct driver_config *cfg = data->dev->config;
    f224:	6858      	ldr	r0, [r3, #4]
	if ((cfg->options & OPTION_ALWAYS_ON) != 0) {
    f226:	7d03      	ldrb	r3, [r0, #20]
    f228:	07db      	lsls	r3, r3, #31
{
    f22a:	460d      	mov	r5, r1
	if ((cfg->options & OPTION_ALWAYS_ON) != 0) {
    f22c:	d414      	bmi.n	f258 <start+0x40>
	uint32_t delay_us = cfg->startup_delay_us;
    f22e:	6846      	ldr	r6, [r0, #4]
	rc = gpio_pin_set_dt(&cfg->enable, true);
    f230:	2101      	movs	r1, #1
    f232:	300c      	adds	r0, #12
    f234:	f7ff ff33 	bl	f09e <gpio_pin_set_dt>
	if (rc == -EWOULDBLOCK) {
    f238:	f110 0f0b 	cmn.w	r0, #11
	rc = gpio_pin_set_dt(&cfg->enable, true);
    f23c:	4603      	mov	r3, r0
	if (rc == -EWOULDBLOCK) {
    f23e:	d10d      	bne.n	f25c <start+0x44>
		data->task = WORK_TASK_ENABLE;
    f240:	2301      	movs	r3, #1
    f242:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
		data->notify = notify;
    f246:	64e5      	str	r5, [r4, #76]	; 0x4c
		k_work_schedule(&data->dwork, K_NO_WAIT);
    f248:	f104 001c 	add.w	r0, r4, #28
    f24c:	2200      	movs	r2, #0
}
    f24e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		k_work_schedule(&data->dwork, K_NO_WAIT);
    f252:	2300      	movs	r3, #0
    f254:	f7fc bf0c 	b.w	c070 <k_work_schedule>
	int rc = 0;
    f258:	2300      	movs	r3, #0
		delay_us = 0;
    f25a:	461e      	mov	r6, r3
	finalize_transition(data, notify, delay_us, rc);
    f25c:	4632      	mov	r2, r6
    f25e:	4629      	mov	r1, r5
    f260:	4638      	mov	r0, r7
}
    f262:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	finalize_transition(data, notify, delay_us, rc);
    f266:	f7fa bacb 	b.w	9800 <finalize_transition>

0000f26a <uarte_nrfx_config_get>:
	*cfg = data->uart_config;
    f26a:	6902      	ldr	r2, [r0, #16]
{
    f26c:	460b      	mov	r3, r1
	*cfg = data->uart_config;
    f26e:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
    f272:	e883 0003 	stmia.w	r3, {r0, r1}
}
    f276:	2000      	movs	r0, #0
    f278:	4770      	bx	lr

0000f27a <uarte_nrfx_err_check>:
	return config->uarte_regs;
    f27a:	6843      	ldr	r3, [r0, #4]
    f27c:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    f27e:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    f282:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
    f286:	4770      	bx	lr

0000f288 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
    f288:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = dev->data;
    f28a:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
    f28c:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f28e:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    f292:	b148      	cbz	r0, f2a8 <uarte_nrfx_poll_in+0x20>
	*c = data->rx_data;
    f294:	7c52      	ldrb	r2, [r2, #17]
    f296:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f298:	2000      	movs	r0, #0
    f29a:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    f29e:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f2a2:	2201      	movs	r2, #1
    f2a4:	601a      	str	r2, [r3, #0]
	return 0;
    f2a6:	4770      	bx	lr
		return -1;
    f2a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    f2ac:	4770      	bx	lr

0000f2ae <is_tx_ready.isra.0>:
	return config->uarte_regs;
    f2ae:	6802      	ldr	r2, [r0, #0]
static bool is_tx_ready(const struct device *dev)
    f2b0:	4603      	mov	r3, r0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f2b2:	f8d2 0158 	ldr.w	r0, [r2, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
    f2b6:	b940      	cbnz	r0, f2ca <is_tx_ready.isra.0+0x1c>
	bool ppi_endtx = config->flags & UARTE_CFG_FLAG_PPI_ENDTX;
    f2b8:	685b      	ldr	r3, [r3, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
    f2ba:	079b      	lsls	r3, r3, #30
    f2bc:	d406      	bmi.n	f2cc <is_tx_ready.isra.0+0x1e>
    f2be:	f8d2 0120 	ldr.w	r0, [r2, #288]	; 0x120
    f2c2:	3800      	subs	r0, #0
    f2c4:	bf18      	it	ne
    f2c6:	2001      	movne	r0, #1
    f2c8:	4770      	bx	lr
    f2ca:	2001      	movs	r0, #1
}
    f2cc:	4770      	bx	lr

0000f2ce <uarte_nrfx_isr_int>:
	const struct uarte_nrfx_config *config = dev->config;
    f2ce:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
    f2d0:	6813      	ldr	r3, [r2, #0]
    return p_reg->INTENSET & mask;
    f2d2:	f8d3 1304 	ldr.w	r1, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
    f2d6:	05c9      	lsls	r1, r1, #23
    f2d8:	d518      	bpl.n	f30c <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f2da:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    f2de:	b1a9      	cbz	r1, f30c <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
    f2e0:	f04f 0020 	mov.w	r0, #32
    f2e4:	f3ef 8111 	mrs	r1, BASEPRI
    f2e8:	f380 8812 	msr	BASEPRI_MAX, r0
    f2ec:	f3bf 8f6f 	isb	sy
    f2f0:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
    f2f4:	b130      	cbz	r0, f304 <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    f2f6:	2000      	movs	r0, #0
    f2f8:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
    f2fc:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    f300:	2001      	movs	r0, #1
    f302:	60d8      	str	r0, [r3, #12]
	__asm__ volatile(
    f304:	f381 8811 	msr	BASEPRI, r1
    f308:	f3bf 8f6f 	isb	sy
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
    f30c:	6852      	ldr	r2, [r2, #4]
    f30e:	06d2      	lsls	r2, r2, #27
    f310:	d515      	bpl.n	f33e <uarte_nrfx_isr_int+0x70>
	__asm__ volatile(
    f312:	f04f 0120 	mov.w	r1, #32
    f316:	f3ef 8211 	mrs	r2, BASEPRI
    f31a:	f381 8812 	msr	BASEPRI_MAX, r1
    f31e:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f322:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
    f326:	b111      	cbz	r1, f32e <uarte_nrfx_isr_int+0x60>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    f328:	2100      	movs	r1, #0
    f32a:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
    f32e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    f332:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
    f336:	f382 8811 	msr	BASEPRI, r2
    f33a:	f3bf 8f6f 	isb	sy
}
    f33e:	4770      	bx	lr

0000f340 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
    f340:	4770      	bx	lr

0000f342 <sys_clock_cycle_get_32>:
{
    f342:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
    f344:	f7fa fe5e 	bl	a004 <z_nrf_rtc_timer_read>
}
    f348:	bd08      	pop	{r3, pc}

0000f34a <nrf52_errata_108>:
            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    f34a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f34e:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
    f352:	1c42      	adds	r2, r0, #1
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    f354:	bf04      	itt	eq
    f356:	f04f 4370 	moveq.w	r3, #4026531840	; 0xf0000000
    f35a:	f893 0fe0 	ldrbeq.w	r0, [r3, #4064]	; 0xfe0
}
    f35e:	1f83      	subs	r3, r0, #6
    f360:	4258      	negs	r0, r3
    f362:	4158      	adcs	r0, r3
    f364:	4770      	bx	lr

0000f366 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
    f366:	4700      	bx	r0

0000f368 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
    f368:	f000 bc17 	b.w	fb9a <z_impl_k_busy_wait>

0000f36c <nrfx_clock_enable>:
{
    f36c:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    f36e:	2000      	movs	r0, #0
    f370:	f7f2 ff3c 	bl	21ec <arch_irq_is_enabled>
    f374:	b918      	cbnz	r0, f37e <nrfx_clock_enable+0x12>
}
    f376:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    f37a:	f7f2 bf13 	b.w	21a4 <arch_irq_enable>
    f37e:	bd08      	pop	{r3, pc}

0000f380 <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
    f380:	f000 001f 	and.w	r0, r0, #31
    f384:	0080      	lsls	r0, r0, #2
    f386:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
    uint32_t cnf = reg->PIN_CNF[pin_number];
    f38a:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
    cnf &= ~to_update;
    f38e:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    f392:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
    f396:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
}
    f39a:	4770      	bx	lr

0000f39c <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
    f39c:	7b0a      	ldrb	r2, [r1, #12]
{
    f39e:	4603      	mov	r3, r0
    switch (p_cb->xfer_desc.type)
    f3a0:	2a03      	cmp	r2, #3
    f3a2:	d829      	bhi.n	f3f8 <xfer_completeness_check+0x5c>
    f3a4:	e8df f002 	tbb	[pc, r2]
    f3a8:	02192521 	.word	0x02192521
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
    f3ac:	688a      	ldr	r2, [r1, #8]
    f3ae:	0350      	lsls	r0, r2, #13
    f3b0:	d504      	bpl.n	f3bc <xfer_completeness_check+0x20>
    return p_reg->TXD.AMOUNT;
    f3b2:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
    f3b6:	6908      	ldr	r0, [r1, #16]
    f3b8:	4290      	cmp	r0, r2
    f3ba:	d107      	bne.n	f3cc <xfer_completeness_check+0x30>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
    f3bc:	688a      	ldr	r2, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
    f3be:	0352      	lsls	r2, r2, #13
    f3c0:	d41a      	bmi.n	f3f8 <xfer_completeness_check+0x5c>
    f3c2:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
    f3c6:	6949      	ldr	r1, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
    f3c8:	4291      	cmp	r1, r2
    f3ca:	d015      	beq.n	f3f8 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
    f3cc:	2000      	movs	r0, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
    f3ce:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
    f3d0:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
    f3d4:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
    f3d8:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
    f3da:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
    f3de:	6908      	ldr	r0, [r1, #16]
    f3e0:	4290      	cmp	r0, r2
    f3e2:	d1f3      	bne.n	f3cc <xfer_completeness_check+0x30>
    return p_reg->RXD.AMOUNT;
    f3e4:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
    f3e8:	e7ed      	b.n	f3c6 <xfer_completeness_check+0x2a>
    return p_reg->TXD.AMOUNT;
    f3ea:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
    f3ee:	6909      	ldr	r1, [r1, #16]
    f3f0:	e7ea      	b.n	f3c8 <xfer_completeness_check+0x2c>
    return p_reg->RXD.AMOUNT;
    f3f2:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
    f3f6:	e7fa      	b.n	f3ee <xfer_completeness_check+0x52>
    bool transfer_complete = true;
    f3f8:	2001      	movs	r0, #1
}
    f3fa:	4770      	bx	lr

0000f3fc <_GetAvailWriteSpace>:
  RdOff = pRing->RdOff;
    f3fc:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
    f3fe:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
    f400:	4293      	cmp	r3, r2
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
    f402:	bf9c      	itt	ls
    f404:	6880      	ldrls	r0, [r0, #8]
    f406:	181b      	addls	r3, r3, r0
    r = RdOff - WrOff - 1u;
    f408:	3b01      	subs	r3, #1
    f40a:	1a98      	subs	r0, r3, r2
}
    f40c:	4770      	bx	lr

0000f40e <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    f40e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  Rem = pRing->SizeOfBuffer - WrOff;
    f412:	e9d0 9402 	ldrd	r9, r4, [r0, #8]
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    f416:	4605      	mov	r5, r0
  Rem = pRing->SizeOfBuffer - WrOff;
    f418:	eba9 0804 	sub.w	r8, r9, r4
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    f41c:	6840      	ldr	r0, [r0, #4]
  if (Rem > NumBytes) {
    f41e:	4590      	cmp	r8, r2
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    f420:	4420      	add	r0, r4
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    f422:	460f      	mov	r7, r1
    pRing->WrOff = WrOff + NumBytes;
    f424:	4414      	add	r4, r2
  if (Rem > NumBytes) {
    f426:	d904      	bls.n	f432 <_WriteNoCheck+0x24>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    f428:	f7fe faed 	bl	da06 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
    f42c:	60ec      	str	r4, [r5, #12]
}
    f42e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
    f432:	4642      	mov	r2, r8
    NumBytesAtOnce = NumBytes - Rem;
    f434:	eba4 0409 	sub.w	r4, r4, r9
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
    f438:	f7fe fae5 	bl	da06 <memcpy>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    f43c:	6868      	ldr	r0, [r5, #4]
    f43e:	4622      	mov	r2, r4
    f440:	eb07 0108 	add.w	r1, r7, r8
    f444:	e7f0      	b.n	f428 <_WriteNoCheck+0x1a>

0000f446 <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    f446:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  WrOff = pRing->WrOff;
    f44a:	68c5      	ldr	r5, [r0, #12]
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    f44c:	4606      	mov	r6, r0
    f44e:	4689      	mov	r9, r1
    f450:	4617      	mov	r7, r2
  NumBytesWritten = 0u;
    f452:	f04f 0800 	mov.w	r8, #0
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
    f456:	6934      	ldr	r4, [r6, #16]
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    f458:	68b3      	ldr	r3, [r6, #8]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    f45a:	6870      	ldr	r0, [r6, #4]
    if (RdOff > WrOff) {
    f45c:	42a5      	cmp	r5, r4
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    f45e:	bf28      	it	cs
    f460:	18e4      	addcs	r4, r4, r3
    f462:	3c01      	subs	r4, #1
    f464:	1b62      	subs	r2, r4, r5
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
    f466:	1b5c      	subs	r4, r3, r5
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    f468:	42bc      	cmp	r4, r7
    f46a:	bf28      	it	cs
    f46c:	463c      	movcs	r4, r7
    f46e:	4294      	cmp	r4, r2
    f470:	bf28      	it	cs
    f472:	4614      	movcs	r4, r2
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
    f474:	4649      	mov	r1, r9
    f476:	4428      	add	r0, r5
    f478:	4622      	mov	r2, r4
    f47a:	f7fe fac4 	bl	da06 <memcpy>
    if (WrOff == pRing->SizeOfBuffer) {
    f47e:	68b3      	ldr	r3, [r6, #8]
    WrOff           += NumBytesToWrite;
    f480:	4425      	add	r5, r4
      WrOff = 0u;
    f482:	42ab      	cmp	r3, r5
    f484:	bf08      	it	eq
    f486:	2500      	moveq	r5, #0
  } while (NumBytes);
    f488:	1b3f      	subs	r7, r7, r4
    NumBytesWritten += NumBytesToWrite;
    f48a:	44a0      	add	r8, r4
    pBuffer         += NumBytesToWrite;
    f48c:	44a1      	add	r9, r4
    pRing->WrOff = WrOff;
    f48e:	60f5      	str	r5, [r6, #12]
  } while (NumBytes);
    f490:	d1e1      	bne.n	f456 <_WriteBlocking+0x10>
}
    f492:	4640      	mov	r0, r8
    f494:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000f498 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
    f498:	f7fc b814 	b.w	b4c4 <_DoInit>

0000f49c <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
    f49c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
    f49e:	f7ff fffb 	bl	f498 <SEGGER_RTT_Init>

	return 0;
}
    f4a2:	2000      	movs	r0, #0
    f4a4:	bd08      	pop	{r3, pc}

0000f4a6 <z_device_state_init>:
}
    f4a6:	4770      	bx	lr

0000f4a8 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    f4a8:	b138      	cbz	r0, f4ba <z_device_is_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    f4aa:	68c3      	ldr	r3, [r0, #12]
    f4ac:	8818      	ldrh	r0, [r3, #0]
    f4ae:	f3c0 0008 	ubfx	r0, r0, #0, #9
    f4b2:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
    f4b6:	4258      	negs	r0, r3
    f4b8:	4158      	adcs	r0, r3
}
    f4ba:	4770      	bx	lr

0000f4bc <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    f4bc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    f4be:	ab0a      	add	r3, sp, #40	; 0x28
    f4c0:	9305      	str	r3, [sp, #20]
    f4c2:	9302      	str	r3, [sp, #8]
    f4c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f4c6:	9301      	str	r3, [sp, #4]
    f4c8:	2300      	movs	r3, #0
    f4ca:	9300      	str	r3, [sp, #0]
    f4cc:	2201      	movs	r2, #1
    f4ce:	4618      	mov	r0, r3
    f4d0:	f7f2 fbb8 	bl	1c44 <z_impl_z_log_msg2_runtime_vcreate>
}
    f4d4:	b007      	add	sp, #28
    f4d6:	f85d fb04 	ldr.w	pc, [sp], #4

0000f4da <arch_system_halt>:
	__asm__ volatile(
    f4da:	f04f 0220 	mov.w	r2, #32
    f4de:	f3ef 8311 	mrs	r3, BASEPRI
    f4e2:	f382 8812 	msr	BASEPRI_MAX, r2
    f4e6:	f3bf 8f6f 	isb	sy
	for (;;) {
    f4ea:	e7fe      	b.n	f4ea <arch_system_halt+0x10>

0000f4ec <k_heap_init>:
{
    f4ec:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
    f4ee:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
    f4f2:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
    f4f6:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
    f4f8:	f7fd bf2e 	b.w	d358 <sys_heap_init>

0000f4fc <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
    f4fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f500:	b085      	sub	sp, #20
    f502:	4606      	mov	r6, r0
    f504:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    f506:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
{
    f50a:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    f50c:	f000 fb49 	bl	fba2 <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    f510:	f106 0a14 	add.w	sl, r6, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    f514:	4605      	mov	r5, r0
    f516:	460f      	mov	r7, r1
    f518:	f04f 0320 	mov.w	r3, #32
    f51c:	f3ef 8411 	mrs	r4, BASEPRI
    f520:	f383 8812 	msr	BASEPRI_MAX, r3
    f524:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    f528:	f106 0b0c 	add.w	fp, r6, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
    f52c:	464a      	mov	r2, r9
    f52e:	4641      	mov	r1, r8
    f530:	4630      	mov	r0, r6
    f532:	f7fd fea9 	bl	d288 <sys_heap_aligned_alloc>
    f536:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
    f538:	f7fd fa7a 	bl	ca30 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
    f53c:	9b03      	ldr	r3, [sp, #12]
    f53e:	b13b      	cbz	r3, f550 <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
    f540:	f384 8811 	msr	BASEPRI, r4
    f544:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
    f548:	4618      	mov	r0, r3
    f54a:	b005      	add	sp, #20
    f54c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
    f550:	1a28      	subs	r0, r5, r0
    f552:	eb67 0101 	sbc.w	r1, r7, r1
    f556:	2801      	cmp	r0, #1
    f558:	f171 0200 	sbcs.w	r2, r1, #0
    f55c:	dbf0      	blt.n	f540 <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    f55e:	e9cd 0100 	strd	r0, r1, [sp]
    f562:	465a      	mov	r2, fp
    f564:	4621      	mov	r1, r4
    f566:	4650      	mov	r0, sl
    f568:	f7fc ff54 	bl	c414 <z_pend_curr>
	__asm__ volatile(
    f56c:	f04f 0320 	mov.w	r3, #32
    f570:	f3ef 8411 	mrs	r4, BASEPRI
    f574:	f383 8812 	msr	BASEPRI_MAX, r3
    f578:	f3bf 8f6f 	isb	sy
    f57c:	e7d6      	b.n	f52c <k_heap_aligned_alloc+0x30>

0000f57e <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
    f57e:	b538      	push	{r3, r4, r5, lr}
    f580:	4604      	mov	r4, r0
    f582:	f04f 0320 	mov.w	r3, #32
    f586:	f3ef 8511 	mrs	r5, BASEPRI
    f58a:	f383 8812 	msr	BASEPRI_MAX, r3
    f58e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
    f592:	f7fd fe41 	bl	d218 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
    f596:	f104 000c 	add.w	r0, r4, #12
    f59a:	f000 fa8b 	bl	fab4 <z_unpend_all>
    f59e:	b130      	cbz	r0, f5ae <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
    f5a0:	4629      	mov	r1, r5
    f5a2:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
    f5a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
    f5aa:	f7fc bde1 	b.w	c170 <z_reschedule>
	__asm__ volatile(
    f5ae:	f385 8811 	msr	BASEPRI, r5
    f5b2:	f3bf 8f6f 	isb	sy
}
    f5b6:	bd38      	pop	{r3, r4, r5, pc}

0000f5b8 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    f5b8:	f3ef 8005 	mrs	r0, IPSR
}
    f5bc:	3800      	subs	r0, #0
    f5be:	bf18      	it	ne
    f5c0:	2001      	movne	r0, #1
    f5c2:	4770      	bx	lr

0000f5c4 <z_impl_k_thread_name_set>:
}
    f5c4:	f06f 0057 	mvn.w	r0, #87	; 0x57
    f5c8:	4770      	bx	lr

0000f5ca <k_thread_name_get>:
}
    f5ca:	2000      	movs	r0, #0
    f5cc:	4770      	bx	lr

0000f5ce <z_impl_k_thread_start>:
	z_sched_start(thread);
    f5ce:	f7fc bec5 	b.w	c35c <z_sched_start>

0000f5d2 <z_pm_save_idle_exit>:
{
    f5d2:	b508      	push	{r3, lr}
	pm_system_resume();
    f5d4:	f7f2 fc46 	bl	1e64 <pm_system_resume>
}
    f5d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
    f5dc:	f7ff beb0 	b.w	f340 <sys_clock_idle_exit>

0000f5e0 <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
    f5e0:	f990 300e 	ldrsb.w	r3, [r0, #14]
    f5e4:	428b      	cmp	r3, r1
    f5e6:	d001      	beq.n	f5ec <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
    f5e8:	f7fc bf28 	b.w	c43c <z_set_prio>
}
    f5ec:	2000      	movs	r0, #0
    f5ee:	4770      	bx	lr

0000f5f0 <queue_insert>:
{
    f5f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f5f4:	4699      	mov	r9, r3
    f5f6:	4604      	mov	r4, r0
    f5f8:	f89d 3020 	ldrb.w	r3, [sp, #32]
    f5fc:	460d      	mov	r5, r1
    f5fe:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    f600:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
    f604:	f04f 0220 	mov.w	r2, #32
    f608:	f3ef 8711 	mrs	r7, BASEPRI
    f60c:	f382 8812 	msr	BASEPRI_MAX, r2
    f610:	f3bf 8f6f 	isb	sy
	if (is_append) {
    f614:	b103      	cbz	r3, f618 <queue_insert+0x28>
	return list->tail;
    f616:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
    f618:	4630      	mov	r0, r6
    f61a:	f000 fa33 	bl	fa84 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
    f61e:	b158      	cbz	r0, f638 <queue_insert+0x48>
    f620:	2400      	movs	r4, #0
    f622:	67c4      	str	r4, [r0, #124]	; 0x7c
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    f624:	f8c0 8014 	str.w	r8, [r0, #20]
	z_ready_thread(thread);
    f628:	f000 f9bb 	bl	f9a2 <z_ready_thread>
	z_reschedule(&queue->lock, key);
    f62c:	4630      	mov	r0, r6
    f62e:	4639      	mov	r1, r7
    f630:	f7fc fd9e 	bl	c170 <z_reschedule>
	return 0;
    f634:	2000      	movs	r0, #0
    f636:	e00c      	b.n	f652 <queue_insert+0x62>
	if (alloc) {
    f638:	f1b9 0f00 	cmp.w	r9, #0
    f63c:	d01b      	beq.n	f676 <queue_insert+0x86>
	return z_thread_aligned_alloc(0, size);
    f63e:	2108      	movs	r1, #8
    f640:	f7fd fb2a 	bl	cc98 <z_thread_aligned_alloc>
		if (anode == NULL) {
    f644:	b938      	cbnz	r0, f656 <queue_insert+0x66>
	__asm__ volatile(
    f646:	f387 8811 	msr	BASEPRI, r7
    f64a:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
    f64e:	f06f 000b 	mvn.w	r0, #11
}
    f652:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
    f656:	2301      	movs	r3, #1
		anode->data = data;
    f658:	f8c0 8004 	str.w	r8, [r0, #4]
    f65c:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    f65e:	6803      	ldr	r3, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
    f660:	f003 0203 	and.w	r2, r3, #3
Z_GENLIST_INSERT(sflist, sfnode)
    f664:	b95d      	cbnz	r5, f67e <queue_insert+0x8e>
	parent->next_and_flags = cur_flags | (unative_t)child;
    f666:	6823      	ldr	r3, [r4, #0]
    f668:	4313      	orrs	r3, r2
    f66a:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
    f66c:	6863      	ldr	r3, [r4, #4]
	list->head = node;
    f66e:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
    f670:	b973      	cbnz	r3, f690 <queue_insert+0xa0>
	list->tail = node;
    f672:	6060      	str	r0, [r4, #4]
}
    f674:	e00c      	b.n	f690 <queue_insert+0xa0>
	node->next_and_flags = flags;
    f676:	f8c8 9000 	str.w	r9, [r8]
}
    f67a:	4640      	mov	r0, r8
    f67c:	e7ef      	b.n	f65e <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    f67e:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
    f680:	f033 0303 	bics.w	r3, r3, #3
    f684:	d110      	bne.n	f6a8 <queue_insert+0xb8>
	parent->next_and_flags = cur_flags | (unative_t)child;
    f686:	6002      	str	r2, [r0, #0]
	return list->tail;
    f688:	6862      	ldr	r2, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
    f68a:	b93a      	cbnz	r2, f69c <queue_insert+0xac>
	list->head = node;
    f68c:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
    f690:	2104      	movs	r1, #4
    f692:	f104 0010 	add.w	r0, r4, #16
    f696:	f000 fc07 	bl	fea8 <z_handle_obj_poll_events>
    f69a:	e7c7      	b.n	f62c <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    f69c:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
    f69e:	f003 0303 	and.w	r3, r3, #3
    f6a2:	4303      	orrs	r3, r0
    f6a4:	6013      	str	r3, [r2, #0]
    f6a6:	e7e4      	b.n	f672 <queue_insert+0x82>
    f6a8:	4313      	orrs	r3, r2
    f6aa:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    f6ac:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
    f6ae:	f003 0303 	and.w	r3, r3, #3
    f6b2:	4303      	orrs	r3, r0
    f6b4:	602b      	str	r3, [r5, #0]
}
    f6b6:	e7eb      	b.n	f690 <queue_insert+0xa0>

0000f6b8 <z_queue_node_peek>:
{
    f6b8:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
    f6ba:	4604      	mov	r4, r0
    f6bc:	b130      	cbz	r0, f6cc <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    f6be:	6802      	ldr	r2, [r0, #0]
    f6c0:	0793      	lsls	r3, r2, #30
    f6c2:	d003      	beq.n	f6cc <z_queue_node_peek+0x14>
		ret = anode->data;
    f6c4:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
    f6c6:	b109      	cbz	r1, f6cc <z_queue_node_peek+0x14>
			k_free(anode);
    f6c8:	f000 fbfc 	bl	fec4 <k_free>
}
    f6cc:	4620      	mov	r0, r4
    f6ce:	bd10      	pop	{r4, pc}

0000f6d0 <k_queue_append>:
{
    f6d0:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
    f6d2:	2301      	movs	r3, #1
    f6d4:	9300      	str	r3, [sp, #0]
    f6d6:	2300      	movs	r3, #0
{
    f6d8:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
    f6da:	4619      	mov	r1, r3
    f6dc:	f7ff ff88 	bl	f5f0 <queue_insert>
}
    f6e0:	b003      	add	sp, #12
    f6e2:	f85d fb04 	ldr.w	pc, [sp], #4

0000f6e6 <k_queue_prepend>:
{
    f6e6:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, false);
    f6e8:	2300      	movs	r3, #0
{
    f6ea:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
    f6ec:	9300      	str	r3, [sp, #0]
    f6ee:	4619      	mov	r1, r3
    f6f0:	f7ff ff7e 	bl	f5f0 <queue_insert>
}
    f6f4:	b003      	add	sp, #12
    f6f6:	f85d fb04 	ldr.w	pc, [sp], #4

0000f6fa <k_queue_append_list>:
{
    f6fa:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f6fe:	4605      	mov	r5, r0
    f700:	4616      	mov	r6, r2
	CHECKIF(head == NULL || tail == NULL) {
    f702:	460c      	mov	r4, r1
    f704:	b391      	cbz	r1, f76c <k_queue_append_list+0x72>
    f706:	b38a      	cbz	r2, f76c <k_queue_append_list+0x72>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    f708:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
    f70c:	f04f 0320 	mov.w	r3, #32
    f710:	f3ef 8811 	mrs	r8, BASEPRI
    f714:	f383 8812 	msr	BASEPRI_MAX, r3
    f718:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
    f71c:	4638      	mov	r0, r7
    f71e:	f000 f9b1 	bl	fa84 <z_unpend_first_thread>
    f722:	f04f 0900 	mov.w	r9, #0
	while ((head != NULL) && (thread != NULL)) {
    f726:	b920      	cbnz	r0, f732 <k_queue_append_list+0x38>
	return list->tail;
    f728:	686a      	ldr	r2, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
    f72a:	b9ca      	cbnz	r2, f760 <k_queue_append_list+0x66>
	list->head = node;
    f72c:	602c      	str	r4, [r5, #0]
	list->tail = node;
    f72e:	606e      	str	r6, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
    f730:	e00a      	b.n	f748 <k_queue_append_list+0x4e>
	thread->base.swap_data = data;
    f732:	6144      	str	r4, [r0, #20]
    f734:	f8c0 907c 	str.w	r9, [r0, #124]	; 0x7c
	z_ready_thread(thread);
    f738:	f000 f933 	bl	f9a2 <z_ready_thread>
		head = *(void **)head;
    f73c:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
    f73e:	4638      	mov	r0, r7
    f740:	f000 f9a0 	bl	fa84 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
    f744:	2c00      	cmp	r4, #0
    f746:	d1ee      	bne.n	f726 <k_queue_append_list+0x2c>
	z_handle_obj_poll_events(&queue->poll_events, state);
    f748:	2104      	movs	r1, #4
    f74a:	f105 0010 	add.w	r0, r5, #16
    f74e:	f000 fbab 	bl	fea8 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
    f752:	4638      	mov	r0, r7
    f754:	4641      	mov	r1, r8
    f756:	f7fc fd0b 	bl	c170 <z_reschedule>
	return 0;
    f75a:	2000      	movs	r0, #0
}
    f75c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    f760:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
    f762:	f003 0303 	and.w	r3, r3, #3
    f766:	431c      	orrs	r4, r3
    f768:	6014      	str	r4, [r2, #0]
}
    f76a:	e7e0      	b.n	f72e <k_queue_append_list+0x34>
		return -EINVAL;
    f76c:	f06f 0015 	mvn.w	r0, #21
    f770:	e7f4      	b.n	f75c <k_queue_append_list+0x62>

0000f772 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
    f772:	b15a      	cbz	r2, f78c <z_impl_k_sem_init+0x1a>
    f774:	428a      	cmp	r2, r1
    f776:	d309      	bcc.n	f78c <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
    f778:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
    f77c:	e9c0 1202 	strd	r1, r2, [r0, #8]
    f780:	e9c0 0000 	strd	r0, r0, [r0]
    f784:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
    f788:	2000      	movs	r0, #0
    f78a:	4770      	bx	lr
		return -EINVAL;
    f78c:	f06f 0015 	mvn.w	r0, #21
}
    f790:	4770      	bx	lr

0000f792 <flag_test_and_clear>:
	return (*flagp & BIT(bit)) != 0U;
    f792:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
    f794:	2301      	movs	r3, #1
    f796:	408b      	lsls	r3, r1
    f798:	ea22 0303 	bic.w	r3, r2, r3
    f79c:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
    f79e:	fa22 f001 	lsr.w	r0, r2, r1
}
    f7a2:	f000 0001 	and.w	r0, r0, #1
    f7a6:	4770      	bx	lr

0000f7a8 <unschedule_locked>:
{
    f7a8:	b538      	push	{r3, r4, r5, lr}
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
    f7aa:	2103      	movs	r1, #3
{
    f7ac:	4605      	mov	r5, r0
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
    f7ae:	300c      	adds	r0, #12
    f7b0:	f7ff ffef 	bl	f792 <flag_test_and_clear>
    f7b4:	4604      	mov	r4, r0
    f7b6:	b118      	cbz	r0, f7c0 <unschedule_locked+0x18>
		z_abort_timeout(&dwork->timeout);
    f7b8:	f105 0010 	add.w	r0, r5, #16
    f7bc:	f000 f9a7 	bl	fb0e <z_abort_timeout>
}
    f7c0:	4620      	mov	r0, r4
    f7c2:	bd38      	pop	{r3, r4, r5, pc}

0000f7c4 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
    f7c4:	b120      	cbz	r0, f7d0 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    f7c6:	2200      	movs	r2, #0
    f7c8:	4611      	mov	r1, r2
    f7ca:	3088      	adds	r0, #136	; 0x88
    f7cc:	f000 b982 	b.w	fad4 <z_sched_wake>
}
    f7d0:	4770      	bx	lr

0000f7d2 <cancel_async_locked>:
	return (*flagp & BIT(bit)) != 0U;
    f7d2:	68c3      	ldr	r3, [r0, #12]
{
    f7d4:	b570      	push	{r4, r5, r6, lr}
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    f7d6:	f3c3 0540 	ubfx	r5, r3, #1, #1
    f7da:	079b      	lsls	r3, r3, #30
{
    f7dc:	4604      	mov	r4, r0
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    f7de:	d416      	bmi.n	f80e <cancel_async_locked+0x3c>
		queue_remove_locked(work->queue, work);
    f7e0:	6886      	ldr	r6, [r0, #8]
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
    f7e2:	2102      	movs	r1, #2
    f7e4:	300c      	adds	r0, #12
    f7e6:	f7ff ffd4 	bl	f792 <flag_test_and_clear>
    f7ea:	b180      	cbz	r0, f80e <cancel_async_locked+0x3c>
	return list->head;
    f7ec:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    f7f0:	b16a      	cbz	r2, f80e <cancel_async_locked+0x3c>
    f7f2:	4294      	cmp	r4, r2
    f7f4:	d11b      	bne.n	f82e <cancel_async_locked+0x5c>
	return node->next;
    f7f6:	6822      	ldr	r2, [r4, #0]
	return list->tail;
    f7f8:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
Z_GENLIST_REMOVE(slist, snode)
    f7fc:	b98d      	cbnz	r5, f822 <cancel_async_locked+0x50>
    f7fe:	428c      	cmp	r4, r1
	list->head = node;
    f800:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
Z_GENLIST_REMOVE(slist, snode)
    f804:	d101      	bne.n	f80a <cancel_async_locked+0x38>
	list->tail = node;
    f806:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
	parent->next = child;
    f80a:	2300      	movs	r3, #0
    f80c:	6023      	str	r3, [r4, #0]
	return *flagp;
    f80e:	68e3      	ldr	r3, [r4, #12]
	if (ret != 0) {
    f810:	f013 000f 	ands.w	r0, r3, #15
	*flagp |= BIT(bit);
    f814:	bf1e      	ittt	ne
    f816:	f043 0302 	orrne.w	r3, r3, #2
    f81a:	60e3      	strne	r3, [r4, #12]
	return flags_get(&work->flags) & K_WORK_MASK;
    f81c:	f003 000f 	andne.w	r0, r3, #15
}
    f820:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_REMOVE(slist, snode)
    f822:	428c      	cmp	r4, r1
	parent->next = child;
    f824:	602a      	str	r2, [r5, #0]
	list->tail = node;
    f826:	bf08      	it	eq
    f828:	f8c6 5084 	streq.w	r5, [r6, #132]	; 0x84
}
    f82c:	e7ed      	b.n	f80a <cancel_async_locked+0x38>
	return node->next;
    f82e:	4615      	mov	r5, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    f830:	6812      	ldr	r2, [r2, #0]
    f832:	e7dd      	b.n	f7f0 <cancel_async_locked+0x1e>

0000f834 <work_timeout>:
{
    f834:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f836:	4604      	mov	r4, r0
    f838:	f04f 0320 	mov.w	r3, #32
    f83c:	f3ef 8511 	mrs	r5, BASEPRI
    f840:	f383 8812 	msr	BASEPRI_MAX, r3
    f844:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
    f848:	2300      	movs	r3, #0
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
    f84a:	f1a0 0610 	sub.w	r6, r0, #16
    f84e:	2103      	movs	r1, #3
    f850:	3804      	subs	r0, #4
	struct k_work_q *queue = NULL;
    f852:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
    f854:	f7ff ff9d 	bl	f792 <flag_test_and_clear>
    f858:	b128      	cbz	r0, f866 <work_timeout+0x32>
		queue = dw->queue;
    f85a:	69a3      	ldr	r3, [r4, #24]
    f85c:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
    f85e:	a901      	add	r1, sp, #4
    f860:	4630      	mov	r0, r6
    f862:	f7fc fb4d 	bl	bf00 <submit_to_queue_locked>
	__asm__ volatile(
    f866:	f385 8811 	msr	BASEPRI, r5
    f86a:	f3bf 8f6f 	isb	sy
}
    f86e:	b002      	add	sp, #8
    f870:	bd70      	pop	{r4, r5, r6, pc}

0000f872 <k_work_submit_to_queue>:
{
    f872:	b537      	push	{r0, r1, r2, r4, r5, lr}
    f874:	9001      	str	r0, [sp, #4]
    f876:	4608      	mov	r0, r1
	__asm__ volatile(
    f878:	f04f 0320 	mov.w	r3, #32
    f87c:	f3ef 8511 	mrs	r5, BASEPRI
    f880:	f383 8812 	msr	BASEPRI_MAX, r3
    f884:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
    f888:	a901      	add	r1, sp, #4
    f88a:	f7fc fb39 	bl	bf00 <submit_to_queue_locked>
    f88e:	4604      	mov	r4, r0
	__asm__ volatile(
    f890:	f385 8811 	msr	BASEPRI, r5
    f894:	f3bf 8f6f 	isb	sy
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
    f898:	2800      	cmp	r0, #0
    f89a:	dd04      	ble.n	f8a6 <k_work_submit_to_queue+0x34>
	return z_impl_k_is_preempt_thread();
    f89c:	f7fc ff18 	bl	c6d0 <z_impl_k_is_preempt_thread>
    f8a0:	b108      	cbz	r0, f8a6 <k_work_submit_to_queue+0x34>
	z_impl_k_yield();
    f8a2:	f7fc fe6d 	bl	c580 <z_impl_k_yield>
}
    f8a6:	4620      	mov	r0, r4
    f8a8:	b003      	add	sp, #12
    f8aa:	bd30      	pop	{r4, r5, pc}

0000f8ac <k_work_init_delayable>:
{
    f8ac:	b538      	push	{r3, r4, r5, lr}
	*dwork = (struct k_work_delayable){
    f8ae:	2230      	movs	r2, #48	; 0x30
{
    f8b0:	4604      	mov	r4, r0
    f8b2:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
    f8b4:	2100      	movs	r1, #0
    f8b6:	f7fe f8b1 	bl	da1c <memset>
    f8ba:	f44f 7380 	mov.w	r3, #256	; 0x100
    f8be:	6065      	str	r5, [r4, #4]
    f8c0:	60e3      	str	r3, [r4, #12]
}
    f8c2:	bd38      	pop	{r3, r4, r5, pc}

0000f8c4 <k_work_cancel_delayable>:

	return ret;
}

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
    f8c4:	b538      	push	{r3, r4, r5, lr}
    f8c6:	4604      	mov	r4, r0
	__asm__ volatile(
    f8c8:	f04f 0320 	mov.w	r3, #32
    f8cc:	f3ef 8511 	mrs	r5, BASEPRI
    f8d0:	f383 8812 	msr	BASEPRI_MAX, r3
    f8d4:	f3bf 8f6f 	isb	sy
	(void)unschedule_locked(dwork);
    f8d8:	f7ff ff66 	bl	f7a8 <unschedule_locked>
	return cancel_async_locked(&dwork->work);
    f8dc:	4620      	mov	r0, r4
    f8de:	f7ff ff78 	bl	f7d2 <cancel_async_locked>
	__asm__ volatile(
    f8e2:	f385 8811 	msr	BASEPRI, r5
    f8e6:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
    f8ea:	bd38      	pop	{r3, r4, r5, pc}

0000f8ec <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
    f8ec:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
    f8f0:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    f8f2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    f8f4:	2300      	movs	r3, #0
	node->prev = NULL;
    f8f6:	e9c0 3300 	strd	r3, r3, [r0]
}
    f8fa:	4770      	bx	lr

0000f8fc <unpend_thread_no_timeout>:
{
    f8fc:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
    f8fe:	f7ff fff5 	bl	f8ec <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    f902:	7b43      	ldrb	r3, [r0, #13]
    f904:	f023 0302 	bic.w	r3, r3, #2
    f908:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
    f90a:	2300      	movs	r3, #0
    f90c:	6083      	str	r3, [r0, #8]
}
    f90e:	bd08      	pop	{r3, pc}

0000f910 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    f910:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
    f914:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
    f918:	4283      	cmp	r3, r0
		return b2 - b1;
    f91a:	bf14      	ite	ne
    f91c:	1ac0      	subne	r0, r0, r3
	return 0;
    f91e:	2000      	moveq	r0, #0
}
    f920:	4770      	bx	lr

0000f922 <z_unpend_thread_no_timeout>:
{
    f922:	b508      	push	{r3, lr}
	__asm__ volatile(
    f924:	f04f 0320 	mov.w	r3, #32
    f928:	f3ef 8111 	mrs	r1, BASEPRI
    f92c:	f383 8812 	msr	BASEPRI_MAX, r3
    f930:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
    f934:	f7ff ffe2 	bl	f8fc <unpend_thread_no_timeout>
	__asm__ volatile(
    f938:	f381 8811 	msr	BASEPRI, r1
    f93c:	f3bf 8f6f 	isb	sy
}
    f940:	bd08      	pop	{r3, pc}

0000f942 <z_unpend_thread>:
{
    f942:	b510      	push	{r4, lr}
	__asm__ volatile(
    f944:	f04f 0320 	mov.w	r3, #32
    f948:	f3ef 8411 	mrs	r4, BASEPRI
    f94c:	f383 8812 	msr	BASEPRI_MAX, r3
    f950:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
    f954:	f7ff ffd2 	bl	f8fc <unpend_thread_no_timeout>
	__asm__ volatile(
    f958:	f384 8811 	msr	BASEPRI, r4
    f95c:	f3bf 8f6f 	isb	sy
}
    f960:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f964:	3018      	adds	r0, #24
    f966:	f000 b8d2 	b.w	fb0e <z_abort_timeout>

0000f96a <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    f96a:	4603      	mov	r3, r0
    f96c:	b920      	cbnz	r0, f978 <z_reschedule_irqlock+0xe>
    f96e:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
    f972:	b90a      	cbnz	r2, f978 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
    f974:	f7f2 bc96 	b.w	22a4 <arch_swap>
    f978:	f383 8811 	msr	BASEPRI, r3
    f97c:	f3bf 8f6f 	isb	sy
}
    f980:	4770      	bx	lr

0000f982 <z_reschedule_unlocked>:
	__asm__ volatile(
    f982:	f04f 0320 	mov.w	r3, #32
    f986:	f3ef 8011 	mrs	r0, BASEPRI
    f98a:	f383 8812 	msr	BASEPRI_MAX, r3
    f98e:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    f992:	f7ff bfea 	b.w	f96a <z_reschedule_irqlock>

0000f996 <z_priq_dumb_best>:
{
    f996:	4603      	mov	r3, r0
	return list->head == list;
    f998:	6800      	ldr	r0, [r0, #0]
}
    f99a:	4283      	cmp	r3, r0
    f99c:	bf08      	it	eq
    f99e:	2000      	moveq	r0, #0
    f9a0:	4770      	bx	lr

0000f9a2 <z_ready_thread>:
{
    f9a2:	b510      	push	{r4, lr}
    f9a4:	f04f 0320 	mov.w	r3, #32
    f9a8:	f3ef 8411 	mrs	r4, BASEPRI
    f9ac:	f383 8812 	msr	BASEPRI_MAX, r3
    f9b0:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
    f9b4:	f7fc fc9c 	bl	c2f0 <ready_thread>
	__asm__ volatile(
    f9b8:	f384 8811 	msr	BASEPRI, r4
    f9bc:	f3bf 8f6f 	isb	sy
}
    f9c0:	bd10      	pop	{r4, pc}

0000f9c2 <z_thread_timeout>:
{
    f9c2:	b510      	push	{r4, lr}
    f9c4:	4601      	mov	r1, r0
	__asm__ volatile(
    f9c6:	f04f 0320 	mov.w	r3, #32
    f9ca:	f3ef 8411 	mrs	r4, BASEPRI
    f9ce:	f383 8812 	msr	BASEPRI_MAX, r3
    f9d2:	f3bf 8f6f 	isb	sy
		if (!killed) {
    f9d6:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
    f9da:	f013 0f28 	tst.w	r3, #40	; 0x28
    f9de:	d10d      	bne.n	f9fc <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
    f9e0:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
    f9e4:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
    f9e6:	b10b      	cbz	r3, f9ec <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
    f9e8:	f7ff ff88 	bl	f8fc <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    f9ec:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
    f9f0:	f023 0314 	bic.w	r3, r3, #20
    f9f4:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
    f9f8:	f7fc fc7a 	bl	c2f0 <ready_thread>
	__asm__ volatile(
    f9fc:	f384 8811 	msr	BASEPRI, r4
    fa00:	f3bf 8f6f 	isb	sy
}
    fa04:	bd10      	pop	{r4, pc}

0000fa06 <add_to_waitq_locked>:
{
    fa06:	b538      	push	{r3, r4, r5, lr}
    fa08:	4604      	mov	r4, r0
    fa0a:	460d      	mov	r5, r1
	unready_thread(thread);
    fa0c:	f7fc fcc4 	bl	c398 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    fa10:	7b63      	ldrb	r3, [r4, #13]
    fa12:	f043 0302 	orr.w	r3, r3, #2
    fa16:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    fa18:	b195      	cbz	r5, fa40 <add_to_waitq_locked+0x3a>
    fa1a:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
    fa1c:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fa1e:	429d      	cmp	r5, r3
    fa20:	d015      	beq.n	fa4e <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    fa22:	b1a3      	cbz	r3, fa4e <add_to_waitq_locked+0x48>
	int32_t b1 = thread_1->base.prio;
    fa24:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
    fa28:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
    fa2c:	4291      	cmp	r1, r2
    fa2e:	d008      	beq.n	fa42 <add_to_waitq_locked+0x3c>
		return b2 - b1;
    fa30:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
    fa32:	2a00      	cmp	r2, #0
    fa34:	dd05      	ble.n	fa42 <add_to_waitq_locked+0x3c>
	sys_dnode_t *const prev = successor->prev;
    fa36:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    fa38:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
    fa3c:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    fa3e:	605c      	str	r4, [r3, #4]
}
    fa40:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
    fa42:	686a      	ldr	r2, [r5, #4]
    fa44:	4293      	cmp	r3, r2
    fa46:	d002      	beq.n	fa4e <add_to_waitq_locked+0x48>
    fa48:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    fa4a:	2b00      	cmp	r3, #0
    fa4c:	d1ec      	bne.n	fa28 <add_to_waitq_locked+0x22>
	sys_dnode_t *const tail = list->tail;
    fa4e:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
    fa50:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
    fa54:	601c      	str	r4, [r3, #0]
	list->tail = node;
    fa56:	606c      	str	r4, [r5, #4]
}
    fa58:	e7f2      	b.n	fa40 <add_to_waitq_locked+0x3a>

0000fa5a <z_unpend1_no_timeout>:
{
    fa5a:	b510      	push	{r4, lr}
	__asm__ volatile(
    fa5c:	f04f 0320 	mov.w	r3, #32
    fa60:	f3ef 8411 	mrs	r4, BASEPRI
    fa64:	f383 8812 	msr	BASEPRI_MAX, r3
    fa68:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
    fa6c:	f7ff ff93 	bl	f996 <z_priq_dumb_best>
		if (thread != NULL) {
    fa70:	4601      	mov	r1, r0
    fa72:	b108      	cbz	r0, fa78 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
    fa74:	f7ff ff42 	bl	f8fc <unpend_thread_no_timeout>
	__asm__ volatile(
    fa78:	f384 8811 	msr	BASEPRI, r4
    fa7c:	f3bf 8f6f 	isb	sy
}
    fa80:	4608      	mov	r0, r1
    fa82:	bd10      	pop	{r4, pc}

0000fa84 <z_unpend_first_thread>:
{
    fa84:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    fa86:	f04f 0320 	mov.w	r3, #32
    fa8a:	f3ef 8511 	mrs	r5, BASEPRI
    fa8e:	f383 8812 	msr	BASEPRI_MAX, r3
    fa92:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
    fa96:	f7ff ff7e 	bl	f996 <z_priq_dumb_best>
		if (thread != NULL) {
    fa9a:	4604      	mov	r4, r0
    fa9c:	b120      	cbz	r0, faa8 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
    fa9e:	f7ff ff2d 	bl	f8fc <unpend_thread_no_timeout>
    faa2:	3018      	adds	r0, #24
    faa4:	f000 f833 	bl	fb0e <z_abort_timeout>
	__asm__ volatile(
    faa8:	f385 8811 	msr	BASEPRI, r5
    faac:	f3bf 8f6f 	isb	sy
}
    fab0:	4620      	mov	r0, r4
    fab2:	bd38      	pop	{r3, r4, r5, pc}

0000fab4 <z_unpend_all>:
{
    fab4:	b538      	push	{r3, r4, r5, lr}
    fab6:	4605      	mov	r5, r0
	int need_sched = 0;
    fab8:	2000      	movs	r0, #0
	return list->head == list;
    faba:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fabc:	42a5      	cmp	r5, r4
    fabe:	d000      	beq.n	fac2 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    fac0:	b904      	cbnz	r4, fac4 <z_unpend_all+0x10>
}
    fac2:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
    fac4:	4620      	mov	r0, r4
    fac6:	f7ff ff3c 	bl	f942 <z_unpend_thread>
		z_ready_thread(thread);
    faca:	4620      	mov	r0, r4
    facc:	f7ff ff69 	bl	f9a2 <z_ready_thread>
		need_sched = 1;
    fad0:	2001      	movs	r0, #1
    fad2:	e7f2      	b.n	faba <z_unpend_all+0x6>

0000fad4 <z_sched_wake>:
{
    fad4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    fad6:	f04f 0320 	mov.w	r3, #32
    fada:	f3ef 8511 	mrs	r5, BASEPRI
    fade:	f383 8812 	msr	BASEPRI_MAX, r3
    fae2:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
    fae6:	f7ff ff56 	bl	f996 <z_priq_dumb_best>
		if (thread != NULL) {
    faea:	4604      	mov	r4, r0
    faec:	b150      	cbz	r0, fb04 <z_sched_wake+0x30>
    faee:	67c1      	str	r1, [r0, #124]	; 0x7c
    faf0:	6142      	str	r2, [r0, #20]
			unpend_thread_no_timeout(thread);
    faf2:	f7ff ff03 	bl	f8fc <unpend_thread_no_timeout>
    faf6:	3018      	adds	r0, #24
    faf8:	f000 f809 	bl	fb0e <z_abort_timeout>
			ready_thread(thread);
    fafc:	4620      	mov	r0, r4
    fafe:	f7fc fbf7 	bl	c2f0 <ready_thread>
			ret = true;
    fb02:	2001      	movs	r0, #1
	__asm__ volatile(
    fb04:	f385 8811 	msr	BASEPRI, r5
    fb08:	f3bf 8f6f 	isb	sy
}
    fb0c:	bd38      	pop	{r3, r4, r5, pc}

0000fb0e <z_abort_timeout>:
{
    fb0e:	b510      	push	{r4, lr}
	__asm__ volatile(
    fb10:	f04f 0220 	mov.w	r2, #32
    fb14:	f3ef 8411 	mrs	r4, BASEPRI
    fb18:	f382 8812 	msr	BASEPRI_MAX, r2
    fb1c:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
    fb20:	6803      	ldr	r3, [r0, #0]
    fb22:	b13b      	cbz	r3, fb34 <z_abort_timeout+0x26>
			remove_timeout(to);
    fb24:	f7fc fe94 	bl	c850 <remove_timeout>
			ret = 0;
    fb28:	2000      	movs	r0, #0
	__asm__ volatile(
    fb2a:	f384 8811 	msr	BASEPRI, r4
    fb2e:	f3bf 8f6f 	isb	sy
}
    fb32:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
    fb34:	f06f 0015 	mvn.w	r0, #21
    fb38:	e7f7      	b.n	fb2a <z_abort_timeout+0x1c>

0000fb3a <z_get_next_timeout_expiry>:
{
    fb3a:	b510      	push	{r4, lr}
	__asm__ volatile(
    fb3c:	f04f 0320 	mov.w	r3, #32
    fb40:	f3ef 8411 	mrs	r4, BASEPRI
    fb44:	f383 8812 	msr	BASEPRI_MAX, r3
    fb48:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
    fb4c:	f7fc fe58 	bl	c800 <next_timeout>
	__asm__ volatile(
    fb50:	f384 8811 	msr	BASEPRI, r4
    fb54:	f3bf 8f6f 	isb	sy
}
    fb58:	bd10      	pop	{r4, pc}

0000fb5a <z_set_timeout_expiry>:
{
    fb5a:	b570      	push	{r4, r5, r6, lr}
    fb5c:	4604      	mov	r4, r0
    fb5e:	460d      	mov	r5, r1
	__asm__ volatile(
    fb60:	f04f 0320 	mov.w	r3, #32
    fb64:	f3ef 8611 	mrs	r6, BASEPRI
    fb68:	f383 8812 	msr	BASEPRI_MAX, r3
    fb6c:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
    fb70:	f7fc fe46 	bl	c800 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    fb74:	2801      	cmp	r0, #1
    fb76:	dd05      	ble.n	fb84 <z_set_timeout_expiry+0x2a>
    fb78:	42a0      	cmp	r0, r4
    fb7a:	db03      	blt.n	fb84 <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    fb7c:	4629      	mov	r1, r5
    fb7e:	4620      	mov	r0, r4
    fb80:	f7fa fbbc 	bl	a2fc <sys_clock_set_timeout>
	__asm__ volatile(
    fb84:	f386 8811 	msr	BASEPRI, r6
    fb88:	f3bf 8f6f 	isb	sy
}
    fb8c:	bd70      	pop	{r4, r5, r6, pc}

0000fb8e <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    fb8e:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    fb90:	f7fc ff4e 	bl	ca30 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    fb94:	bd08      	pop	{r3, pc}

0000fb96 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
    fb96:	f7fc bf4b 	b.w	ca30 <sys_clock_tick_get>

0000fb9a <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    fb9a:	b108      	cbz	r0, fba0 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    fb9c:	f7f3 b854 	b.w	2c48 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    fba0:	4770      	bx	lr

0000fba2 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    fba2:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    fba6:	bf08      	it	eq
    fba8:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
    fbac:	b538      	push	{r3, r4, r5, lr}
    fbae:	4605      	mov	r5, r0
    fbb0:	460c      	mov	r4, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    fbb2:	d01d      	beq.n	fbf0 <sys_clock_timeout_end_calc+0x4e>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    fbb4:	ea51 0300 	orrs.w	r3, r1, r0
    fbb8:	d103      	bne.n	fbc2 <sys_clock_timeout_end_calc+0x20>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
    fbba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
    fbbe:	f7fc bf37 	b.w	ca30 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
    fbc2:	f06f 0301 	mvn.w	r3, #1
    fbc6:	1a18      	subs	r0, r3, r0
    fbc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    fbcc:	eb63 0101 	sbc.w	r1, r3, r1
    fbd0:	2900      	cmp	r1, #0
    fbd2:	da0c      	bge.n	fbee <sys_clock_timeout_end_calc+0x4c>
		return sys_clock_tick_get() + MAX(1, dt);
    fbd4:	f7fc ff2c 	bl	ca30 <sys_clock_tick_get>
    fbd8:	2d01      	cmp	r5, #1
    fbda:	4622      	mov	r2, r4
    fbdc:	f174 0400 	sbcs.w	r4, r4, #0
    fbe0:	462b      	mov	r3, r5
    fbe2:	bfbc      	itt	lt
    fbe4:	2301      	movlt	r3, #1
    fbe6:	2200      	movlt	r2, #0
    fbe8:	1818      	adds	r0, r3, r0
    fbea:	eb41 0102 	adc.w	r1, r1, r2
}
    fbee:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
    fbf0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fbf4:	4601      	mov	r1, r0
    fbf6:	e7fa      	b.n	fbee <sys_clock_timeout_end_calc+0x4c>

0000fbf8 <k_timer_init>:
	timer->status = 0U;
    fbf8:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
    fbfa:	e9c0 1208 	strd	r1, r2, [r0, #32]
    fbfe:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
    fc02:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
    fc06:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
    fc0a:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
    fc0c:	6343      	str	r3, [r0, #52]	; 0x34
}
    fc0e:	4770      	bx	lr

0000fc10 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    fc10:	b510      	push	{r4, lr}
    fc12:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
    fc14:	f7ff ff7b 	bl	fb0e <z_abort_timeout>

	if (inactive) {
    fc18:	b9b0      	cbnz	r0, fc48 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
    fc1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    fc1c:	b10b      	cbz	r3, fc22 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
    fc1e:	4620      	mov	r0, r4
    fc20:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
    fc22:	f104 0018 	add.w	r0, r4, #24
    fc26:	f7ff ff18 	bl	fa5a <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
    fc2a:	b168      	cbz	r0, fc48 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
    fc2c:	f7ff feb9 	bl	f9a2 <z_ready_thread>
	__asm__ volatile(
    fc30:	f04f 0320 	mov.w	r3, #32
    fc34:	f3ef 8011 	mrs	r0, BASEPRI
    fc38:	f383 8812 	msr	BASEPRI_MAX, r3
    fc3c:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
    fc40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
    fc44:	f7ff be91 	b.w	f96a <z_reschedule_irqlock>
    fc48:	bd10      	pop	{r4, pc}

0000fc4a <add_event>:
{
    fc4a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    fc4c:	460d      	mov	r5, r1
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    fc4e:	e9d0 1300 	ldrd	r1, r3, [r0]
    fc52:	4288      	cmp	r0, r1
    fc54:	4604      	mov	r4, r0
    fc56:	d00d      	beq.n	fc74 <add_event+0x2a>
	if ((pending == NULL) ||
    fc58:	b163      	cbz	r3, fc74 <add_event+0x2a>
		(z_sched_prio_cmp(poller_thread(pending->poller),
    fc5a:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    fc5c:	b100      	cbz	r0, fc60 <add_event+0x16>
    fc5e:	3860      	subs	r0, #96	; 0x60
    fc60:	f1a2 0760 	sub.w	r7, r2, #96	; 0x60
		(z_sched_prio_cmp(poller_thread(pending->poller),
    fc64:	4639      	mov	r1, r7
    fc66:	f7ff fe53 	bl	f910 <z_sched_prio_cmp>
	if ((pending == NULL) ||
    fc6a:	2800      	cmp	r0, #0
    fc6c:	dc02      	bgt.n	fc74 <add_event+0x2a>
	return list->head == list;
    fc6e:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fc70:	42b4      	cmp	r4, r6
    fc72:	d109      	bne.n	fc88 <add_event+0x3e>
	sys_dnode_t *const tail = list->tail;
    fc74:	6863      	ldr	r3, [r4, #4]
	node->prev = tail;
    fc76:	e9c5 4300 	strd	r4, r3, [r5]
	tail->next = node;
    fc7a:	601d      	str	r5, [r3, #0]
	list->tail = node;
    fc7c:	6065      	str	r5, [r4, #4]
}
    fc7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    fc80:	6863      	ldr	r3, [r4, #4]
    fc82:	42b3      	cmp	r3, r6
    fc84:	d0f6      	beq.n	fc74 <add_event+0x2a>
    fc86:	6836      	ldr	r6, [r6, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    fc88:	2e00      	cmp	r6, #0
    fc8a:	d0f3      	beq.n	fc74 <add_event+0x2a>
		if (z_sched_prio_cmp(poller_thread(poller),
    fc8c:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    fc8e:	b101      	cbz	r1, fc92 <add_event+0x48>
    fc90:	3960      	subs	r1, #96	; 0x60
		if (z_sched_prio_cmp(poller_thread(poller),
    fc92:	4638      	mov	r0, r7
    fc94:	f7ff fe3c 	bl	f910 <z_sched_prio_cmp>
    fc98:	2800      	cmp	r0, #0
    fc9a:	ddf1      	ble.n	fc80 <add_event+0x36>
	sys_dnode_t *const prev = successor->prev;
    fc9c:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
    fc9e:	e9c5 6300 	strd	r6, r3, [r5]
	prev->next = node;
    fca2:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    fca4:	6075      	str	r5, [r6, #4]
			return;
    fca6:	e7ea      	b.n	fc7e <add_event+0x34>

0000fca8 <register_events>:
{
    fca8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
    fcac:	2500      	movs	r5, #0
{
    fcae:	468b      	mov	fp, r1
    fcb0:	4614      	mov	r4, r2
    fcb2:	461f      	mov	r7, r3
    fcb4:	4682      	mov	sl, r0
	int events_registered = 0;
    fcb6:	462e      	mov	r6, r5
	event->poller = NULL;
    fcb8:	46a8      	mov	r8, r5
	for (int ii = 0; ii < num_events; ii++) {
    fcba:	455d      	cmp	r5, fp
    fcbc:	db02      	blt.n	fcc4 <register_events+0x1c>
}
    fcbe:	4630      	mov	r0, r6
    fcc0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fcc4:	f04f 0320 	mov.w	r3, #32
    fcc8:	f3ef 8911 	mrs	r9, BASEPRI
    fccc:	f383 8812 	msr	BASEPRI_MAX, r3
    fcd0:	f3bf 8f6f 	isb	sy
	switch (event->type) {
    fcd4:	f89a 300d 	ldrb.w	r3, [sl, #13]
    fcd8:	f003 031f 	and.w	r3, r3, #31
    fcdc:	3b01      	subs	r3, #1
    fcde:	2b07      	cmp	r3, #7
    fce0:	d80f      	bhi.n	fd02 <register_events+0x5a>
    fce2:	e8df f003 	tbb	[pc, r3]
    fce6:	041e      	.short	0x041e
    fce8:	0e0e0a0e 	.word	0x0e0e0a0e
    fcec:	250e      	.short	0x250e
		if (k_sem_count_get(event->sem) > 0U) {
    fcee:	f8da 3010 	ldr.w	r3, [sl, #16]
    fcf2:	689b      	ldr	r3, [r3, #8]
    fcf4:	b12b      	cbz	r3, fd02 <register_events+0x5a>
			*state = K_POLL_STATE_SEM_AVAILABLE;
    fcf6:	2302      	movs	r3, #2
    fcf8:	e020      	b.n	fd3c <register_events+0x94>
		if (!k_queue_is_empty(event->queue)) {
    fcfa:	f8da 3010 	ldr.w	r3, [sl, #16]
    fcfe:	681b      	ldr	r3, [r3, #0]
    fd00:	bb8b      	cbnz	r3, fd66 <register_events+0xbe>
		} else if (!just_check && poller->is_polling) {
    fd02:	bb47      	cbnz	r7, fd56 <register_events+0xae>
    fd04:	7823      	ldrb	r3, [r4, #0]
    fd06:	b333      	cbz	r3, fd56 <register_events+0xae>
	switch (event->type) {
    fd08:	f89a 300d 	ldrb.w	r3, [sl, #13]
    fd0c:	f003 031f 	and.w	r3, r3, #31
    fd10:	3b01      	subs	r3, #1
    fd12:	2b07      	cmp	r3, #7
    fd14:	d830      	bhi.n	fd78 <register_events+0xd0>
    fd16:	e8df f003 	tbb	[pc, r3]
    fd1a:	2833      	.short	0x2833
    fd1c:	2f2f282f 	.word	0x2f2f282f
    fd20:	382f      	.short	0x382f
		if (event->signal->signaled != 0U) {
    fd22:	f8da 3010 	ldr.w	r3, [sl, #16]
    fd26:	689b      	ldr	r3, [r3, #8]
    fd28:	2b00      	cmp	r3, #0
    fd2a:	d0ea      	beq.n	fd02 <register_events+0x5a>
			*state = K_POLL_STATE_SIGNALED;
    fd2c:	2301      	movs	r3, #1
    fd2e:	e005      	b.n	fd3c <register_events+0x94>
		if (event->msgq->used_msgs > 0) {
    fd30:	f8da 3010 	ldr.w	r3, [sl, #16]
    fd34:	6a1b      	ldr	r3, [r3, #32]
    fd36:	2b00      	cmp	r3, #0
    fd38:	d0e3      	beq.n	fd02 <register_events+0x5a>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
    fd3a:	2310      	movs	r3, #16
	event->state |= state;
    fd3c:	f8da 200c 	ldr.w	r2, [sl, #12]
	event->poller = NULL;
    fd40:	f8ca 8008 	str.w	r8, [sl, #8]
	event->state |= state;
    fd44:	f3c2 3145 	ubfx	r1, r2, #13, #6
    fd48:	430b      	orrs	r3, r1
    fd4a:	f363 3252 	bfi	r2, r3, #13, #6
    fd4e:	f8ca 200c 	str.w	r2, [sl, #12]
			poller->is_polling = false;
    fd52:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
    fd56:	f389 8811 	msr	BASEPRI, r9
    fd5a:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
    fd5e:	3501      	adds	r5, #1
    fd60:	f10a 0a14 	add.w	sl, sl, #20
    fd64:	e7a9      	b.n	fcba <register_events+0x12>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
    fd66:	2304      	movs	r3, #4
    fd68:	e7e8      	b.n	fd3c <register_events+0x94>
		add_event(&event->queue->poll_events, event, poller);
    fd6a:	f8da 0010 	ldr.w	r0, [sl, #16]
    fd6e:	4622      	mov	r2, r4
    fd70:	4651      	mov	r1, sl
    fd72:	3010      	adds	r0, #16
		add_event(&event->msgq->poll_events, event, poller);
    fd74:	f7ff ff69 	bl	fc4a <add_event>
	event->poller = poller;
    fd78:	f8ca 4008 	str.w	r4, [sl, #8]
			events_registered += 1;
    fd7c:	3601      	adds	r6, #1
    fd7e:	e7ea      	b.n	fd56 <register_events+0xae>
		add_event(&event->signal->poll_events, event, poller);
    fd80:	f8da 0010 	ldr.w	r0, [sl, #16]
    fd84:	4622      	mov	r2, r4
    fd86:	4651      	mov	r1, sl
    fd88:	e7f4      	b.n	fd74 <register_events+0xcc>
		add_event(&event->msgq->poll_events, event, poller);
    fd8a:	f8da 0010 	ldr.w	r0, [sl, #16]
    fd8e:	4622      	mov	r2, r4
    fd90:	4651      	mov	r1, sl
    fd92:	3024      	adds	r0, #36	; 0x24
    fd94:	e7ee      	b.n	fd74 <register_events+0xcc>

0000fd96 <signal_poll_event>:
{
    fd96:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
    fd9a:	6884      	ldr	r4, [r0, #8]
{
    fd9c:	4605      	mov	r5, r0
    fd9e:	460e      	mov	r6, r1
	if (poller != NULL) {
    fda0:	b144      	cbz	r4, fdb4 <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
    fda2:	7863      	ldrb	r3, [r4, #1]
    fda4:	2b01      	cmp	r3, #1
    fda6:	d136      	bne.n	fe16 <signal_poll_event+0x80>
	if (!z_is_thread_pending(thread)) {
    fda8:	f814 3c53 	ldrb.w	r3, [r4, #-83]
    fdac:	f013 0302 	ands.w	r3, r3, #2
    fdb0:	d10a      	bne.n	fdc8 <signal_poll_event+0x32>
		poller->is_polling = false;
    fdb2:	7023      	strb	r3, [r4, #0]
	event->state |= state;
    fdb4:	68eb      	ldr	r3, [r5, #12]
    fdb6:	f3c3 3145 	ubfx	r1, r3, #13, #6
    fdba:	430e      	orrs	r6, r1
	event->poller = NULL;
    fdbc:	2000      	movs	r0, #0
	event->state |= state;
    fdbe:	f366 3352 	bfi	r3, r6, #13, #6
	event->poller = NULL;
    fdc2:	60a8      	str	r0, [r5, #8]
	event->state |= state;
    fdc4:	60eb      	str	r3, [r5, #12]
	return retcode;
    fdc6:	e00b      	b.n	fde0 <signal_poll_event+0x4a>
	if (z_is_thread_timeout_expired(thread)) {
    fdc8:	e954 230e 	ldrd	r2, r3, [r4, #-56]	; 0x38
    fdcc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    fdd0:	bf08      	it	eq
    fdd2:	f112 0f02 	cmneq.w	r2, #2
    fdd6:	d105      	bne.n	fde4 <signal_poll_event+0x4e>
		poller->is_polling = false;
    fdd8:	2300      	movs	r3, #0
    fdda:	7023      	strb	r3, [r4, #0]
		return -EAGAIN;
    fddc:	f06f 000a 	mvn.w	r0, #10
}
    fde0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    fde4:	f1a4 0860 	sub.w	r8, r4, #96	; 0x60
	z_unpend_thread(thread);
    fde8:	4640      	mov	r0, r8
    fdea:	f7ff fdaa 	bl	f942 <z_unpend_thread>
	arch_thread_return_value_set(thread,
    fdee:	2e08      	cmp	r6, #8
    fdf0:	bf0c      	ite	eq
    fdf2:	f06f 0303 	mvneq.w	r3, #3
    fdf6:	2300      	movne	r3, #0
    fdf8:	61e3      	str	r3, [r4, #28]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    fdfa:	f814 3c53 	ldrb.w	r3, [r4, #-83]
    fdfe:	06db      	lsls	r3, r3, #27
    fe00:	d102      	bne.n	fe08 <signal_poll_event+0x72>
	if (!z_is_thread_ready(thread)) {
    fe02:	f854 7c48 	ldr.w	r7, [r4, #-72]
    fe06:	b10f      	cbz	r7, fe0c <signal_poll_event+0x76>
		poller->is_polling = false;
    fe08:	2300      	movs	r3, #0
    fe0a:	e7d2      	b.n	fdb2 <signal_poll_event+0x1c>
	z_ready_thread(thread);
    fe0c:	4640      	mov	r0, r8
    fe0e:	f7ff fdc8 	bl	f9a2 <z_ready_thread>
		poller->is_polling = false;
    fe12:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
    fe14:	e7ce      	b.n	fdb4 <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
    fe16:	2b02      	cmp	r3, #2
    fe18:	d1f6      	bne.n	fe08 <signal_poll_event+0x72>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
    fe1a:	7823      	ldrb	r3, [r4, #0]
    fe1c:	2b00      	cmp	r3, #0
    fe1e:	d0c9      	beq.n	fdb4 <signal_poll_event+0x1e>
    fe20:	f854 7c04 	ldr.w	r7, [r4, #-4]
    fe24:	2f00      	cmp	r7, #0
    fe26:	d0f4      	beq.n	fe12 <signal_poll_event+0x7c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
    fe28:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
    fe2c:	f1a4 0914 	sub.w	r9, r4, #20
    fe30:	f104 0014 	add.w	r0, r4, #20
    fe34:	f7ff fe6b 	bl	fb0e <z_abort_timeout>
		twork->poll_result = 0;
    fe38:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		k_work_submit_to_queue(work_q, &twork->work);
    fe3c:	4649      	mov	r1, r9
    fe3e:	4638      	mov	r0, r7
    fe40:	f7ff fd17 	bl	f872 <k_work_submit_to_queue>
		poller->is_polling = false;
    fe44:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
    fe48:	e7b4      	b.n	fdb4 <signal_poll_event+0x1e>

0000fe4a <clear_event_registrations>:
	while (num_events--) {
    fe4a:	2314      	movs	r3, #20
{
    fe4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    fe4e:	fb03 0001 	mla	r0, r3, r1, r0
	event->poller = NULL;
    fe52:	2400      	movs	r4, #0
    fe54:	2601      	movs	r6, #1
	while (num_events--) {
    fe56:	b901      	cbnz	r1, fe5a <clear_event_registrations+0x10>
}
    fe58:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (event->type) {
    fe5a:	f810 3c07 	ldrb.w	r3, [r0, #-7]
	event->poller = NULL;
    fe5e:	f840 4c0c 	str.w	r4, [r0, #-12]
	switch (event->type) {
    fe62:	f003 031f 	and.w	r3, r3, #31
    fe66:	2b08      	cmp	r3, #8
    fe68:	f1a0 0714 	sub.w	r7, r0, #20
    fe6c:	d80d      	bhi.n	fe8a <clear_event_registrations+0x40>
    fe6e:	fa06 f303 	lsl.w	r3, r6, r3
    fe72:	f413 7f8b 	tst.w	r3, #278	; 0x116
    fe76:	d008      	beq.n	fe8a <clear_event_registrations+0x40>
	return node->next != NULL;
    fe78:	f850 3c14 	ldr.w	r3, [r0, #-20]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
    fe7c:	b12b      	cbz	r3, fe8a <clear_event_registrations+0x40>
	sys_dnode_t *const prev = node->prev;
    fe7e:	f850 5c10 	ldr.w	r5, [r0, #-16]
	prev->next = next;
    fe82:	602b      	str	r3, [r5, #0]
	next->prev = prev;
    fe84:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
    fe86:	e940 4405 	strd	r4, r4, [r0, #-20]
    fe8a:	f382 8811 	msr	BASEPRI, r2
    fe8e:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    fe92:	f04f 0320 	mov.w	r3, #32
    fe96:	f3ef 8211 	mrs	r2, BASEPRI
    fe9a:	f383 8812 	msr	BASEPRI_MAX, r3
    fe9e:	f3bf 8f6f 	isb	sy
    fea2:	3901      	subs	r1, #1
    fea4:	4638      	mov	r0, r7
    fea6:	e7d6      	b.n	fe56 <clear_event_registrations+0xc>

0000fea8 <z_handle_obj_poll_events>:
{
    fea8:	4603      	mov	r3, r0
	return list->head == list;
    feaa:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
    feac:	4283      	cmp	r3, r0
    feae:	d008      	beq.n	fec2 <z_handle_obj_poll_events+0x1a>
	sys_dnode_t *const next = node->next;
    feb0:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
    feb4:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    feb6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    feb8:	2300      	movs	r3, #0
	node->prev = NULL;
    feba:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
    febe:	f7ff bf6a 	b.w	fd96 <signal_poll_event>
}
    fec2:	4770      	bx	lr

0000fec4 <k_free>:
	if (ptr != NULL) {
    fec4:	b120      	cbz	r0, fed0 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
    fec6:	1f01      	subs	r1, r0, #4
    fec8:	f850 0c04 	ldr.w	r0, [r0, #-4]
    fecc:	f7ff bb57 	b.w	f57e <k_heap_free>
}
    fed0:	4770      	bx	lr
	...

0000fed4 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
    fed4:	f7fa ba6a 	b.w	a3ac <SystemInit>
